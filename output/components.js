this["rl_components"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "output";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	__webpack_require__(2);
	__webpack_require__(4);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	__webpack_require__(7);
	__webpack_require__(14);
	var behaviors = __webpack_require__(15);
	exports.behaviors = behaviors;
	var components = __webpack_require__(24);
	exports.components = components;
	var services = __webpack_require__(159);
	exports.services = services;
	var types = __webpack_require__(173);
	exports.types = types;
	exports.moduleName = 'rl.ui';
	angular.module(exports.moduleName, [
	    'ui.bootstrap',
	    'ui.bootstrap-slider',
	    'ngSanitize',
	    typescript_angular_utilities_1.name,
	    behaviors.moduleName,
	    components.moduleName,
	    services.moduleName,
	]);


/***/ },
/* 1 */
/***/ function(module, exports) {

	(function() { module.exports = this["angular"]; }());

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	module.exports = 'ui.bootstrap';


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
	 * angular-ui-bootstrap
	 * http://angular-ui.github.io/bootstrap/
	
	 * Version: 0.13.4 - 2015-09-03
	 * License: MIT
	 */
	angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.transition","ui.bootstrap.typeahead"]);
	angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-popup.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/tooltip/tooltip-template-popup.html","template/popover/popover-html.html","template/popover/popover-template.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
	angular.module('ui.bootstrap.collapse', [])
	
	  .directive('collapse', ['$animate', function($animate) {
	    return {
	      link: function(scope, element, attrs) {
	        function expand() {
	          element.removeClass('collapse')
	            .addClass('collapsing')
	            .attr('aria-expanded', true)
	            .attr('aria-hidden', false);
	
	          $animate.addClass(element, 'in', {
	            to: { height: element[0].scrollHeight + 'px' }
	          }).then(expandDone);
	        }
	
	        function expandDone() {
	          element.removeClass('collapsing');
	          element.css({height: 'auto'});
	        }
	
	        function collapse() {
	          if (!element.hasClass('collapse') && !element.hasClass('in')) {
	            return collapseDone();
	          }
	
	          element
	            // IMPORTANT: The height must be set before adding "collapsing" class.
	            // Otherwise, the browser attempts to animate from height 0 (in
	            // collapsing class) to the given height here.
	            .css({height: element[0].scrollHeight + 'px'})
	            // initially all panel collapse have the collapse class, this removal
	            // prevents the animation from jumping to collapsed state
	            .removeClass('collapse')
	            .addClass('collapsing')
	            .attr('aria-expanded', false)
	            .attr('aria-hidden', true);
	
	          $animate.removeClass(element, 'in', {
	            to: {height: '0'}
	          }).then(collapseDone);
	        }
	
	        function collapseDone() {
	          element.css({height: '0'}); // Required so that collapse works when animation is disabled
	          element.removeClass('collapsing');
	          element.addClass('collapse');
	        }
	
	        scope.$watch(attrs.collapse, function(shouldCollapse) {
	          if (shouldCollapse) {
	            collapse();
	          } else {
	            expand();
	          }
	        });
	      }
	    };
	  }]);
	
	angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])
	
	.constant('accordionConfig', {
	  closeOthers: true
	})
	
	.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function($scope, $attrs, accordionConfig) {
	  // This array keeps track of the accordion groups
	  this.groups = [];
	
	  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
	  this.closeOthers = function(openGroup) {
	    var closeOthers = angular.isDefined($attrs.closeOthers) ?
	      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	    if (closeOthers) {
	      angular.forEach(this.groups, function(group) {
	        if (group !== openGroup) {
	          group.isOpen = false;
	        }
	      });
	    }
	  };
	
	  // This is called from the accordion-group directive to add itself to the accordion
	  this.addGroup = function(groupScope) {
	    var that = this;
	    this.groups.push(groupScope);
	
	    groupScope.$on('$destroy', function(event) {
	      that.removeGroup(groupScope);
	    });
	  };
	
	  // This is called from the accordion-group directive when to remove itself
	  this.removeGroup = function(group) {
	    var index = this.groups.indexOf(group);
	    if (index !== -1) {
	      this.groups.splice(index, 1);
	    }
	  };
	
	}])
	
	// The accordion directive simply sets up the directive controller
	// and adds an accordion CSS class to itself element.
	.directive('accordion', function() {
	  return {
	    restrict: 'EA',
	    controller: 'AccordionController',
	    controllerAs: 'accordion',
	    transclude: true,
	    replace: false,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/accordion/accordion.html';
	    }
	  };
	})
	
	// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
	.directive('accordionGroup', function() {
	  return {
	    require: '^accordion',         // We need this directive to be inside an accordion
	    restrict: 'EA',
	    transclude: true,              // It transcludes the contents of the directive into the template
	    replace: true,                // The element containing the directive will be replaced with the template
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/accordion/accordion-group.html';
	    },
	    scope: {
	      heading: '@',               // Interpolate the heading attribute onto this scope
	      isOpen: '=?',
	      isDisabled: '=?'
	    },
	    controller: function() {
	      this.setHeading = function(element) {
	        this.heading = element;
	      };
	    },
	    link: function(scope, element, attrs, accordionCtrl) {
	      accordionCtrl.addGroup(scope);
	
	      scope.openClass = attrs.openClass || 'panel-open';
	      scope.panelClass = attrs.panelClass;
	      scope.$watch('isOpen', function(value) {
	        element.toggleClass(scope.openClass, value);
	        if (value) {
	          accordionCtrl.closeOthers(scope);
	        }
	      });
	
	      scope.toggleOpen = function($event) {
	        if (!scope.isDisabled) {
	          if (!$event || $event.which === 32) {
	            scope.isOpen = !scope.isOpen;
	          }
	        }
	      };
	    }
	  };
	})
	
	// Use accordion-heading below an accordion-group to provide a heading containing HTML
	// <accordion-group>
	//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
	// </accordion-group>
	.directive('accordionHeading', function() {
	  return {
	    restrict: 'EA',
	    transclude: true,   // Grab the contents to be used as the heading
	    template: '',       // In effect remove this element!
	    replace: true,
	    require: '^accordionGroup',
	    link: function(scope, element, attr, accordionGroupCtrl, transclude) {
	      // Pass the heading to the accordion-group controller
	      // so that it can be transcluded into the right place in the template
	      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
	    }
	  };
	})
	
	// Use in the accordion-group template to indicate where you want the heading to be transcluded
	// You must provide the property on the accordion-group controller that will hold the transcluded element
	// <div class="accordion-group">
	//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
	//   ...
	// </div>
	.directive('accordionTransclude', function() {
	  return {
	    require: '^accordionGroup',
	    link: function(scope, element, attr, controller) {
	      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
	        if (heading) {
	          element.find('span').html('');
	          element.find('span').append(heading);
	        }
	      });
	    }
	  };
	})
	
	;
	
	angular.module('ui.bootstrap.alert', [])
	
	.controller('AlertController', ['$scope', '$attrs', function($scope, $attrs) {
	  $scope.closeable = !!$attrs.close;
	  this.close = $scope.close;
	}])
	
	.directive('alert', function() {
	  return {
	    controller: 'AlertController',
	    controllerAs: 'alert',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/alert/alert.html';
	    },
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@',
	      close: '&'
	    }
	  };
	})
	
	.directive('dismissOnTimeout', ['$timeout', function($timeout) {
	  return {
	    require: 'alert',
	    link: function(scope, element, attrs, alertCtrl) {
	      $timeout(function() {
	        alertCtrl.close();
	      }, parseInt(attrs.dismissOnTimeout, 10));
	    }
	  };
	}]);
	
	angular.module('ui.bootstrap.bindHtml', [])
	
	  .value('$bindHtmlUnsafeSuppressDeprecated', false)
	
	  .directive('bindHtmlUnsafe', ['$log', '$bindHtmlUnsafeSuppressDeprecated', function ($log, $bindHtmlUnsafeSuppressDeprecated) {
	    return function (scope, element, attr) {
	      if (!$bindHtmlUnsafeSuppressDeprecated) {
	        $log.warn('bindHtmlUnsafe is now deprecated. Use ngBindHtml instead');
	      }
	      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
	      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
	        element.html(value || '');
	      });
	    };
	  }]);
	angular.module('ui.bootstrap.buttons', [])
	
	.constant('buttonConfig', {
	  activeClass: 'active',
	  toggleEvent: 'click'
	})
	
	.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {
	  this.activeClass = buttonConfig.activeClass || 'active';
	  this.toggleEvent = buttonConfig.toggleEvent || 'click';
	}])
	
	.directive('btnRadio', function() {
	  return {
	    require: ['btnRadio', 'ngModel'],
	    controller: 'ButtonsController',
	    controllerAs: 'buttons',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      element.find('input').css({display: 'none'});
	
	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
	      };
	
	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }
	
	        var isActive = element.hasClass(buttonsCtrl.activeClass);
	
	        if (!isActive || angular.isDefined(attrs.uncheckable)) {
	          scope.$apply(function() {
	            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
	            ngModelCtrl.$render();
	          });
	        }
	      });
	    }
	  };
	})
	
	.directive('btnCheckbox', ['$document', function($document) {
	  return {
	    require: ['btnCheckbox', 'ngModel'],
	    controller: 'ButtonsController',
	    controllerAs: 'button',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      element.find('input').css({display: 'none'});
	
	      function getTrueValue() {
	        return getCheckboxValue(attrs.btnCheckboxTrue, true);
	      }
	
	      function getFalseValue() {
	        return getCheckboxValue(attrs.btnCheckboxFalse, false);
	      }
	
	      function getCheckboxValue(attributeValue, defaultValue) {
	        var val = scope.$eval(attributeValue);
	        return angular.isDefined(val) ? val : defaultValue;
	      }
	
	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	      };
	
	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }
	
	        scope.$apply(function() {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	
	      //accessibility
	      element.on('keypress', function(e) {
	        if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
	          return;
	        }
	
	        scope.$apply(function() {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	    }
	  };
	}]);
	
	/**
	* @ngdoc overview
	* @name ui.bootstrap.carousel
	*
	* @description
	* AngularJS version of an image carousel.
	*
	*/
	angular.module('ui.bootstrap.carousel', [])
	.controller('CarouselController', ['$scope', '$element', '$interval', '$animate', function ($scope, $element, $interval, $animate) {
	  var self = this,
	    slides = self.slides = $scope.slides = [],
	    NEW_ANIMATE = angular.version.minor >= 4,
	    NO_TRANSITION = 'uib-noTransition',
	    SLIDE_DIRECTION = 'uib-slideDirection',
	    currentIndex = -1,
	    currentInterval, isPlaying;
	  self.currentSlide = null;
	
	  var destroyed = false;
	  /* direction: "prev" or "next" */
	  self.select = $scope.select = function(nextSlide, direction) {
	    var nextIndex = $scope.indexOfSlide(nextSlide);
	    //Decide direction if it's not given
	    if (direction === undefined) {
	      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
	    }
	    //Prevent this user-triggered transition from occurring if there is already one in progress
	    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
	      goNext(nextSlide, nextIndex, direction);
	    }
	  };
	
	  function goNext(slide, index, direction) {
	    // Scope has been destroyed, stop here.
	    if (destroyed) { return; }
	
	    angular.extend(slide, {direction: direction, active: true});
	    angular.extend(self.currentSlide || {}, {direction: direction, active: false});
	    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&
	      slide.$element && self.slides.length > 1) {
	      slide.$element.data(SLIDE_DIRECTION, slide.direction);
	      if (self.currentSlide && self.currentSlide.$element) {
	        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
	      }
	
	      $scope.$currentTransition = true;
	      if (NEW_ANIMATE) {
	        $animate.on('addClass', slide.$element, function (element, phase) {
	          if (phase === 'close') {
	            $scope.$currentTransition = null;
	            $animate.off('addClass', element);
	          }
	        });
	      } else {
	        slide.$element.one('$animate:close', function closeFn() {
	          $scope.$currentTransition = null;
	        });
	      }
	    }
	
	    self.currentSlide = slide;
	    currentIndex = index;
	
	    //every time you change slides, reset the timer
	    restartTimer();
	  }
	
	  $scope.$on('$destroy', function () {
	    destroyed = true;
	  });
	
	  function getSlideByIndex(index) {
	    if (angular.isUndefined(slides[index].index)) {
	      return slides[index];
	    }
	    var i, len = slides.length;
	    for (i = 0; i < slides.length; ++i) {
	      if (slides[i].index == index) {
	        return slides[i];
	      }
	    }
	  }
	
	  self.getCurrentIndex = function() {
	    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
	      return +self.currentSlide.index;
	    }
	    return currentIndex;
	  };
	
	  /* Allow outside people to call indexOf on slides array */
	  $scope.indexOfSlide = function(slide) {
	    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
	  };
	
	  $scope.next = function() {
	    var newIndex = (self.getCurrentIndex() + 1) % slides.length;
	
	    if (newIndex === 0 && $scope.noWrap()) {
	      $scope.pause();
	      return;
	    }
	
	    return self.select(getSlideByIndex(newIndex), 'next');
	  };
	
	  $scope.prev = function() {
	    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
	
	    if ($scope.noWrap() && newIndex === slides.length - 1){
	      $scope.pause();
	      return;
	    }
	
	    return self.select(getSlideByIndex(newIndex), 'prev');
	  };
	
	  $scope.isActive = function(slide) {
	     return self.currentSlide === slide;
	  };
	
	  $scope.$watch('interval', restartTimer);
	  $scope.$on('$destroy', resetTimer);
	
	  function restartTimer() {
	    resetTimer();
	    var interval = +$scope.interval;
	    if (!isNaN(interval) && interval > 0) {
	      currentInterval = $interval(timerFn, interval);
	    }
	  }
	
	  function resetTimer() {
	    if (currentInterval) {
	      $interval.cancel(currentInterval);
	      currentInterval = null;
	    }
	  }
	
	  function timerFn() {
	    var interval = +$scope.interval;
	    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
	      $scope.next();
	    } else {
	      $scope.pause();
	    }
	  }
	
	  $scope.play = function() {
	    if (!isPlaying) {
	      isPlaying = true;
	      restartTimer();
	    }
	  };
	  $scope.pause = function() {
	    if (!$scope.noPause) {
	      isPlaying = false;
	      resetTimer();
	    }
	  };
	
	  self.addSlide = function(slide, element) {
	    slide.$element = element;
	    slides.push(slide);
	    //if this is the first slide or the slide is set to active, select it
	    if(slides.length === 1 || slide.active) {
	      self.select(slides[slides.length-1]);
	      if (slides.length == 1) {
	        $scope.play();
	      }
	    } else {
	      slide.active = false;
	    }
	  };
	
	  self.removeSlide = function(slide) {
	    if (angular.isDefined(slide.index)) {
	      slides.sort(function(a, b) {
	        return +a.index > +b.index;
	      });
	    }
	    //get the index of the slide inside the carousel
	    var index = slides.indexOf(slide);
	    slides.splice(index, 1);
	    if (slides.length > 0 && slide.active) {
	      if (index >= slides.length) {
	        self.select(slides[index-1]);
	      } else {
	        self.select(slides[index]);
	      }
	    } else if (currentIndex > index) {
	      currentIndex--;
	    }
	    
	    //clean the currentSlide when no more slide
	    if (slides.length === 0) {
	      self.currentSlide = null;
	    }
	  };
	
	  $scope.$watch('noTransition', function(noTransition) {
	    $element.data(NO_TRANSITION, noTransition);
	  });
	
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:carousel
	 * @restrict EA
	 *
	 * @description
	 * Carousel is the outer container for a set of image 'slides' to showcase.
	 *
	 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
	 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
	 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <carousel>
	      <slide>
	        <img src="http://placekitten.com/150/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>Beautiful!</p>
	        </div>
	      </slide>
	      <slide>
	        <img src="http://placekitten.com/100/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>D'aww!</p>
	        </div>
	      </slide>
	    </carousel>
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	 */
	.directive('carousel', [function() {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    controller: 'CarouselController',
	    controllerAs: 'carousel',
	    require: 'carousel',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/carousel.html';
	    },
	    scope: {
	      interval: '=',
	      noTransition: '=',
	      noPause: '=',
	      noWrap: '&'
	    }
	  };
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:slide
	 * @restrict EA
	 *
	 * @description
	 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
	 *
	 * @param {boolean=} active Model binding, whether or not this slide is currently active.
	 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	<div ng-controller="CarouselDemoCtrl">
	  <carousel>
	    <slide ng-repeat="slide in slides" active="slide.active" index="$index">
	      <img ng-src="{{slide.image}}" style="margin:auto;">
	      <div class="carousel-caption">
	        <h4>Slide {{$index}}</h4>
	        <p>{{slide.text}}</p>
	      </div>
	    </slide>
	  </carousel>
	  Interval, in milliseconds: <input type="number" ng-model="myInterval">
	  <br />Enter a negative number to stop the interval.
	</div>
	  </file>
	  <file name="script.js">
	function CarouselDemoCtrl($scope) {
	  $scope.myInterval = 5000;
	}
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	*/
	
	.directive('slide', function() {
	  return {
	    require: '^carousel',
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/slide.html';
	    },
	    scope: {
	      active: '=?',
	      actual: '=?',
	      index: '=?'
	    },
	    link: function (scope, element, attrs, carouselCtrl) {
	      carouselCtrl.addSlide(scope, element);
	      //when the scope is destroyed then remove the slide from the current slides array
	      scope.$on('$destroy', function() {
	        carouselCtrl.removeSlide(scope);
	      });
	
	      scope.$watch('active', function(active) {
	        if (active) {
	          carouselCtrl.select(scope);
	        }
	      });
	    }
	  };
	})
	
	.animation('.item', [
	         '$injector', '$animate',
	function ($injector, $animate) {
	  var NO_TRANSITION = 'uib-noTransition',
	    SLIDE_DIRECTION = 'uib-slideDirection',
	    $animateCss = null;
	
	  if ($injector.has('$animateCss')) {
	    $animateCss = $injector.get('$animateCss');
	  }
	
	  function removeClass(element, className, callback) {
	    element.removeClass(className);
	    if (callback) {
	      callback();
	    }
	  }
	
	  return {
	    beforeAddClass: function (element, className, done) {
	      // Due to transclusion, noTransition property is on parent's scope
	      if (className == 'active' && element.parent() &&
	          !element.parent().data(NO_TRANSITION)) {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction == 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element,
	          directionClass + ' ' + direction, done);
	        element.addClass(direction);
	
	        if ($animateCss) {
	          $animateCss(element, {addClass: directionClass})
	            .start()
	            .done(removeClassFn);
	        } else {
	          $animate.addClass(element, directionClass).then(function () {
	            if (!stopped) {
	              removeClassFn();
	            }
	            done();
	          });
	        }
	
	        return function () {
	          stopped = true;
	        };
	      }
	      done();
	    },
	    beforeRemoveClass: function (element, className, done) {
	      // Due to transclusion, noTransition property is on parent's scope
	      if (className === 'active' && element.parent() &&
	          !element.parent().data(NO_TRANSITION)) {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction == 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element, directionClass, done);
	
	        if ($animateCss) {
	          $animateCss(element, {addClass: directionClass})
	            .start()
	            .done(removeClassFn);
	        } else {
	          $animate.addClass(element, directionClass).then(function () {
	            if (!stopped) {
	              removeClassFn();
	            }
	            done();
	          });
	        }
	        return function () {
	          stopped = true;
	        };
	      }
	      done();
	    }
	  };
	
	}])
	
	
	;
	
	angular.module('ui.bootstrap.dateparser', [])
	
	.service('dateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {
	  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
	  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	
	  this.parsers = {};
	
	  var formatCodeToRegex = {
	    'yyyy': {
	      regex: '\\d{4}',
	      apply: function(value) { this.year = +value; }
	    },
	    'yy': {
	      regex: '\\d{2}',
	      apply: function(value) { this.year = +value + 2000; }
	    },
	    'y': {
	      regex: '\\d{1,4}',
	      apply: function(value) { this.year = +value; }
	    },
	    'MMMM': {
	      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
	      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
	    },
	    'MMM': {
	      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
	      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
	    },
	    'MM': {
	      regex: '0[1-9]|1[0-2]',
	      apply: function(value) { this.month = value - 1; }
	    },
	    'M': {
	      regex: '[1-9]|1[0-2]',
	      apply: function(value) { this.month = value - 1; }
	    },
	    'dd': {
	      regex: '[0-2][0-9]{1}|3[0-1]{1}',
	      apply: function(value) { this.date = +value; }
	    },
	    'd': {
	      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
	      apply: function(value) { this.date = +value; }
	    },
	    'EEEE': {
	      regex: $locale.DATETIME_FORMATS.DAY.join('|')
	    },
	    'EEE': {
	      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
	    },
	    'HH': {
	      regex: '(?:0|1)[0-9]|2[0-3]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'hh': {
	      regex: '0[0-9]|1[0-2]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'H': {
	      regex: '1?[0-9]|2[0-3]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'h': {
	      regex: '[0-9]|1[0-2]',
	      apply: function(value) { this.hours = +value; }
	    },
	    'mm': {
	      regex: '[0-5][0-9]',
	      apply: function(value) { this.minutes = +value; }
	    },
	    'm': {
	      regex: '[0-9]|[1-5][0-9]',
	      apply: function(value) { this.minutes = +value; }
	    },
	    'sss': {
	      regex: '[0-9][0-9][0-9]',
	      apply: function(value) { this.milliseconds = +value; }
	    },
	    'ss': {
	      regex: '[0-5][0-9]',
	      apply: function(value) { this.seconds = +value; }
	    },
	    's': {
	      regex: '[0-9]|[1-5][0-9]',
	      apply: function(value) { this.seconds = +value; }
	    },
	    'a': {
	      regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
	      apply: function(value) {
	        if (this.hours === 12) {
	          this.hours = 0;
	        }
	
	        if (value === 'PM') {
	          this.hours += 12;
	        }
	      }
	    }
	  };
	
	  function createParser(format) {
	    var map = [], regex = format.split('');
	
	    angular.forEach(formatCodeToRegex, function(data, code) {
	      var index = format.indexOf(code);
	
	      if (index > -1) {
	        format = format.split('');
	
	        regex[index] = '(' + data.regex + ')';
	        format[index] = '$'; // Custom symbol to define consumed part of format
	        for (var i = index + 1, n = index + code.length; i < n; i++) {
	          regex[i] = '';
	          format[i] = '$';
	        }
	        format = format.join('');
	
	        map.push({ index: index, apply: data.apply });
	      }
	    });
	
	    return {
	      regex: new RegExp('^' + regex.join('') + '$'),
	      map: orderByFilter(map, 'index')
	    };
	  }
	
	  this.parse = function(input, format, baseDate) {
	    if (!angular.isString(input) || !format) {
	      return input;
	    }
	
	    format = $locale.DATETIME_FORMATS[format] || format;
	    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
	
	    if (!this.parsers[format]) {
	      this.parsers[format] = createParser(format);
	    }
	
	    var parser = this.parsers[format],
	        regex = parser.regex,
	        map = parser.map,
	        results = input.match(regex);
	
	    if (results && results.length) {
	      var fields, dt;
	      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
	        fields = {
	          year: baseDate.getFullYear(),
	          month: baseDate.getMonth(),
	          date: baseDate.getDate(),
	          hours: baseDate.getHours(),
	          minutes: baseDate.getMinutes(),
	          seconds: baseDate.getSeconds(),
	          milliseconds: baseDate.getMilliseconds()
	        };
	      } else {
	        if (baseDate) {
	          $log.warn('dateparser:', 'baseDate is not a valid date');
	        }
	        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
	      }
	
	      for (var i = 1, n = results.length; i < n; i++) {
	        var mapper = map[i-1];
	        if (mapper.apply) {
	          mapper.apply.call(fields, results[i]);
	        }
	      }
	
	      if (isValid(fields.year, fields.month, fields.date)) {
	        dt = new Date(fields.year, fields.month, fields.date,
	          fields.hours, fields.minutes, fields.seconds,
	          fields.milliseconds || 0);
	      }
	
	      return dt;
	    }
	  };
	
	  // Check if date is valid for specific month (and year for February).
	  // Month: 0 = Jan, 1 = Feb, etc
	  function isValid(year, month, date) {
	    if (date < 1) {
	      return false;
	    }
	
	    if (month === 1 && date > 28) {
	      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
	    }
	
	    if (month === 3 || month === 5 || month === 8 || month === 10) {
	      return date < 31;
	    }
	
	    return true;
	  }
	}]);
	
	angular.module('ui.bootstrap.position', [])
	
	/**
	 * A set of utility methods that can be use to retrieve position of DOM elements.
	 * It is meant to be used where we need to absolute-position DOM elements in
	 * relation to other, existing elements (this is the case for tooltips, popovers,
	 * typeahead suggestions etc.).
	 */
	  .factory('$position', ['$document', '$window', function($document, $window) {
	    function getStyle(el, cssprop) {
	      if (el.currentStyle) { //IE
	        return el.currentStyle[cssprop];
	      } else if ($window.getComputedStyle) {
	        return $window.getComputedStyle(el)[cssprop];
	      }
	      // finally try and get inline style
	      return el.style[cssprop];
	    }
	
	    /**
	     * Checks if a given element is statically positioned
	     * @param element - raw DOM element
	     */
	    function isStaticPositioned(element) {
	      return (getStyle(element, 'position') || 'static' ) === 'static';
	    }
	
	    /**
	     * returns the closest, non-statically positioned parentOffset of a given element
	     * @param element
	     */
	    var parentOffsetEl = function(element) {
	      var docDomEl = $document[0];
	      var offsetParent = element.offsetParent || docDomEl;
	      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
	        offsetParent = offsetParent.offsetParent;
	      }
	      return offsetParent || docDomEl;
	    };
	
	    return {
	      /**
	       * Provides read-only equivalent of jQuery's position function:
	       * http://api.jquery.com/position/
	       */
	      position: function(element) {
	        var elBCR = this.offset(element);
	        var offsetParentBCR = { top: 0, left: 0 };
	        var offsetParentEl = parentOffsetEl(element[0]);
	        if (offsetParentEl != $document[0]) {
	          offsetParentBCR = this.offset(angular.element(offsetParentEl));
	          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
	          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
	        }
	
	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: elBCR.top - offsetParentBCR.top,
	          left: elBCR.left - offsetParentBCR.left
	        };
	      },
	
	      /**
	       * Provides read-only equivalent of jQuery's offset function:
	       * http://api.jquery.com/offset/
	       */
	      offset: function(element) {
	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
	          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
	        };
	      },
	
	      /**
	       * Provides coordinates for the targetEl in relation to hostEl
	       */
	      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
	        var positionStrParts = positionStr.split('-');
	        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';
	
	        var hostElPos,
	          targetElWidth,
	          targetElHeight,
	          targetElPos;
	
	        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
	
	        targetElWidth = targetEl.prop('offsetWidth');
	        targetElHeight = targetEl.prop('offsetHeight');
	
	        var shiftWidth = {
	          center: function() {
	            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
	          },
	          left: function() {
	            return hostElPos.left;
	          },
	          right: function() {
	            return hostElPos.left + hostElPos.width;
	          }
	        };
	
	        var shiftHeight = {
	          center: function() {
	            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
	          },
	          top: function() {
	            return hostElPos.top;
	          },
	          bottom: function() {
	            return hostElPos.top + hostElPos.height;
	          }
	        };
	
	        switch (pos0) {
	          case 'right':
	            targetElPos = {
	              top: shiftHeight[pos1](),
	              left: shiftWidth[pos0]()
	            };
	            break;
	          case 'left':
	            targetElPos = {
	              top: shiftHeight[pos1](),
	              left: hostElPos.left - targetElWidth
	            };
	            break;
	          case 'bottom':
	            targetElPos = {
	              top: shiftHeight[pos0](),
	              left: shiftWidth[pos1]()
	            };
	            break;
	          default:
	            targetElPos = {
	              top: hostElPos.top - targetElHeight,
	              left: shiftWidth[pos1]()
	            };
	            break;
	        }
	
	        return targetElPos;
	      }
	    };
	  }]);
	
	angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])
	
	.value('$datepickerSuppressError', false)
	
	.constant('datepickerConfig', {
	  formatDay: 'dd',
	  formatMonth: 'MMMM',
	  formatYear: 'yyyy',
	  formatDayHeader: 'EEE',
	  formatDayTitle: 'MMMM yyyy',
	  formatMonthTitle: 'yyyy',
	  datepickerMode: 'day',
	  minMode: 'day',
	  maxMode: 'year',
	  showWeeks: true,
	  startingDay: 0,
	  yearRange: 20,
	  minDate: null,
	  maxDate: null,
	  shortcutPropagation: false
	})
	
	.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'datepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;
	
	  // Modes chain
	  this.modes = ['day', 'month', 'year'];
	
	  // Configuration attributes
	  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
	                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
	    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
	  });
	
	  // Watchable date attributes
	  angular.forEach(['minDate', 'maxDate'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = value ? new Date(value) : null;
	        self.refreshView();
	      });
	    } else {
	      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
	    }
	  });
	
	  angular.forEach(['minMode', 'maxMode'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = angular.isDefined(value) ? value : $attrs[key];
	        $scope[key] = self[key];
	        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
	          $scope.datepickerMode = self[key];
	        }
	      });
	    } else {
	      self[key] = datepickerConfig[key] || null;
	      $scope[key] = self[key];
	    }
	  });
	
	  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
	  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
	
	  if (angular.isDefined($attrs.initDate)) {
	    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
	    $scope.$parent.$watch($attrs.initDate, function(initDate) {
	      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
	        self.activeDate = initDate;
	        self.refreshView();
	      }
	    });
	  } else {
	    this.activeDate = new Date();
	  }
	
	  $scope.isActive = function(dateObject) {
	    if (self.compare(dateObject.date, self.activeDate) === 0) {
	      $scope.activeDateId = dateObject.uid;
	      return true;
	    }
	    return false;
	  };
	
	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	  };
	
	  this.render = function() {
	    if (ngModelCtrl.$viewValue) {
	      var date = new Date(ngModelCtrl.$viewValue),
	          isValid = !isNaN(date);
	
	      if (isValid) {
	        this.activeDate = date;
	      } else if (!$datepickerSuppressError) {
	        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	      }
	    }
	    this.refreshView();
	  };
	
	  this.refreshView = function() {
	    if (this.element) {
	      this._refreshView();
	
	      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
	    }
	  };
	
	  this.createDateObject = function(date, format) {
	    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	    return {
	      date: date,
	      label: dateFilter(date, format),
	      selected: model && this.compare(date, model) === 0,
	      disabled: this.isDisabled(date),
	      current: this.compare(date, new Date()) === 0,
	      customClass: this.customClass(date)
	    };
	  };
	
	  this.isDisabled = function(date) {
	    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
	  };
	
	  this.customClass = function(date) {
	    return $scope.customClass({date: date, mode: $scope.datepickerMode});
	  };
	
	  // Split array into smaller arrays
	  this.split = function(arr, size) {
	    var arrays = [];
	    while (arr.length > 0) {
	      arrays.push(arr.splice(0, size));
	    }
	    return arrays;
	  };
	
	  // Fix a hard-reprodusible bug with timezones
	  // The bug depends on OS, browser, current timezone and current date
	  // i.e.
	  // var date = new Date(2014, 0, 1);
	  // console.log(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours());
	  // can result in "2013 11 31 23" because of the bug.
	  this.fixTimeZone = function(date) {
	    var hours = date.getHours();
	    date.setHours(hours === 23 ? hours + 2 : 0);
	  };
	
	  $scope.select = function(date) {
	    if ($scope.datepickerMode === self.minMode) {
	      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
	      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	      ngModelCtrl.$setViewValue(dt);
	      ngModelCtrl.$render();
	    } else {
	      self.activeDate = date;
	      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
	    }
	  };
	
	  $scope.move = function(direction) {
	    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
	        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	    self.activeDate.setFullYear(year, month, 1);
	    self.refreshView();
	  };
	
	  $scope.toggleMode = function(direction) {
	    direction = direction || 1;
	
	    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
	      return;
	    }
	
	    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
	  };
	
	  // Key event mapper
	  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
	
	  var focusElement = function() {
	    self.element[0].focus();
	  };
	
	  // Listen for focus requests from popup directive
	  $scope.$on('datepicker.focus', focusElement);
	
	  $scope.keydown = function(evt) {
	    var key = $scope.keys[evt.which];
	
	    if (!key || evt.shiftKey || evt.altKey) {
	      return;
	    }
	
	    evt.preventDefault();
	    if (!self.shortcutPropagation) {
	      evt.stopPropagation();
	    }
	
	    if (key === 'enter' || key === 'space') {
	      if (self.isDisabled(self.activeDate)) {
	        return; // do nothing
	      }
	      $scope.select(self.activeDate);
	      focusElement();
	    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	      $scope.toggleMode(key === 'up' ? 1 : -1);
	      focusElement();
	    } else {
	      self.handleKeyDown(key, evt);
	      self.refreshView();
	    }
	  };
	}])
	
	.directive('datepicker', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/datepicker.html';
	    },
	    scope: {
	      datepickerMode: '=?',
	      dateDisabled: '&',
	      customClass: '&',
	      shortcutPropagation: '&?'
	    },
	    require: ['datepicker', '^ngModel'],
	    controller: 'DatepickerController',
	    controllerAs: 'datepicker',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      datepickerCtrl.init(ngModelCtrl);
	    }
	  };
	})
	
	.directive('daypicker', ['dateFilter', function(dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/day.html',
	    require: '^datepicker',
	    link: function(scope, element, attrs, ctrl) {
	      scope.showWeeks = ctrl.showWeeks;
	
	      ctrl.step = { months: 1 };
	      ctrl.element = element;
	
	      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	      function getDaysInMonth(year, month) {
	        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
	      }
	
	      function getDates(startDate, n) {
	        var dates = new Array(n), current = new Date(startDate), i = 0, date;
	        while (i < n) {
	          date = new Date(current);
	          ctrl.fixTimeZone(date);
	          dates[i++] = date;
	          current.setDate(current.getDate() + 1);
	        }
	        return dates;
	      }
	
	      ctrl._refreshView = function() {
	        var year = ctrl.activeDate.getFullYear(),
	          month = ctrl.activeDate.getMonth(),
	          firstDayOfMonth = new Date(year, month, 1),
	          difference = ctrl.startingDay - firstDayOfMonth.getDay(),
	          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
	          firstDate = new Date(firstDayOfMonth);
	
	        if (numDisplayedFromPreviousMonth > 0) {
	          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
	        }
	
	        // 42 is the number of days on a six-month calendar
	        var days = getDates(firstDate, 42);
	        for (var i = 0; i < 42; i ++) {
	          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
	            secondary: days[i].getMonth() !== month,
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.labels = new Array(7);
	        for (var j = 0; j < 7; j++) {
	          scope.labels[j] = {
	            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
	            full: dateFilter(days[j].date, 'EEEE')
	          };
	        }
	
	        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
	        scope.rows = ctrl.split(days, 7);
	
	        if (scope.showWeeks) {
	          scope.weekNumbers = [];
	          var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7,
	              numWeeks = scope.rows.length;
	          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
	            scope.weekNumbers.push(
	              getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
	          }
	        }
	      };
	
	      ctrl.compare = function(date1, date2) {
	        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
	      };
	
	      function getISO8601WeekNumber(date) {
	        var checkDate = new Date(date);
	        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	        var time = checkDate.getTime();
	        checkDate.setMonth(0); // Compare with Jan 1
	        checkDate.setDate(1);
	        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	      }
	
	      ctrl.handleKeyDown = function(key, evt) {
	        var date = ctrl.activeDate.getDate();
	
	        if (key === 'left') {
	          date = date - 1;   // up
	        } else if (key === 'up') {
	          date = date - 7;   // down
	        } else if (key === 'right') {
	          date = date + 1;   // down
	        } else if (key === 'down') {
	          date = date + 7;
	        } else if (key === 'pageup' || key === 'pagedown') {
	          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
	          ctrl.activeDate.setMonth(month, 1);
	          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
	        } else if (key === 'home') {
	          date = 1;
	        } else if (key === 'end') {
	          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
	        }
	        ctrl.activeDate.setDate(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}])
	
	.directive('monthpicker', ['dateFilter', function(dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/month.html',
	    require: '^datepicker',
	    link: function(scope, element, attrs, ctrl) {
	      ctrl.step = { years: 1 };
	      ctrl.element = element;
	
	      ctrl._refreshView = function() {
	        var months = new Array(12),
	            year = ctrl.activeDate.getFullYear(),
	            date;
	
	        for (var i = 0; i < 12; i++) {
	          date = new Date(year, i, 1);
	          ctrl.fixTimeZone(date);
	          months[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatMonth), {
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
	        scope.rows = ctrl.split(months, 3);
	      };
	
	      ctrl.compare = function(date1, date2) {
	        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
	      };
	
	      ctrl.handleKeyDown = function(key, evt) {
	        var date = ctrl.activeDate.getMonth();
	
	        if (key === 'left') {
	          date = date - 1;   // up
	        } else if (key === 'up') {
	          date = date - 3;   // down
	        } else if (key === 'right') {
	          date = date + 1;   // down
	        } else if (key === 'down') {
	          date = date + 3;
	        } else if (key === 'pageup' || key === 'pagedown') {
	          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
	          ctrl.activeDate.setFullYear(year);
	        } else if (key === 'home') {
	          date = 0;
	        } else if (key === 'end') {
	          date = 11;
	        }
	        ctrl.activeDate.setMonth(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}])
	
	.directive('yearpicker', ['dateFilter', function(dateFilter) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/year.html',
	    require: '^datepicker',
	    link: function(scope, element, attrs, ctrl) {
	      var range = ctrl.yearRange;
	
	      ctrl.step = { years: range };
	      ctrl.element = element;
	
	      function getStartingYear( year ) {
	        return parseInt((year - 1) / range, 10) * range + 1;
	      }
	
	      ctrl._refreshView = function() {
	        var years = new Array(range), date;
	
	        for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
	          date = new Date(start + i, 0, 1);
	          ctrl.fixTimeZone(date);
	          years[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatYear), {
	            uid: scope.uniqueId + '-' + i
	          });
	        }
	
	        scope.title = [years[0].label, years[range - 1].label].join(' - ');
	        scope.rows = ctrl.split(years, 5);
	      };
	
	      ctrl.compare = function(date1, date2) {
	        return date1.getFullYear() - date2.getFullYear();
	      };
	
	      ctrl.handleKeyDown = function(key, evt) {
	        var date = ctrl.activeDate.getFullYear();
	
	        if (key === 'left') {
	          date = date - 1;   // up
	        } else if (key === 'up') {
	          date = date - 5;   // down
	        } else if (key === 'right') {
	          date = date + 1;   // down
	        } else if (key === 'down') {
	          date = date + 5;
	        } else if (key === 'pageup' || key === 'pagedown') {
	          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;
	        } else if (key === 'home') {
	          date = getStartingYear(ctrl.activeDate.getFullYear());
	        } else if (key === 'end') {
	          date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
	        }
	        ctrl.activeDate.setFullYear(date);
	      };
	
	      ctrl.refreshView();
	    }
	  };
	}])
	
	.constant('datepickerPopupConfig', {
	  datepickerPopup: 'yyyy-MM-dd',
	  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
	  datepickerTemplateUrl: 'template/datepicker/datepicker.html',
	  html5Types: {
	    date: 'yyyy-MM-dd',
	    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
	    'month': 'yyyy-MM'
	  },
	  currentText: 'Today',
	  clearText: 'Clear',
	  closeText: 'Done',
	  closeOnDateSelection: true,
	  appendToBody: false,
	  showButtonBar: true,
	  onOpenFocus: true
	})
	
	.directive('datepickerPopup', ['$compile', '$parse', '$document', '$rootScope', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig', '$timeout',
	function($compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
	  return {
	    restrict: 'EA',
	    require: 'ngModel',
	    scope: {
	      isOpen: '=?',
	      currentText: '@',
	      clearText: '@',
	      closeText: '@',
	      dateDisabled: '&',
	      customClass: '&'
	    },
	    link: function(scope, element, attrs, ngModel) {
	      var dateFormat,
	          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
	          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody,
	          onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus,
	          datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl,
	          datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl,
	          cache = {};
	
	      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
	
	      scope.getText = function(key) {
	        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
	      };
	
	      scope.isDisabled = function(date) {
	        if (date === 'today') {
	          date = new Date();
	        }
	
	        return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||
	          (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));
	      };
	
	      scope.compare = function(date1, date2) {
	        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
	      };
	
	      var isHtml5DateInput = false;
	      if (datepickerPopupConfig.html5Types[attrs.type]) {
	        dateFormat = datepickerPopupConfig.html5Types[attrs.type];
	        isHtml5DateInput = true;
	      } else {
	        dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
	        attrs.$observe('datepickerPopup', function(value, oldValue) {
	            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
	            // Invalidate the $modelValue to ensure that formatters re-run
	            // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
	            if (newDateFormat !== dateFormat) {
	              dateFormat = newDateFormat;
	              ngModel.$modelValue = null;
	
	              if (!dateFormat) {
	                throw new Error('datepickerPopup must have a date format specified.');
	              }
	            }
	        });
	      }
	
	      if (!dateFormat) {
	        throw new Error('datepickerPopup must have a date format specified.');
	      }
	
	      if (isHtml5DateInput && attrs.datepickerPopup) {
	        throw new Error('HTML5 date input types do not support custom formats.');
	      }
	
	      // popup element used to display calendar
	      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
	      popupEl.attr({
	        'ng-model': 'date',
	        'ng-change': 'dateSelection(date)',
	        'template-url': datepickerPopupTemplateUrl
	      });
	
	      function cameltoDash(string) {
	        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
	      }
	
	      // datepicker element
	      var datepickerEl = angular.element(popupEl.children()[0]);
	      datepickerEl.attr('template-url', datepickerTemplateUrl);
	
	      if (isHtml5DateInput) {
	        if (attrs.type === 'month') {
	          datepickerEl.attr('datepicker-mode', '"month"');
	          datepickerEl.attr('min-mode', 'month');
	        }
	      }
	
	      if (attrs.datepickerOptions) {
	        var options = scope.$parent.$eval(attrs.datepickerOptions);
	        if (options && options.initDate) {
	          scope.initDate = options.initDate;
	          datepickerEl.attr('init-date', 'initDate');
	          delete options.initDate;
	        }
	        angular.forEach(options, function(value, option) {
	          datepickerEl.attr( cameltoDash(option), value );
	        });
	      }
	
	      scope.watchData = {};
	      angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
	        if (attrs[key]) {
	          var getAttribute = $parse(attrs[key]);
	          scope.$parent.$watch(getAttribute, function(value) {
	            scope.watchData[key] = value;
	            if (key === 'minDate' || key === 'maxDate') {
	              cache[key] = new Date(value);
	            }
	          });
	          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
	
	          // Propagate changes from datepicker to outside
	          if (key === 'datepickerMode') {
	            var setAttribute = getAttribute.assign;
	            scope.$watch('watchData.' + key, function(value, oldvalue) {
	              if (angular.isFunction(setAttribute) && value !== oldvalue) {
	                setAttribute(scope.$parent, value);
	              }
	            });
	          }
	        }
	      });
	      if (attrs.dateDisabled) {
	        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
	      }
	
	      if (attrs.showWeeks) {
	        datepickerEl.attr('show-weeks', attrs.showWeeks);
	      }
	
	      if (attrs.customClass) {
	        datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
	      }
	
	      function parseDate(viewValue) {
	        if (angular.isNumber(viewValue)) {
	          // presumably timestamp to date object
	          viewValue = new Date(viewValue);
	        }
	
	        if (!viewValue) {
	          return null;
	        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
	          return viewValue;
	        } else if (angular.isString(viewValue)) {
	          var date = dateParser.parse(viewValue, dateFormat, scope.date);
	          if (isNaN(date)) {
	            return undefined;
	          } else {
	            return date;
	          }
	        } else {
	          return undefined;
	        }
	      }
	
	      function validator(modelValue, viewValue) {
	        var value = modelValue || viewValue;
	
	        if (!attrs.ngRequired && !value) {
	          return true;
	        }
	
	        if (angular.isNumber(value)) {
	          value = new Date(value);
	        }
	        if (!value) {
	          return true;
	        } else if (angular.isDate(value) && !isNaN(value)) {
	          return true;
	        } else if (angular.isString(value)) {
	          var date = dateParser.parse(value, dateFormat);
	          return !isNaN(date);
	        } else {
	          return false;
	        }
	      }
	
	      if (!isHtml5DateInput) {
	        // Internal API to maintain the correct ng-invalid-[key] class
	        ngModel.$$parserName = 'date';
	        ngModel.$validators.date = validator;
	        ngModel.$parsers.unshift(parseDate);
	        ngModel.$formatters.push(function(value) {
	          scope.date = value;
	          return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
	        });
	      } else {
	        ngModel.$formatters.push(function(value) {
	          scope.date = value;
	          return value;
	        });
	      }
	
	      // Inner change
	      scope.dateSelection = function(dt) {
	        if (angular.isDefined(dt)) {
	          scope.date = dt;
	        }
	        var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
	        element.val(date);
	        ngModel.$setViewValue(date);
	
	        if (closeOnDateSelection) {
	          scope.isOpen = false;
	          element[0].focus();
	        }
	      };
	
	      // Detect changes in the view from the text box
	      ngModel.$viewChangeListeners.push(function() {
	        scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
	      });
	
	      var documentClickBind = function(event) {
	        if (scope.isOpen && !(element[0].contains(event.target) || popupEl[0].contains(event.target))) {
	          scope.$apply(function() {
	            scope.isOpen = false;
	          });
	        }
	      };
	
	      var inputKeydownBind = function(evt) {
	        if (evt.which === 27 && scope.isOpen) {
	          evt.preventDefault();
	          evt.stopPropagation();
	          scope.$apply(function() {
	            scope.isOpen = false;
	          });
	          element[0].focus();
	        } else if (evt.which === 40 && !scope.isOpen) {
	          evt.preventDefault();
	          evt.stopPropagation();
	          scope.$apply(function() {
	            scope.isOpen = true;
	          });
	        }
	      };
	      element.bind('keydown', inputKeydownBind);
	
	      scope.keydown = function(evt) {
	        if (evt.which === 27) {
	          scope.isOpen = false;
	          element[0].focus();
	        }
	      };
	
	      scope.$watch('isOpen', function(value) {
	        if (value) {
	          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	          scope.position.top = scope.position.top + element.prop('offsetHeight');
	
	          $timeout(function() {
	            if (onOpenFocus) {
	              scope.$broadcast('datepicker.focus');
	            }
	            $document.bind('click', documentClickBind);
	          }, 0, false);
	        } else {
	          $document.unbind('click', documentClickBind);
	        }
	      });
	
	      scope.select = function(date) {
	        if (date === 'today') {
	          var today = new Date();
	          if (angular.isDate(scope.date)) {
	            date = new Date(scope.date);
	            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
	          } else {
	            date = new Date(today.setHours(0, 0, 0, 0));
	          }
	        }
	        scope.dateSelection(date);
	      };
	
	      scope.close = function() {
	        scope.isOpen = false;
	        element[0].focus();
	      };
	
	      var $popup = $compile(popupEl)(scope);
	      // Prevent jQuery cache memory leak (template is now redundant after linking)
	      popupEl.remove();
	
	      if (appendToBody) {
	        $document.find('body').append($popup);
	      } else {
	        element.after($popup);
	      }
	
	      scope.$on('$destroy', function() {
	        if (scope.isOpen === true) {
	          if (!$rootScope.$$phase) {
	            scope.$apply(function() {
	              scope.isOpen = false;
	            });
	          }
	        }
	
	        $popup.remove();
	        element.unbind('keydown', inputKeydownBind);
	        $document.unbind('click', documentClickBind);
	      });
	    }
	  };
	}])
	
	.directive('datepickerPopupWrap', function() {
	  return {
	    restrict:'EA',
	    replace: true,
	    transclude: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/popup.html';
	    }
	  };
	});
	
	angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])
	
	.constant('dropdownConfig', {
	  openClass: 'open'
	})
	
	.service('dropdownService', ['$document', '$rootScope', function($document, $rootScope) {
	  var openScope = null;
	
	  this.open = function(dropdownScope) {
	    if (!openScope) {
	      $document.bind('click', closeDropdown);
	      $document.bind('keydown', keybindFilter);
	    }
	
	    if (openScope && openScope !== dropdownScope) {
	      openScope.isOpen = false;
	    }
	
	    openScope = dropdownScope;
	  };
	
	  this.close = function(dropdownScope) {
	    if (openScope === dropdownScope) {
	      openScope = null;
	      $document.unbind('click', closeDropdown);
	      $document.unbind('keydown', keybindFilter);
	    }
	  };
	
	  var closeDropdown = function(evt) {
	    // This method may still be called during the same mouse event that
	    // unbound this event handler. So check openScope before proceeding.
	    if (!openScope) { return; }
	
	    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }
	
	    var toggleElement = openScope.getToggleElement();
	    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
	      return;
	    }
	
	    var dropdownElement = openScope.getDropdownElement();
	    if (evt && openScope.getAutoClose() === 'outsideClick' &&
	      dropdownElement && dropdownElement[0].contains(evt.target)) {
	      return;
	    }
	
	    openScope.isOpen = false;
	
	    if (!$rootScope.$$phase) {
	      openScope.$apply();
	    }
	  };
	
	  var keybindFilter = function(evt) {
	    if (evt.which === 27) {
	      openScope.focusToggleElement();
	      closeDropdown();
	    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      openScope.focusDropdownEntry(evt.which);
	    }
	  };
	}])
	
	.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', '$position', '$document', '$compile', '$templateRequest', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document, $compile, $templateRequest) {
	  var self = this,
	    scope = $scope.$new(), // create a child scope so we are not polluting original one
	    templateScope,
	    openClass = dropdownConfig.openClass,
	    getIsOpen,
	    setIsOpen = angular.noop,
	    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
	    appendToBody = false,
	    keynavEnabled = false,
	    selectedOption = null,
	    body = $document.find('body');
	
	  this.init = function(element) {
	    self.$element = element;
	
	    if ($attrs.isOpen) {
	      getIsOpen = $parse($attrs.isOpen);
	      setIsOpen = getIsOpen.assign;
	
	      $scope.$watch(getIsOpen, function(value) {
	        scope.isOpen = !!value;
	      });
	    }
	
	    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
	    keynavEnabled = angular.isDefined($attrs.keyboardNav);
	
	    if (appendToBody && self.dropdownMenu) {
	      body.append(self.dropdownMenu);
	      body.addClass('dropdown');
	      element.on('$destroy', function handleDestroyEvent() {
	        self.dropdownMenu.remove();
	      });
	    }
	  };
	
	  this.toggle = function(open) {
	    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	  };
	
	  // Allow other directives to watch status
	  this.isOpen = function() {
	    return scope.isOpen;
	  };
	
	  scope.getToggleElement = function() {
	    return self.toggleElement;
	  };
	
	  scope.getAutoClose = function() {
	    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
	  };
	
	  scope.getElement = function() {
	    return self.$element;
	  };
	
	  scope.isKeynavEnabled = function() {
	    return keynavEnabled;
	  };
	
	  scope.focusDropdownEntry = function(keyCode) {
	    var elems = self.dropdownMenu ? //If append to body is used.
	      (angular.element(self.dropdownMenu).find('a')) :
	      (angular.element(self.$element).find('ul').eq(0).find('a'));
	
	    switch (keyCode) {
	      case (40): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = 0;
	        } else {
	          self.selectedOption = (self.selectedOption === elems.length -1 ?
	            self.selectedOption :
	            self.selectedOption + 1);
	        }
	        break;
	      }
	      case (38): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = elems.length - 1;
	        } else {
	          self.selectedOption = self.selectedOption === 0 ?
	            0 : self.selectedOption - 1;
	        }
	        break;
	      }
	    }
	    elems[self.selectedOption].focus();
	  };
	
	  scope.getDropdownElement = function() {
	    return self.dropdownMenu;
	  };
	
	  scope.focusToggleElement = function() {
	    if (self.toggleElement) {
	      self.toggleElement[0].focus();
	    }
	  };
	
	  scope.$watch('isOpen', function(isOpen, wasOpen) {
	    if (appendToBody && self.dropdownMenu) {
	      var pos = $position.positionElements(self.$element, self.dropdownMenu, 'bottom-left', true);
	      var css = {
	        top: pos.top + 'px',
	        display: isOpen ? 'block' : 'none'
	      };
	
	      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
	      if (!rightalign) {
	        css.left = pos.left + 'px';
	        css.right = 'auto';
	      } else {
	        css.left = 'auto';
	        css.right = (window.innerWidth - (pos.left + self.$element.prop('offsetWidth'))) + 'px';
	      }
	
	      self.dropdownMenu.css(css);
	    }
	
	    var openContainer = appendToBody ? body : self.$element;
	
	    $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, openClass).then(function() {
	      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
	        toggleInvoker($scope, { open: !!isOpen });
	      }
	    });
	
	    if (isOpen) {
	      if (self.dropdownMenuTemplateUrl) {
	        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
	          templateScope = scope.$new();
	          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
	            var newEl = dropdownElement;
	            self.dropdownMenu.replaceWith(newEl);
	            self.dropdownMenu = newEl;
	          });
	        });
	      }
	
	      scope.focusToggleElement();
	      dropdownService.open(scope);
	    } else {
	      if (self.dropdownMenuTemplateUrl) {
	        if (templateScope) {
	          templateScope.$destroy();
	        }
	        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
	        self.dropdownMenu.replaceWith(newEl);
	        self.dropdownMenu = newEl;
	      }
	
	      dropdownService.close(scope);
	      self.selectedOption = null;
	    }
	
	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen($scope, isOpen);
	    }
	  });
	
	  $scope.$on('$locationChangeSuccess', function() {
	    if (scope.getAutoClose() !== 'disabled') {
	      scope.isOpen = false;
	    }
	  });
	
	  var offDestroy = $scope.$on('$destroy', function() {
	    scope.$destroy();
	  });
	  scope.$on('$destroy', offDestroy);
	}])
	
	.directive('dropdown', function() {
	  return {
	    controller: 'DropdownController',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      dropdownCtrl.init( element );
	      element.addClass('dropdown');
	    }
	  };
	})
	
	.directive('dropdownMenu', function() {
	  return {
	    restrict: 'AC',
	    require: '?^dropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }
	      var tplUrl = attrs.templateUrl;
	      if (tplUrl) {
	        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
	      }
	      if (!dropdownCtrl.dropdownMenu) {
	        dropdownCtrl.dropdownMenu = element;
	      }
	    }
	  };
	})
	
	.directive('keyboardNav', function() {
	  return {
	    restrict: 'A',
	    require: '?^dropdown',
	    link: function (scope, element, attrs, dropdownCtrl) {
	
	      element.bind('keydown', function(e) {
	        if ([38, 40].indexOf(e.which) !== -1) {
	          e.preventDefault();
	          e.stopPropagation();
	
	          var elems = dropdownCtrl.dropdownMenu.find('a');
	
	          switch (e.which) {
	            case (40): { // Down
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = 0;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
	                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
	              }
	              break;
	            }
	            case (38): { // Up
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = elems.length - 1;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
	                  0 : dropdownCtrl.selectedOption - 1;
	              }
	              break;
	            }
	          }
	          elems[dropdownCtrl.selectedOption].focus();
	        }
	      });
	    }
	  };
	})
	
	.directive('dropdownToggle', function() {
	  return {
	    require: '?^dropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }
	
	      element.addClass('dropdown-toggle');
	
	      dropdownCtrl.toggleElement = element;
	
	      var toggleDropdown = function(event) {
	        event.preventDefault();
	
	        if (!element.hasClass('disabled') && !attrs.disabled) {
	          scope.$apply(function() {
	            dropdownCtrl.toggle();
	          });
	        }
	      };
	
	      element.bind('click', toggleDropdown);
	
	      // WAI-ARIA
	      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {
	        element.attr('aria-expanded', !!isOpen);
	      });
	
	      scope.$on('$destroy', function() {
	        element.unbind('click', toggleDropdown);
	      });
	    }
	  };
	});
	
	angular.module('ui.bootstrap.modal', [])
	
	/**
	 * A helper, internal data structure that acts as a map but also allows getting / removing
	 * elements in the LIFO order
	 */
	  .factory('$$stackedMap', function() {
	    return {
	      createNew: function() {
	        var stack = [];
	
	        return {
	          add: function(key, value) {
	            stack.push({
	              key: key,
	              value: value
	            });
	          },
	          get: function(key) {
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                return stack[i];
	              }
	            }
	          },
	          keys: function() {
	            var keys = [];
	            for (var i = 0; i < stack.length; i++) {
	              keys.push(stack[i].key);
	            }
	            return keys;
	          },
	          top: function() {
	            return stack[stack.length - 1];
	          },
	          remove: function(key) {
	            var idx = -1;
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                idx = i;
	                break;
	              }
	            }
	            return stack.splice(idx, 1)[0];
	          },
	          removeTop: function() {
	            return stack.splice(stack.length - 1, 1)[0];
	          },
	          length: function() {
	            return stack.length;
	          }
	        };
	      }
	    };
	  })
	
	/**
	 * A helper, internal data structure that stores all references attached to key
	 */
	  .factory('$$multiMap', function() {
	    return {
	      createNew: function() {
	        var map = {};
	
	        return {
	          entries: function() {
	            return Object.keys(map).map(function(key) {
	              return {
	                key: key,
	                value: map[key]
	              };
	            });
	          },
	          get: function(key) {
	            return map[key];
	          },
	          hasKey: function(key) {
	            return !!map[key];
	          },
	          keys: function() {
	            return Object.keys(map);
	          },
	          put: function(key, value) {
	            if (!map[key]) {
	              map[key] = [];
	            }
	
	            map[key].push(value);
	          },
	          remove: function(key, value) {
	            var values = map[key];
	
	            if (!values) {
	              return;
	            }
	
	            var idx = values.indexOf(value);
	
	            if (idx !== -1) {
	              values.splice(idx, 1);
	            }
	
	            if (!values.length) {
	              delete map[key];
	            }
	          }
	        };
	      }
	    };
	  })
	
	/**
	 * A helper directive for the $modal service. It creates a backdrop element.
	 */
	  .directive('modalBackdrop', [
	           '$animate', '$injector', '$modalStack',
	  function($animate ,  $injector,   $modalStack) {
	    var $animateCss = null;
	
	    if ($injector.has('$animateCss')) {
	      $animateCss = $injector.get('$animateCss');
	    }
	
	    return {
	      restrict: 'EA',
	      replace: true,
	      templateUrl: 'template/modal/backdrop.html',
	      compile: function(tElement, tAttrs) {
	        tElement.addClass(tAttrs.backdropClass);
	        return linkFn;
	      }
	    };
	
	    function linkFn(scope, element, attrs) {
	      if (attrs.modalInClass) {
	        if ($animateCss) {
	          $animateCss(element, {
	            addClass: attrs.modalInClass
	          }).start();
	        } else {
	          $animate.addClass(element, attrs.modalInClass);
	        }
	
	        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	          var done = setIsAsync();
	          if ($animateCss) {
	            $animateCss(element, {
	              removeClass: attrs.modalInClass
	            }).start().then(done);
	          } else {
	            $animate.removeClass(element, attrs.modalInClass).then(done);
	          }
	        });
	      }
	    }
	  }])
	
	  .directive('modalWindow', [
	           '$modalStack', '$q', '$animate', '$injector',
	  function($modalStack ,  $q ,  $animate,   $injector) {
	    var $animateCss = null;
	
	    if ($injector.has('$animateCss')) {
	      $animateCss = $injector.get('$animateCss');
	    }
	
	    return {
	      restrict: 'EA',
	      scope: {
	        index: '@'
	      },
	      replace: true,
	      transclude: true,
	      templateUrl: function(tElement, tAttrs) {
	        return tAttrs.templateUrl || 'template/modal/window.html';
	      },
	      link: function(scope, element, attrs) {
	        element.addClass(attrs.windowClass || '');
	        scope.size = attrs.size;
	
	        scope.close = function(evt) {
	          var modal = $modalStack.getTop();
	          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
	            evt.preventDefault();
	            evt.stopPropagation();
	            $modalStack.dismiss(modal.key, 'backdrop click');
	          }
	        };
	
	        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
	        // We can detect that by using this property in the template associated with this directive and then use
	        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
	        scope.$isRendered = true;
	
	        // Deferred object that will be resolved when this modal is render.
	        var modalRenderDeferObj = $q.defer();
	        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
	        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
	        attrs.$observe('modalRender', function(value) {
	          if (value == 'true') {
	            modalRenderDeferObj.resolve();
	          }
	        });
	
	        modalRenderDeferObj.promise.then(function() {
	          var animationPromise = null;
	
	          if (attrs.modalInClass) {
	            if ($animateCss) {
	              animationPromise = $animateCss(element, {
	                addClass: attrs.modalInClass
	              }).start();
	            } else {
	              animationPromise = $animate.addClass(element, attrs.modalInClass);
	            }
	
	            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	              var done = setIsAsync();
	              if ($animateCss) {
	                $animateCss(element, {
	                  removeClass: attrs.modalInClass
	                }).start().then(done);
	              } else {
	                $animate.removeClass(element, attrs.modalInClass).then(done);
	              }
	            });
	          }
	
	
	          $q.when(animationPromise).then(function() {
	            var inputsWithAutofocus = element[0].querySelectorAll('[autofocus]');
	            /**
	             * Auto-focusing of a freshly-opened modal element causes any child elements
	             * with the autofocus attribute to lose focus. This is an issue on touch
	             * based devices which will show and then hide the onscreen keyboard.
	             * Attempts to refocus the autofocus element via JavaScript will not reopen
	             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
	             * the modal element if the modal does not contain an autofocus element.
	             */
	            if (inputsWithAutofocus.length) {
	              inputsWithAutofocus[0].focus();
	            } else {
	              element[0].focus();
	            }
	          });
	
	          // Notify {@link $modalStack} that modal is rendered.
	          var modal = $modalStack.getTop();
	          if (modal) {
	            $modalStack.modalRendered(modal.key);
	          }
	        });
	      }
	    };
	  }])
	
	  .directive('modalAnimationClass', [
	    function () {
	      return {
	        compile: function(tElement, tAttrs) {
	          if (tAttrs.modalAnimation) {
	            tElement.addClass(tAttrs.modalAnimationClass);
	          }
	        }
	      };
	    }])
	
	  .directive('modalTransclude', function() {
	    return {
	      link: function($scope, $element, $attrs, controller, $transclude) {
	        $transclude($scope.$parent, function(clone) {
	          $element.empty();
	          $element.append(clone);
	        });
	      }
	    };
	  })
	
	  .factory('$modalStack', [
	             '$animate', '$timeout', '$document', '$compile', '$rootScope',
	             '$q',
	             '$injector',
	             '$$multiMap',
	             '$$stackedMap',
	    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
	              $q,
	              $injector,
	              $$multiMap,
	              $$stackedMap) {
	      var $animateCss = null;
	
	      if ($injector.has('$animateCss')) {
	        $animateCss = $injector.get('$animateCss');
	      }
	
	      var OPENED_MODAL_CLASS = 'modal-open';
	
	      var backdropDomEl, backdropScope;
	      var openedWindows = $$stackedMap.createNew();
	      var openedClasses = $$multiMap.createNew();
	      var $modalStack = {
	        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
	      };
	
	      //Modal focus behavior
	      var focusableElementList;
	      var focusIndex = 0;
	      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
	        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
	        'iframe, object, embed, *[tabindex], *[contenteditable=true]';
	
	      function backdropIndex() {
	        var topBackdropIndex = -1;
	        var opened = openedWindows.keys();
	        for (var i = 0; i < opened.length; i++) {
	          if (openedWindows.get(opened[i]).value.backdrop) {
	            topBackdropIndex = i;
	          }
	        }
	        return topBackdropIndex;
	      }
	
	      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
	        if (backdropScope) {
	          backdropScope.index = newBackdropIndex;
	        }
	      });
	
	      function removeModalWindow(modalInstance, elementToReceiveFocus) {
	        var body = $document.find('body').eq(0);
	        var modalWindow = openedWindows.get(modalInstance).value;
	
	        //clean up the stack
	        openedWindows.remove(modalInstance);
	
	        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
	          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
	          openedClasses.remove(modalBodyClass, modalInstance);
	          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
	        });
	        checkRemoveBackdrop();
	
	        //move focus to specified element if available, or else to body
	        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
	          elementToReceiveFocus.focus();
	        } else {
	          body.focus();
	        }
	      }
	
	      function checkRemoveBackdrop() {
	          //remove backdrop if no longer needed
	          if (backdropDomEl && backdropIndex() == -1) {
	            var backdropScopeRef = backdropScope;
	            removeAfterAnimate(backdropDomEl, backdropScope, function() {
	              backdropScopeRef = null;
	            });
	            backdropDomEl = undefined;
	            backdropScope = undefined;
	          }
	      }
	
	      function removeAfterAnimate(domEl, scope, done) {
	        var asyncDeferred;
	        var asyncPromise = null;
	        var setIsAsync = function() {
	          if (!asyncDeferred) {
	            asyncDeferred = $q.defer();
	            asyncPromise = asyncDeferred.promise;
	          }
	
	          return function asyncDone() {
	            asyncDeferred.resolve();
	          };
	        };
	        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
	
	        // Note that it's intentional that asyncPromise might be null.
	        // That's when setIsAsync has not been called during the
	        // NOW_CLOSING_EVENT broadcast.
	        return $q.when(asyncPromise).then(afterAnimating);
	
	        function afterAnimating() {
	          if (afterAnimating.done) {
	            return;
	          }
	          afterAnimating.done = true;
	
	          if ($animateCss) {
	            $animateCss(domEl, {
	              event: 'leave'
	            }).start().then(function() {
	              domEl.remove();
	            });
	          } else {
	            $animate.leave(domEl);
	          }
	          scope.$destroy();
	          if (done) {
	            done();
	          }
	        }
	      }
	
	      $document.bind('keydown', function(evt) {
	        if (evt.isDefaultPrevented()) {
	          return evt;
	        }
	
	        var modal = openedWindows.top();
	        if (modal && modal.value.keyboard) {
	          switch (evt.which){
	            case 27: {
	              evt.preventDefault();
	              $rootScope.$apply(function() {
	                $modalStack.dismiss(modal.key, 'escape key press');
	              });
	              break;
	            }
	            case 9: {
	              $modalStack.loadFocusElementList(modal);
	              var focusChanged = false;
	              if (evt.shiftKey) {
	                if ($modalStack.isFocusInFirstItem(evt)) {
	                  focusChanged = $modalStack.focusLastFocusableElement();
	                }
	              } else {
	                if ($modalStack.isFocusInLastItem(evt)) {
	                  focusChanged = $modalStack.focusFirstFocusableElement();
	                }
	              }
	
	              if (focusChanged) {
	                evt.preventDefault();
	                evt.stopPropagation();
	              }
	              break;
	            }
	          }
	        }
	      });
	
	      $modalStack.open = function(modalInstance, modal) {
	        var modalOpener = $document[0].activeElement,
	          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
	
	        openedWindows.add(modalInstance, {
	          deferred: modal.deferred,
	          renderDeferred: modal.renderDeferred,
	          modalScope: modal.scope,
	          backdrop: modal.backdrop,
	          keyboard: modal.keyboard,
	          openedClass: modal.openedClass
	        });
	
	        openedClasses.put(modalBodyClass, modalInstance);
	
	        var body = $document.find('body').eq(0),
	            currBackdropIndex = backdropIndex();
	
	        if (currBackdropIndex >= 0 && !backdropDomEl) {
	          backdropScope = $rootScope.$new(true);
	          backdropScope.index = currBackdropIndex;
	          var angularBackgroundDomEl = angular.element('<div modal-backdrop="modal-backdrop"></div>');
	          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
	          if (modal.animation) {
	            angularBackgroundDomEl.attr('modal-animation', 'true');
	          }
	          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
	          body.append(backdropDomEl);
	        }
	
	        var angularDomEl = angular.element('<div modal-window="modal-window"></div>');
	        angularDomEl.attr({
	          'template-url': modal.windowTemplateUrl,
	          'window-class': modal.windowClass,
	          'size': modal.size,
	          'index': openedWindows.length() - 1,
	          'animate': 'animate'
	        }).html(modal.content);
	        if (modal.animation) {
	          angularDomEl.attr('modal-animation', 'true');
	        }
	
	        var modalDomEl = $compile(angularDomEl)(modal.scope);
	        openedWindows.top().value.modalDomEl = modalDomEl;
	        openedWindows.top().value.modalOpener = modalOpener;
	        body.append(modalDomEl);
	        body.addClass(modalBodyClass);
	
	        $modalStack.clearFocusListCache();
	      };
	
	      function broadcastClosing(modalWindow, resultOrReason, closing) {
	          return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
	      }
	
	      $modalStack.close = function(modalInstance, result) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.resolve(result);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };
	
	      $modalStack.dismiss = function(modalInstance, reason) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.reject(reason);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };
	
	      $modalStack.dismissAll = function(reason) {
	        var topModal = this.getTop();
	        while (topModal && this.dismiss(topModal.key, reason)) {
	          topModal = this.getTop();
	        }
	      };
	
	      $modalStack.getTop = function() {
	        return openedWindows.top();
	      };
	
	      $modalStack.modalRendered = function(modalInstance) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow) {
	          modalWindow.value.renderDeferred.resolve();
	        }
	      };
	
	      $modalStack.focusFirstFocusableElement = function() {
	        if (focusableElementList.length > 0) {
	          focusableElementList[0].focus();
	          return true;
	        }
	        return false;
	      };
	      $modalStack.focusLastFocusableElement = function() {
	        if (focusableElementList.length > 0) {
	          focusableElementList[focusableElementList.length - 1].focus();
	          return true;
	        }
	        return false;
	      };
	
	      $modalStack.isFocusInFirstItem = function(evt) {
	        if (focusableElementList.length > 0) {
	          return (evt.target || evt.srcElement) == focusableElementList[0];
	        }
	        return false;
	      };
	
	      $modalStack.isFocusInLastItem = function(evt) {
	        if (focusableElementList.length > 0) {
	          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
	        }
	        return false;
	      };
	
	      $modalStack.clearFocusListCache = function() {
	        focusableElementList = [];
	        focusIndex = 0;
	      };
	
	      $modalStack.loadFocusElementList = function(modalWindow) {
	        if (focusableElementList === undefined || !focusableElementList.length0) {
	          if (modalWindow) {
	            var modalDomE1 = modalWindow.value.modalDomEl;
	            if (modalDomE1 && modalDomE1.length) {
	              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
	            }
	          }
	        }
	      };
	
	      return $modalStack;
	    }])
	
	  .provider('$modal', function() {
	    var $modalProvider = {
	      options: {
	        animation: true,
	        backdrop: true, //can also be false or 'static'
	        keyboard: true
	      },
	      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$modalStack',
	        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack) {
	          var $modal = {};
	
	          function getTemplatePromise(options) {
	            return options.template ? $q.when(options.template) :
	              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
	          }
	
	          function getResolvePromises(resolves) {
	            var promisesArr = [];
	            angular.forEach(resolves, function(value) {
	              if (angular.isFunction(value) || angular.isArray(value)) {
	                promisesArr.push($q.when($injector.invoke(value)));
	              } else if (angular.isString(value)) {
	                promisesArr.push($q.when($injector.get(value)));
	              } else {
	                promisesArr.push($q.when(value));
	              }
	            });
	            return promisesArr;
	          }
	
	          var promiseChain = null;
	          $modal.getPromiseChain = function() {
	            return promiseChain;
	          };
	
	          $modal.open = function (modalOptions) {
	
	            var modalResultDeferred = $q.defer();
	            var modalOpenedDeferred = $q.defer();
	            var modalRenderDeferred = $q.defer();
	
	            //prepare an instance of a modal to be injected into controllers and returned to a caller
	            var modalInstance = {
	              result: modalResultDeferred.promise,
	              opened: modalOpenedDeferred.promise,
	              rendered: modalRenderDeferred.promise,
	              close: function (result) {
	                return $modalStack.close(modalInstance, result);
	              },
	              dismiss: function (reason) {
	                return $modalStack.dismiss(modalInstance, reason);
	              }
	            };
	
	            //merge and clean up options
	            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
	            modalOptions.resolve = modalOptions.resolve || {};
	
	            //verify options
	            if (!modalOptions.template && !modalOptions.templateUrl) {
	              throw new Error('One of template or templateUrl options is required.');
	            }
	
	            var templateAndResolvePromise =
	              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
	
	            // Wait for the resolution of the existing promise chain.
	            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
	            // Then add to $modalStack and resolve opened.
	            // Finally clean up the chain variable if no subsequent modal has overwritten it.
	            var samePromise;
	            samePromise = promiseChain = $q.all([promiseChain])
	              .then(function() { return templateAndResolvePromise; }, function() { return templateAndResolvePromise; })
	              .then(function resolveSuccess(tplAndVars) {
	
	                var modalScope = (modalOptions.scope || $rootScope).$new();
	                modalScope.$close = modalInstance.close;
	                modalScope.$dismiss = modalInstance.dismiss;
	
	                modalScope.$on('$destroy', function() {
	                  if (!modalScope.$$uibDestructionScheduled) {
	                    modalScope.$dismiss('$uibUnscheduledDestruction');
	                  }
	                });
	
	                var ctrlInstance, ctrlLocals = {};
	                var resolveIter = 1;
	
	                //controllers
	                if (modalOptions.controller) {
	                  ctrlLocals.$scope = modalScope;
	                  ctrlLocals.$modalInstance = modalInstance;
	                  angular.forEach(modalOptions.resolve, function(value, key) {
	                    ctrlLocals[key] = tplAndVars[resolveIter++];
	                  });
	
	                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
	                  if (modalOptions.controllerAs) {
	                    if (modalOptions.bindToController) {
	                      angular.extend(ctrlInstance, modalScope);
	                    }
	
	                    modalScope[modalOptions.controllerAs] = ctrlInstance;
	                  }
	                }
	
	                $modalStack.open(modalInstance, {
	                  scope: modalScope,
	                  deferred: modalResultDeferred,
	                  renderDeferred: modalRenderDeferred,
	                  content: tplAndVars[0],
	                  animation: modalOptions.animation,
	                  backdrop: modalOptions.backdrop,
	                  keyboard: modalOptions.keyboard,
	                  backdropClass: modalOptions.backdropClass,
	                  windowClass: modalOptions.windowClass,
	                  windowTemplateUrl: modalOptions.windowTemplateUrl,
	                  size: modalOptions.size,
	                  openedClass: modalOptions.openedClass
	                });
	                modalOpenedDeferred.resolve(true);
	
	            }, function resolveError(reason) {
	              modalOpenedDeferred.reject(reason);
	              modalResultDeferred.reject(reason);
	            })
	            .finally(function() {
	              if (promiseChain === samePromise) {
	                promiseChain = null;
	              }
	            });
	
	            return modalInstance;
	          };
	
	          return $modal;
	        }]
	    };
	
	    return $modalProvider;
	  });
	
	angular.module('ui.bootstrap.pagination', [])
	.controller('PaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	
	  this.init = function(ngModelCtrl_, config) {
	    ngModelCtrl = ngModelCtrl_;
	    this.config = config;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	
	    if ($attrs.itemsPerPage) {
	      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
	        self.itemsPerPage = parseInt(value, 10);
	        $scope.totalPages = self.calculateTotalPages();
	      });
	    } else {
	      this.itemsPerPage = config.itemsPerPage;
	    }
	
	    $scope.$watch('totalItems', function() {
	      $scope.totalPages = self.calculateTotalPages();
	    });
	
	    $scope.$watch('totalPages', function(value) {
	      setNumPages($scope.$parent, value); // Readonly variable
	
	      if ( $scope.page > value ) {
	        $scope.selectPage(value);
	      } else {
	        ngModelCtrl.$render();
	      }
	    });
	  };
	
	  this.calculateTotalPages = function() {
	    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
	    return Math.max(totalPages || 0, 1);
	  };
	
	  this.render = function() {
	    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
	  };
	
	  $scope.selectPage = function(page, evt) {
	    if (evt) {
	      evt.preventDefault();
	    }
	
	    var clickAllowed = !$scope.ngDisabled || !evt;
	    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
	      if (evt && evt.target) {
	        evt.target.blur();
	      }
	      ngModelCtrl.$setViewValue(page);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.getText = function(key) {
	    return $scope[key + 'Text'] || self.config[key + 'Text'];
	  };
	
	  $scope.noPrevious = function() {
	    return $scope.page === 1;
	  };
	
	  $scope.noNext = function() {
	    return $scope.page === $scope.totalPages;
	  };
	}])
	
	.constant('paginationConfig', {
	  itemsPerPage: 10,
	  boundaryLinks: false,
	  directionLinks: true,
	  firstText: 'First',
	  previousText: 'Previous',
	  nextText: 'Next',
	  lastText: 'Last',
	  rotate: true
	})
	
	.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      firstText: '@',
	      previousText: '@',
	      nextText: '@',
	      lastText: '@',
	      ngDisabled:'='
	    },
	    require: ['pagination', '?ngModel'],
	    controller: 'PaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pagination.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      // Setup configuration parameters
	      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
	          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
	      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
	      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
	
	      paginationCtrl.init(ngModelCtrl, paginationConfig);
	
	      if (attrs.maxSize) {
	        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
	          maxSize = parseInt(value, 10);
	          paginationCtrl.render();
	        });
	      }
	
	      // Create page object used in template
	      function makePage(number, text, isActive) {
	        return {
	          number: number,
	          text: text,
	          active: isActive
	        };
	      }
	
	      function getPages(currentPage, totalPages) {
	        var pages = [];
	
	        // Default page limits
	        var startPage = 1, endPage = totalPages;
	        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
	
	        // recompute if maxSize
	        if (isMaxSized) {
	          if (rotate) {
	            // Current page is displayed in the middle of the visible ones
	            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
	            endPage   = startPage + maxSize - 1;
	
	            // Adjust if limit is exceeded
	            if (endPage > totalPages) {
	              endPage   = totalPages;
	              startPage = endPage - maxSize + 1;
	            }
	          } else {
	            // Visible pages are paginated with maxSize
	            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
	
	            // Adjust last page if limit is exceeded
	            endPage = Math.min(startPage + maxSize - 1, totalPages);
	          }
	        }
	
	        // Add page number links
	        for (var number = startPage; number <= endPage; number++) {
	          var page = makePage(number, number, number === currentPage);
	          pages.push(page);
	        }
	
	        // Add links to move between page sets
	        if (isMaxSized && ! rotate) {
	          if (startPage > 1) {
	            var previousPageSet = makePage(startPage - 1, '...', false);
	            pages.unshift(previousPageSet);
	          }
	
	          if (endPage < totalPages) {
	            var nextPageSet = makePage(endPage + 1, '...', false);
	            pages.push(nextPageSet);
	          }
	        }
	
	        return pages;
	      }
	
	      var originalRender = paginationCtrl.render;
	      paginationCtrl.render = function() {
	        originalRender();
	        if (scope.page > 0 && scope.page <= scope.totalPages) {
	          scope.pages = getPages(scope.page, scope.totalPages);
	        }
	      };
	    }
	  };
	}])
	
	.constant('pagerConfig', {
	  itemsPerPage: 10,
	  previousText: ' Previous',
	  nextText: 'Next ',
	  align: true
	})
	
	.directive('pager', ['pagerConfig', function(pagerConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      previousText: '@',
	      nextText: '@',
	      ngDisabled: '='
	    },
	    require: ['pager', '?ngModel'],
	    controller: 'PaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pager.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
	      paginationCtrl.init(ngModelCtrl, pagerConfig);
	    }
	  };
	}]);
	
	/**
	 * The following features are still outstanding: animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html tooltips, and selector delegation.
	 */
	angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])
	
	/**
	 * The $tooltip service creates tooltip- and popover-like directives as well as
	 * houses global options for them.
	 */
	.provider('$tooltip', function() {
	  // The default options tooltip and popover.
	  var defaultOptions = {
	    placement: 'top',
	    animation: true,
	    popupDelay: 0,
	    useContentExp: false
	  };
	
	  // Default hide triggers for each show trigger
	  var triggerMap = {
	    'mouseenter': 'mouseleave',
	    'click': 'click',
	    'focus': 'blur',
	    'none': ''
	  };
	
	  // The options specified to the provider globally.
	  var globalOptions = {};
	
	  /**
	   * `options({})` allows global configuration of all tooltips in the
	   * application.
	   *
	   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
	   *     // place tooltips left instead of top by default
	   *     $tooltipProvider.options( { placement: 'left' } );
	   *   });
	   */
		this.options = function(value) {
			angular.extend(globalOptions, value);
		};
	
	  /**
	   * This allows you to extend the set of trigger mappings available. E.g.:
	   *
	   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
	   */
	  this.setTriggers = function setTriggers(triggers) {
	    angular.extend(triggerMap, triggers);
	  };
	
	  /**
	   * This is a helper function for translating camel-case to snake-case.
	   */
	  function snake_case(name) {
	    var regexp = /[A-Z]/g;
	    var separator = '-';
	    return name.replace(regexp, function(letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }
	
	  /**
	   * Returns the actual instance of the $tooltip service.
	   * TODO support multiple triggers
	   */
	  this.$get = ['$window', '$compile', '$timeout', '$document', '$position', '$interpolate', '$rootScope', '$parse', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse) {
	    return function $tooltip(type, prefix, defaultTriggerShow, options) {
	      options = angular.extend({}, defaultOptions, globalOptions, options);
	
	      /**
	       * Returns an object of show and hide triggers.
	       *
	       * If a trigger is supplied,
	       * it is used to show the tooltip; otherwise, it will use the `trigger`
	       * option passed to the `$tooltipProvider.options` method; else it will
	       * default to the trigger supplied to this directive factory.
	       *
	       * The hide trigger is based on the show trigger. If the `trigger` option
	       * was passed to the `$tooltipProvider.options` method, it will use the
	       * mapped trigger from `triggerMap` or the passed trigger if the map is
	       * undefined; otherwise, it uses the `triggerMap` value of the show
	       * trigger; else it will just use the show trigger.
	       */
	      function getTriggers(trigger) {
	        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
	        var hide = show.map(function(trigger) {
	          return triggerMap[trigger] || trigger;
	        });
	        return {
	          show: show,
	          hide: hide
	        };
	      }
	
	      var directiveName = snake_case(type);
	
	      var startSym = $interpolate.startSymbol();
	      var endSym = $interpolate.endSymbol();
	      var template =
	        '<div '+ directiveName +'-popup '+
	          'title="'+startSym+'title'+endSym+'" '+
	          (options.useContentExp ?
	            'content-exp="contentExp()" ' :
	            'content="'+startSym+'content'+endSym+'" ') +
	          'placement="'+startSym+'placement'+endSym+'" '+
	          'popup-class="'+startSym+'popupClass'+endSym+'" '+
	          'animation="animation" '+
	          'is-open="isOpen"'+
	          'origin-scope="origScope" '+
	          '>'+
	        '</div>';
	
	      return {
	        restrict: 'EA',
	        compile: function(tElem, tAttrs) {
	          var tooltipLinker = $compile( template );
	
	          return function link(scope, element, attrs, tooltipCtrl) {
	            var tooltip;
	            var tooltipLinkedScope;
	            var transitionTimeout;
	            var popupTimeout;
	            var positionTimeout;
	            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
	            var triggers = getTriggers(undefined);
	            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
	            var ttScope = scope.$new(true);
	            var repositionScheduled = false;
	            var isOpenExp = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
	
	            var positionTooltip = function() {
	              if (!tooltip) { return; }
	
	              if (!positionTimeout) {
	                positionTimeout = $timeout(function() {
	                  // Reset the positioning and box size for correct width and height values.
	                  tooltip.css({ top: 0, left: 0, width: 'auto', height: 'auto' });
	
	                  var ttBox = $position.position(tooltip);
	                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
	                  ttCss.top += 'px';
	                  ttCss.left += 'px';
	
	                  ttCss.width = ttBox.width + 'px';
	                  ttCss.height = ttBox.height + 'px';
	
	                  // Now set the calculated positioning and size.
	                  tooltip.css(ttCss);
	
	                  positionTimeout = null;
	
	                }, 0, false);
	              }
	            };
	
	            // Set up the correct scope to allow transclusion later
	            ttScope.origScope = scope;
	
	            // By default, the tooltip is not open.
	            // TODO add ability to start tooltip opened
	            ttScope.isOpen = false;
	
	            function toggleTooltipBind() {
	              if (!ttScope.isOpen) {
	                showTooltipBind();
	              } else {
	                hideTooltipBind();
	              }
	            }
	
	            // Show the tooltip with delay if specified, otherwise show it immediately
	            function showTooltipBind() {
	              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
	                return;
	              }
	
	              prepareTooltip();
	
	              if (ttScope.popupDelay) {
	                // Do nothing if the tooltip was already scheduled to pop-up.
	                // This happens if show is triggered multiple times before any hide is triggered.
	                if (!popupTimeout) {
	                  popupTimeout = $timeout(show, ttScope.popupDelay, false);
	                }
	              } else {
	                show();
	              }
	            }
	
	            function hideTooltipBind () {
	              hide();
	              if (!$rootScope.$$phase) {
	                $rootScope.$digest();
	              }
	            }
	
	            // Show the tooltip popup element.
	            function show() {
	              popupTimeout = null;
	
	              // If there is a pending remove transition, we must cancel it, lest the
	              // tooltip be mysteriously removed.
	              if (transitionTimeout) {
	                $timeout.cancel(transitionTimeout);
	                transitionTimeout = null;
	              }
	
	              // Don't show empty tooltips.
	              if (!(options.useContentExp ? ttScope.contentExp() : ttScope.content)) {
	                return angular.noop;
	              }
	
	              createTooltip();
	
	              // And show the tooltip.
	              ttScope.isOpen = true;
	              if (isOpenExp) {
	                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
	              }
	
	              if (!$rootScope.$$phase) {
	                ttScope.$apply(); // digest required as $apply is not called
	              }
	
	              tooltip.css({ display: 'block' });
	
	              positionTooltip();
	            }
	
	            // Hide the tooltip popup element.
	            function hide() {
	              // First things first: we don't show it anymore.
	              ttScope.isOpen = false;
	              if (isOpenExp) {
	                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
	              }
	
	              //if tooltip is going to be shown after delay, we must cancel this
	              $timeout.cancel(popupTimeout);
	              popupTimeout = null;
	
	              $timeout.cancel(positionTimeout);
	              positionTimeout = null;
	
	              // And now we remove it from the DOM. However, if we have animation, we
	              // need to wait for it to expire beforehand.
	              // FIXME: this is a placeholder for a port of the transitions library.
	              if (ttScope.animation) {
	                if (!transitionTimeout) {
	                  transitionTimeout = $timeout(removeTooltip, 500);
	                }
	              } else {
	                removeTooltip();
	              }
	            }
	
	            function createTooltip() {
	              // There can only be one tooltip element per directive shown at once.
	              if (tooltip) {
	                removeTooltip();
	              }
	              tooltipLinkedScope = ttScope.$new();
	              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
	                if (appendToBody) {
	                  $document.find('body').append(tooltip);
	                } else {
	                  element.after(tooltip);
	                }
	              });
	
	              if (options.useContentExp) {
	                tooltipLinkedScope.$watch('contentExp()', function(val) {
	                  if (!val && ttScope.isOpen) {
	                    hide();
	                  }
	                });
	
	                tooltipLinkedScope.$watch(function() {
	                  if (!repositionScheduled) {
	                    repositionScheduled = true;
	                    tooltipLinkedScope.$$postDigest(function() {
	                      repositionScheduled = false;
	                      if (ttScope.isOpen) {
	                        positionTooltip();
	                      }
	                    });
	                  }
	                });
	
	              }
	            }
	
	            function removeTooltip() {
	              transitionTimeout = null;
	              if (tooltip) {
	                tooltip.remove();
	                tooltip = null;
	              }
	              if (tooltipLinkedScope) {
	                tooltipLinkedScope.$destroy();
	                tooltipLinkedScope = null;
	              }
	            }
	
	            function prepareTooltip() {
	              prepPopupClass();
	              prepPlacement();
	              prepPopupDelay();
	            }
	
	            ttScope.contentExp = function() {
	              return scope.$eval(attrs[type]);
	            };
	
	            /**
	             * Observe the relevant attributes.
	             */
	            if (!options.useContentExp) {
	              attrs.$observe(type, function(val) {
	                ttScope.content = val;
	
	                if (!val && ttScope.isOpen) {
	                  hide();
	                } else {
	                  positionTooltip();
	                }
	              });
	            }
	
	            attrs.$observe('disabled', function(val) {
	              if (popupTimeout && val) {
	                $timeout.cancel(popupTimeout);
	                popupTimeout = null;
	              }
	
	              if (val && ttScope.isOpen) {
	                hide();
	              }
	            });
	
	            attrs.$observe(prefix + 'Title', function(val) {
	              ttScope.title = val;
	              positionTooltip();
	            });
	
	            attrs.$observe(prefix + 'Placement', function() {
	              if (ttScope.isOpen) {
	                prepPlacement();
	                positionTooltip();
	              }
	            });
	
	            if (isOpenExp) {
	              scope.$watch(isOpenExp, function(val) {
	                if (val !== ttScope.isOpen) {
	                  toggleTooltipBind();
	                }
	              });
	            }
	
	            function prepPopupClass() {
	              ttScope.popupClass = attrs[prefix + 'Class'];
	            }
	
	            function prepPlacement() {
	              var val = attrs[prefix + 'Placement'];
	              ttScope.placement = angular.isDefined(val) ? val : options.placement;
	            }
	
	            function prepPopupDelay() {
	              var val = attrs[prefix + 'PopupDelay'];
	              var delay = parseInt(val, 10);
	              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
	            }
	
	            var unregisterTriggers = function() {
	              triggers.show.forEach(function(trigger) {
	                element.unbind(trigger, showTooltipBind);
	              });
	              triggers.hide.forEach(function(trigger) {
	                element.unbind(trigger, hideTooltipBind);
	              });
	            };
	
	            function prepTriggers() {
	              var val = attrs[prefix + 'Trigger'];
	              unregisterTriggers();
	
	              triggers = getTriggers(val);
	
	              if (triggers.show !== 'none') {
	                triggers.show.forEach(function(trigger, idx) {
	                  // Using raw addEventListener due to jqLite/jQuery bug - #4060
	                  if (trigger === triggers.hide[idx]) {
	                    element[0].addEventListener(trigger, toggleTooltipBind);
	                  } else if (trigger) {
	                    element[0].addEventListener(trigger, showTooltipBind);
	                    element[0].addEventListener(triggers.hide[idx], hideTooltipBind);
	                  }
	                });
	              }
	            }
	            prepTriggers();
	
	            var animation = scope.$eval(attrs[prefix + 'Animation']);
	            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
	
	            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
	            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
	
	            // if a tooltip is attached to <body> we need to remove it on
	            // location change as its parent scope will probably not be destroyed
	            // by the change.
	            if (appendToBody) {
	              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
	                if (ttScope.isOpen) {
	                  hide();
	                }
	              });
	            }
	
	            // Make sure tooltip is destroyed and removed.
	            scope.$on('$destroy', function onDestroyTooltip() {
	              $timeout.cancel(transitionTimeout);
	              $timeout.cancel(popupTimeout);
	              $timeout.cancel(positionTimeout);
	              unregisterTriggers();
	              removeTooltip();
	              ttScope = null;
	            });
	          };
	        }
	      };
	    };
	  }];
	})
	
	// This is mostly ngInclude code but with a custom scope
	.directive('tooltipTemplateTransclude', [
	         '$animate', '$sce', '$compile', '$templateRequest',
	function ($animate ,  $sce ,  $compile ,  $templateRequest) {
	  return {
	    link: function(scope, elem, attrs) {
	      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
	
	      var changeCounter = 0,
	        currentScope,
	        previousElement,
	        currentElement;
	
	      var cleanupLastIncludeContent = function() {
	        if (previousElement) {
	          previousElement.remove();
	          previousElement = null;
	        }
	        if (currentScope) {
	          currentScope.$destroy();
	          currentScope = null;
	        }
	        if (currentElement) {
	          $animate.leave(currentElement).then(function() {
	            previousElement = null;
	          });
	          previousElement = currentElement;
	          currentElement = null;
	        }
	      };
	
	      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
	        var thisChangeId = ++changeCounter;
	
	        if (src) {
	          //set the 2nd param to true to ignore the template request error so that the inner
	          //contents and scope can be cleaned up.
	          $templateRequest(src, true).then(function(response) {
	            if (thisChangeId !== changeCounter) { return; }
	            var newScope = origScope.$new();
	            var template = response;
	
	            var clone = $compile(template)(newScope, function(clone) {
	              cleanupLastIncludeContent();
	              $animate.enter(clone, elem);
	            });
	
	            currentScope = newScope;
	            currentElement = clone;
	
	            currentScope.$emit('$includeContentLoaded', src);
	          }, function() {
	            if (thisChangeId === changeCounter) {
	              cleanupLastIncludeContent();
	              scope.$emit('$includeContentError', src);
	            }
	          });
	          scope.$emit('$includeContentRequested', src);
	        } else {
	          cleanupLastIncludeContent();
	        }
	      });
	
	      scope.$on('$destroy', cleanupLastIncludeContent);
	    }
	  };
	}])
	
	/**
	 * Note that it's intentional that these classes are *not* applied through $animate.
	 * They must not be animated as they're expected to be present on the tooltip on
	 * initialization.
	 */
	.directive('tooltipClasses', function() {
	  return {
	    restrict: 'A',
	    link: function(scope, element, attrs) {
	      if (scope.placement) {
	        element.addClass(scope.placement);
	      }
	      if (scope.popupClass) {
	        element.addClass(scope.popupClass);
	      }
	      if (scope.animation()) {
	        element.addClass(attrs.tooltipAnimationClass);
	      }
	    }
	  };
	})
	
	.directive('tooltipPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-popup.html'
	  };
	})
	
	.directive('tooltip', [ '$tooltip', function($tooltip) {
	  return $tooltip('tooltip', 'tooltip', 'mouseenter');
	}])
	
	.directive('tooltipTemplatePopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/tooltip/tooltip-template-popup.html'
	  };
	})
	
	.directive('tooltipTemplate', ['$tooltip', function($tooltip) {
	  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}])
	
	.directive('tooltipHtmlPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-popup.html'
	  };
	})
	
	.directive('tooltipHtml', ['$tooltip', function($tooltip) {
	  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}])
	
	/*
	Deprecated
	*/
	.directive('tooltipHtmlUnsafePopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
	  };
	})
	
	.value('tooltipHtmlUnsafeSuppressDeprecated', false)
	.directive('tooltipHtmlUnsafe', [
	          '$tooltip', 'tooltipHtmlUnsafeSuppressDeprecated', '$log',
	function($tooltip ,  tooltipHtmlUnsafeSuppressDeprecated ,  $log) {
	  if (!tooltipHtmlUnsafeSuppressDeprecated) {
	    $log.warn('tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead.');
	  }
	  return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
	}]);
	
	/**
	 * The following features are still outstanding: popup delay, animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, and selector delegatation.
	 */
	angular.module( 'ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
	
	.directive('popoverTemplatePopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/popover/popover-template.html'
	  };
	})
	
	.directive('popoverTemplate', ['$tooltip', function($tooltip) {
	  return $tooltip('popoverTemplate', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('popoverHtmlPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover-html.html'
	  };
	})
	
	.directive('popoverHtml', ['$tooltip', function($tooltip) {
	  return $tooltip( 'popoverHtml', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('popoverPopup', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover.html'
	  };
	})
	
	.directive('popover', ['$tooltip', function($tooltip) {
	  return $tooltip( 'popover', 'popover', 'click' );
	}]);
	
	angular.module('ui.bootstrap.progressbar', [])
	
	.constant('progressConfig', {
	  animate: true,
	  max: 100
	})
	
	.value('$progressSuppressWarning', false)
	
	.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {
	  var self = this,
	      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
	
	  this.bars = [];
	  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
	
	  this.addBar = function(bar, element) {
	    if (!animate) {
	      element.css({'transition': 'none'});
	    }
	
	    this.bars.push(bar);
	
	    bar.max = $scope.max;
	
	    bar.$watch('value', function(value) {
	      bar.recalculatePercentage();
	    });
	
	    bar.recalculatePercentage = function() {
	      bar.percent = +(100 * bar.value / bar.max).toFixed(2);
	
	      var totalPercentage = self.bars.reduce(function(total, bar) {
	        return total + bar.percent;
	      }, 0);
	
	      if (totalPercentage > 100) {
	        bar.percent -= totalPercentage - 100;
	      }
	    };
	
	    bar.$on('$destroy', function() {
	      element = null;
	      self.removeBar(bar);
	    });
	  };
	
	  this.removeBar = function(bar) {
	      this.bars.splice(this.bars.indexOf(bar), 1);
	  };
	
	  $scope.$watch('max', function(max) {
	    self.bars.forEach(function(bar) {
	      bar.max = $scope.max;
	      bar.recalculatePercentage();
	    });
	  });
	}])
	
	.directive('uibProgress', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    require: 'uibProgress',
	    scope: {
	      max: '=?'
	    },
	    templateUrl: 'template/progressbar/progress.html'
	  };
	})
	
	.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    require: 'progress',
	    scope: {
	      max: '=?'
	    },
	    templateUrl: 'template/progressbar/progress.html',
	    link: function() {
	      if ($progressSuppressWarning) {
	        $log.warn('progress is now deprecated. Use uib-progress instead');
	      }
	    }
	  };
	}])
	
	.directive('uibBar', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    require: '^uibProgress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/bar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, element);
	    }
	  };
	})
	
	.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    require: '^progress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/bar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      if ($progressSuppressWarning) {
	        $log.warn('bar is now deprecated. Use uib-bar instead');
	      }
	      progressCtrl.addBar(scope, element);
	    }
	  };
	}])
	
	.directive('progressbar', function() {
	  return {
	    restrict: 'EA',
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    scope: {
	      value: '=',
	      max: '=?',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/progressbar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, angular.element(element.children()[0]));
	    }
	  };
	});
	
	angular.module('ui.bootstrap.rating', [])
	
	.constant('ratingConfig', {
	  max: 5,
	  stateOn: null,
	  stateOff: null,
	  titles : ['one', 'two', 'three', 'four', 'five']
	})
	
	.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {
	  var ngModelCtrl  = { $setViewValue: angular.noop };
	
	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    ngModelCtrl.$formatters.push(function(value) {
	      if (angular.isNumber(value) && value << 0 !== value) {
	        value = Math.round(value);
	      }
	      return value;
	    });
	
	    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
	    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;    
	    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
	      tmpTitles : ratingConfig.titles;
	    
	    var ratingStates = angular.isDefined($attrs.ratingStates) ?
	      $scope.$parent.$eval($attrs.ratingStates) :
	      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
	    $scope.range = this.buildTemplateObjects(ratingStates);
	  };
	
	  this.buildTemplateObjects = function(states) {
	    for (var i = 0, n = states.length; i < n; i++) {
	      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
	    }
	    return states;
	  };
	  
	  this.getTitle = function(index) {
	    if (index >= this.titles.length) {
	      return index + 1;
	    } else {
	      return this.titles[index];
	    }
	  };
	  
	  $scope.rate = function(value) {
	    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
	      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.enter = function(value) {
	    if (!$scope.readonly) {
	      $scope.value = value;
	    }
	    $scope.onHover({value: value});
	  };
	
	  $scope.reset = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.onLeave();
	  };
	
	  $scope.onKeydown = function(evt) {
	    if (/(37|38|39|40)/.test(evt.which)) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
	    }
	  };
	
	  this.render = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	  };
	}])
	
	.directive('rating', function() {
	  return {
	    restrict: 'EA',
	    require: ['rating', 'ngModel'],
	    scope: {
	      readonly: '=?',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'RatingController',
	    templateUrl: 'template/rating/rating.html',
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	      ratingCtrl.init( ngModelCtrl );
	    }
	  };
	});
	
	
	/**
	 * @ngdoc overview
	 * @name ui.bootstrap.tabs
	 *
	 * @description
	 * AngularJS version of the tabs directive.
	 */
	
	angular.module('ui.bootstrap.tabs', [])
	
	.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
	  var ctrl = this,
	      tabs = ctrl.tabs = $scope.tabs = [];
	
	  ctrl.select = function(selectedTab) {
	    angular.forEach(tabs, function(tab) {
	      if (tab.active && tab !== selectedTab) {
	        tab.active = false;
	        tab.onDeselect();
	        selectedTab.selectCalled = false;
	      }
	    });
	    selectedTab.active = true;
	    // only call select if it has not already been called
	    if (!selectedTab.selectCalled) {
	      selectedTab.onSelect();
	      selectedTab.selectCalled = true;
	    }
	  };
	
	  ctrl.addTab = function addTab(tab) {
	    tabs.push(tab);
	    // we can't run the select function on the first tab
	    // since that would select it twice
	    if (tabs.length === 1 && tab.active !== false) {
	      tab.active = true;
	    } else if (tab.active) {
	      ctrl.select(tab);
	    } else {
	      tab.active = false;
	    }
	  };
	
	  ctrl.removeTab = function removeTab(tab) {
	    var index = tabs.indexOf(tab);
	    //Select a new tab if the tab to be removed is selected and not destroyed
	    if (tab.active && tabs.length > 1 && !destroyed) {
	      //If this is the last tab, select the previous tab. else, the next tab.
	      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
	      ctrl.select(tabs[newActiveIndex]);
	    }
	    tabs.splice(index, 1);
	  };
	
	  var destroyed;
	  $scope.$on('$destroy', function() {
	    destroyed = true;
	  });
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabset
	 * @restrict EA
	 *
	 * @description
	 * Tabset is the outer container for the tabs directive
	 *
	 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
	 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab heading="Tab 1"><b>First</b> Content!</tab>
	      <tab heading="Tab 2"><i>Second</i> Content!</tab>
	    </tabset>
	    <hr />
	    <tabset vertical="true">
	      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
	      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
	    </tabset>
	    <tabset justified="true">
	      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
	      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tabset', function() {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@'
	    },
	    controller: 'TabsetController',
	    templateUrl: 'template/tabs/tabset.html',
	    link: function(scope, element, attrs) {
	      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
	      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
	    }
	  };
	})
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tab
	 * @restrict EA
	 *
	 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
	 * @param {string=} select An expression to evaluate when the tab is selected.
	 * @param {boolean=} active A binding, telling whether or not this tab is selected.
	 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
	 *
	 * @description
	 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <div ng-controller="TabsDemoCtrl">
	      <button class="btn btn-small" ng-click="items[0].active = true">
	        Select item 1, using active binding
	      </button>
	      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
	        Enable/disable item 2, using disabled binding
	      </button>
	      <br />
	      <tabset>
	        <tab heading="Tab 1">First Tab</tab>
	        <tab select="alertMe()">
	          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
	          Second Tab, with alert callback and html heading!
	        </tab>
	        <tab ng-repeat="item in items"
	          heading="{{item.title}}"
	          disabled="item.disabled"
	          active="item.active">
	          {{item.content}}
	        </tab>
	      </tabset>
	    </div>
	  </file>
	  <file name="script.js">
	    function TabsDemoCtrl($scope) {
	      $scope.items = [
	        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
	        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
	      ];
	
	      $scope.alertMe = function() {
	        setTimeout(function() {
	          alert("You've selected the alert tab!");
	        });
	      };
	    };
	  </file>
	</example>
	 */
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabHeading
	 * @restrict EA
	 *
	 * @description
	 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab>
	        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
	        And some content, too!
	      </tab>
	      <tab>
	        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
	        That's right.
	      </tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tab', ['$parse', '$log', function($parse, $log) {
	  return {
	    require: '^tabset',
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/tabs/tab.html',
	    transclude: true,
	    scope: {
	      active: '=?',
	      heading: '@',
	      onSelect: '&select', //This callback is called in contentHeadingTransclude
	                          //once it inserts the tab's content into the dom
	      onDeselect: '&deselect'
	    },
	    controller: function() {
	      //Empty controller so other directives can require being 'under' a tab
	    },
	    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
	      scope.$watch('active', function(active) {
	        if (active) {
	          tabsetCtrl.select(scope);
	        }
	      });
	
	      scope.disabled = false;
	      if (attrs.disable) {
	        scope.$parent.$watch($parse(attrs.disable), function(value) {
	          scope.disabled = !! value;
	        });
	      }
	
	      // Deprecation support of "disabled" parameter
	      // fix(tab): IE9 disabled attr renders grey text on enabled tab #2677
	      // This code is duplicated from the lines above to make it easy to remove once
	      // the feature has been completely deprecated
	      if (attrs.disabled) {
	        $log.warn('Use of "disabled" attribute has been deprecated, please use "disable"');
	        scope.$parent.$watch($parse(attrs.disabled), function(value) {
	          scope.disabled = !! value;
	        });
	      }
	
	      scope.select = function() {
	        if (!scope.disabled) {
	          scope.active = true;
	        }
	      };
	
	      tabsetCtrl.addTab(scope);
	      scope.$on('$destroy', function() {
	        tabsetCtrl.removeTab(scope);
	      });
	
	      //We need to transclude later, once the content container is ready.
	      //when this link happens, we're inside a tab heading.
	      scope.$transcludeFn = transclude;
	    }
	  };
	}])
	
	.directive('tabHeadingTransclude', function() {
	  return {
	    restrict: 'A',
	    require: '^tab',
	    link: function(scope, elm, attrs, tabCtrl) {
	      scope.$watch('headingElement', function updateHeadingElement(heading) {
	        if (heading) {
	          elm.html('');
	          elm.append(heading);
	        }
	      });
	    }
	  };
	})
	
	.directive('tabContentTransclude', function() {
	  return {
	    restrict: 'A',
	    require: '^tabset',
	    link: function(scope, elm, attrs) {
	      var tab = scope.$eval(attrs.tabContentTransclude);
	
	      //Now our tab is ready to be transcluded: both the tab heading area
	      //and the tab content area are loaded.  Transclude 'em both.
	      tab.$transcludeFn(tab.$parent, function(contents) {
	        angular.forEach(contents, function(node) {
	          if (isTabHeading(node)) {
	            //Let tabHeadingTransclude know.
	            tab.headingElement = node;
	          } else {
	            elm.append(node);
	          }
	        });
	      });
	    }
	  };
	
	  function isTabHeading(node) {
	    return node.tagName && (
	      node.hasAttribute('tab-heading') ||
	      node.hasAttribute('data-tab-heading') ||
	      node.hasAttribute('x-tab-heading') ||
	      node.tagName.toLowerCase() === 'tab-heading' ||
	      node.tagName.toLowerCase() === 'data-tab-heading' ||
	      node.tagName.toLowerCase() === 'x-tab-heading'
	    );
	  }
	});
	
	angular.module('ui.bootstrap.timepicker', [])
	
	.constant('timepickerConfig', {
	  hourStep: 1,
	  minuteStep: 1,
	  showMeridian: true,
	  meridians: null,
	  readonlyInput: false,
	  mousewheel: true,
	  arrowkeys: true,
	  showSpinners: true
	})
	
	.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
	  var selected = new Date(),
	      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
	
	  this.init = function(ngModelCtrl_, inputs) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    ngModelCtrl.$formatters.unshift(function(modelValue) {
	      return modelValue ? new Date(modelValue) : null;
	    });
	
	    var hoursInputEl = inputs.eq(0),
	        minutesInputEl = inputs.eq(1);
	
	    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
	    if (mousewheel) {
	      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
	    }
	
	    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
	    if (arrowkeys) {
	      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
	    }
	
	    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
	    this.setupInputEvents(hoursInputEl, minutesInputEl);
	  };
	
	  var hourStep = timepickerConfig.hourStep;
	  if ($attrs.hourStep) {
	    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
	      hourStep = parseInt(value, 10);
	    });
	  }
	
	  var minuteStep = timepickerConfig.minuteStep;
	  if ($attrs.minuteStep) {
	    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
	      minuteStep = parseInt(value, 10);
	    });
	  }
	
	  var min;
	  $scope.$parent.$watch($parse($attrs.min), function(value) {
	    var dt = new Date(value);
	    min = isNaN(dt) ? undefined : dt;
	  });
	
	  var max;
	  $scope.$parent.$watch($parse($attrs.max), function(value) {
	    var dt = new Date(value);
	    max = isNaN(dt) ? undefined : dt;
	  });
	
	  $scope.noIncrementHours = function() {
	    var incrementedSelected = addMinutes(selected, hourStep * 60);
	    return incrementedSelected > max ||
	      (incrementedSelected < selected && incrementedSelected < min);
	  };
	
	  $scope.noDecrementHours = function() {
	    var decrementedSelected = addMinutes(selected, -hourStep * 60);
	    return decrementedSelected < min ||
	      (decrementedSelected > selected && decrementedSelected > max);
	  };
	
	  $scope.noIncrementMinutes = function() {
	    var incrementedSelected = addMinutes(selected, minuteStep);
	    return incrementedSelected > max ||
	      (incrementedSelected < selected && incrementedSelected < min);
	  };
	
	  $scope.noDecrementMinutes = function() {
	    var decrementedSelected = addMinutes(selected, -minuteStep);
	    return decrementedSelected < min ||
	      (decrementedSelected > selected && decrementedSelected > max);
	  };
	
	  $scope.noToggleMeridian = function() {
	    if (selected.getHours() < 13) {
	      return addMinutes(selected, 12 * 60) > max;
	    } else {
	      return addMinutes(selected, -12 * 60) < min;
	    }
	  };
	
	  // 12H / 24H mode
	  $scope.showMeridian = timepickerConfig.showMeridian;
	  if ($attrs.showMeridian) {
	    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
	      $scope.showMeridian = !!value;
	
	      if (ngModelCtrl.$error.time) {
	        // Evaluate from template
	        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
	        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	          selected.setHours(hours);
	          refresh();
	        }
	      } else {
	        updateTemplate();
	      }
	    });
	  }
	
	  // Get $scope.hours in 24H mode if valid
	  function getHoursFromTemplate() {
	    var hours = parseInt($scope.hours, 10);
	    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
	    if (!valid) {
	      return undefined;
	    }
	
	    if ($scope.showMeridian) {
	      if (hours === 12) {
	        hours = 0;
	      }
	      if ($scope.meridian === meridians[1]) {
	        hours = hours + 12;
	      }
	    }
	    return hours;
	  }
	
	  function getMinutesFromTemplate() {
	    var minutes = parseInt($scope.minutes, 10);
	    return (minutes >= 0 && minutes < 60) ? minutes : undefined;
	  }
	
	  function pad(value) {
	    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();
	  }
	
	  // Respond on mousewheel spin
	  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
	    var isScrollingUp = function(e) {
	      if (e.originalEvent) {
	        e = e.originalEvent;
	      }
	      //pick correct delta variable depending on event
	      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
	      return (e.detail || delta > 0);
	    };
	
	    hoursInputEl.bind('mousewheel wheel', function(e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
	      e.preventDefault();
	    });
	
	    minutesInputEl.bind('mousewheel wheel', function(e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
	      e.preventDefault();
	    });
	
	  };
	
	  // Respond on up/down arrowkeys
	  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
	    hoursInputEl.bind('keydown', function(e) {
	      if (e.which === 38) { // up
	        e.preventDefault();
	        $scope.incrementHours();
	        $scope.$apply();
	      } else if (e.which === 40) { // down
	        e.preventDefault();
	        $scope.decrementHours();
	        $scope.$apply();
	      }
	    });
	
	    minutesInputEl.bind('keydown', function(e) {
	      if (e.which === 38) { // up
	        e.preventDefault();
	        $scope.incrementMinutes();
	        $scope.$apply();
	      } else if (e.which === 40) { // down
	        e.preventDefault();
	        $scope.decrementMinutes();
	        $scope.$apply();
	      }
	    });
	  };
	
	  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
	    if ($scope.readonlyInput) {
	      $scope.updateHours = angular.noop;
	      $scope.updateMinutes = angular.noop;
	      return;
	    }
	
	    var invalidate = function(invalidHours, invalidMinutes) {
	      ngModelCtrl.$setViewValue(null);
	      ngModelCtrl.$setValidity('time', false);
	      if (angular.isDefined(invalidHours)) {
	        $scope.invalidHours = invalidHours;
	      }
	      if (angular.isDefined(invalidMinutes)) {
	        $scope.invalidMinutes = invalidMinutes;
	      }
	    };
	
	    $scope.updateHours = function() {
	      var hours = getHoursFromTemplate(),
	        minutes = getMinutesFromTemplate();
	
	      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	        selected.setHours(hours);
	        if (selected < min || selected > max) {
	          invalidate(true);
	        } else {
	          refresh('h');
	        }
	      } else {
	        invalidate(true);
	      }
	    };
	
	    hoursInputEl.bind('blur', function(e) {
	      if (!$scope.invalidHours && $scope.hours < 10) {
	        $scope.$apply(function() {
	          $scope.hours = pad($scope.hours);
	        });
	      }
	    });
	
	    $scope.updateMinutes = function() {
	      var minutes = getMinutesFromTemplate(),
	        hours = getHoursFromTemplate();
	
	      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
	        selected.setMinutes(minutes);
	        if (selected < min || selected > max) {
	          invalidate(undefined, true);
	        } else {
	          refresh('m');
	        }
	      } else {
	        invalidate(undefined, true);
	      }
	    };
	
	    minutesInputEl.bind('blur', function(e) {
	      if (!$scope.invalidMinutes && $scope.minutes < 10) {
	        $scope.$apply(function() {
	          $scope.minutes = pad($scope.minutes);
	        });
	      }
	    });
	
	  };
	
	  this.render = function() {
	    var date = ngModelCtrl.$viewValue;
	
	    if (isNaN(date)) {
	      ngModelCtrl.$setValidity('time', false);
	      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	    } else {
	      if (date) {
	        selected = date;
	      }
	
	      if (selected < min || selected > max) {
	        ngModelCtrl.$setValidity('time', false);
	        $scope.invalidHours = true;
	        $scope.invalidMinutes = true;
	      } else {
	        makeValid();
	      }
	      updateTemplate();
	    }
	  };
	
	  // Call internally when we know that model is valid.
	  function refresh(keyboardChange) {
	    makeValid();
	    ngModelCtrl.$setViewValue(new Date(selected));
	    updateTemplate(keyboardChange);
	  }
	
	  function makeValid() {
	    ngModelCtrl.$setValidity('time', true);
	    $scope.invalidHours = false;
	    $scope.invalidMinutes = false;
	  }
	
	  function updateTemplate(keyboardChange) {
	    var hours = selected.getHours(), minutes = selected.getMinutes();
	
	    if ($scope.showMeridian) {
	      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system
	    }
	
	    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
	    if (keyboardChange !== 'm') {
	      $scope.minutes = pad(minutes);
	    }
	    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	  }
	
	  function addMinutes(date, minutes) {
	    var dt = new Date(date.getTime() + minutes * 60000);
	    var newDate = new Date(date);
	    newDate.setHours(dt.getHours(), dt.getMinutes());
	    return newDate;
	  }
	
	  function addMinutesToSelected(minutes) {
	    selected = addMinutes(selected, minutes);
	    refresh();
	  }
	
	  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
	    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
	
	  $scope.incrementHours = function() {
	    if (!$scope.noIncrementHours()) {
	      addMinutesToSelected(hourStep * 60);
	    }
	  };
	
	  $scope.decrementHours = function() {
	    if (!$scope.noDecrementHours()) {
	      addMinutesToSelected(-hourStep * 60);
	    }
	  };
	
	  $scope.incrementMinutes = function() {
	    if (!$scope.noIncrementMinutes()) {
	      addMinutesToSelected(minuteStep);
	    }
	  };
	
	  $scope.decrementMinutes = function() {
	    if (!$scope.noDecrementMinutes()) {
	      addMinutesToSelected(-minuteStep);
	    }
	  };
	
	  $scope.toggleMeridian = function() {
	    if (!$scope.noToggleMeridian()) {
	      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
	    }
	  };
	}])
	
	.directive('timepicker', function() {
	  return {
	    restrict: 'EA',
	    require: ['timepicker', '?^ngModel'],
	    controller:'TimepickerController',
	    controllerAs: 'timepicker',
	    replace: true,
	    scope: {},
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/timepicker/timepicker.html';
	    },
	    link: function(scope, element, attrs, ctrls) {
	      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (ngModelCtrl) {
	        timepickerCtrl.init(ngModelCtrl, element.find('input'));
	      }
	    }
	  };
	});
	
	angular.module('ui.bootstrap.transition', [])
	
	.value('$transitionSuppressDeprecated', false)
	/**
	 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
	 * @param  {DOMElement} element  The DOMElement that will be animated.
	 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
	 *   - As a string, it represents the css class to be added to the element.
	 *   - As an object, it represents a hash of style attributes to be applied to the element.
	 *   - As a function, it represents a function to be called that will cause the transition to occur.
	 * @return {Promise}  A promise that is resolved when the transition finishes.
	 */
	.factory('$transition', [
	        '$q', '$timeout', '$rootScope', '$log', '$transitionSuppressDeprecated',
	function($q ,  $timeout ,  $rootScope ,  $log ,  $transitionSuppressDeprecated) {
	
	  if (!$transitionSuppressDeprecated) {
	    $log.warn('$transition is now deprecated. Use $animate from ngAnimate instead.');
	  }
	
	  var $transition = function(element, trigger, options) {
	    options = options || {};
	    var deferred = $q.defer();
	    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];
	
	    var transitionEndHandler = function(event) {
	      $rootScope.$apply(function() {
	        element.unbind(endEventName, transitionEndHandler);
	        deferred.resolve(element);
	      });
	    };
	
	    if (endEventName) {
	      element.bind(endEventName, transitionEndHandler);
	    }
	
	    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
	    $timeout(function() {
	      if ( angular.isString(trigger) ) {
	        element.addClass(trigger);
	      } else if ( angular.isFunction(trigger) ) {
	        trigger(element);
	      } else if ( angular.isObject(trigger) ) {
	        element.css(trigger);
	      }
	      //If browser does not support transitions, instantly resolve
	      if ( !endEventName ) {
	        deferred.resolve(element);
	      }
	    });
	
	    // Add our custom cancel function to the promise that is returned
	    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
	    // i.e. it will therefore never raise a transitionEnd event for that transition
	    deferred.promise.cancel = function() {
	      if ( endEventName ) {
	        element.unbind(endEventName, transitionEndHandler);
	      }
	      deferred.reject('Transition cancelled');
	    };
	
	    return deferred.promise;
	  };
	
	  // Work out the name of the transitionEnd event
	  var transElement = document.createElement('trans');
	  var transitionEndEventNames = {
	    'WebkitTransition': 'webkitTransitionEnd',
	    'MozTransition': 'transitionend',
	    'OTransition': 'oTransitionEnd',
	    'transition': 'transitionend'
	  };
	  var animationEndEventNames = {
	    'WebkitTransition': 'webkitAnimationEnd',
	    'MozTransition': 'animationend',
	    'OTransition': 'oAnimationEnd',
	    'transition': 'animationend'
	  };
	  function findEndEventName(endEventNames) {
	    for (var name in endEventNames){
	      if (transElement.style[name] !== undefined) {
	        return endEventNames[name];
	      }
	    }
	  }
	  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
	  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
	  return $transition;
	}]);
	
	angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])
	
	/**
	 * A helper service that can parse typeahead's syntax (string provided by users)
	 * Extracted to a separate service for ease of unit testing
	 */
	  .factory('typeaheadParser', ['$parse', function($parse) {
	
	  //                      00000111000000000000022200000000000000003333333333333330000000000044000
	  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
	
	  return {
	    parse: function(input) {
	      var match = input.match(TYPEAHEAD_REGEXP);
	      if (!match) {
	        throw new Error(
	          'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
	            ' but got "' + input + '".');
	      }
	
	      return {
	        itemName:match[3],
	        source:$parse(match[4]),
	        viewMapper:$parse(match[2] || match[1]),
	        modelMapper:$parse(match[1])
	      };
	    }
	  };
	}])
	
	  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$position', 'typeaheadParser',
	    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
	    var HOT_KEYS = [9, 13, 27, 38, 40];
	    var eventDebounceTime = 200;
	
	    return {
	      require: ['ngModel', '^?ngModelOptions'],
	      link: function(originalScope, element, attrs, ctrls) {
	        var modelCtrl = ctrls[0];
	        var ngModelOptions = ctrls[1];
	        //SUPPORTED ATTRIBUTES (OPTIONS)
	
	        //minimal no of characters that needs to be entered before typeahead kicks-in
	        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
	        if (!minLength && minLength !== 0) {
	          minLength = 1;
	        }
	
	        //minimal wait time after last character typed before typeahead kicks-in
	        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
	
	        //should it restrict model values to the ones selected from the popup only?
	        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	
	        //binding to a variable that indicates if matches are being retrieved asynchronously
	        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
	
	        //a callback executed when a match is selected
	        var onSelectCallback = $parse(attrs.typeaheadOnSelect);
	
	        //should it select highlighted popup value when losing focus?
	        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
	
	        //binding to a variable that indicates if there were no results after the query is completed
	        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
	
	        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
	
	        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
	
	        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
	
	        //If input matches an item of the list exactly, select it automatically
	        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
	
	        //INTERNAL VARIABLES
	
	        //model setter executed upon match selection
	        var parsedModel = $parse(attrs.ngModel);
	        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
	        var $setModelValue = function(scope, newValue) {
	          if (angular.isFunction(parsedModel(originalScope)) &&
	            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
	            return invokeModelSetter(scope, {$$$p: newValue});
	          } else {
	            return parsedModel.assign(scope, newValue);
	          }
	        };
	
	        //expressions used by typeahead
	        var parserResult = typeaheadParser.parse(attrs.typeahead);
	
	        var hasFocus;
	
	        //Used to avoid bug in iOS webview where iOS keyboard does not fire
	        //mousedown & mouseup events
	        //Issue #3699
	        var selected;
	
	        //create a child scope for the typeahead directive so we are not polluting original scope
	        //with typeahead-specific data (matches, query etc.)
	        var scope = originalScope.$new();
	        var offDestroy = originalScope.$on('$destroy', function() {
				    scope.$destroy();
	        });
	        scope.$on('$destroy', offDestroy);
	
	        // WAI-ARIA
	        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	        element.attr({
	          'aria-autocomplete': 'list',
	          'aria-expanded': false,
	          'aria-owns': popupId
	        });
	
	        //pop-up element used to display matches
	        var popUpEl = angular.element('<div typeahead-popup></div>');
	        popUpEl.attr({
	          id: popupId,
	          matches: 'matches',
	          active: 'activeIdx',
	          select: 'select(activeIdx)',
	          'move-in-progress': 'moveInProgress',
	          query: 'query',
	          position: 'position'
	        });
	        //custom item template
	        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	        }
	
	        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
	          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
	        }
	
	        var resetMatches = function() {
	          scope.matches = [];
	          scope.activeIdx = -1;
	          element.attr('aria-expanded', false);
	        };
	
	        var getMatchId = function(index) {
	          return popupId + '-option-' + index;
	        };
	
	        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	        // This attribute is added or removed automatically when the `activeIdx` changes.
	        scope.$watch('activeIdx', function(index) {
	          if (index < 0) {
	            element.removeAttr('aria-activedescendant');
	          } else {
	            element.attr('aria-activedescendant', getMatchId(index));
	          }
	        });
	
	        var inputIsExactMatch = function(inputValue, index) {
	          if (scope.matches.length > index && inputValue) {
	            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
	          }
	
	          return false;
	        };
	
	        var getMatchesAsync = function(inputValue) {
	          var locals = {$viewValue: inputValue};
	          isLoadingSetter(originalScope, true);
	          isNoResultsSetter(originalScope, false);
	          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
	            //it might happen that several async queries were in progress if a user were typing fast
	            //but we are interested only in responses that correspond to the current view value
	            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
	            if (onCurrentRequest && hasFocus) {
	              if (matches && matches.length > 0) {
	
	                scope.activeIdx = focusFirst ? 0 : -1;
	                isNoResultsSetter(originalScope, false);
	                scope.matches.length = 0;
	
	                //transform labels
	                for (var i = 0; i < matches.length; i++) {
	                  locals[parserResult.itemName] = matches[i];
	                  scope.matches.push({
	                    id: getMatchId(i),
	                    label: parserResult.viewMapper(scope, locals),
	                    model: matches[i]
	                  });
	                }
	
	                scope.query = inputValue;
	                //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	                //due to other elements being rendered
	                recalculatePosition();
	
	                element.attr('aria-expanded', true);
	
	                //Select the single remaining option if user input matches
	                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
	                  scope.select(0);
	                }
	              } else {
	                resetMatches();
	                isNoResultsSetter(originalScope, true);
	              }
	            }
	            if (onCurrentRequest) {
	              isLoadingSetter(originalScope, false);
	            }
	          }, function() {
	            resetMatches();
	            isLoadingSetter(originalScope, false);
	            isNoResultsSetter(originalScope, true);
	          });
	        };
	
	        // bind events only if appendToBody params exist - performance feature
	        if (appendToBody) {
	          angular.element($window).bind('resize', fireRecalculating);
	          $document.find('body').bind('scroll', fireRecalculating);
	        }
	
	        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	        var timeoutEventPromise;
	
	        // Default progress type
	        scope.moveInProgress = false;
	
	        function fireRecalculating() {
	          if (!scope.moveInProgress) {
	            scope.moveInProgress = true;
	            scope.$digest();
	          }
	
	          // Cancel previous timeout
	          if (timeoutEventPromise) {
	            $timeout.cancel(timeoutEventPromise);
	          }
	
	          // Debounced executing recalculate after events fired
	          timeoutEventPromise = $timeout(function() {
	            // if popup is visible
	            if (scope.matches.length) {
	              recalculatePosition();
	            }
	
	            scope.moveInProgress = false;
	            scope.$digest();
	          }, eventDebounceTime);
	        }
	
	        // recalculate actual position and set new values to scope
	        // after digest loop is popup in right position
	        function recalculatePosition() {
	          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	          scope.position.top += element.prop('offsetHeight');
	        }
	
	        resetMatches();
	
	        //we need to propagate user's query so we can higlight matches
	        scope.query = undefined;
	
	        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	        var timeoutPromise;
	
	        var scheduleSearchWithTimeout = function(inputValue) {
	          timeoutPromise = $timeout(function() {
	            getMatchesAsync(inputValue);
	          }, waitTime);
	        };
	
	        var cancelPreviousTimeout = function() {
	          if (timeoutPromise) {
	            $timeout.cancel(timeoutPromise);
	          }
	        };
	
	        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	        modelCtrl.$parsers.unshift(function(inputValue) {
	          hasFocus = true;
	
	          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
	            if (waitTime > 0) {
	              cancelPreviousTimeout();
	              scheduleSearchWithTimeout(inputValue);
	            } else {
	              getMatchesAsync(inputValue);
	            }
	          } else {
	            isLoadingSetter(originalScope, false);
	            cancelPreviousTimeout();
	            resetMatches();
	          }
	
	          if (isEditable) {
	            return inputValue;
	          } else {
	            if (!inputValue) {
	              // Reset in case user had typed something previously.
	              modelCtrl.$setValidity('editable', true);
	              return null;
	            } else {
	              modelCtrl.$setValidity('editable', false);
	              return undefined;
	            }
	          }
	        });
	
	        modelCtrl.$formatters.push(function(modelValue) {
	          var candidateViewValue, emptyViewValue;
	          var locals = {};
	
	          // The validity may be set to false via $parsers (see above) if
	          // the model is restricted to selected values. If the model
	          // is set manually it is considered to be valid.
	          if (!isEditable) {
	            modelCtrl.$setValidity('editable', true);
	          }
	
	          if (inputFormatter) {
	            locals.$model = modelValue;
	            return inputFormatter(originalScope, locals);
	          } else {
	            //it might happen that we don't have enough info to properly render input value
	            //we need to check for this situation and simply return model value if we can't apply custom formatting
	            locals[parserResult.itemName] = modelValue;
	            candidateViewValue = parserResult.viewMapper(originalScope, locals);
	            locals[parserResult.itemName] = undefined;
	            emptyViewValue = parserResult.viewMapper(originalScope, locals);
	
	            return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
	          }
	        });
	
	        scope.select = function(activeIdx) {
	          //called from within the $digest() cycle
	          var locals = {};
	          var model, item;
	
	          selected = true;
	          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	          model = parserResult.modelMapper(originalScope, locals);
	          $setModelValue(originalScope, model);
	          modelCtrl.$setValidity('editable', true);
	          modelCtrl.$setValidity('parse', true);
	
	          onSelectCallback(originalScope, {
	            $item: item,
	            $model: model,
	            $label: parserResult.viewMapper(originalScope, locals)
	          });
	
	          resetMatches();
	
	          //return focus to the input element if a match was selected via a mouse click event
	          // use timeout to avoid $rootScope:inprog error
	          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
	            $timeout(function() { element[0].focus(); }, 0, false);
	          }
	        };
	
	        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	        element.bind('keydown', function(evt) {
	          //typeahead is open and an "interesting" key was pressed
	          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	            return;
	          }
	
	          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
	          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
	            resetMatches();
	            scope.$digest();
	            return;
	          }
	
	          evt.preventDefault();
	
	          if (evt.which === 40) {
	            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	            scope.$digest();
	
	          } else if (evt.which === 38) {
	            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
	            scope.$digest();
	
	          } else if (evt.which === 13 || evt.which === 9) {
	            scope.$apply(function () {
	              scope.select(scope.activeIdx);
	            });
	
	          } else if (evt.which === 27) {
	            evt.stopPropagation();
	
	            resetMatches();
	            scope.$digest();
	          }
	        });
	
	        element.bind('blur', function() {
	          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
	            selected = true;
	            scope.$apply(function() {
	              scope.select(scope.activeIdx);
	            });
	          }
	          hasFocus = false;
	          selected = false;
	        });
	
	        // Keep reference to click handler to unbind it.
	        var dismissClickHandler = function(evt) {
	          // Issue #3973
	          // Firefox treats right click as a click on document
	          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
	            resetMatches();
	            if (!$rootScope.$$phase) {
	              scope.$digest();
	            }
	          }
	        };
	
	        $document.bind('click', dismissClickHandler);
	
	        originalScope.$on('$destroy', function() {
	          $document.unbind('click', dismissClickHandler);
	          if (appendToBody) {
	            $popup.remove();
	          }
	          // Prevent jQuery cache memory leak
	          popUpEl.remove();
	        });
	
	        var $popup = $compile(popUpEl)(scope);
	
	        if (appendToBody) {
	          $document.find('body').append($popup);
	        } else {
	          element.after($popup);
	        }
	      }
	    };
	
	  }])
	
	  .directive('typeaheadPopup', function() {
	    return {
	      restrict: 'EA',
	      scope: {
	        matches: '=',
	        query: '=',
	        active: '=',
	        position: '&',
	        moveInProgress: '=',
	        select: '&'
	      },
	      replace: true,
	      templateUrl: function(element, attrs) {
	        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
	      },
	      link: function(scope, element, attrs) {
	        scope.templateUrl = attrs.templateUrl;
	
	        scope.isOpen = function() {
	          return scope.matches.length > 0;
	        };
	
	        scope.isActive = function(matchIdx) {
	          return scope.active == matchIdx;
	        };
	
	        scope.selectActive = function(matchIdx) {
	          scope.active = matchIdx;
	        };
	
	        scope.selectMatch = function(activeIdx) {
	          scope.select({activeIdx:activeIdx});
	        };
	      }
	    };
	  })
	
	  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
	    return {
	      restrict: 'EA',
	      scope: {
	        index: '=',
	        match: '=',
	        query: '='
	      },
	      link:function(scope, element, attrs) {
	        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
	        $templateRequest(tplUrl).then(function(tplContent) {
	          $compile(tplContent.trim())(scope, function(clonedElement) {
	            element.replaceWith(clonedElement);
	          });
	        });
	      }
	    };
	  }])
	
	  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
	    var isSanitizePresent;
	    isSanitizePresent = $injector.has('$sanitize');
	
	    function escapeRegexp(queryToEscape) {
	      // Regex: capture the whole query string and replace it with the string that will be used to match
	      // the results, for example if the capture is "a" the result will be \a
	      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	    }
	
	    function containsHtml(matchItem) {
	      return /<.*>/g.test(matchItem);
	    }
	
	    return function(matchItem, query) {
	      if (!isSanitizePresent && containsHtml(matchItem)) {
	        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
	      }
	      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
	      if (!isSanitizePresent) {
	        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
	      }
	      return matchItem;
	    };
	  }]);
	
	angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion-group.html",
	    "<div class=\"panel {{panelClass || 'panel-default'}}\">\n" +
	    "  <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
	    "    <h4 class=\"panel-title\">\n" +
	    "      <a href tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
	    "    </h4>\n" +
	    "  </div>\n" +
	    "  <div class=\"panel-collapse collapse\" collapse=\"!isOpen\">\n" +
	    "	  <div class=\"panel-body\" ng-transclude></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion.html",
	    "<div class=\"panel-group\" ng-transclude></div>");
	}]);
	
	angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/alert/alert.html",
	    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
	    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close($event)\">\n" +
	    "        <span aria-hidden=\"true\">&times;</span>\n" +
	    "        <span class=\"sr-only\">Close</span>\n" +
	    "    </button>\n" +
	    "    <div ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/carousel.html",
	    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
	    "    <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
	    "        <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
	    "    </ol>\n" +
	    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
	    "    <a class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-left\"></span></a>\n" +
	    "    <a class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-right\"></span></a>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/slide.html",
	    "<div ng-class=\"{\n" +
	    "    'active': active\n" +
	    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/datepicker.html",
	    "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
	    "  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n" +
	    "  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n" +
	    "  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n" +
	    "</div>");
	}]);
	
	angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/day.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
	    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/month.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/popup.html",
	    "<ul class=\"dropdown-menu\" ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
	    "	<li ng-transclude></li>\n" +
	    "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
	    "		<span class=\"btn-group pull-left\">\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
	    "		</span>\n" +
	    "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
	    "	</li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/year.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"3\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/backdrop.html",
	    "<div class=\"modal-backdrop\"\n" +
	    "     modal-animation-class=\"fade\"\n" +
	    "     modal-in-class=\"in\"\n" +
	    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
	    "></div>\n" +
	    "");
	}]);
	
	angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/window.html",
	    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
	    "    modal-animation-class=\"fade\"\n" +
	    "    modal-in-class=\"in\"\n" +
	    "	ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" +
	    "    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" modal-transclude></div></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pager.html",
	    "<ul class=\"pager\">\n" +
	    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pagination.html",
	    "<ul class=\"pagination\">\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-html-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-template-popup.html",
	    "<div class=\"tooltip\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\"\n" +
	    "    tooltip-template-transclude=\"contentExp()\"\n" +
	    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover-html.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover-template.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\"\n" +
	    "        tooltip-template-transclude=\"contentExp()\"\n" +
	    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover.html",
	    "<div class=\"popover\"\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/bar.html",
	    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" style=\"min-width: 0;\" ng-transclude></div>\n" +
	    "");
	}]);
	
	angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progress.html",
	    "<div class=\"progress\" ng-transclude></div>");
	}]);
	
	angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progressbar.html",
	    "<div class=\"progress\">\n" +
	    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" style=\"min-width: 0;\" ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/rating/rating.html",
	    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
	    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
	    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" ></i>\n" +
	    "</span>\n" +
	    "");
	}]);
	
	angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tab.html",
	    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
	    "  <a href ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
	    "</li>\n" +
	    "");
	}]);
	
	angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tabset.html",
	    "<div>\n" +
	    "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
	    "  <div class=\"tab-content\">\n" +
	    "    <div class=\"tab-pane\" \n" +
	    "         ng-repeat=\"tab in tabs\" \n" +
	    "         ng-class=\"{active: tab.active}\"\n" +
	    "         tab-content-transclude=\"tab\">\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/timepicker/timepicker.html",
	    "<table>\n" +
	    "  <tbody>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\">\n" +
	    "      </td>\n" +
	    "      <td>:</td>\n" +
	    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\">\n" +
	    "      </td>\n" +
	    "      <td ng-show=\"showMeridian\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n" +
	    "    </tr>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-match.html",
	    "<a href tabindex=\"-1\" ng-bind-html=\"match.label | typeaheadHighlight:query\"></a>\n" +
	    "");
	}]);
	
	angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-popup.html",
	    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
	    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{::match.id}}\">\n" +
	    "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
	    "    </li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = 'ngSanitize';


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.4.7
	 * (c) 2010-2015 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 *     Any commits to this file should be reviewed with security in mind.  *
	 *   Changes to this file can potentially create security vulnerabilities. *
	 *          An approval from 2 Core members with history of modifying      *
	 *                         this file is required.                          *
	 *                                                                         *
	 *  Does the change somehow allow for arbitrary javascript to be executed? *
	 *    Or allows for someone to change the prototype of built-in objects?   *
	 *     Or gives undesired access to variables likes document or window?    *
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	var $sanitizeMinErr = angular.$$minErr('$sanitize');
	
	/**
	 * @ngdoc module
	 * @name ngSanitize
	 * @description
	 *
	 * # ngSanitize
	 *
	 * The `ngSanitize` module provides functionality to sanitize HTML.
	 *
	 *
	 * <div doc-module-components="ngSanitize"></div>
	 *
	 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
	 */
	
	/*
	 * HTML Parser By Misko Hevery (misko@hevery.com)
	 * based on:  HTML Parser By John Resig (ejohn.org)
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 *
	 * // Use like so:
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 */
	
	
	/**
	 * @ngdoc service
	 * @name $sanitize
	 * @kind function
	 *
	 * @description
	 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
	 *   then serialized back to properly escaped html string. This means that no unsafe input can make
	 *   it into the returned string, however, since our parser is more strict than a typical browser
	 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
	 *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
	 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
	 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
	 *
	 * @param {string} html HTML input.
	 * @returns {string} Sanitized HTML.
	 *
	 * @example
	   <example module="sanitizeExample" deps="angular-sanitize.js">
	   <file name="index.html">
	     <script>
	         angular.module('sanitizeExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
	             $scope.snippet =
	               '<p style="color:blue">an html\n' +
	               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
	               'snippet</p>';
	             $scope.deliberatelyTrustDangerousSnippet = function() {
	               return $sce.trustAsHtml($scope.snippet);
	             };
	           }]);
	     </script>
	     <div ng-controller="ExampleController">
	        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Directive</td>
	           <td>How</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="bind-html-with-sanitize">
	           <td>ng-bind-html</td>
	           <td>Automatically uses $sanitize</td>
	           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind-html="snippet"></div></td>
	         </tr>
	         <tr id="bind-html-with-trust">
	           <td>ng-bind-html</td>
	           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
	           <td>
	           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
	&lt;/div&gt;</pre>
	           </td>
	           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
	         </tr>
	         <tr id="bind-default">
	           <td>ng-bind</td>
	           <td>Automatically escapes</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	       </div>
	   </file>
	   <file name="protractor.js" type="protractor">
	     it('should sanitize the html snippet by default', function() {
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
	     });
	
	     it('should inline raw snippet if bound to a trusted value', function() {
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
	         toBe("<p style=\"color:blue\">an html\n" +
	              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
	              "snippet</p>");
	     });
	
	     it('should escape snippet without any filter', function() {
	       expect(element(by.css('#bind-default div')).getInnerHtml()).
	         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
	              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
	              "snippet&lt;/p&gt;");
	     });
	
	     it('should update', function() {
	       element(by.model('snippet')).clear();
	       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('new <b>text</b>');
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
	         'new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
	         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
	     });
	   </file>
	   </example>
	 */
	function $SanitizeProvider() {
	  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
	    return function(html) {
	      var buf = [];
	      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
	        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
	      }));
	      return buf.join('');
	    };
	  }];
	}
	
	function sanitizeText(chars) {
	  var buf = [];
	  var writer = htmlSanitizeWriter(buf, angular.noop);
	  writer.chars(chars);
	  return buf.join('');
	}
	
	
	// Regular Expressions for parsing tags and attributes
	var START_TAG_REGEXP =
	       /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
	  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
	  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
	  BEGIN_TAG_REGEXP = /^</,
	  BEGING_END_TAGE_REGEXP = /^<\//,
	  COMMENT_REGEXP = /<!--(.*?)-->/g,
	  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
	  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
	  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	  // Match everything outside of normal chars and " (quote character)
	  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
	
	
	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var voidElements = makeMap("area,br,col,hr,img,wbr");
	
	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
	    optionalEndTagInlineElements = makeMap("rp,rt"),
	    optionalEndTagElements = angular.extend({},
	                                            optionalEndTagInlineElements,
	                                            optionalEndTagBlockElements);
	
	// Safe Block Elements - HTML5
	var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
	        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
	        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
	
	// Inline Elements - HTML5
	var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
	        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
	        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
	
	// SVG Elements
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
	// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
	// They can potentially allow for arbitrary javascript to be executed. See #11290
	var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
	        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
	        "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
	
	// Special Elements (can contain anything)
	var specialElements = makeMap("script,style");
	
	var validElements = angular.extend({},
	                                   voidElements,
	                                   blockElements,
	                                   inlineElements,
	                                   optionalEndTagElements,
	                                   svgElements);
	
	//Attributes that have href and hence need to be sanitized
	var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
	
	var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
	    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
	    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
	    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
	    'valign,value,vspace,width');
	
	// SVG attributes (without "id" and "name" attributes)
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
	var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
	    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
	    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
	    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
	    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
	    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
	    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
	    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
	    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
	    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
	    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
	    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
	    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
	    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
	    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
	
	var validAttrs = angular.extend({},
	                                uriAttrs,
	                                svgAttrs,
	                                htmlAttrs);
	
	function makeMap(str, lowercaseKeys) {
	  var obj = {}, items = str.split(','), i;
	  for (i = 0; i < items.length; i++) {
	    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
	  }
	  return obj;
	}
	
	
	/**
	 * @example
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 * @param {string} html string
	 * @param {object} handler
	 */
	function htmlParser(html, handler) {
	  if (typeof html !== 'string') {
	    if (html === null || typeof html === 'undefined') {
	      html = '';
	    } else {
	      html = '' + html;
	    }
	  }
	  var index, chars, match, stack = [], last = html, text;
	  stack.last = function() { return stack[stack.length - 1]; };
	
	  while (html) {
	    text = '';
	    chars = true;
	
	    // Make sure we're not in a script or style element
	    if (!stack.last() || !specialElements[stack.last()]) {
	
	      // Comment
	      if (html.indexOf("<!--") === 0) {
	        // comments containing -- are not allowed unless they terminate the comment
	        index = html.indexOf("--", 4);
	
	        if (index >= 0 && html.lastIndexOf("-->", index) === index) {
	          if (handler.comment) handler.comment(html.substring(4, index));
	          html = html.substring(index + 3);
	          chars = false;
	        }
	      // DOCTYPE
	      } else if (DOCTYPE_REGEXP.test(html)) {
	        match = html.match(DOCTYPE_REGEXP);
	
	        if (match) {
	          html = html.replace(match[0], '');
	          chars = false;
	        }
	      // end tag
	      } else if (BEGING_END_TAGE_REGEXP.test(html)) {
	        match = html.match(END_TAG_REGEXP);
	
	        if (match) {
	          html = html.substring(match[0].length);
	          match[0].replace(END_TAG_REGEXP, parseEndTag);
	          chars = false;
	        }
	
	      // start tag
	      } else if (BEGIN_TAG_REGEXP.test(html)) {
	        match = html.match(START_TAG_REGEXP);
	
	        if (match) {
	          // We only have a valid start-tag if there is a '>'.
	          if (match[4]) {
	            html = html.substring(match[0].length);
	            match[0].replace(START_TAG_REGEXP, parseStartTag);
	          }
	          chars = false;
	        } else {
	          // no ending tag found --- this piece should be encoded as an entity.
	          text += '<';
	          html = html.substring(1);
	        }
	      }
	
	      if (chars) {
	        index = html.indexOf("<");
	
	        text += index < 0 ? html : html.substring(0, index);
	        html = index < 0 ? "" : html.substring(index);
	
	        if (handler.chars) handler.chars(decodeEntities(text));
	      }
	
	    } else {
	      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\W\w].
	      html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
	        function(all, text) {
	          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
	
	          if (handler.chars) handler.chars(decodeEntities(text));
	
	          return "";
	      });
	
	      parseEndTag("", stack.last());
	    }
	
	    if (html == last) {
	      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
	                                        "of html: {0}", html);
	    }
	    last = html;
	  }
	
	  // Clean up any remaining tags
	  parseEndTag();
	
	  function parseStartTag(tag, tagName, rest, unary) {
	    tagName = angular.lowercase(tagName);
	    if (blockElements[tagName]) {
	      while (stack.last() && inlineElements[stack.last()]) {
	        parseEndTag("", stack.last());
	      }
	    }
	
	    if (optionalEndTagElements[tagName] && stack.last() == tagName) {
	      parseEndTag("", tagName);
	    }
	
	    unary = voidElements[tagName] || !!unary;
	
	    if (!unary) {
	      stack.push(tagName);
	    }
	
	    var attrs = {};
	
	    rest.replace(ATTR_REGEXP,
	      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
	        var value = doubleQuotedValue
	          || singleQuotedValue
	          || unquotedValue
	          || '';
	
	        attrs[name] = decodeEntities(value);
	    });
	    if (handler.start) handler.start(tagName, attrs, unary);
	  }
	
	  function parseEndTag(tag, tagName) {
	    var pos = 0, i;
	    tagName = angular.lowercase(tagName);
	    if (tagName) {
	      // Find the closest opened tag of the same type
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos] == tagName) break;
	      }
	    }
	
	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (i = stack.length - 1; i >= pos; i--)
	        if (handler.end) handler.end(stack[i]);
	
	      // Remove the open elements from the stack
	      stack.length = pos;
	    }
	  }
	}
	
	var hiddenPre=document.createElement("pre");
	/**
	 * decodes all entities into regular string
	 * @param value
	 * @returns {string} A string with decoded entities.
	 */
	function decodeEntities(value) {
	  if (!value) { return ''; }
	
	  hiddenPre.innerHTML = value.replace(/</g,"&lt;");
	  // innerText depends on styling as it doesn't display hidden elements.
	  // Therefore, it's better to use textContent not to cause unnecessary reflows.
	  return hiddenPre.textContent;
	}
	
	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param value
	 * @returns {string} escaped text
	 */
	function encodeEntities(value) {
	  return value.
	    replace(/&/g, '&amp;').
	    replace(SURROGATE_PAIR_REGEXP, function(value) {
	      var hi = value.charCodeAt(0);
	      var low = value.charCodeAt(1);
	      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	    }).
	    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
	      return '&#' + value.charCodeAt(0) + ';';
	    }).
	    replace(/</g, '&lt;').
	    replace(/>/g, '&gt;');
	}
	
	/**
	 * create an HTML/XML writer which writes to buffer
	 * @param {Array} buf use buf.jain('') to get out sanitized html string
	 * @returns {object} in the form of {
	 *     start: function(tag, attrs, unary) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * }
	 */
	function htmlSanitizeWriter(buf, uriValidator) {
	  var ignore = false;
	  var out = angular.bind(buf, buf.push);
	  return {
	    start: function(tag, attrs, unary) {
	      tag = angular.lowercase(tag);
	      if (!ignore && specialElements[tag]) {
	        ignore = tag;
	      }
	      if (!ignore && validElements[tag] === true) {
	        out('<');
	        out(tag);
	        angular.forEach(attrs, function(value, key) {
	          var lkey=angular.lowercase(key);
	          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
	          if (validAttrs[lkey] === true &&
	            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
	            out(' ');
	            out(key);
	            out('="');
	            out(encodeEntities(value));
	            out('"');
	          }
	        });
	        out(unary ? '/>' : '>');
	      }
	    },
	    end: function(tag) {
	        tag = angular.lowercase(tag);
	        if (!ignore && validElements[tag] === true) {
	          out('</');
	          out(tag);
	          out('>');
	        }
	        if (tag == ignore) {
	          ignore = false;
	        }
	      },
	    chars: function(chars) {
	        if (!ignore) {
	          out(encodeEntities(chars));
	        }
	      }
	  };
	}
	
	
	// define ngSanitize module and register $sanitize service
	angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
	
	/* global sanitizeText: false */
	
	/**
	 * @ngdoc filter
	 * @name linky
	 * @kind function
	 *
	 * @description
	 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
	 * plain email address links.
	 *
	 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
	 *
	 * @param {string} text Input text.
	 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
	 * @returns {string} Html-linkified text.
	 *
	 * @usage
	   <span ng-bind-html="linky_expression | linky"></span>
	 *
	 * @example
	   <example module="linkyExample" deps="angular-sanitize.js">
	     <file name="index.html">
	       <script>
	         angular.module('linkyExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', function($scope) {
	             $scope.snippet =
	               'Pretty text with some links:\n'+
	               'http://angularjs.org/,\n'+
	               'mailto:us@somewhere.org,\n'+
	               'another@somewhere.org,\n'+
	               'and one more: ftp://127.0.0.1/.';
	             $scope.snippetWithTarget = 'http://angularjs.org/';
	           }]);
	       </script>
	       <div ng-controller="ExampleController">
	       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Filter</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="linky-filter">
	           <td>linky filter</td>
	           <td>
	             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
	           </td>
	           <td>
	             <div ng-bind-html="snippet | linky"></div>
	           </td>
	         </tr>
	         <tr id="linky-target">
	          <td>linky target</td>
	          <td>
	            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
	          </td>
	          <td>
	            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
	          </td>
	         </tr>
	         <tr id="escaped-html">
	           <td>no filter</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	     </file>
	     <file name="protractor.js" type="protractor">
	       it('should linkify the snippet with urls', function() {
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
	       });
	
	       it('should not linkify snippet without the linky filter', function() {
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
	       });
	
	       it('should update', function() {
	         element(by.model('snippet')).clear();
	         element(by.model('snippet')).sendKeys('new http://link.');
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('new http://link.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
	             .toBe('new http://link.');
	       });
	
	       it('should work with the target property', function() {
	        expect(element(by.id('linky-target')).
	            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
	            toBe('http://angularjs.org/');
	        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
	       });
	     </file>
	   </example>
	 */
	angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
	  var LINKY_URL_REGEXP =
	        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
	      MAILTO_REGEXP = /^mailto:/i;
	
	  return function(text, target) {
	    if (!text) return text;
	    var match;
	    var raw = text;
	    var html = [];
	    var url;
	    var i;
	    while ((match = raw.match(LINKY_URL_REGEXP))) {
	      // We can not end in these as they are sometimes found at the end of the sentence
	      url = match[0];
	      // if we did not match ftp/http/www/mailto then assume mailto
	      if (!match[2] && !match[4]) {
	        url = (match[3] ? 'http://' : 'mailto:') + url;
	      }
	      i = match.index;
	      addText(raw.substr(0, i));
	      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
	      raw = raw.substring(i + match[0].length);
	    }
	    addText(raw);
	    return $sanitize(html.join(''));
	
	    function addText(text) {
	      if (!text) {
	        return;
	      }
	      html.push(sanitizeText(text));
	    }
	
	    function addLink(url, text) {
	      html.push('<a ');
	      if (angular.isDefined(target)) {
	        html.push('target="',
	                  target,
	                  '" ');
	      }
	      html.push('href="',
	                url.replace(/"/g, '&quot;'),
	                '">');
	      addText(text);
	      html.push('</a>');
	    }
	  };
	}]);
	
	
	})(window, window.angular);


/***/ },
/* 6 */
/***/ function(module, exports) {

	(function() { module.exports = this["rl_utilities"]; }());

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(8);
	var Slider = __webpack_require__(12);
	
	angular.module('ui.bootstrap-slider', [])
	    .directive('slider', ['$parse', '$timeout', '$rootScope', function ($parse, $timeout, $rootScope) {
	        return {
	            restrict: 'AE',
	            replace: true,
	            template: '<div><input class="slider-input" type="text" style="width:100%" /></div>',
	            require: 'ngModel',
	            scope: {
	                max: "=",
	                min: "=",
	                step: "=",
	                value: "=",
	                ngModel: '=',
	                ngDisabled: '=',
	                range: '=',
	                sliderid: '=',
	                ticks: '=',
	                ticksLabels: '=',
	                ticksSnapBounds: '=',
	                ticksPositions: '=',
	                scale: '=',
	                formatter: '&',
	                onStartSlide: '&',
	                onStopSlide: '&',
	                onSlide: '&'
	            },
	            link: function ($scope, element, attrs, ngModelCtrl, $compile) {
	                var ngModelDeregisterFn, ngDisabledDeregisterFn;
	
	                initSlider();
	
	                function initSlider() {
	                    var options = {};
	
	                    function setOption(key, value, defaultValue) {
	                        options[key] = value || defaultValue;
	                    }
	
	                    function setFloatOption(key, value, defaultValue) {
	                        options[key] = value || value === 0 ? parseFloat(value) : defaultValue;
	                    }
	
	                    function setBooleanOption(key, value, defaultValue) {
	                        options[key] = value ? value + '' === 'true' : defaultValue;
	                    }
	
	                    function getArrayOrValue(value) {
	                        return (angular.isString(value) && value.indexOf("[") === 0) ? angular.fromJson(value) : value;
	                    }
	
	                    setOption('id', $scope.sliderid);
	                    setOption('orientation', attrs.orientation, 'horizontal');
	                    setOption('selection', attrs.selection, 'before');
	                    setOption('handle', attrs.handle, 'round');
	                    setOption('tooltip', attrs.sliderTooltip || attrs.tooltip, 'show');
	                    setOption('tooltip_position', attrs.sliderTooltipPosition, 'top');
	                    setOption('tooltipseparator', attrs.tooltipseparator, ':');
	                    setOption('ticks', $scope.ticks);
	                    setOption('ticks_labels', $scope.ticksLabels);
	                    setOption('ticks_snap_bounds', $scope.ticksSnapBounds);
	                    setOption('ticks_positions', $scope.ticksPositions);
	                    setOption('scale', $scope.scale, 'linear');
	
	                    setFloatOption('min', $scope.min, 0);
	                    setFloatOption('max', $scope.max, 10);
	                    setFloatOption('step', $scope.step, 1);
	                    var strNbr = options.step + '';
	                    var decimals = strNbr.substring(strNbr.lastIndexOf('.') + 1);
	                    setFloatOption('precision', attrs.precision, decimals);
	
	                    setBooleanOption('tooltip_split', attrs.tooltipsplit, false);
	                    setBooleanOption('enabled', attrs.enabled, true);
	                    setBooleanOption('naturalarrowkeys', attrs.naturalarrowkeys, false);
	                    setBooleanOption('reversed', attrs.reversed, false);
	
	                    setBooleanOption('range', $scope.range, false);
	                    if (options.range) {
	                        if (angular.isArray($scope.value)) {
	                            options.value = $scope.value;
	                        }
	                        else if (angular.isString($scope.value)) {
	                            options.value = getArrayOrValue($scope.value);
	                            if (!angular.isArray(options.value)) {
	                                var value = parseFloat($scope.value);
	                                if (isNaN(value)) value = 5;
	
	                                if (value < $scope.min) {
	                                    value = $scope.min;
	                                    options.value = [value, options.max];
	                                }
	                                else if (value > $scope.max) {
	                                    value = $scope.max;
	                                    options.value = [options.min, value];
	                                }
	                                else {
	                                    options.value = [options.min, options.max];
	                                }
	                            }
	                        }
	                        else {
	                            options.value = [options.min, options.max]; // This is needed, because of value defined at $.fn.slider.defaults - default value 5 prevents creating range slider
	                        }
	                        $scope.ngModel = options.value; // needed, otherwise turns value into [null, ##]
	                    }
	                    else {
	                        setFloatOption('value', $scope.value, 5);
	                    }
	
	                    if ($scope.formatter) options.formatter = $scope.$eval($scope.formatter);
	
	
	                    // check if slider jQuery plugin exists
	                    if ('$' in window && $.fn.slider) {
	                        // adding methods to jQuery slider plugin prototype
	                        $.fn.slider.constructor.prototype.disable = function () {
	                            this.picker.off();
	                        };
	                        $.fn.slider.constructor.prototype.enable = function () {
	                            this.picker.on();
	                        };
	                    }
	
	                    // destroy previous slider to reset all options
	                    if (element[0].__slider)
	                        element[0].__slider.destroy();
	
	                    var slider = new Slider(element[0].getElementsByClassName('slider-input')[0], options);
	                    element[0].__slider = slider;
	
	                    // everything that needs slider element
	                    var updateEvent = getArrayOrValue(attrs.updateevent);
	                    if (angular.isString(updateEvent)) {
	                        // if only single event name in string
	                        updateEvent = [updateEvent];
	                    }
	                    else {
	                        // default to slide event
	                        updateEvent = ['slide'];
	                    }
	                    angular.forEach(updateEvent, function (sliderEvent) {
	                        slider.on(sliderEvent, function (ev) {
	                            ngModelCtrl.$setViewValue(ev);
	                            $timeout(function () {
	                                $scope.$apply();
	                            });
	                        });
	                    });
	                    slider.on('change', function (ev) {
	                        ngModelCtrl.$setViewValue(ev.newValue);
	                        $timeout(function () {
	                            $scope.$apply();
	                        });
	                    });
	
	                    // Event listeners
	                    var sliderEvents = {
	                        slideStart: 'onStartSlide',
	                        slide: 'onSlide',
	                        slideStop: 'onStopSlide'
	                    };
	                    angular.forEach(sliderEvents, function (sliderEventAttr, sliderEvent) {
	                        var fn = $parse(attrs[sliderEventAttr]);
	                        slider.on(sliderEvent, function (ev) {
	                            if ($scope[sliderEventAttr]) {
	
	                                var callback = function () {
	                                    fn($scope.$parent, { $event: ev, value: ev });
	                                }
	
	                                if ($rootScope.$$phase) {
	                                    $scope.$evalAsync(callback);
	                                } else {
	                                    $scope.$apply(callback);
	                                }
	                            }
	                        });
	                    });
	
	                    // deregister ngDisabled watcher to prevent memory leaks
	                    if (angular.isFunction(ngDisabledDeregisterFn)) {
	                        ngDisabledDeregisterFn();
	                        ngDisabledDeregisterFn = null;
	                    }
	
	                    ngDisabledDeregisterFn = $scope.$watch('ngDisabled', function (value) {
	                        if (value) {
	                            slider.disable();
	                        }
	                        else {
	                            slider.enable();
	                        }
	                    });
	
	                    // deregister ngModel watcher to prevent memory leaks
	                    if (angular.isFunction(ngModelDeregisterFn)) ngModelDeregisterFn();
	                    ngModelDeregisterFn = $scope.$watch('ngModel', function (value) {
	                        if($scope.range){
	                            slider.setValue(value);
	                        }else{
	                            slider.setValue(parseFloat(value));
	                        }
	                    }, true);
	                }
	
	
	                var watchers = ['min', 'max', 'step', 'range', 'scale'];
	                angular.forEach(watchers, function (prop) {
	                    $scope.$watch(prop, function () {
	                        initSlider();
	                    });
	                });
	            }
	        };
	    }])
	;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(9);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(11)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./bootstrap-slider.min.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./bootstrap-slider.min.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(10)();
	// imports
	
	
	// module
	exports.push([module.id, "/*! =======================================================\r\n                      VERSION  5.1.1\r\n========================================================= */\r\n/*! =========================================================\r\n * bootstrap-slider.js\r\n *\r\n * Maintainers:\r\n *\t\tKyle Kemp\r\n *\t\t\t- Twitter: @seiyria\r\n *\t\t\t- Github:  seiyria\r\n *\t\tRohit Kalkur\r\n *\t\t\t- Twitter: @Rovolutionary\r\n *\t\t\t- Github:  rovolution\r\n *\r\n * =========================================================\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ========================================================= */.slider{display:inline-block;vertical-align:middle;position:relative}.slider.slider-horizontal{width:210px;height:20px}.slider.slider-horizontal .slider-track{height:10px;width:100%;margin-top:-5px;top:50%;left:0}.slider.slider-horizontal .slider-selection,.slider.slider-horizontal .slider-track-low,.slider.slider-horizontal .slider-track-high{height:100%;top:0;bottom:0}.slider.slider-horizontal .slider-tick,.slider.slider-horizontal .slider-handle{margin-left:-10px;margin-top:-5px}.slider.slider-horizontal .slider-tick.triangle,.slider.slider-horizontal .slider-handle.triangle{border-width:0 10px 10px 10px;width:0;height:0;border-bottom-color:#0480be;margin-top:0}.slider.slider-horizontal .slider-tick-label-container{white-space:nowrap;margin-top:20px}.slider.slider-horizontal .slider-tick-label-container .slider-tick-label{padding-top:4px;display:inline-block;text-align:center}.slider.slider-vertical{height:210px;width:20px}.slider.slider-vertical .slider-track{width:10px;height:100%;margin-left:-5px;left:50%;top:0}.slider.slider-vertical .slider-selection{width:100%;left:0;top:0;bottom:0}.slider.slider-vertical .slider-track-low,.slider.slider-vertical .slider-track-high{width:100%;left:0;right:0}.slider.slider-vertical .slider-tick,.slider.slider-vertical .slider-handle{margin-left:-5px;margin-top:-10px}.slider.slider-vertical .slider-tick.triangle,.slider.slider-vertical .slider-handle.triangle{border-width:10px 0 10px 10px;width:1px;height:1px;border-left-color:#0480be;margin-left:0}.slider.slider-disabled .slider-handle{background-image:-webkit-linear-gradient(top,#dfdfdf 0,#bebebe 100%);background-image:-o-linear-gradient(top,#dfdfdf 0,#bebebe 100%);background-image:linear-gradient(to bottom,#dfdfdf 0,#bebebe 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdfdfdf',endColorstr='#ffbebebe',GradientType=0)}.slider.slider-disabled .slider-track{background-image:-webkit-linear-gradient(top,#e5e5e5 0,#e9e9e9 100%);background-image:-o-linear-gradient(top,#e5e5e5 0,#e9e9e9 100%);background-image:linear-gradient(to bottom,#e5e5e5 0,#e9e9e9 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe5e5e5',endColorstr='#ffe9e9e9',GradientType=0);cursor:not-allowed}.slider input{display:none}.slider .tooltip.top{margin-top:-36px}.slider .tooltip-inner{white-space:nowrap}.slider .hide{display:none}.slider-track{position:absolute;cursor:pointer;background-image:-webkit-linear-gradient(top,#f5f5f5 0,#f9f9f9 100%);background-image:-o-linear-gradient(top,#f5f5f5 0,#f9f9f9 100%);background-image:linear-gradient(to bottom,#f5f5f5 0,#f9f9f9 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);border-radius:4px}.slider-selection{position:absolute;background-image:-webkit-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:linear-gradient(to bottom,#f9f9f9 0,#f5f5f5 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;border-radius:4px}.slider-selection.tick-slider-selection{background-image:-webkit-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:-o-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:linear-gradient(to bottom,#89cdef 0,#81bfde 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef',endColorstr='#ff81bfde',GradientType=0)}.slider-track-low,.slider-track-high{position:absolute;background:transparent;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;border-radius:4px}.slider-handle{position:absolute;width:20px;height:20px;background-color:#337ab7;background-image:-webkit-linear-gradient(top,#149bdf 0,#0480be 100%);background-image:-o-linear-gradient(top,#149bdf 0,#0480be 100%);background-image:linear-gradient(to bottom,#149bdf 0,#0480be 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);filter:none;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);border:0 solid transparent}.slider-handle.round{border-radius:50%}.slider-handle.triangle{background:transparent none}.slider-handle.custom{background:transparent none}.slider-handle.custom::before{line-height:20px;font-size:20px;content:'\\2605';color:#726204}.slider-tick{position:absolute;width:20px;height:20px;background-image:-webkit-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:linear-gradient(to bottom,#f9f9f9 0,#f5f5f5 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;filter:none;opacity:.8;border:0 solid transparent}.slider-tick.round{border-radius:50%}.slider-tick.triangle{background:transparent none}.slider-tick.custom{background:transparent none}.slider-tick.custom::before{line-height:20px;font-size:20px;content:'\\2605';color:#726204}.slider-tick.in-selection{background-image:-webkit-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:-o-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:linear-gradient(to bottom,#89cdef 0,#81bfde 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef',endColorstr='#ff81bfde',GradientType=0);opacity:1}", ""]);
	
	// exports


/***/ },
/* 10 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! =======================================================
	                      VERSION  5.1.1
	========================================================= */
	/*! =========================================================
	 * bootstrap-slider.js
	 *
	 * Maintainers:
	 *		Kyle Kemp
	 *			- Twitter: @seiyria
	 *			- Github:  seiyria
	 *		Rohit Kalkur
	 *			- Twitter: @Rovolutionary
	 *			- Github:  rovolution
	 *
	 * =========================================================
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================= */
	!function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(13)], __WEBPACK_AMD_DEFINE_FACTORY__ = (b), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if("object"==typeof module&&module.exports){var c;try{c=require("jquery")}catch(d){c=null}module.exports=b(c)}else a.Slider=b(a.jQuery)}(this,function(a){var b;return function(a){"use strict";function b(){}function c(a){function c(b){b.prototype.option||(b.prototype.option=function(b){a.isPlainObject(b)&&(this.options=a.extend(!0,this.options,b))})}function e(b,c){a.fn[b]=function(e){if("string"==typeof e){for(var g=d.call(arguments,1),h=0,i=this.length;i>h;h++){var j=this[h],k=a.data(j,b);if(k)if(a.isFunction(k[e])&&"_"!==e.charAt(0)){var l=k[e].apply(k,g);if(void 0!==l&&l!==k)return l}else f("no such method '"+e+"' for "+b+" instance");else f("cannot call methods on "+b+" prior to initialization; attempted to call '"+e+"'")}return this}var m=this.map(function(){var d=a.data(this,b);return d?(d.option(e),d._init()):(d=new c(this,e),a.data(this,b,d)),a(this)});return!m||m.length>1?m:m[0]}}if(a){var f="undefined"==typeof console?b:function(a){console.error(a)};return a.bridget=function(a,b){c(b),e(a,b)},a.bridget}}var d=Array.prototype.slice;c(a)}(a),function(a){function c(b,c){function d(a,b){var c="data-slider-"+b.replace(/_/g,"-"),d=a.getAttribute(c);try{return JSON.parse(d)}catch(e){return d}}this._state={value:null,enabled:null,offset:null,size:null,percentage:null,inDrag:!1,over:!1},"string"==typeof b?this.element=document.querySelector(b):b instanceof HTMLElement&&(this.element=b),c=c?c:{};for(var f=Object.keys(this.defaultOptions),g=0;g<f.length;g++){var h=f[g],i=c[h];i="undefined"!=typeof i?i:d(this.element,h),i=null!==i?i:this.defaultOptions[h],this.options||(this.options={}),this.options[h]=i}"vertical"!==this.options.orientation||"top"!==this.options.tooltip_position&&"bottom"!==this.options.tooltip_position?"horizontal"!==this.options.orientation||"left"!==this.options.tooltip_position&&"right"!==this.options.tooltip_position||(this.options.tooltip_position="top"):this.options.tooltip_position="right";var j,k,l,m,n,o=this.element.style.width,p=!1,q=this.element.parentNode;if(this.sliderElem)p=!0;else{this.sliderElem=document.createElement("div"),this.sliderElem.className="slider";var r=document.createElement("div");if(r.className="slider-track",k=document.createElement("div"),k.className="slider-track-low",j=document.createElement("div"),j.className="slider-selection",l=document.createElement("div"),l.className="slider-track-high",m=document.createElement("div"),m.className="slider-handle min-slider-handle",n=document.createElement("div"),n.className="slider-handle max-slider-handle",r.appendChild(k),r.appendChild(j),r.appendChild(l),this.ticks=[],Array.isArray(this.options.ticks)&&this.options.ticks.length>0){for(g=0;g<this.options.ticks.length;g++){var s=document.createElement("div");s.className="slider-tick",this.ticks.push(s),r.appendChild(s)}j.className+=" tick-slider-selection"}if(r.appendChild(m),r.appendChild(n),this.tickLabels=[],Array.isArray(this.options.ticks_labels)&&this.options.ticks_labels.length>0)for(this.tickLabelContainer=document.createElement("div"),this.tickLabelContainer.className="slider-tick-label-container",g=0;g<this.options.ticks_labels.length;g++){var t=document.createElement("div");t.className="slider-tick-label",t.innerHTML=this.options.ticks_labels[g],this.tickLabels.push(t),this.tickLabelContainer.appendChild(t)}var u=function(a){var b=document.createElement("div");b.className="tooltip-arrow";var c=document.createElement("div");c.className="tooltip-inner",a.appendChild(b),a.appendChild(c)},v=document.createElement("div");v.className="tooltip tooltip-main",u(v);var w=document.createElement("div");w.className="tooltip tooltip-min",u(w);var x=document.createElement("div");x.className="tooltip tooltip-max",u(x),this.sliderElem.appendChild(r),this.sliderElem.appendChild(v),this.sliderElem.appendChild(w),this.sliderElem.appendChild(x),this.tickLabelContainer&&this.sliderElem.appendChild(this.tickLabelContainer),q.insertBefore(this.sliderElem,this.element),this.element.style.display="none"}if(a&&(this.$element=a(this.element),this.$sliderElem=a(this.sliderElem)),this.eventToCallbackMap={},this.sliderElem.id=this.options.id,this.touchCapable="ontouchstart"in window||window.DocumentTouch&&document instanceof window.DocumentTouch,this.tooltip=this.sliderElem.querySelector(".tooltip-main"),this.tooltipInner=this.tooltip.querySelector(".tooltip-inner"),this.tooltip_min=this.sliderElem.querySelector(".tooltip-min"),this.tooltipInner_min=this.tooltip_min.querySelector(".tooltip-inner"),this.tooltip_max=this.sliderElem.querySelector(".tooltip-max"),this.tooltipInner_max=this.tooltip_max.querySelector(".tooltip-inner"),e[this.options.scale]&&(this.options.scale=e[this.options.scale]),p===!0&&(this._removeClass(this.sliderElem,"slider-horizontal"),this._removeClass(this.sliderElem,"slider-vertical"),this._removeClass(this.tooltip,"hide"),this._removeClass(this.tooltip_min,"hide"),this._removeClass(this.tooltip_max,"hide"),["left","top","width","height"].forEach(function(a){this._removeProperty(this.trackLow,a),this._removeProperty(this.trackSelection,a),this._removeProperty(this.trackHigh,a)},this),[this.handle1,this.handle2].forEach(function(a){this._removeProperty(a,"left"),this._removeProperty(a,"top")},this),[this.tooltip,this.tooltip_min,this.tooltip_max].forEach(function(a){this._removeProperty(a,"left"),this._removeProperty(a,"top"),this._removeProperty(a,"margin-left"),this._removeProperty(a,"margin-top"),this._removeClass(a,"right"),this._removeClass(a,"top")},this)),"vertical"===this.options.orientation?(this._addClass(this.sliderElem,"slider-vertical"),this.stylePos="top",this.mousePos="pageY",this.sizePos="offsetHeight"):(this._addClass(this.sliderElem,"slider-horizontal"),this.sliderElem.style.width=o,this.options.orientation="horizontal",this.stylePos="left",this.mousePos="pageX",this.sizePos="offsetWidth"),this._setTooltipPosition(),Array.isArray(this.options.ticks)&&this.options.ticks.length>0&&(this.options.max=Math.max.apply(Math,this.options.ticks),this.options.min=Math.min.apply(Math,this.options.ticks)),Array.isArray(this.options.value)?(this.options.range=!0,this._state.value=this.options.value):this._state.value=this.options.range?[this.options.value,this.options.max]:this.options.value,this.trackLow=k||this.trackLow,this.trackSelection=j||this.trackSelection,this.trackHigh=l||this.trackHigh,"none"===this.options.selection&&(this._addClass(this.trackLow,"hide"),this._addClass(this.trackSelection,"hide"),this._addClass(this.trackHigh,"hide")),this.handle1=m||this.handle1,this.handle2=n||this.handle2,p===!0)for(this._removeClass(this.handle1,"round triangle"),this._removeClass(this.handle2,"round triangle hide"),g=0;g<this.ticks.length;g++)this._removeClass(this.ticks[g],"round triangle hide");var y=["round","triangle","custom"],z=-1!==y.indexOf(this.options.handle);if(z)for(this._addClass(this.handle1,this.options.handle),this._addClass(this.handle2,this.options.handle),g=0;g<this.ticks.length;g++)this._addClass(this.ticks[g],this.options.handle);this._state.offset=this._offset(this.sliderElem),this._state.size=this.sliderElem[this.sizePos],this.setValue(this._state.value),this.handle1Keydown=this._keydown.bind(this,0),this.handle1.addEventListener("keydown",this.handle1Keydown,!1),this.handle2Keydown=this._keydown.bind(this,1),this.handle2.addEventListener("keydown",this.handle2Keydown,!1),this.mousedown=this._mousedown.bind(this),this.touchCapable&&this.sliderElem.addEventListener("touchstart",this.mousedown,!1),this.sliderElem.addEventListener("mousedown",this.mousedown,!1),"hide"===this.options.tooltip?(this._addClass(this.tooltip,"hide"),this._addClass(this.tooltip_min,"hide"),this._addClass(this.tooltip_max,"hide")):"always"===this.options.tooltip?(this._showTooltip(),this._alwaysShowTooltip=!0):(this.showTooltip=this._showTooltip.bind(this),this.hideTooltip=this._hideTooltip.bind(this),this.sliderElem.addEventListener("mouseenter",this.showTooltip,!1),this.sliderElem.addEventListener("mouseleave",this.hideTooltip,!1),this.handle1.addEventListener("focus",this.showTooltip,!1),this.handle1.addEventListener("blur",this.hideTooltip,!1),this.handle2.addEventListener("focus",this.showTooltip,!1),this.handle2.addEventListener("blur",this.hideTooltip,!1)),this.options.enabled?this.enable():this.disable()}var d={formatInvalidInputErrorMsg:function(a){return"Invalid input value '"+a+"' passed in"},callingContextNotSliderInstance:"Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"},e={linear:{toValue:function(a){var b=a/100*(this.options.max-this.options.min);if(this.options.ticks_positions.length>0){for(var c,d,e,f=0,g=0;g<this.options.ticks_positions.length;g++)if(a<=this.options.ticks_positions[g]){c=g>0?this.options.ticks[g-1]:0,e=g>0?this.options.ticks_positions[g-1]:0,d=this.options.ticks[g],f=this.options.ticks_positions[g];break}if(g>0){var h=(a-e)/(f-e);b=c+h*(d-c)}}var i=this.options.min+Math.round(b/this.options.step)*this.options.step;return i<this.options.min?this.options.min:i>this.options.max?this.options.max:i},toPercentage:function(a){if(this.options.max===this.options.min)return 0;if(this.options.ticks_positions.length>0){for(var b,c,d,e=0,f=0;f<this.options.ticks.length;f++)if(a<=this.options.ticks[f]){b=f>0?this.options.ticks[f-1]:0,d=f>0?this.options.ticks_positions[f-1]:0,c=this.options.ticks[f],e=this.options.ticks_positions[f];break}if(f>0){var g=(a-b)/(c-b);return d+g*(e-d)}}return 100*(a-this.options.min)/(this.options.max-this.options.min)}},logarithmic:{toValue:function(a){var b=0===this.options.min?0:Math.log(this.options.min),c=Math.log(this.options.max),d=Math.exp(b+(c-b)*a/100);return d=this.options.min+Math.round((d-this.options.min)/this.options.step)*this.options.step,d<this.options.min?this.options.min:d>this.options.max?this.options.max:d},toPercentage:function(a){if(this.options.max===this.options.min)return 0;var b=Math.log(this.options.max),c=0===this.options.min?0:Math.log(this.options.min),d=0===a?0:Math.log(a);return 100*(d-c)/(b-c)}}};if(b=function(a,b){return c.call(this,a,b),this},b.prototype={_init:function(){},constructor:b,defaultOptions:{id:"",min:0,max:10,step:1,precision:0,orientation:"horizontal",value:5,range:!1,selection:"before",tooltip:"show",tooltip_split:!1,handle:"round",reversed:!1,enabled:!0,formatter:function(a){return Array.isArray(a)?a[0]+" : "+a[1]:a},natural_arrow_keys:!1,ticks:[],ticks_positions:[],ticks_labels:[],ticks_snap_bounds:0,scale:"linear",focus:!1,tooltip_position:null},getElement:function(){return this.sliderElem},getValue:function(){return this.options.range?this._state.value:this._state.value[0]},setValue:function(a,b,c){a||(a=0);var d=this.getValue();this._state.value=this._validateInputValue(a);var e=this._applyPrecision.bind(this);this.options.range?(this._state.value[0]=e(this._state.value[0]),this._state.value[1]=e(this._state.value[1]),this._state.value[0]=Math.max(this.options.min,Math.min(this.options.max,this._state.value[0])),this._state.value[1]=Math.max(this.options.min,Math.min(this.options.max,this._state.value[1]))):(this._state.value=e(this._state.value),this._state.value=[Math.max(this.options.min,Math.min(this.options.max,this._state.value))],this._addClass(this.handle2,"hide"),this._state.value[1]="after"===this.options.selection?this.options.max:this.options.min),this._state.percentage=this.options.max>this.options.min?[this._toPercentage(this._state.value[0]),this._toPercentage(this._state.value[1]),100*this.options.step/(this.options.max-this.options.min)]:[0,0,100],this._layout();var f=this.options.range?this._state.value:this._state.value[0];return b===!0&&this._trigger("slide",f),d!==f&&c===!0&&this._trigger("change",{oldValue:d,newValue:f}),this._setDataVal(f),this},destroy:function(){this._removeSliderEventHandlers(),this.sliderElem.parentNode.removeChild(this.sliderElem),this.element.style.display="",this._cleanUpEventCallbacksMap(),this.element.removeAttribute("data"),a&&(this._unbindJQueryEventHandlers(),this.$element.removeData("slider"))},disable:function(){return this._state.enabled=!1,this.handle1.removeAttribute("tabindex"),this.handle2.removeAttribute("tabindex"),this._addClass(this.sliderElem,"slider-disabled"),this._trigger("slideDisabled"),this},enable:function(){return this._state.enabled=!0,this.handle1.setAttribute("tabindex",0),this.handle2.setAttribute("tabindex",0),this._removeClass(this.sliderElem,"slider-disabled"),this._trigger("slideEnabled"),this},toggle:function(){return this._state.enabled?this.disable():this.enable(),this},isEnabled:function(){return this._state.enabled},on:function(a,b){return this._bindNonQueryEventHandler(a,b),this},off:function(b,c){a?(this.$element.off(b,c),this.$sliderElem.off(b,c)):this._unbindNonQueryEventHandler(b,c)},getAttribute:function(a){return a?this.options[a]:this.options},setAttribute:function(a,b){return this.options[a]=b,this},refresh:function(){return this._removeSliderEventHandlers(),c.call(this,this.element,this.options),a&&a.data(this.element,"slider",this),this},relayout:function(){return this._layout(),this},_removeSliderEventHandlers:function(){this.handle1.removeEventListener("keydown",this.handle1Keydown,!1),this.handle1.removeEventListener("focus",this.showTooltip,!1),this.handle1.removeEventListener("blur",this.hideTooltip,!1),this.handle2.removeEventListener("keydown",this.handle2Keydown,!1),this.handle2.removeEventListener("focus",this.handle2Keydown,!1),this.handle2.removeEventListener("blur",this.handle2Keydown,!1),this.sliderElem.removeEventListener("mouseenter",this.showTooltip,!1),this.sliderElem.removeEventListener("mouseleave",this.hideTooltip,!1),this.sliderElem.removeEventListener("touchstart",this.mousedown,!1),this.sliderElem.removeEventListener("mousedown",this.mousedown,!1)},_bindNonQueryEventHandler:function(a,b){void 0===this.eventToCallbackMap[a]&&(this.eventToCallbackMap[a]=[]),this.eventToCallbackMap[a].push(b)},_unbindNonQueryEventHandler:function(a,b){var c=this.eventToCallbackMap[a];if(void 0!==c)for(var d=0;d<c.length;d++)if(c[d]===b){c.splice(d,1);break}},_cleanUpEventCallbacksMap:function(){for(var a=Object.keys(this.eventToCallbackMap),b=0;b<a.length;b++){var c=a[b];this.eventToCallbackMap[c]=null}},_showTooltip:function(){this.options.tooltip_split===!1?(this._addClass(this.tooltip,"in"),this.tooltip_min.style.display="none",this.tooltip_max.style.display="none"):(this._addClass(this.tooltip_min,"in"),this._addClass(this.tooltip_max,"in"),this.tooltip.style.display="none"),this._state.over=!0},_hideTooltip:function(){this._state.inDrag===!1&&this.alwaysShowTooltip!==!0&&(this._removeClass(this.tooltip,"in"),this._removeClass(this.tooltip_min,"in"),this._removeClass(this.tooltip_max,"in")),this._state.over=!1},_layout:function(){var a;if(a=this.options.reversed?[100-this._state.percentage[0],this.options.range?100-this._state.percentage[1]:this._state.percentage[1]]:[this._state.percentage[0],this._state.percentage[1]],this.handle1.style[this.stylePos]=a[0]+"%",this.handle2.style[this.stylePos]=a[1]+"%",Array.isArray(this.options.ticks)&&this.options.ticks.length>0){var b=Math.max.apply(Math,this.options.ticks),c=Math.min.apply(Math,this.options.ticks),d="vertical"===this.options.orientation?"height":"width",e="vertical"===this.options.orientation?"marginTop":"marginLeft",f=this._state.size/(this.options.ticks.length-1);if(this.tickLabelContainer){var g=0;if(0===this.options.ticks_positions.length)this.tickLabelContainer.style[e]=-f/2+"px",g=this.tickLabelContainer.offsetHeight;else for(h=0;h<this.tickLabelContainer.childNodes.length;h++)this.tickLabelContainer.childNodes[h].offsetHeight>g&&(g=this.tickLabelContainer.childNodes[h].offsetHeight);"horizontal"===this.options.orientation&&(this.sliderElem.style.marginBottom=g+"px")}for(var h=0;h<this.options.ticks.length;h++){var i=this.options.ticks_positions[h]||100*(this.options.ticks[h]-c)/(b-c);this.ticks[h].style[this.stylePos]=i+"%",this._removeClass(this.ticks[h],"in-selection"),this.options.range?i>=a[0]&&i<=a[1]&&this._addClass(this.ticks[h],"in-selection"):"after"===this.options.selection&&i>=a[0]?this._addClass(this.ticks[h],"in-selection"):"before"===this.options.selection&&i<=a[0]&&this._addClass(this.ticks[h],"in-selection"),this.tickLabels[h]&&(this.tickLabels[h].style[d]=f+"px",void 0!==this.options.ticks_positions[h]&&(this.tickLabels[h].style.position="absolute",this.tickLabels[h].style[this.stylePos]=this.options.ticks_positions[h]+"%",this.tickLabels[h].style[e]=-f/2+"px"))}}var j;if(this.options.range){j=this.options.formatter(this._state.value),this._setText(this.tooltipInner,j),this.tooltip.style[this.stylePos]=(a[1]+a[0])/2+"%","vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px"),"vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px");var k=this.options.formatter(this._state.value[0]);this._setText(this.tooltipInner_min,k);var l=this.options.formatter(this._state.value[1]);this._setText(this.tooltipInner_max,l),this.tooltip_min.style[this.stylePos]=a[0]+"%","vertical"===this.options.orientation?this._css(this.tooltip_min,"margin-top",-this.tooltip_min.offsetHeight/2+"px"):this._css(this.tooltip_min,"margin-left",-this.tooltip_min.offsetWidth/2+"px"),this.tooltip_max.style[this.stylePos]=a[1]+"%","vertical"===this.options.orientation?this._css(this.tooltip_max,"margin-top",-this.tooltip_max.offsetHeight/2+"px"):this._css(this.tooltip_max,"margin-left",-this.tooltip_max.offsetWidth/2+"px")}else j=this.options.formatter(this._state.value[0]),this._setText(this.tooltipInner,j),this.tooltip.style[this.stylePos]=a[0]+"%","vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px");if("vertical"===this.options.orientation)this.trackLow.style.top="0",this.trackLow.style.height=Math.min(a[0],a[1])+"%",this.trackSelection.style.top=Math.min(a[0],a[1])+"%",this.trackSelection.style.height=Math.abs(a[0]-a[1])+"%",this.trackHigh.style.bottom="0",this.trackHigh.style.height=100-Math.min(a[0],a[1])-Math.abs(a[0]-a[1])+"%";else{this.trackLow.style.left="0",this.trackLow.style.width=Math.min(a[0],a[1])+"%",this.trackSelection.style.left=Math.min(a[0],a[1])+"%",this.trackSelection.style.width=Math.abs(a[0]-a[1])+"%",this.trackHigh.style.right="0",this.trackHigh.style.width=100-Math.min(a[0],a[1])-Math.abs(a[0]-a[1])+"%";var m=this.tooltip_min.getBoundingClientRect(),n=this.tooltip_max.getBoundingClientRect();m.right>n.left?(this._removeClass(this.tooltip_max,"top"),this._addClass(this.tooltip_max,"bottom"),this.tooltip_max.style.top="18px"):(this._removeClass(this.tooltip_max,"bottom"),this._addClass(this.tooltip_max,"top"),this.tooltip_max.style.top=this.tooltip_min.style.top)}},_removeProperty:function(a,b){a.style.removeProperty?a.style.removeProperty(b):a.style.removeAttribute(b)},_mousedown:function(a){if(!this._state.enabled)return!1;this._state.offset=this._offset(this.sliderElem),this._state.size=this.sliderElem[this.sizePos];var b=this._getPercentage(a);if(this.options.range){var c=Math.abs(this._state.percentage[0]-b),d=Math.abs(this._state.percentage[1]-b);this._state.dragged=d>c?0:1}else this._state.dragged=0;this._state.percentage[this._state.dragged]=b,this._layout(),this.touchCapable&&(document.removeEventListener("touchmove",this.mousemove,!1),document.removeEventListener("touchend",this.mouseup,!1)),this.mousemove&&document.removeEventListener("mousemove",this.mousemove,!1),this.mouseup&&document.removeEventListener("mouseup",this.mouseup,!1),this.mousemove=this._mousemove.bind(this),this.mouseup=this._mouseup.bind(this),this.touchCapable&&(document.addEventListener("touchmove",this.mousemove,!1),document.addEventListener("touchend",this.mouseup,!1)),document.addEventListener("mousemove",this.mousemove,!1),document.addEventListener("mouseup",this.mouseup,!1),this._state.inDrag=!0;var e=this._calculateValue();return this._trigger("slideStart",e),this._setDataVal(e),this.setValue(e,!1,!0),this._pauseEvent(a),this.options.focus&&this._triggerFocusOnHandle(this._state.dragged),!0},_triggerFocusOnHandle:function(a){0===a&&this.handle1.focus(),1===a&&this.handle2.focus()},_keydown:function(a,b){if(!this._state.enabled)return!1;var c;switch(b.keyCode){case 37:case 40:c=-1;break;case 39:case 38:c=1}if(c){if(this.options.natural_arrow_keys){var d="vertical"===this.options.orientation&&!this.options.reversed,e="horizontal"===this.options.orientation&&this.options.reversed;(d||e)&&(c=-c)}var f=this._state.value[a]+c*this.options.step;return this.options.range&&(f=[a?this._state.value[0]:f,a?f:this._state.value[1]]),this._trigger("slideStart",f),this._setDataVal(f),this.setValue(f,!0,!0),this._setDataVal(f),this._trigger("slideStop",f),this._layout(),this._pauseEvent(b),!1}},_pauseEvent:function(a){a.stopPropagation&&a.stopPropagation(),a.preventDefault&&a.preventDefault(),a.cancelBubble=!0,a.returnValue=!1},_mousemove:function(a){if(!this._state.enabled)return!1;var b=this._getPercentage(a);this._adjustPercentageForRangeSliders(b),this._state.percentage[this._state.dragged]=b,this._layout();var c=this._calculateValue(!0);return this.setValue(c,!0,!0),!1},_adjustPercentageForRangeSliders:function(a){if(this.options.range){var b=this._getNumDigitsAfterDecimalPlace(a);b=b?b-1:0;var c=this._applyToFixedAndParseFloat(a,b);0===this._state.dragged&&this._applyToFixedAndParseFloat(this._state.percentage[1],b)<c?(this._state.percentage[0]=this._state.percentage[1],this._state.dragged=1):1===this._state.dragged&&this._applyToFixedAndParseFloat(this._state.percentage[0],b)>c&&(this._state.percentage[1]=this._state.percentage[0],this._state.dragged=0)}},_mouseup:function(){if(!this._state.enabled)return!1;this.touchCapable&&(document.removeEventListener("touchmove",this.mousemove,!1),document.removeEventListener("touchend",this.mouseup,!1)),document.removeEventListener("mousemove",this.mousemove,!1),document.removeEventListener("mouseup",this.mouseup,!1),this._state.inDrag=!1,this._state.over===!1&&this._hideTooltip();var a=this._calculateValue(!0);return this._layout(),this._setDataVal(a),this._trigger("slideStop",a),!1},_calculateValue:function(a){var b;if(this.options.range?(b=[this.options.min,this.options.max],0!==this._state.percentage[0]&&(b[0]=this._toValue(this._state.percentage[0]),b[0]=this._applyPrecision(b[0])),100!==this._state.percentage[1]&&(b[1]=this._toValue(this._state.percentage[1]),b[1]=this._applyPrecision(b[1]))):(b=this._toValue(this._state.percentage[0]),b=parseFloat(b),b=this._applyPrecision(b)),a){for(var c=[b,1/0],d=0;d<this.options.ticks.length;d++){var e=Math.abs(this.options.ticks[d]-b);e<=c[1]&&(c=[this.options.ticks[d],e])}if(c[1]<=this.options.ticks_snap_bounds)return c[0]}return b},_applyPrecision:function(a){var b=this.options.precision||this._getNumDigitsAfterDecimalPlace(this.options.step);return this._applyToFixedAndParseFloat(a,b)},_getNumDigitsAfterDecimalPlace:function(a){var b=(""+a).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return b?Math.max(0,(b[1]?b[1].length:0)-(b[2]?+b[2]:0)):0},_applyToFixedAndParseFloat:function(a,b){var c=a.toFixed(b);return parseFloat(c)},_getPercentage:function(a){!this.touchCapable||"touchstart"!==a.type&&"touchmove"!==a.type||(a=a.touches[0]);var b=a[this.mousePos],c=this._state.offset[this.stylePos],d=b-c,e=d/this._state.size*100;return e=Math.round(e/this._state.percentage[2])*this._state.percentage[2],this.options.reversed&&(e=100-e),Math.max(0,Math.min(100,e))},_validateInputValue:function(a){if("number"==typeof a)return a;if(Array.isArray(a))return this._validateArray(a),a;throw new Error(d.formatInvalidInputErrorMsg(a))},_validateArray:function(a){for(var b=0;b<a.length;b++){var c=a[b];if("number"!=typeof c)throw new Error(d.formatInvalidInputErrorMsg(c))}},_setDataVal:function(a){this.element.setAttribute("data-value",a),this.element.setAttribute("value",a),this.element.value=a},_trigger:function(b,c){c=c||0===c?c:void 0;var d=this.eventToCallbackMap[b];if(d&&d.length)for(var e=0;e<d.length;e++){var f=d[e];f(c)}a&&this._triggerJQueryEvent(b,c)},_triggerJQueryEvent:function(a,b){var c={type:a,value:b};this.$element.trigger(c),this.$sliderElem.trigger(c)},_unbindJQueryEventHandlers:function(){this.$element.off(),this.$sliderElem.off()},_setText:function(a,b){"undefined"!=typeof a.innerText?a.innerText=b:"undefined"!=typeof a.textContent&&(a.textContent=b)},_removeClass:function(a,b){for(var c=b.split(" "),d=a.className,e=0;e<c.length;e++){var f=c[e],g=new RegExp("(?:\\s|^)"+f+"(?:\\s|$)");d=d.replace(g," ")}a.className=d.trim()},_addClass:function(a,b){for(var c=b.split(" "),d=a.className,e=0;e<c.length;e++){var f=c[e],g=new RegExp("(?:\\s|^)"+f+"(?:\\s|$)"),h=g.test(d);h||(d+=" "+f)}a.className=d.trim()},_offsetLeft:function(a){return a.getBoundingClientRect().left},_offsetTop:function(a){for(var b=a.offsetTop;(a=a.offsetParent)&&!isNaN(a.offsetTop);)b+=a.offsetTop;return b},_offset:function(a){return{left:this._offsetLeft(a),top:this._offsetTop(a)}},_css:function(b,c,d){if(a)a.style(b,c,d);else{var e=c.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,function(a,b){return b.toUpperCase()});b.style[e]=d}},_toValue:function(a){return this.options.scale.toValue.apply(this,[a])},_toPercentage:function(a){return this.options.scale.toPercentage.apply(this,[a])},_setTooltipPosition:function(){var a=[this.tooltip,this.tooltip_min,this.tooltip_max];if("vertical"===this.options.orientation){var b=this.options.tooltip_position||"right",c="left"===b?"right":"left";a.forEach(function(a){this._addClass(a,b),a.style[c]="100%"}.bind(this))}else a.forEach("bottom"===this.options.tooltip_position?function(a){this._addClass(a,"bottom"),a.style.top="22px"}.bind(this):function(a){this._addClass(a,"top"),a.style.top=-this.tooltip.outerHeight-14+"px"}.bind(this))}},a){var f=a.fn.slider?"bootstrapSlider":"slider";a.bridget(f,b)}}(a),b});

/***/ },
/* 13 */
/***/ function(module, exports) {

	(function() { module.exports = this["$"]; }());

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return (root['SignaturePad'] = factory());
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    root['SignaturePad'] = factory();
	  }
	}(this, function () {
	
	/*!
	 * Signature Pad v1.4.0
	 * https://github.com/szimek/signature_pad
	 *
	 * Copyright 2015 Szymon Nowak
	 * Released under the MIT license
	 *
	 * The main idea and some parts of the code (e.g. drawing variable width Bzier curve) are taken from:
	 * http://corner.squareup.com/2012/07/smoother-signatures.html
	 *
	 * Implementation of interpolation using cubic Bzier curves is taken from:
	 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
	 *
	 * Algorithm for approximated length of a Bzier curve is taken from:
	 * http://www.lemoda.net/maths/bezier-length/index.html
	 *
	 */
	var SignaturePad = (function (document) {
	    "use strict";
	
	    var SignaturePad = function (canvas, options) {
	        var self = this,
	            opts = options || {};
	
	        this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
	        this.minWidth = opts.minWidth || 0.5;
	        this.maxWidth = opts.maxWidth || 2.5;
	        this.dotSize = opts.dotSize || function () {
	            return (this.minWidth + this.maxWidth) / 2;
	        };
	        this.penColor = opts.penColor || "black";
	        this.backgroundColor = opts.backgroundColor || "rgba(0,0,0,0)";
	        this.onEnd = opts.onEnd;
	        this.onBegin = opts.onBegin;
	
	        this._canvas = canvas;
	        this._ctx = canvas.getContext("2d");
	        this.clear();
	
	        // we need add these inline so they are available to unbind while still having
	        //  access to 'self' we could use _.bind but it's not worth adding a dependency
	        this._handleMouseDown = function (event) {
	            if (event.which === 1) {
	                self._mouseButtonDown = true;
	                self._strokeBegin(event);
	            }
	        };
	
	        this._handleMouseMove = function (event) {
	            if (self._mouseButtonDown) {
	                self._strokeUpdate(event);
	            }
	        };
	
	        this._handleMouseUp = function (event) {
	            if (event.which === 1 && self._mouseButtonDown) {
	                self._mouseButtonDown = false;
	                self._strokeEnd(event);
	            }
	        };
	
	        this._handleTouchStart = function (event) {
	            var touch = event.changedTouches[0];
	            self._strokeBegin(touch);
	        };
	
	        this._handleTouchMove = function (event) {
	            // Prevent scrolling.
	            event.preventDefault();
	
	            var touch = event.changedTouches[0];
	            self._strokeUpdate(touch);
	        };
	
	        this._handleTouchEnd = function (event) {
	            var wasCanvasTouched = event.target === self._canvas;
	            if (wasCanvasTouched) {
	                self._strokeEnd(event);
	            }
	        };
	
	        this._handleMouseEvents();
	        this._handleTouchEvents();
	    };
	
	    SignaturePad.prototype.clear = function () {
	        var ctx = this._ctx,
	            canvas = this._canvas;
	
	        ctx.fillStyle = this.backgroundColor;
	        ctx.clearRect(0, 0, canvas.width, canvas.height);
	        ctx.fillRect(0, 0, canvas.width, canvas.height);
	        this._reset();
	    };
	
	    SignaturePad.prototype.toDataURL = function (imageType, quality) {
	        var canvas = this._canvas;
	        return canvas.toDataURL.apply(canvas, arguments);
	    };
	
	    SignaturePad.prototype.fromDataURL = function (dataUrl) {
	        var self = this,
	            image = new Image(),
	            ratio = window.devicePixelRatio || 1,
	            width = this._canvas.width / ratio,
	            height = this._canvas.height / ratio;
	
	        this._reset();
	        image.src = dataUrl;
	        image.onload = function () {
	            self._ctx.drawImage(image, 0, 0, width, height);
	        };
	        this._isEmpty = false;
	    };
	
	    SignaturePad.prototype._strokeUpdate = function (event) {
	        var point = this._createPoint(event);
	        this._addPoint(point);
	    };
	
	    SignaturePad.prototype._strokeBegin = function (event) {
	        this._reset();
	        this._strokeUpdate(event);
	        if (typeof this.onBegin === 'function') {
	            this.onBegin(event);
	        }
	    };
	
	    SignaturePad.prototype._strokeDraw = function (point) {
	        var ctx = this._ctx,
	            dotSize = typeof(this.dotSize) === 'function' ? this.dotSize() : this.dotSize;
	
	        ctx.beginPath();
	        this._drawPoint(point.x, point.y, dotSize);
	        ctx.closePath();
	        ctx.fill();
	    };
	
	    SignaturePad.prototype._strokeEnd = function (event) {
	        var canDrawCurve = this.points.length > 2,
	            point = this.points[0];
	
	        if (!canDrawCurve && point) {
	            this._strokeDraw(point);
	        }
	        if (typeof this.onEnd === 'function') {
	            this.onEnd(event);
	        }
	    };
	
	    SignaturePad.prototype._handleMouseEvents = function () {
	        var self = this;
	        this._mouseButtonDown = false;
	
	        this._canvas.addEventListener("mousedown", this._handleMouseDown);
	        this._canvas.addEventListener("mousemove", this._handleMouseMove);
	        document.addEventListener("mouseup", this._handleMouseUp);
	    };
	
	    SignaturePad.prototype._handleTouchEvents = function () {
	        var self = this;
	
	        // Pass touch events to canvas element on mobile IE.
	        this._canvas.style.msTouchAction = 'none';
	
	        this._canvas.addEventListener("touchstart", this._handleTouchStart);
	        this._canvas.addEventListener("touchmove", this._handleTouchMove);
	        document.addEventListener("touchend", this._handleTouchEnd);
	    };
	
	    SignaturePad.prototype.off = function () {
	        this._canvas.removeEventListener("mousedown", this._handleMouseDown);
	        this._canvas.removeEventListener("mousemove", this._handleMouseMove);
	        document.removeEventListener("mouseup", this._handleMouseUp);
	
	        this._canvas.removeEventListener("touchstart", this._handleTouchStart);
	        this._canvas.removeEventListener("touchmove", this._handleTouchMove);
	        document.removeEventListener("touchend", this._handleTouchEnd);
	    };
	
	    SignaturePad.prototype.isEmpty = function () {
	        return this._isEmpty;
	    };
	
	    SignaturePad.prototype._reset = function () {
	        this.points = [];
	        this._lastVelocity = 0;
	        this._lastWidth = (this.minWidth + this.maxWidth) / 2;
	        this._isEmpty = true;
	        this._ctx.fillStyle = this.penColor;
	    };
	
	    SignaturePad.prototype._createPoint = function (event) {
	        var rect = this._canvas.getBoundingClientRect();
	        return new Point(
	            event.clientX - rect.left,
	            event.clientY - rect.top
	        );
	    };
	
	    SignaturePad.prototype._addPoint = function (point) {
	        var points = this.points,
	            c2, c3,
	            curve, tmp;
	
	        points.push(point);
	
	        if (points.length > 2) {
	            // To reduce the initial lag make it work with 3 points
	            // by copying the first point to the beginning.
	            if (points.length === 3) points.unshift(points[0]);
	
	            tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
	            c2 = tmp.c2;
	            tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
	            c3 = tmp.c1;
	            curve = new Bezier(points[1], c2, c3, points[2]);
	            this._addCurve(curve);
	
	            // Remove the first element from the list,
	            // so that we always have no more than 4 points in points array.
	            points.shift();
	        }
	    };
	
	    SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
	        var dx1 = s1.x - s2.x, dy1 = s1.y - s2.y,
	            dx2 = s2.x - s3.x, dy2 = s2.y - s3.y,
	
	            m1 = {x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0},
	            m2 = {x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0},
	
	            l1 = Math.sqrt(dx1*dx1 + dy1*dy1),
	            l2 = Math.sqrt(dx2*dx2 + dy2*dy2),
	
	            dxm = (m1.x - m2.x),
	            dym = (m1.y - m2.y),
	
	            k = l2 / (l1 + l2),
	            cm = {x: m2.x + dxm*k, y: m2.y + dym*k},
	
	            tx = s2.x - cm.x,
	            ty = s2.y - cm.y;
	
	        return {
	            c1: new Point(m1.x + tx, m1.y + ty),
	            c2: new Point(m2.x + tx, m2.y + ty)
	        };
	    };
	
	    SignaturePad.prototype._addCurve = function (curve) {
	        var startPoint = curve.startPoint,
	            endPoint = curve.endPoint,
	            velocity, newWidth;
	
	        velocity = endPoint.velocityFrom(startPoint);
	        velocity = this.velocityFilterWeight * velocity
	            + (1 - this.velocityFilterWeight) * this._lastVelocity;
	
	        newWidth = this._strokeWidth(velocity);
	        this._drawCurve(curve, this._lastWidth, newWidth);
	
	        this._lastVelocity = velocity;
	        this._lastWidth = newWidth;
	    };
	
	    SignaturePad.prototype._drawPoint = function (x, y, size) {
	        var ctx = this._ctx;
	
	        ctx.moveTo(x, y);
	        ctx.arc(x, y, size, 0, 2 * Math.PI, false);
	        this._isEmpty = false;
	    };
	
	    SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
	        var ctx = this._ctx,
	            widthDelta = endWidth - startWidth,
	            drawSteps, width, i, t, tt, ttt, u, uu, uuu, x, y;
	
	        drawSteps = Math.floor(curve.length());
	        ctx.beginPath();
	        for (i = 0; i < drawSteps; i++) {
	            // Calculate the Bezier (x, y) coordinate for this step.
	            t = i / drawSteps;
	            tt = t * t;
	            ttt = tt * t;
	            u = 1 - t;
	            uu = u * u;
	            uuu = uu * u;
	
	            x = uuu * curve.startPoint.x;
	            x += 3 * uu * t * curve.control1.x;
	            x += 3 * u * tt * curve.control2.x;
	            x += ttt * curve.endPoint.x;
	
	            y = uuu * curve.startPoint.y;
	            y += 3 * uu * t * curve.control1.y;
	            y += 3 * u * tt * curve.control2.y;
	            y += ttt * curve.endPoint.y;
	
	            width = startWidth + ttt * widthDelta;
	            this._drawPoint(x, y, width);
	        }
	        ctx.closePath();
	        ctx.fill();
	    };
	
	    SignaturePad.prototype._strokeWidth = function (velocity) {
	        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
	    };
	
	
	    var Point = function (x, y, time) {
	        this.x = x;
	        this.y = y;
	        this.time = time || new Date().getTime();
	    };
	
	    Point.prototype.velocityFrom = function (start) {
	        return (this.time !== start.time) ? this.distanceTo(start) / (this.time - start.time) : 1;
	    };
	
	    Point.prototype.distanceTo = function (start) {
	        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
	    };
	
	    var Bezier = function (startPoint, control1, control2, endPoint) {
	        this.startPoint = startPoint;
	        this.control1 = control1;
	        this.control2 = control2;
	        this.endPoint = endPoint;
	    };
	
	    // Returns approximated length.
	    Bezier.prototype.length = function () {
	        var steps = 10,
	            length = 0,
	            i, t, cx, cy, px, py, xdiff, ydiff;
	
	        for (i = 0; i <= steps; i++) {
	            t = i / steps;
	            cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
	            cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
	            if (i > 0) {
	                xdiff = cx - px;
	                ydiff = cy - py;
	                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	            }
	            px = cx;
	            py = cy;
	        }
	        return length;
	    };
	
	    Bezier.prototype._point = function (t, start, c1, c2, end) {
	        return          start * (1.0 - t) * (1.0 - t)  * (1.0 - t)
	               + 3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t
	               + 3.0 *  c2    * (1.0 - t) * t          * t
	               +        end   * t         * t          * t;
	    };
	
	    return SignaturePad;
	})(document);
	
	return SignaturePad;
	
	}));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var angular = __webpack_require__(1);
	var alias = __webpack_require__(16);
	exports.alias = alias;
	var autosave = __webpack_require__(17);
	exports.autosave = autosave;
	exports.moduleName = 'rl.ui.behaviors';
	angular.module(exports.moduleName, [
	    alias.moduleName,
	    autosave.moduleName,
	]);
	//# sourceMappingURL=behaviors.module.js.map

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.behaviors.alias';
	exports.directiveName = 'rlAlias';
	exports.controllerName = 'AliasController';
	var AliasController = (function () {
	    function AliasController($scope, $attrs, $parse, $interpolate) {
	        var expression;
	        $scope.$watch(function () {
	            expression = $attrs.rlAlias.split(' as ');
	            return $parse(expression[0])($scope);
	        }, function (item) {
	            var alias = $interpolate(expression[1])($scope);
	            if (alias != null) {
	                $scope[alias] = item;
	            }
	        });
	    }
	    AliasController.$inject = ['$scope', '$attrs', '$parse', '$interpolate'];
	    return AliasController;
	})();
	exports.AliasController = AliasController;
	function alias() {
	    return {
	        restrict: 'A',
	        controller: exports.controllerName,
	    };
	}
	exports.alias = alias;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, alias)
	    .controller(exports.controllerName, AliasController);
	//# sourceMappingURL=alias.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __objectUtility = typescript_angular_utilities_1.services.object;
	var autosave_service_1 = __webpack_require__(18);
	exports.moduleName = 'rl.ui.behaviors.autosave';
	exports.directiveName = 'rlAutosave';
	exports.controllerName = 'AutosaveController';
	var AutosaveController = (function () {
	    function AutosaveController($scope, $attrs, $parse, $element, $timeout, autosaveFactory, parentChildBehavior, objectUtility) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$timeout = $timeout;
	        var contentForm = $element.controller('form');
	        var hasValidator = objectUtility.isNullOrWhitespace($attrs.validate) === false;
	        var validateExpression = $parse($attrs.validate);
	        var validate;
	        if (hasValidator) {
	            validate = function () {
	                return validateExpression($scope);
	            };
	        }
	        var saveExpression = $parse($attrs.save);
	        var save = function () {
	            return saveExpression($scope);
	        };
	        var debounce = $parse($attrs.debounceDuration)($scope);
	        var unbind = $scope.$watch(function () { return _this.keyupListener; }, function (keyupListener) {
	            if (keyupListener) {
	                _this.autosave = autosaveFactory.getInstance({
	                    save: save,
	                    validate: validate,
	                    contentForm: contentForm,
	                    debounceDuration: debounce,
	                    triggers: $attrs.triggers,
	                    setChangeListener: keyupListener,
	                });
	                var behavior = {
	                    autosave: _this.autosave.autosave,
	                };
	                // register autosave behavior and assign the value back to the parent
	                var childLink = $parse($attrs.rlAutosave)($scope);
	                parentChildBehavior.registerChildBehavior(childLink, behavior);
	                unbind();
	            }
	        });
	    }
	    AutosaveController.$inject = ['$scope',
	        '$attrs',
	        '$parse',
	        '$element',
	        '$timeout',
	        autosave_service_1.factoryName,
	        __parentChild.serviceName,
	        __objectUtility.serviceName];
	    return AutosaveController;
	})();
	exports.AutosaveController = AutosaveController;
	function autosave() {
	    'use strict';
	    return {
	        restrict: 'A',
	        require: ['rlAutosave', '?ngForm'],
	        controller: exports.controllerName,
	        link: function (scope, element, attrs, controllers) {
	            var autosaveController = controllers[0];
	            autosaveController.keyupListener = function (callback) {
	                element.on('keyup', function () { scope.$apply(callback); });
	                return function () {
	                    element.off('keyup');
	                };
	            };
	        },
	    };
	}
	exports.autosave = autosave;
	angular.module(exports.moduleName, [
	    autosave_service_1.moduleName,
	    __objectUtility.moduleName,
	    __parentChild.moduleName,
	])
	    .directive(exports.directiveName, autosave)
	    .controller(exports.controllerName, AutosaveController);
	//# sourceMappingURL=autosave.js.map

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var autosaveAction_service_1 = __webpack_require__(20);
	var triggers = __webpack_require__(21);
	exports.triggers = triggers;
	exports.moduleName = 'rl.utilities.services.autosave';
	exports.factoryName = 'autosaveFactory';
	var AutosaveService = (function () {
	    function AutosaveService(autosaveService, options, triggerServiceFactory) {
	        var _this = this;
	        this.autosaveService = autosaveService;
	        this.autosave = function () {
	            var data = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                data[_i - 0] = arguments[_i];
	            }
	            if (_this.contentForm.$pristine) {
	                return true;
	            }
	            var valid = true;
	            if (_this.hasValidator) {
	                valid = _this.validate();
	                if (valid === undefined) {
	                    valid = true;
	                }
	            }
	            if (valid) {
	                var promise = _this.save.apply(_this, data);
	                if (!_.isUndefined(promise)) {
	                    _this.autosaveService.trigger(promise.then(function () {
	                        if (_this.contentForm != null) {
	                            _this.contentForm.$setPristine();
	                        }
	                    }));
	                }
	                return true;
	            }
	            else {
	                return false;
	            }
	        };
	        this.hasValidator = options.validate != null;
	        this.contentForm = options.contentForm || this.nullForm();
	        this.save = options.save;
	        this.validate = options.validate;
	        this.triggerService = triggerServiceFactory.getInstance();
	        this.configureTriggers(options);
	        this.triggerService.setTriggers(options.triggers, this.autosave);
	    }
	    AutosaveService.prototype.configureTriggers = function (options) {
	        this.triggerService.triggers.onChange.configure({
	            form: options.contentForm,
	            setChangeListener: options.setChangeListener,
	            debounceDuration: options.debounceDuration,
	        });
	    };
	    AutosaveService.prototype.nullForm = function () {
	        return {
	            $pristine: false,
	            $dirty: true,
	            $setPristine: function () {
	                return;
	            },
	        };
	    };
	    return AutosaveService;
	})();
	autosaveServiceFactory.$inject = [autosaveAction_service_1.serviceName, triggers.factoryName];
	function autosaveServiceFactory(autosaveService, triggerServiceFactory) {
	    'use strict';
	    return {
	        getInstance: function (options) {
	            return new AutosaveService(autosaveService, options, triggerServiceFactory);
	        }
	    };
	}
	angular.module(exports.moduleName, [autosaveAction_service_1.moduleName, triggers.moduleName])
	    .factory(exports.factoryName, autosaveServiceFactory);
	//# sourceMappingURL=autosave.service.js.map

/***/ },
/* 19 */
/***/ function(module, exports) {

	(function() { module.exports = this["_"]; }());

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ng = __webpack_require__(1);
	exports.moduleName = 'rl.utilities.services.autosaveAction';
	exports.serviceName = 'autosaveAction';
	var AutosaveActionService = (function () {
	    function AutosaveActionService($timeout) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.completeMessageDuration = 1000;
	        this.autosaveSuccessful = function (data) {
	            return _this.resolveAutosave(data, true);
	        };
	        this.autosaveFailed = function (data) {
	            return _this.resolveAutosave(data, false);
	        };
	        this.resolveAutosave = function (data, success) {
	            _this._saving = false;
	            _this._complete = true;
	            _this._successful = success;
	            _this.$timeout(function () {
	                _this._complete = false;
	            }, _this.completeMessageDuration);
	            return data;
	        };
	    }
	    Object.defineProperty(AutosaveActionService.prototype, "saving", {
	        get: function () {
	            return this._saving;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AutosaveActionService.prototype, "complete", {
	        get: function () {
	            return this._complete;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AutosaveActionService.prototype, "successful", {
	        get: function () {
	            return this._successful;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AutosaveActionService.prototype.trigger = function (promise) {
	        this._saving = true;
	        return promise.then(this.autosaveSuccessful)
	            .catch(this.autosaveFailed);
	    };
	    AutosaveActionService.$inject = ['$timeout'];
	    return AutosaveActionService;
	})();
	ng.module(exports.moduleName, [])
	    .service(exports.serviceName, AutosaveActionService);
	//# sourceMappingURL=autosaveAction.service.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var onChangeTrigger_1 = __webpack_require__(22);
	var trigger_1 = __webpack_require__(23);
	__export(__webpack_require__(22));
	__export(__webpack_require__(23));
	exports.defaultTriggers = 'onChange';
	exports.moduleName = 'rl.ui.services.autosave.triggers';
	exports.factoryName = 'autosaveTriggers';
	var TriggerService = (function () {
	    function TriggerService($rootScope, $timeout) {
	        this.triggers = {
	            onChange: new onChangeTrigger_1.OnChangeTrigger($rootScope, $timeout),
	            none: new trigger_1.Trigger('none'),
	        };
	    }
	    TriggerService.prototype.setTriggers = function (triggerString, autosave) {
	        if (triggerString == null) {
	            triggerString = exports.defaultTriggers;
	        }
	        _.each(this.triggers, function (trigger) {
	            if (trigger.hasMatch(triggerString)) {
	                trigger.setTrigger(autosave);
	            }
	        });
	    };
	    return TriggerService;
	})();
	triggerServiceFactory.$inject = ['$rootScope', '$timeout'];
	function triggerServiceFactory($rootScope, $timeout) {
	    return {
	        getInstance: function () {
	            return new TriggerService($rootScope, $timeout);
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .factory(exports.factoryName, triggerServiceFactory);
	//# sourceMappingURL=triggers.service.js.map

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(19);
	var trigger_1 = __webpack_require__(23);
	var OnChangeTrigger = (function (_super) {
	    __extends(OnChangeTrigger, _super);
	    function OnChangeTrigger($rootScope, $timeout) {
	        _super.call(this, 'onChange');
	        this.$rootScope = $rootScope;
	        this.$timeout = $timeout;
	        this.debounceDuration = 1000;
	    }
	    OnChangeTrigger.prototype.setTrigger = function (autosave) {
	        var _this = this;
	        if (_.isUndefined(this.settings)) {
	            return;
	        }
	        this.initChangeListeners();
	        this.$rootScope.$watch(function () {
	            return _this.settings.form != null
	                ? _this.settings.form.$dirty
	                : false;
	        }, function (value) {
	            if (value) {
	                _this.setTimer(autosave);
	                _this.clearChangeListener = _this.setChangeListener(function () {
	                    _this.$timeout.cancel(_this.timer);
	                    _this.setTimer(autosave);
	                });
	            }
	        });
	    };
	    OnChangeTrigger.prototype.setTimer = function (autosave) {
	        var _this = this;
	        this.timer = this.$timeout(function () {
	            _this.clearChangeListener();
	            autosave();
	        }, this.debounceDuration);
	    };
	    OnChangeTrigger.prototype.initChangeListeners = function () {
	        this.setChangeListener = this.settings.setChangeListener || this.nullSetListener;
	        this.clearChangeListener = this.nullClearListener;
	    };
	    OnChangeTrigger.prototype.nullSetListener = function () {
	        console.log('No change listener available');
	        return this.nullClearListener;
	    };
	    OnChangeTrigger.prototype.nullClearListener = function () {
	        console.log('No change listener register');
	    };
	    return OnChangeTrigger;
	})(trigger_1.Trigger);
	exports.OnChangeTrigger = OnChangeTrigger;
	//# sourceMappingURL=onChangeTrigger.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var Trigger = (function () {
	    function Trigger(aliases, triggerAction) {
	        this.triggerAction = triggerAction;
	        this.aliases = aliases.split(' ');
	    }
	    Trigger.prototype.setTrigger = function (autosave) {
	        if (_.isFunction(this.triggerAction)) {
	            this.triggerAction(this.settings);
	        }
	    };
	    Trigger.prototype.hasMatch = function (triggers) {
	        var _this = this;
	        var triggerList = triggers.split(' ');
	        return _.any(triggerList, function (trigger) {
	            return _.any(_this.aliases, function (alias) {
	                return trigger === alias;
	            });
	        });
	    };
	    Trigger.prototype.configure = function (settings) {
	        this.settings = settings;
	    };
	    return Trigger;
	})();
	exports.Trigger = Trigger;
	//# sourceMappingURL=trigger.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var autosaveDialogFooter = __webpack_require__(25);
	exports.autosaveDialogFooter = autosaveDialogFooter;
	var busy = __webpack_require__(27);
	exports.busy = busy;
	var button = __webpack_require__(30);
	exports.button = button;
	var buttonAsync = __webpack_require__(32);
	exports.buttonAsync = buttonAsync;
	var buttonLink = __webpack_require__(34);
	exports.buttonLink = buttonLink;
	var buttonToggle = __webpack_require__(36);
	exports.buttonToggle = buttonToggle;
	var cardContainer = __webpack_require__(38);
	exports.cardContainer = cardContainer;
	var checkbox = __webpack_require__(90);
	exports.checkbox = checkbox;
	var commaList = __webpack_require__(92);
	exports.commaList = commaList;
	var dateTime = __webpack_require__(93);
	exports.dateTime = dateTime;
	var genericContainer = __webpack_require__(101);
	exports.genericContainer = genericContainer;
	var lazyLoad = __webpack_require__(104);
	exports.lazyLoad = lazyLoad;
	var longClickButton = __webpack_require__(105);
	exports.longClickButton = longClickButton;
	var messageLog = __webpack_require__(107);
	exports.messageLog = messageLog;
	var multiStepIndicator = __webpack_require__(112);
	exports.multiStepIndicator = multiStepIndicator;
	var radio = __webpack_require__(114);
	exports.radio = radio;
	var ratingBar = __webpack_require__(117);
	exports.ratingBar = ratingBar;
	var richTextEditor = __webpack_require__(120);
	exports.richTextEditor = richTextEditor;
	var select = __webpack_require__(128);
	exports.select = select;
	var signaturePad = __webpack_require__(133);
	exports.signaturePad = signaturePad;
	var simpleCardList = __webpack_require__(134);
	exports.simpleCardList = simpleCardList;
	var spinner = __webpack_require__(138);
	exports.spinner = spinner;
	var stringWithWatermark = __webpack_require__(144);
	exports.stringWithWatermark = stringWithWatermark;
	var tabs = __webpack_require__(145);
	exports.tabs = tabs;
	var textarea = __webpack_require__(150);
	exports.textarea = textarea;
	var textbox = __webpack_require__(152);
	exports.textbox = textbox;
	var typeahead = __webpack_require__(154);
	exports.typeahead = typeahead;
	var userRating = __webpack_require__(156);
	exports.userRating = userRating;
	var validationGroup = __webpack_require__(157);
	exports.validationGroup = validationGroup;
	exports.moduleName = 'rl.ui.components';
	angular.module(exports.moduleName, [
	    autosaveDialogFooter.moduleName,
	    busy.moduleName,
	    button.moduleName,
	    buttonAsync.moduleName,
	    buttonLink.moduleName,
	    buttonToggle.moduleName,
	    cardContainer.moduleName,
	    checkbox.moduleName,
	    commaList.moduleName,
	    dateTime.moduleName,
	    genericContainer.moduleName,
	    lazyLoad.moduleName,
	    longClickButton.moduleName,
	    messageLog.moduleName,
	    multiStepIndicator.moduleName,
	    radio.moduleName,
	    ratingBar.moduleName,
	    richTextEditor.moduleName,
	    select.moduleName,
	    signaturePad.moduleName,
	    simpleCardList.moduleName,
	    spinner.moduleName,
	    stringWithWatermark.moduleName,
	    tabs.moduleName,
	    textarea.moduleName,
	    textbox.moduleName,
	    typeahead.moduleName,
	    userRating.moduleName,
	    validationGroup.moduleName,
	]);
	//# sourceMappingURL=components.module.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.autosaveDialogFooter';
	exports.directiveName = 'rlAutosaveDialogFooter';
	function autosaveDialogFooter() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(26),
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, autosaveDialogFooter);
	//# sourceMappingURL=autosaveDialogFooter.js.map

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = "<div class=\"modal-footer\">\r\n\t<button class=\"btn btn-default\" type=\"button\" ng-click=\"$close()\">Cancel</button>\r\n\t<button class=\"btn btn-primary\" type=\"button\" ng-click=\"$dismiss()\">Save</button>\r\n</div>"

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(28);
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.busy';
	exports.directiveName = 'rlBusy';
	function busy() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: '<i class="busy rl-{{size}}" ng-show="loading"></i>',
	        scope: {
	            loading: '=',
	            // Valid values are:
	            // `lg`, `2x`, `3x`, `4x`, and `5x`
	            size: '@',
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, busy);
	//# sourceMappingURL=busy.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(29);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(11)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./busy.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./busy.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(10)();
	// imports
	
	
	// module
	exports.push([module.id, ".busy {\r\n\t-webkit-animation: fa-spin 2s infinite linear;\r\n\tanimation: fa-spin 2s infinite linear;\r\n\tdisplay: inline-block;\r\n\tfont-size: inherit;\r\n\tfont-style: normal;\r\n\tfont-family: FontAwesome;\r\n}\r\n\r\n.busy:before {\r\n\tcontent: \"\\F110\"; /* fa-spinner */\r\n}", ""]);
	
	// exports


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.button';
	exports.directiveName = 'rlButton';
	exports.controllerName = 'ButtonController';
	var ButtonController = (function () {
	    function ButtonController() {
	        this.type = this.type != null ? this.type : 'default';
	        this.configuredSize = this.size != null ? 'btn-' + this.size : null;
	    }
	    return ButtonController;
	})();
	exports.ButtonController = ButtonController;
	function button() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(31),
	        scope: {},
	        bindToController: {
	            action: '&',
	            type: '@',
	            ngDisabled: '=',
	            size: '@',
	        },
	        controller: exports.controllerName,
	        controllerAs: 'button',
	    };
	}
	exports.button = button;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, button)
	    .controller(exports.controllerName, ButtonController);
	//# sourceMappingURL=button.js.map

/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{button.type}} {{button.configuredSize}}\" ng-click=\"button.action()\" ng-disabled=\"button.ngDisabled\">\r\n\t<span ng-transclude></span>\r\n</button>"

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __promiseUtility = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.buttonAsync';
	exports.directiveName = 'rlButtonAsync';
	exports.controllerName = 'ButtonAsyncController';
	var ButtonAsyncController = (function () {
	    function ButtonAsyncController(promiseUtility) {
	        this.promiseUtility = promiseUtility;
	        this.type = this.type != null ? this.type : 'default';
	        this.sizeClass = this.size != null ? 'btn-' + this.size : null;
	    }
	    ButtonAsyncController.prototype.trigger = function () {
	        var _this = this;
	        if (!this.busy) {
	            this.busy = true;
	            var result = this.action();
	            if (this.promiseUtility.isPromise(result) && _.isFunction(result.finally)) {
	                result.finally(function () {
	                    _this.busy = false;
	                });
	            }
	        }
	    };
	    ButtonAsyncController.$inject = [__promiseUtility.serviceName];
	    return ButtonAsyncController;
	})();
	exports.ButtonAsyncController = ButtonAsyncController;
	function buttonAsync() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(33),
	        scope: {},
	        bindToController: {
	            busy: '=',
	            action: '&',
	            type: '@',
	            ngDisabled: '=',
	            rightAligned: '=',
	            size: '@',
	        },
	        controller: exports.controllerName,
	        controllerAs: 'button',
	    };
	}
	angular.module(exports.moduleName, [__promiseUtility.moduleName])
	    .directive(exports.directiveName, buttonAsync)
	    .controller(exports.controllerName, ButtonAsyncController);
	//# sourceMappingURL=buttonAsync.js.map

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{button.type}} {{button.sizeClass}}\" ng-click=\"button.trigger()\" ng-disabled=\"button.busy || button.ngDisabled\">\r\n\t<rl-busy ng-show=\"button.rightAligned\" loading=\"button.busy\"></rl-busy>\r\n\t<span ng-transclude></span>\r\n\t<rl-busy ng-hide=\"button.rightAligned\" loading=\"button.busy\"></rl-busy>\r\n</button>"

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.buttonLink';
	exports.directiveName = 'rlButtonLink';
	exports.controllerName = 'ButtonLinkController';
	var ButtonLinkController = (function () {
	    function ButtonLinkController() {
	        this.type = this.type != null ? this.type : 'default';
	        this.configuredSize = this.size != null ? 'btn-' + this.size : null;
	        this.target = this.newTab ? '_blank' : '_self';
	    }
	    return ButtonLinkController;
	})();
	exports.ButtonLinkController = ButtonLinkController;
	function buttonLink() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(35),
	        scope: {},
	        bindToController: {
	            link: '@',
	            type: '@',
	            ngDisabled: '=',
	            size: '@',
	            newTab: '=',
	        },
	        controller: exports.controllerName,
	        controllerAs: 'button',
	    };
	}
	exports.buttonLink = buttonLink;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, buttonLink)
	    .controller(exports.controllerName, ButtonLinkController);
	//# sourceMappingURL=buttonLink.js.map

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = "<a class=\"btn btn-{{button.type}} {{button.configuredSize}}\" ng-href=\"{{button.link}}\" ng-disabled=\"button.ngDisabled\" target=\"{{button.target}}\">\r\n\t<span ng-transclude></span>\r\n</a>"

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __boolean = typescript_angular_utilities_1.services.boolean;
	exports.moduleName = 'rl.ui.components.buttonToggle';
	exports.directiveName = 'rlButtonToggle';
	exports.controllerName = 'ButtonToggleController';
	var ButtonToggleController = (function () {
	    function ButtonToggleController($scope, bool) {
	        var _this = this;
	        this.$scope = $scope;
	        this.buttonClass = $scope.type != null ? $scope.type : 'default';
	        this.buttonSize = $scope.size != null ? 'btn-' + $scope.size : null;
	        $scope.$watch('ngModel.$modelValue', function (value) {
	            _this.isActive = bool.toBool(value);
	            if (value != null && _.isFunction($scope.onToggle)) {
	                $scope.onToggle({ value: value });
	            }
	        });
	    }
	    ButtonToggleController.prototype.clicked = function () {
	        this.$scope.ngModel.$setViewValue(!this.$scope.ngModel.$viewValue);
	    };
	    ButtonToggleController.$inject = ['$scope', __boolean.serviceName];
	    return ButtonToggleController;
	})();
	function buttonToggle() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: '^ngModel',
	        transclude: true,
	        template: __webpack_require__(37),
	        controller: exports.controllerName,
	        controllerAs: 'buttonToggle',
	        scope: {
	            type: '@',
	            size: '@',
	            onToggle: '&',
	            disabled: '=ngDisabled',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.ngModel = ngModel;
	        }
	    };
	}
	angular.module(exports.moduleName, [__boolean.moduleName])
	    .directive(exports.directiveName, buttonToggle)
	    .controller(exports.controllerName, ButtonToggleController);
	//# sourceMappingURL=buttonToggle.js.map

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{buttonToggle.buttonClass}} {{buttonToggle.buttonSize}}\" \r\n\t\tng-class=\"{ active : buttonToggle.isActive }\" ng-click=\"buttonToggle.clicked()\" ng-disabled=\"disabled\">\r\n\t<i ng-show=\"buttonToggle.isActive\" class=\"fa fa-check completed\"></i> <span ng-transclude></span>\r\n</button>"

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var __array = typescript_angular_utilities_1.services.array;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __genericSearchFilter = typescript_angular_utilities_1.services.genericSearchFilter;
	var card = __webpack_require__(39);
	exports.card = card;
	var cardSearch = __webpack_require__(45);
	exports.cardSearch = cardSearch;
	var columnHeader = __webpack_require__(47);
	exports.columnHeader = columnHeader;
	var dataSources = __webpack_require__(49);
	exports.dataSources = dataSources;
	var filters = __webpack_require__(61);
	exports.filters = filters;
	var itemCount = __webpack_require__(75);
	exports.itemCount = itemCount;
	var pager = __webpack_require__(77);
	exports.pager = pager;
	var pageSize = __webpack_require__(79);
	exports.pageSize = pageSize;
	var selectionControl = __webpack_require__(81);
	exports.selectionControl = selectionControl;
	var sorts = __webpack_require__(50);
	exports.sorts = sorts;
	var cardContainer_1 = __webpack_require__(83);
	var builder = __webpack_require__(88);
	exports.builder = builder;
	__export(__webpack_require__(83));
	__export(__webpack_require__(84));
	__export(__webpack_require__(89));
	exports.moduleName = 'rl.ui.components.cardContainer';
	angular.module(exports.moduleName, [
	    // dependencies
	    dataSources.dataPager.moduleName,
	    __object.moduleName,
	    __array.moduleName,
	    __parentChild.moduleName,
	    __genericSearchFilter.moduleName,
	    // components
	    card.moduleName,
	    cardSearch.moduleName,
	    columnHeader.moduleName,
	    itemCount.moduleName,
	    pager.moduleName,
	    pageSize.moduleName,
	    selectionControl.moduleName,
	    // submodules
	    dataSources.moduleName,
	    filters.moduleName,
	    sorts.moduleName,
	])
	    .directive(cardContainer_1.directiveName, cardContainer_1.cardContainer)
	    .controller(cardContainer_1.controllerName, cardContainer_1.CardContainerController)
	    .factory(builder.factoryName, builder.cardContainerBuilderFactory);
	//# sourceMappingURL=cardContainer.module.js.map

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __object = typescript_angular_utilities_1.services.object;
	var headerColumn_module_1 = __webpack_require__(40);
	exports.moduleName = 'rl.ui.components.cardContainer.card';
	exports.directiveName = 'rlCard';
	exports.controllerName = 'CardController';
	var CardController = (function () {
	    function CardController($scope, $controller, $q, parentChild, object) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.parentChild = parentChild;
	        this.showContent = false;
	        this.dirty = false;
	        this.autosaveLink = {};
	        this.autosave = function () {
	            if (_this.showContent === false) {
	                return true;
	            }
	            return _this.parentChild.triggerChildBehavior(_this.autosaveLink, function (behavior) {
	                if (behavior.autosave()) {
	                    _this.showContent = false;
	                    return true;
	                }
	                else {
	                    return false;
	                }
	            });
	        };
	        if (this.cardAs) {
	            $scope[this.cardAs] = this.item;
	        }
	        $scope.collapse = this.autosave;
	        $scope.setSelected = this.setSelected.bind(this);
	        $scope.refresh = function () {
	            _this.source.refresh();
	            $scope.$broadcast('card.refresh');
	        };
	        $scope.remove = function () {
	            _this.source.remove(_this.item);
	        };
	        $scope.containerData = this.containerData;
	        if (object.isNullOrWhitespace(this.cardController) === false) {
	            var controller = $controller(this.cardController, { $scope: $scope });
	            if (object.isNullOrWhitespace(this.cardControllerAs) === false) {
	                $scope[this.cardControllerAs] = controller;
	            }
	        }
	        parentChild.registerChildBehavior(this.item, {
	            close: this.autosave,
	        });
	        $scope.__initContents = function (hasBody, hasFooter) {
	            _this.hasBody = hasBody;
	            _this.hasFooter = hasFooter;
	        };
	    }
	    CardController.prototype.toggleContent = function () {
	        if (!this.showContent) {
	            this.open();
	        }
	        else {
	            this.autosave();
	        }
	    };
	    CardController.prototype.validateCard = function () {
	        var behavior = this.parentChild.getChildBehavior(this.item);
	        if (_.isFunction(behavior.validateCard)) {
	            return behavior.validateCard();
	        }
	        else {
	            return true;
	        }
	    };
	    CardController.prototype.saveCard = function () {
	        var behavior = this.parentChild.getChildBehavior(this.item);
	        if (_.isFunction(behavior.saveCard)) {
	            return behavior.saveCard();
	        }
	        else {
	            return this.$q.when();
	        }
	    };
	    CardController.prototype.clickCard = function () {
	        this.parentChild.triggerChildBehavior(this.item, function (behavior) {
	            if (_.isFunction(behavior.clickCard)) {
	                return behavior.clickCard();
	            }
	        });
	    };
	    CardController.prototype.open = function () {
	        this.parentChild.triggerChildBehavior(this.item, function (behavior) {
	            if (_.isFunction(behavior.initCard)) {
	                behavior.initCard();
	            }
	        });
	        if (this.$scope.__rlCardContainer.openCard()) {
	            this.showContent = true;
	        }
	    };
	    CardController.prototype.setSelected = function (value) {
	        if (_.isUndefined(this.item.viewData)) {
	            this.item.viewData = {};
	        }
	        this.item.viewData.selected = value;
	        this.selectionChanged();
	    };
	    CardController.$inject = ['$scope', '$controller', '$q', __parentChild.serviceName, __object.serviceName];
	    return CardController;
	})();
	exports.CardController = CardController;
	function card() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(44),
	        require: '^^rlCardContainer',
	        controller: exports.controllerName,
	        controllerAs: '__card',
	        scope: {},
	        bindToController: {
	            columns: '=',
	            item: '=',
	            clickable: '=',
	            source: '=',
	            containerData: '=',
	            cardController: '=',
	            cardControllerAs: '=',
	            cardAs: '=',
	            permanentFooter: '=',
	            selectable: '=',
	            selectionChanged: '&',
	        },
	        link: function (scope, element, attrs, rlCardContainer) {
	            scope.__rlCardContainer = rlCardContainer;
	            rlCardContainer.makeCard(scope, function (clone) {
	                var content = clone.filter('rl-card-content');
	                var footer = clone.filter('rl-card-footer');
	                var contentArea = element.find('.content-template');
	                contentArea.append(content);
	                var hasBody = content.length > 0;
	                var hasFooter = (footer.length > 0);
	                if (hasFooter) {
	                    var footerArea = element.find('.footer-template');
	                    footerArea.append(footer);
	                }
	                scope.__initContents(hasBody, hasFooter);
	            });
	        },
	    };
	}
	exports.card = card;
	angular.module(exports.moduleName, [
	    __parentChild.moduleName,
	    __object.moduleName,
	    headerColumn_module_1.moduleName,
	])
	    .directive(exports.directiveName, card)
	    .controller(exports.controllerName, CardController);
	//# sourceMappingURL=card.js.map

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var headerColumn_1 = __webpack_require__(41);
	var sizeForBreakpoints_1 = __webpack_require__(42);
	exports.moduleName = 'rl.ui.components.cardContainer.card.headerColumn';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.string.moduleName,
	])
	    .directive(sizeForBreakpoints_1.sizeForBreakpointsName, sizeForBreakpoints_1.sizeForBreakpoints)
	    .directive(headerColumn_1.directiveName, headerColumn_1.headerColumn)
	    .controller(headerColumn_1.controllerName, headerColumn_1.HeaderColumnController);
	//# sourceMappingURL=headerColumn.module.js.map

/***/ },
/* 41 */
/***/ function(module, exports) {

	// /// <reference path='../../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	exports.directiveName = 'rlCardHeaderColumn';
	exports.controllerName = 'CardHeaderColumnController';
	var HeaderColumnController = (function () {
	    function HeaderColumnController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        this.update = function () {
	            _this.value = _this.column.getValue(_this.item);
	        };
	        this.update();
	        $scope.$on('card.refresh', this.update); //*event?
	    }
	    HeaderColumnController.$inject = ['$scope'];
	    return HeaderColumnController;
	})();
	exports.HeaderColumnController = HeaderColumnController;
	headerColumn.$inject = ['$compile'];
	function headerColumn($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div rl-size-for-breakpoints=\"header.column.size\" title=\"{{::header.column.description}}\">\n\t\t\t\t<div class=\"template-container\" style=\"display: inline-block\"></div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'header',
	        scope: {},
	        bindToController: {
	            column: '=',
	            item: '=',
	        },
	        compile: function () {
	            return {
	                pre: function (scope, element, attrs, header) {
	                    var column = header.column;
	                    if (column.templateUrl != null) {
	                        header.renderedTemplate = $compile('<div ng-include="\'' + column.templateUrl + '\'"></div>')(scope);
	                    }
	                    else if (column.template != null) {
	                        header.renderedTemplate = $compile(column.template)(scope);
	                    }
	                    else {
	                        header.renderedTemplate = $compile('<span>{{header.value}}</span>')(scope);
	                    }
	                },
	                post: function (scope, element, attrs, header) {
	                    var container = element.find('.template-container');
	                    container.append(header.renderedTemplate);
	                },
	            };
	        },
	    };
	}
	exports.headerColumn = headerColumn;
	//# sourceMappingURL=headerColumn.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __string = typescript_angular_utilities_1.services.string;
	var breakpoint_1 = __webpack_require__(43);
	exports.sizeForBreakpointsName = 'rlSizeForBreakpoints';
	sizeForBreakpoints.$inject = ['$parse', __string.serviceName];
	function sizeForBreakpoints($parse, stringUtility) {
	    'use strict';
	    return {
	        restrict: 'A',
	        link: linkDirective,
	    };
	    function linkDirective(scope, element, attributes) {
	        var sizes = $parse(attributes.rlSizeForBreakpoints)(scope);
	        var classes = [];
	        classes.push(getColumnClass(sizes, breakpoint_1.xs));
	        classes.push(getColumnClass(sizes, breakpoint_1.sm));
	        classes.push(getColumnClass(sizes, breakpoint_1.md));
	        classes.push(getColumnClass(sizes, breakpoint_1.lg));
	        element.addClass(classes.join(' '));
	    }
	    function getColumnClass(columnSizes, breakpoint) {
	        var value = columnSizes[breakpoint];
	        if (value > 0 && value !== 'hidden') {
	            return stringUtility.substitute('col-{0}-{1}', breakpoint, value);
	        }
	        else {
	            return 'hidden-' + breakpoint;
	        }
	    }
	}
	exports.sizeForBreakpoints = sizeForBreakpoints;
	//# sourceMappingURL=sizeForBreakpoints.js.map

/***/ },
/* 43 */
/***/ function(module, exports) {

	'use strict';
	exports.lg = 'lg';
	exports.md = 'md';
	exports.sm = 'sm';
	exports.xs = 'xs';
	exports.all = [exports.xs, exports.sm, exports.md, exports.lg];
	//# sourceMappingURL=breakpoint.js.map

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = "<rl-generic-container selector=\"__card.selectable\">\r\n\t<template when-selector=\"false\" default>\r\n\t\t<div class=\"card\" ng-class=\"{ 'selected': __card.item.viewData.selected }\">\r\n\t\t\t<div class=\"header\" ng-click=\"__card.toggleContent()\" ng-class=\"{ 'active': __card.hasBody || !__card.permanentFooter }\">\r\n\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t<div ng-repeat=\"column in __card.columns\">\r\n\t\t\t\t\t\t<rl-card-header-column column=\"column\" item=\"__card.item\"></rl-card-header-column>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\r\n\t\t\t<div ng-show=\"__card.showContent\">\r\n\t\t\t\t<ng-form rl-autosave=\"__card.autosaveLink\" save=\"__card.saveCard()\" validate=\"__card.validateCard()\">\r\n\t\t\t\t\t<div class=\"body\" ng-class=\"{ 'active': __card.clickable }\" ng-click=\"__card.clickCard()\">\r\n\t\t\t\t\t\t<div class=\"content-template\"></div>\r\n\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</ng-form>\r\n\t\t\t</div>\r\n\t\t\t<div ng-show=\"__card.hasFooter && (__card.showContent || __card.permanentFooter)\">\r\n\t\t\t\t<div class=\"footer\">\r\n\t\t\t\t\t<div class=\"footer-template\"></div>\r\n\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</template>\r\n\t<template when-selector=\"true\">\r\n\t\t<div class=\"select-group\">\r\n\t\t\t<div class=\"select-column\">\r\n\t\t\t\t<input type=\"checkbox\" class=\"stand-alone-checkbox\" ng-model=\"__card.item.viewData.selected\" ng-change=\"__card.selectionChanged()\"\r\n\t\t\t\t\t   ng-disabled=\"__card.item.viewData.disabledSelection\" title=\"{{__card.item.viewData.selectionTitle}}\" />\r\n\t\t\t</div>\r\n\t\t\t<div class=\"select-content\">\r\n\r\n\t\t\t\t<div class=\"card selectable\" ng-class=\"{ 'selected': __card.item.viewData.selected }\">\r\n\t\t\t\t\t<div class=\"header active\" ng-click=\"__card.toggleContent()\">\r\n\t\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t\t<div ng-repeat=\"column in __card.columns\">\r\n\t\t\t\t\t\t\t\t<rl-card-header-column column=\"column\" item=\"__card.item\"></rl-card-header-column>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\r\n\t\t\t\t\t<div ng-show=\"__card.showContent\">\r\n\t\t\t\t\t\t<ng-form rl-autosave=\"__card.autosaveLink\" save=\"__card.saveCard()\" validate=\"__card.validateCard()\">\r\n\t\t\t\t\t\t\t<div class=\"body\" ng-class=\"{ 'active': __card.clickable }\" ng-click=\"__card.clickCard()\">\r\n\t\t\t\t\t\t\t\t<div class=\"content-template\"></div>\r\n\t\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</ng-form>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div ng-show=\"__card.hasFooter && (__card.showContent || __card.permanentFooter)\">\r\n\t\t\t\t\t\t<div class=\"footer\">\r\n\t\t\t\t\t\t\t<div class=\"footer-template\"></div>\r\n\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</template>\r\n</rl-generic-container>"

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __genericSearchFilter = typescript_angular_utilities_1.services.genericSearchFilter;
	exports.moduleName = 'rl.ui.components.cardContainer.cardSearch';
	exports.directiveName = 'rlCardSearch';
	exports.controllerName = 'CardSearchController';
	exports.defaultSearchPlaceholder = 'Search';
	exports.defaultSearchDelay = 1000;
	var CardSearchController = (function () {
	    function CardSearchController($scope, $timeout) {
	        var _this = this;
	        this.searchLengthError = false;
	        this.hasSearchFilter = true;
	        if (this.containerService == null) {
	            return;
	        }
	        if (this.searchFilter == null) {
	            var filter = this.containerService.lookupFilter(__genericSearchFilter.filterName);
	            this.searchFilter = filter;
	            if (filter == null) {
	                this.hasSearchFilter = false;
	            }
	        }
	        if (this.hasSearchFilter) {
	            this.searchPlaceholder = exports.defaultSearchPlaceholder;
	            var dataSource = this.containerService.dataSource;
	            var delay = this.delay != null
	                ? this.delay
	                : exports.defaultSearchDelay;
	            var timer;
	            $scope.$watch(function () { return _this.searchText; }, function (search) {
	                _this.searchFilter.searchText = search;
	                _this.minSearchLength = _this.searchFilter.minSearchLength;
	                _this.validateSearchLength(search, _this.minSearchLength);
	                if (timer != null) {
	                    $timeout.cancel(timer);
	                }
	                timer = $timeout(dataSource.refresh.bind(dataSource), delay);
	            });
	        }
	    }
	    CardSearchController.prototype.validateSearchLength = function (search, minLength) {
	        // show error if search string exists but is below minimum size
	        this.searchLengthError = search != null
	            && search.length > 0
	            && search.length < minLength;
	    };
	    CardSearchController.$inject = ['$scope', '$timeout'];
	    return CardSearchController;
	})();
	exports.CardSearchController = CardSearchController;
	function cardSearch() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(46),
	        controller: exports.controllerName,
	        controllerAs: 'cardSearch',
	        scope: {},
	        bindToController: {
	            delay: '=searchDelay',
	            containerService: '=',
	            searchFilter: '=',
	        },
	    };
	}
	exports.cardSearch = cardSearch;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, cardSearch)
	    .controller(exports.controllerName, CardSearchController);
	//# sourceMappingURL=cardSearch.js.map

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = "<div class=\"input-group\" ng-show=\"cardSearch.hasSearchFilter\" ng-class=\"{ 'has-error': cardSearch.searchLengthError }\">\r\n\t<input class=\"form-control\" type=\"text\" placeholder=\"{{cardSearch.searchPlaceholder}}\" ng-model=\"cardSearch.searchText\"\r\n\t\t\tpopover=\"You must enter at least {{cardSearch.minSearchLength}} characters to perform a search\" popover-trigger=\"mouseenter\" popover-enable=\"cardSearch.searchLengthError\" />\r\n\t<div class=\"input-group-btn\">\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-disabled=\"cardSearch.searchText | isEmpty\" ng-click=\"cardSearch.searchText = null\">\r\n\t\t\t<i class=\"fa fa-times\"></i>\r\n\t\t</button>\r\n\t</div>\r\n</div>"

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var sortDirection_1 = __webpack_require__(48);
	exports.moduleName = 'rl.ui.components.cardContainer.columnHeader';
	exports.directiveName = 'rlColumnHeader';
	cardColumnHeader.$inject = ['$compile'];
	function cardColumnHeader($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: '^^rlCardContainer',
	        template: "\n\t\t\t<div rl-size-for-breakpoints=\"column.size\" ng-click=\"sort()\" title=\"{{::column.description}}\"\n\t\t\t\t\tclass=\"column-header\">\n\t\t\t\t<div class=\"template-container\" style=\"display: inline-block\"></div>\n\t\t\t\t<i ng-show=\"sorting === sortDirection.ascending\" class=\"fa fa-sort-asc\"></i>\n\t\t\t\t<i ng-show=\"sorting === sortDirection.descending\" class=\"fa fa-sort-desc\"></i>\n\t\t\t</div>\n\t\t",
	        scope: {
	            column: '=',
	            sorting: '=',
	            sort: '&',
	        },
	        compile: function () {
	            return {
	                pre: function (scope) {
	                    var column = scope.column;
	                    if (column.headerTemplateUrl != null) {
	                        scope.renderedTemplate = $compile('<div ng-include="\'' + column.headerTemplateUrl + '\'"></div>')(scope);
	                    }
	                    else if (column.headerTemplate != null) {
	                        scope.renderedTemplate = $compile(column.headerTemplate)(scope);
	                    }
	                    else {
	                        scope.renderedTemplate = ('<h5>' + column.label + '</h5');
	                    }
	                },
	                post: function (scope, element) {
	                    if (scope.column.displayColumnHeader != null && scope.column.displayColumnHeader === false) {
	                        element.remove();
	                        return;
	                    }
	                    var container = element.find('.template-container');
	                    container.append(scope.renderedTemplate);
	                    scope.sortDirection = sortDirection_1.SortDirection;
	                },
	            };
	        }
	    };
	}
	exports.cardColumnHeader = cardColumnHeader;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, cardColumnHeader);
	//# sourceMappingURL=columnHeader.js.map

/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict';
	var SortDirection = (function () {
	    function SortDirection(value) {
	        this.value = value;
	    }
	    SortDirection.toggle = function (direction) {
	        if (direction === SortDirection.ascending) {
	            return SortDirection.descending;
	        }
	        else if (direction === SortDirection.descending) {
	            return SortDirection.none;
	        }
	        else {
	            return SortDirection.ascending;
	        }
	    };
	    SortDirection.getFullName = function (direction) {
	        'use strict';
	        if (direction === SortDirection.ascending) {
	            return 'ascending';
	        }
	        else if (direction === SortDirection.descending) {
	            return 'descending';
	        }
	        else {
	            return 'none';
	        }
	    };
	    SortDirection.none = new SortDirection(0);
	    SortDirection.ascending = new SortDirection(1);
	    SortDirection.descending = new SortDirection(2);
	    return SortDirection;
	})();
	exports.SortDirection = SortDirection;
	//# sourceMappingURL=sortDirection.js.map

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var sorts_module_1 = __webpack_require__(50);
	var dataPager = __webpack_require__(54);
	exports.dataPager = dataPager;
	var dataServiceDataSource = __webpack_require__(55);
	exports.dataServiceDataSource = dataServiceDataSource;
	var simpleDataSource = __webpack_require__(58);
	exports.simpleDataSource = simpleDataSource;
	var serverSearchDataSource = __webpack_require__(59);
	exports.serverSearchDataSource = serverSearchDataSource;
	var dataSourceProcessor = __webpack_require__(57);
	exports.dataSourceProcessor = dataSourceProcessor;
	var dataSourceBase = __webpack_require__(56);
	exports.dataSourceBase = dataSourceBase;
	__export(__webpack_require__(60));
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.object.moduleName,
	    sorts_module_1.moduleName,
	    dataPager.moduleName,
	    dataServiceDataSource.moduleName,
	    simpleDataSource.moduleName,
	    serverSearchDataSource.moduleName,
	])
	    .service(dataSourceProcessor.processorServiceName, dataSourceProcessor.DataSourceProcessor);
	//# sourceMappingURL=dataSources.module.js.map

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var mergeSort = __webpack_require__(51);
	exports.mergeSort = mergeSort;
	var sorter = __webpack_require__(52);
	exports.sorter = sorter;
	__export(__webpack_require__(53));
	__export(__webpack_require__(48));
	exports.moduleName = 'rl.ui.components.cardContainer.sorts';
	angular.module(exports.moduleName, [
	    mergeSort.moduleName,
	    sorter.moduleName,
	]);
	//# sourceMappingURL=sorts.module.js.map

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	exports.moduleName = 'rl.ui.components.cardContainer.sorts.mergeSort';
	exports.serviceName = 'mergeSort';
	var MergeSort = (function () {
	    function MergeSort() {
	    }
	    MergeSort.prototype.sort = function (data, compare) {
	        if (data.length < 2) {
	            return data;
	        }
	        if (compare == null) {
	            compare = this.defaultCompare;
	        }
	        var mid;
	        var left;
	        var right;
	        mid = data.length / 2;
	        left = this.sort(data.slice(0, mid), compare);
	        right = this.sort(data.slice(mid, data.length), compare);
	        return this.merge(left, right, compare);
	    };
	    MergeSort.prototype.defaultCompare = function (a, b) {
	        return a < b
	            ? typescript_angular_utilities_1.types.CompareResult.less
	            : (a > b ? typescript_angular_utilities_1.types.CompareResult.greater : typescript_angular_utilities_1.types.CompareResult.equal);
	    };
	    MergeSort.prototype.merge = function (left, right, compare) {
	        var result = [];
	        while (left.length && right.length) {
	            if (compare(left[0], right[0]) === typescript_angular_utilities_1.types.CompareResult.greater) {
	                result.push(right.shift());
	            }
	            else {
	                // if equal it should preserve same order (stable)
	                result.push(left.shift());
	            }
	        }
	        if (left.length) {
	            result.push.apply(result, left);
	        }
	        if (right.length) {
	            result.push.apply(result, right);
	        }
	        return result;
	    };
	    return MergeSort;
	})();
	exports.MergeSort = MergeSort;
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, MergeSort);
	//# sourceMappingURL=mergeSort.service.js.map

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var sortDirection_1 = __webpack_require__(48);
	var mergeSort_service_1 = __webpack_require__(51);
	exports.moduleName = 'rl.ui.components.cardContainer.sorts.sorter';
	exports.serviceName = 'sorter';
	var Sorter = (function () {
	    function Sorter(mergeSort) {
	        this.mergeSort = mergeSort;
	    }
	    Sorter.prototype.sort = function (data, sort) {
	        var _this = this;
	        if (sort === null) {
	            return data;
	        }
	        if (_.isArray(sort)) {
	            var reverseSorts = _.clone(sort);
	            reverseSorts.reverse();
	            return _.reduce(reverseSorts, function (sortedData, nextSort) {
	                return _this.singleSort(sortedData, nextSort);
	            }, data);
	        }
	        return this.singleSort(data, sort);
	    };
	    Sorter.prototype.singleSort = function (data, sort) {
	        var compareFunction = this.buildSortFunction(sort);
	        return this.mergeSort.sort(data, compareFunction);
	    };
	    Sorter.prototype.buildSortFunction = function (sort) {
	        return function (a, b) {
	            if (sort.direction === sortDirection_1.SortDirection.none) {
	                return typescript_angular_utilities_1.types.CompareResult.equal;
	            }
	            var valueOfA = sort.column.getValue(a);
	            var valueOfB = sort.column.getValue(b);
	            var greaterResult = typescript_angular_utilities_1.types.CompareResult.greater;
	            var lessResult = typescript_angular_utilities_1.types.CompareResult.less;
	            var descendingSort = (sort.direction === sortDirection_1.SortDirection.descending);
	            var flip = sort.column.flipSort;
	            // Exclusive OR... if flipping a descending sort, you get an ascending sort
	            if ((descendingSort || flip) && !(descendingSort && flip)) {
	                greaterResult = typescript_angular_utilities_1.types.CompareResult.less;
	                lessResult = typescript_angular_utilities_1.types.CompareResult.greater;
	            }
	            return valueOfA > valueOfB
	                ? greaterResult
	                : (valueOfA < valueOfB ? lessResult : typescript_angular_utilities_1.types.CompareResult.equal);
	        };
	    };
	    Sorter.$inject = [mergeSort_service_1.serviceName];
	    return Sorter;
	})();
	exports.Sorter = Sorter;
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, Sorter);
	//# sourceMappingURL=sorter.service.js.map

/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=sort.js.map

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/lodashTypeExtensions.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.dataPager';
	exports.factoryName = 'dataPager';
	exports.defaultPageSize = 10;
	var DataPager = (function () {
	    function DataPager() {
	        this.pageNumber = 1;
	        this.pageSize = exports.defaultPageSize;
	    }
	    DataPager.prototype.filter = function (dataSet) {
	        var size = this.pageSize;
	        var start = (this.pageNumber - 1) * size;
	        return _(dataSet)
	            .drop(start)
	            .take(size)
	            .value();
	    };
	    return DataPager;
	})();
	exports.DataPager = DataPager;
	function dataPagerFactory() {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new DataPager();
	        },
	    };
	}
	exports.dataPagerFactory = dataPagerFactory;
	angular.module(exports.moduleName, [])
	    .factory(exports.factoryName, dataPagerFactory);
	//# sourceMappingURL=dataPager.service.js.map

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var dataSourceBase_service_1 = __webpack_require__(56);
	var dataSourceProcessor_service_1 = __webpack_require__(57);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.dataServiceDataSource';
	exports.factoryName = 'dataServiceDataSource';
	var DataServiceDataSource = (function (_super) {
	    __extends(DataServiceDataSource, _super);
	    function DataServiceDataSource(getDataSet, $q, observableFactory, dataSourceProcessor, array) {
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.getDataSet = getDataSet;
	        this.$q = $q;
	        this.countFilterGroups = true;
	        if (_.isFunction(this.getDataSet)) {
	            this.reload();
	        }
	    }
	    DataServiceDataSource.prototype.reload = function () {
	        var _this = this;
	        this.dataSet = null;
	        this.rawDataSet = null;
	        this.loadingDataSet = true;
	        this.$q.when(this.getDataSet()).then(function (data) {
	            _this.loadingDataSet = false;
	            _this.rawDataSet = data;
	            _this.refresh();
	            _this.observable.fire('reloaded');
	            _this.observable.fire('changed');
	        });
	    };
	    return DataServiceDataSource;
	})(dataSourceBase_service_1.DataSourceBase);
	exports.DataServiceDataSource = DataServiceDataSource;
	dataServiceDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, '$q'];
	function dataServiceDataSourceFactory(observableFactory, dataSourceProcessor, array, $q) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet) {
	            return new DataServiceDataSource(getDataSet, $q, observableFactory, dataSourceProcessor, array);
	        },
	    };
	}
	exports.dataServiceDataSourceFactory = dataServiceDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName])
	    .factory(exports.factoryName, dataServiceDataSourceFactory);
	//# sourceMappingURL=dataServiceDataSource.service.js.map

/***/ },
/* 56 */
/***/ function(module, exports) {

	'use strict';
	var DataSourceBase = (function () {
	    function DataSourceBase(observableFactory, dataSourceProcessor, array) {
	        this.dataSourceProcessor = dataSourceProcessor;
	        this.array = array;
	        this.sorts = [];
	        this.filters = {};
	        this.count = 0;
	        this.countFilterGroups = false;
	        this.loadingDataSet = false;
	        this.observable = observableFactory.getInstance();
	    }
	    DataSourceBase.prototype.watch = function (action, event) {
	        return this.observable.register(action, event);
	    };
	    DataSourceBase.prototype.processData = function () {
	        var processedData;
	        if (this.countFilterGroups) {
	            processedData = this.dataSourceProcessor.processAndCount(this.sorts, this.filters, this.pager, this.rawDataSet);
	        }
	        else {
	            processedData = this.dataSourceProcessor.process(this.sorts, this.filters, this.pager, this.rawDataSet);
	        }
	        this.count = processedData.count;
	        this.dataSet = processedData.dataSet;
	        this.filteredDataSet = processedData.filteredDataSet;
	    };
	    DataSourceBase.prototype.refresh = function () {
	        if (!this.loadingDataSet) {
	            this.processData();
	            this.observable.fire('redrawing');
	        }
	    };
	    DataSourceBase.prototype.remove = function (data) {
	        var item = this.array.remove(this.rawDataSet, data);
	        if (item != null) {
	            this.observable.fire('removed');
	            this.observable.fire('changed');
	            if (this.pager) {
	                this.refresh();
	            }
	        }
	    };
	    DataSourceBase.prototype.push = function (data) {
	        this.rawDataSet.push(data);
	        this.observable.fire('added');
	        this.observable.fire('changed');
	        this.refresh();
	    };
	    DataSourceBase.prototype.replace = function (oldData, newData) {
	        var locationOfOldData = this.rawDataSet.indexOf(oldData);
	        if (locationOfOldData >= 0) {
	            this.array.replace(this.rawDataSet, oldData, newData);
	            this.observable.fire('replaced');
	            this.observable.fire('changed');
	            this.refresh();
	        }
	    };
	    return DataSourceBase;
	})();
	exports.DataSourceBase = DataSourceBase;
	//# sourceMappingURL=dataSourceBase.service.js.map

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var sorter_service_1 = __webpack_require__(52);
	exports.processorServiceName = 'dataSourceProcessor';
	var DataSourceProcessor = (function () {
	    function DataSourceProcessor(object, sorter) {
	        this.object = object;
	        this.sorter = sorter;
	    }
	    DataSourceProcessor.prototype.process = function (sorts, filters, pager, data) {
	        var processedData = data;
	        if (this.object.isNullOrEmpty(sorts) === false) {
	            processedData = this.sorter.sort(processedData, sorts);
	        }
	        if (this.object.isNullOrEmpty(filters) === false) {
	            processedData = _.reduce(filters, function (filteredData, filter) {
	                // Filter the data set using the filter function on the filter
	                return _.filter(filteredData, filter.filter, filter);
	            }, processedData);
	        }
	        var result = {
	            count: (processedData != null ? processedData.length : 0),
	            filteredDataSet: processedData,
	            dataSet: processedData,
	        };
	        if (pager != null) {
	            result.dataSet = pager.filter(processedData);
	        }
	        return result;
	    };
	    DataSourceProcessor.prototype.processAndCount = function (sorts, filters, pager, data) {
	        var _this = this;
	        // If there are no filters that need to updated option counts, use the normal processor
	        if (this.object.isNullOrEmpty(filters)
	            || _.any(filters, function (filter) { return _.isFunction(filter.updateOptionCounts); }) === false) {
	            return this.process(sorts, filters, pager, data);
	        }
	        var processedData = data;
	        if (this.object.isNullOrEmpty(sorts) === false) {
	            processedData = this.sorter.sort(processedData, sorts);
	        }
	        var wrappedData = this.wrapData(processedData);
	        // Run filtration logic and compute visible items
	        _.each(filters, function (filter) {
	            _.each(wrappedData, function (item) {
	                item.filterData[filter.type] = filter.filter(item.data);
	            });
	        });
	        // Give each filter a chance to update option counts
	        _.each(filters, function (filter) {
	            if (_.isFunction(filter.updateOptionCounts)) {
	                var otherFiltersApplied = _.filter(wrappedData, function (item) {
	                    // Omit the true or false of the current filter an
	                    //  only filter out items removed by other filters
	                    var filterData = _.omit(item.filterData, filter.type); //*filterData
	                    return _.all(_.values(filterData));
	                });
	                filter.updateOptionCounts(_this.unwrapData(otherFiltersApplied));
	            }
	        });
	        // Filter down to final data set by removing items that don't match all filters
	        wrappedData = _.filter(wrappedData, function (item) {
	            return _.all(_.values(item.filterData));
	        });
	        processedData = this.unwrapData(wrappedData);
	        var result = {
	            count: processedData.length,
	            filteredDataSet: processedData,
	            dataSet: processedData,
	        };
	        if (pager != null) {
	            result.dataSet = pager.filter(processedData);
	        }
	        return result;
	    };
	    DataSourceProcessor.prototype.wrapData = function (data) {
	        return _.map(data, function (item) {
	            return {
	                data: item,
	                filterData: {},
	            };
	        });
	    };
	    DataSourceProcessor.prototype.unwrapData = function (data) {
	        return _.map(data, function (item) {
	            return item.data;
	        });
	    };
	    DataSourceProcessor.$inject = [__object.serviceName, sorter_service_1.serviceName];
	    return DataSourceProcessor;
	})();
	exports.DataSourceProcessor = DataSourceProcessor;
	//# sourceMappingURL=dataSourceProcessor.service.js.map

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var dataSourceBase_service_1 = __webpack_require__(56);
	var dataSourceProcessor_service_1 = __webpack_require__(57);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.simpleDataSource';
	exports.factoryName = 'simpleDataSource';
	var SimpleDataSource = (function (_super) {
	    __extends(SimpleDataSource, _super);
	    function SimpleDataSource(data, observableFactory, dataSourceProcessor, array) {
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.countFilterGroups = false;
	        this.rawDataSet = data;
	        this.processData();
	    }
	    return SimpleDataSource;
	})(dataSourceBase_service_1.DataSourceBase);
	exports.SimpleDataSource = SimpleDataSource;
	simpleDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName];
	function simpleDataSourceFactory(observableFactory, dataSourceProcessor, array) {
	    'use strict';
	    return {
	        getInstance: function (data) {
	            return new SimpleDataSource(data, observableFactory, dataSourceProcessor, array);
	        },
	    };
	}
	exports.simpleDataSourceFactory = simpleDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName])
	    .factory(exports.factoryName, simpleDataSourceFactory);
	//# sourceMappingURL=simpleDataSource.service.js.map

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var __object = typescript_angular_utilities_1.services.object;
	var __synchronizedRequests = typescript_angular_utilities_1.services.synchronizedRequests;
	var dataSourceBase_service_1 = __webpack_require__(56);
	var dataSourceProcessor_service_1 = __webpack_require__(57);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.serverSearchDataSource';
	exports.factoryName = 'serverSearchDataSource';
	var ServerSearchDataSource = (function (_super) {
	    __extends(ServerSearchDataSource, _super);
	    function ServerSearchDataSource(getDataSet, searchFilter, getFilterModel, validateModel, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	        var _this = this;
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.searchFilter = searchFilter;
	        this.getFilterModel = getFilterModel;
	        this.validateModel = validateModel;
	        this.object = object;
	        this.minSearchLength = 4;
	        this.resolveReload = function (data) {
	            _this.loadingDataSet = false;
	            _this.rawDataSet = data;
	            _this.refresh();
	            _this.observable.fire('reloaded');
	            _this.observable.fire('changed');
	        };
	        this.getFilterModel = this.getFilterModel || function () { return null; };
	        this.validateModel = this.validateModel || function () { return true; };
	        this.countFilterGroups = true;
	        this.search = searchFilter.searchText;
	        this.filterModel = _.clone(this.getFilterModel());
	        searchFilter.minSearchLength = this.minSearchLength;
	        this.synchronizedRequests = synchronizedRequestsFactory.getInstance(getDataSet, this.resolveReload.bind(this));
	    }
	    Object.defineProperty(ServerSearchDataSource.prototype, "getDataSet", {
	        set: function (value) {
	            this.synchronizedRequests.dataProvider = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ServerSearchDataSource.prototype.refresh = function () {
	        if (this.searchFilter.searchText !== this.search
	            || this.filterModelChanged()) {
	            this.reload();
	        }
	        else {
	            _super.prototype.refresh.call(this);
	        }
	    };
	    ServerSearchDataSource.prototype.reload = function () {
	        this.search = this.searchFilter.searchText;
	        this.filterModel = _.clone(this.getFilterModel());
	        var hasValidSearch = !this.object.isNullOrEmpty(this.search) && this.search.length >= this.minSearchLength;
	        var hasValidFilterModel = this.filterModel != null && this.validateModel(this.filterModel);
	        if (!hasValidSearch && !hasValidFilterModel) {
	            this.resolveReload(null);
	            return;
	        }
	        this.dataSet = null;
	        this.rawDataSet = null;
	        this.loadingDataSet = true;
	        this.synchronizedRequests.getData(this.buildSearchParams());
	    };
	    ServerSearchDataSource.prototype.filterModelChanged = function () {
	        return !this.object.areEqual(this.getFilterModel(), this.filterModel);
	    };
	    ServerSearchDataSource.prototype.buildSearchParams = function () {
	        var searchModel = this.getFilterModel();
	        if (searchModel != null) {
	            searchModel.search = this.search;
	        }
	        else {
	            searchModel = this.search;
	        }
	        return searchModel;
	    };
	    return ServerSearchDataSource;
	})(dataSourceBase_service_1.DataSourceBase);
	exports.ServerSearchDataSource = ServerSearchDataSource;
	serverSearchDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, __object.serviceName, __synchronizedRequests.factoryName];
	function serverSearchDataSourceFactory(observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet, searchFilter, getFilterModel, validateModel) {
	            return new ServerSearchDataSource(getDataSet, searchFilter, getFilterModel, validateModel, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory);
	        },
	    };
	}
	exports.serverSearchDataSourceFactory = serverSearchDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName, __object.moduleName, __synchronizedRequests.moduleName])
	    .factory(exports.factoryName, serverSearchDataSourceFactory);
	//# sourceMappingURL=serverSearchDataSource.service.js.map

/***/ },
/* 60 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=dataSource.js.map

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var columnSearchFilter = __webpack_require__(62);
	exports.columnSearchFilter = columnSearchFilter;
	var filterGroup = __webpack_require__(63);
	exports.filterGroup = filterGroup;
	var selectFilter = __webpack_require__(71);
	exports.selectFilter = selectFilter;
	exports.moduleName = 'rl.ui.components.cardContainer.filters';
	angular.module(exports.moduleName, [
	    columnSearchFilter.moduleName,
	    filterGroup.moduleName,
	    selectFilter.moduleName
	]);
	//# sourceMappingURL=filters.module.js.map

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var __string = typescript_angular_utilities_1.services.string;
	exports.moduleName = 'rl.ui.components.cardContainer.filters.columnSearchFilter';
	exports.factoryName = 'columnSearchFilter';
	exports.filterName = 'column-search';
	var ColumnSearchFilter = (function () {
	    function ColumnSearchFilter(object, string) {
	        this.object = object;
	        this.string = string;
	        this.type = exports.filterName;
	    }
	    ColumnSearchFilter.prototype.filter = function (item) {
	        if (this.column == null) {
	            return true;
	        }
	        var value = this.object.toString(this.column.getValue(item));
	        var search = this.searchText;
	        if (!this.caseSensitive) {
	            search = search.toLowerCase();
	            value = value.toLowerCase();
	        }
	        return this.string.contains(value, search);
	    };
	    return ColumnSearchFilter;
	})();
	exports.ColumnSearchFilter = ColumnSearchFilter;
	columnSearchFilterFactory.$inject = [__object.serviceName, __string.serviceName];
	function columnSearchFilterFactory(object, string) {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new ColumnSearchFilter(object, string);
	        },
	    };
	}
	exports.columnSearchFilterFactory = columnSearchFilterFactory;
	angular.module(exports.moduleName, [__object.moduleName, __string.moduleName])
	    .factory(exports.factoryName, columnSearchFilterFactory);
	//# sourceMappingURL=columnSearchFilter.service.js.map

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var filterOption = __webpack_require__(64);
	exports.filterOption = filterOption;
	var modeFilterGroup = __webpack_require__(66);
	exports.modeFilterGroup = modeFilterGroup;
	var rangeFilterGroup = __webpack_require__(68);
	exports.rangeFilterGroup = rangeFilterGroup;
	var filterGroup_service_1 = __webpack_require__(67);
	var filterGroup_directive_1 = __webpack_require__(69);
	__export(__webpack_require__(69));
	__export(__webpack_require__(67));
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.object.moduleName,
	    filterOption.moduleName,
	    modeFilterGroup.moduleName,
	    rangeFilterGroup.moduleName,
	])
	    .factory(filterGroup_service_1.factoryName, filterGroup_service_1.filterGroupFactory)
	    .directive(filterGroup_directive_1.directiveName, filterGroup_directive_1.filterGroup)
	    .controller(filterGroup_directive_1.controllerName, filterGroup_directive_1.FilterGroupController);
	//# sourceMappingURL=filterGroup.module.js.map

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.filterOption';
	exports.directiveName = 'rlFilterOption';
	function filterOption() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(65),
	        scope: {
	            activate: '&',
	            isActive: '=active',
	            option: '=',
	        },
	    };
	}
	exports.filterOption = filterOption;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, filterOption);
	//# sourceMappingURL=filterOption.js.map

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row filter-option\" ng-class=\"{ 'active': isActive }\" ng-click=\"activate()\">\r\n\t<div class=\"col-xs-1\">\r\n\t\t<i class='fa fa-arrow-right' ng-show=\"isActive == true\"></i>\r\n\t</div>\r\n\t<div class=\"col-xs-1\" ng-if=\"hasIcon\" ng-bind-html=\"option.icon\"></div>\r\n\t<div ng-class=\"{ 'col-xs-6': hasIcon, 'col-xs-7': !hasIcon }\">\r\n\t\t{{option.label}}\r\n\t</div>\r\n\t<div class=\"col-xs-3 text-right\" ng-show=\"option.count != null\">\r\n\t\t({{option.count}})\r\n\t</div>\r\n</div>"

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var filterGroup_service_1 = __webpack_require__(67);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.modeFilterGroup';
	exports.factoryName = 'modeFilterGroup';
	var ModeFilterGroup = (function (_super) {
	    __extends(ModeFilterGroup, _super);
	    function ModeFilterGroup(settings, object) {
	        this.getValue = settings.getValue;
	        settings.options = _.map(settings.options, this.buildModeOption, this);
	        _super.call(this, settings, object);
	    }
	    ModeFilterGroup.prototype.buildModeOption = function (option) {
	        var _this = this;
	        var modeOption = option;
	        modeOption.filter = function (item) {
	            if (modeOption.displayAll) {
	                return true;
	            }
	            return _this.getValue(item) === modeOption.value;
	        };
	        return modeOption;
	    };
	    return ModeFilterGroup;
	})(filterGroup_service_1.FilterGroup);
	exports.ModeFilterGroup = ModeFilterGroup;
	modeFilterGroupFactory.$inject = [__object.serviceName];
	function modeFilterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new ModeFilterGroup(settings, object);
	        },
	    };
	}
	exports.modeFilterGroupFactory = modeFilterGroupFactory;
	angular.module(exports.moduleName, [__object.moduleName])
	    .factory(exports.factoryName, modeFilterGroupFactory);
	//# sourceMappingURL=modeFilterGroup.service.js.map

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	exports.factoryName = 'filterGroup';
	var FilterGroup = (function () {
	    function FilterGroup(settings, object) {
	        this.label = settings.label;
	        this.type = settings.type != null ? settings.type : settings.label;
	        this.options = settings.options;
	        this.activeOption = this.options[0];
	        _.each(this.options, function (option) {
	            if (_.isUndefined(option.type)) {
	                option.type = option.label;
	            }
	            option.type = object.toString(option.type).toLowerCase();
	        });
	    }
	    FilterGroup.prototype.filter = function (item) {
	        return this.activeOption.filter(item);
	    };
	    FilterGroup.prototype.setActiveOption = function (index) {
	        if (index >= 0 && index < this.options.length) {
	            this.activeOption = this.options[index];
	        }
	    };
	    FilterGroup.prototype.setOptionCounts = function (counts) {
	        _.each(this.options, function (option) {
	            if (_.has(counts, option.type)) {
	                option.count = counts[option.type];
	            }
	        });
	    };
	    FilterGroup.prototype.updateOptionCounts = function (filteredDataSet) {
	        _.each(this.options, function (option) {
	            option.count = _.filter(filteredDataSet, option.filter, option).length;
	        });
	    };
	    return FilterGroup;
	})();
	exports.FilterGroup = FilterGroup;
	filterGroupFactory.$inject = [__object.serviceName];
	function filterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new FilterGroup(settings, object);
	        },
	    };
	}
	exports.filterGroupFactory = filterGroupFactory;
	//# sourceMappingURL=filterGroup.service.js.map

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var filterGroup_service_1 = __webpack_require__(67);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.rangeFilterGroup';
	exports.factoryName = 'rangeFilterGroup';
	var RangeFilterGroup = (function (_super) {
	    __extends(RangeFilterGroup, _super);
	    function RangeFilterGroup(settings, object) {
	        this.getValue = settings.getValue;
	        settings.options = _.map(settings.options, this.buildRangeOption, this);
	        _super.call(this, settings, object);
	    }
	    RangeFilterGroup.prototype.buildRangeOption = function (option) {
	        var _this = this;
	        var modeOption = option;
	        modeOption.filter = function (item) {
	            var value = _this.getValue(item);
	            var result = true;
	            if (_.isUndefined(option.highExclusive) === false) {
	                result = value < option.highExclusive;
	            }
	            else if (_.isUndefined(option.highInclusive) === false) {
	                result = value <= option.highInclusive;
	            }
	            if (_.isUndefined(option.lowExclusive) === false) {
	                result = result && value > option.lowExclusive;
	            }
	            else if (_.isUndefined(option.lowInclusive) === false) {
	                result = result && value >= option.lowInclusive;
	            }
	            return result;
	        };
	        return modeOption;
	    };
	    return RangeFilterGroup;
	})(filterGroup_service_1.FilterGroup);
	rangeFilterGroupFactory.$inject = [__object.serviceName];
	function rangeFilterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new RangeFilterGroup(settings, object);
	        },
	    };
	}
	exports.rangeFilterGroupFactory = rangeFilterGroupFactory;
	angular.module(exports.moduleName, [__object.moduleName])
	    .factory(exports.factoryName, rangeFilterGroupFactory);
	//# sourceMappingURL=rangeFilterGroup.service.js.map

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/commonjs.d.ts' />
	'use strict';
	exports.directiveName = 'rlFilterGroup';
	exports.controllerName = 'FilterGroupController';
	var FilterGroupController = (function () {
	    function FilterGroupController($scope) {
	        this.$scope = $scope;
	        this.hasIcon = this.icon != null && this.icon !== '';
	        this.showChildren = true;
	    }
	    FilterGroupController.prototype.toggleChildren = function () {
	        this.showChildren = !this.showChildren;
	    };
	    FilterGroupController.prototype.selectOption = function (option) {
	        this.filterGroup.activeOption = option;
	        this.showChildren = false;
	        if (this.source != null) {
	            this.source.refresh();
	        }
	        else {
	            this.$scope.$emit('dataSource.requestRefresh'); //*event?
	        }
	    };
	    FilterGroupController.$inject = ['$scope'];
	    return FilterGroupController;
	})();
	exports.FilterGroupController = FilterGroupController;
	function filterGroup() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(70),
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            icon: '=',
	            filterGroup: '=',
	            source: '=',
	        },
	    };
	}
	exports.filterGroup = filterGroup;
	//# sourceMappingURL=filterGroup.directive.js.map

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filter-group\">\r\n\t<div class=\"row filter-header\" ng-click=\"controller.toggleChildren()\">\r\n\t\t<div class=\"col-sm-12\">\r\n\t\t\t<i class=\"collapse-icon fa fa-caret-down fa-2x\" ng-show=\"controller.showChildren\" title=\"Hide filter list\"></i>\r\n\t\t\t<i class=\"collapse-icon fa fa-caret-right fa-2x\" ng-hide=\"controller.showChildren\" title=\"Show filter list\"></i>\r\n\t\t\t<div class=\"filter-option\">\r\n\t\t\t\t<div style=\"display:inline-block\" ng-show=\"controller.hasIcon\" ng-bind-html=\"controller.icon\"></div>\r\n\t\t\t\t<h4 style=\"display: inline-block\">{{controller.filterGroup.label}}: {{controller.filterGroup.activeOption.label}}</h4>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n\t<div ng-show=\"controller.showChildren\" ng-repeat=\"filterOption in controller.filterGroup.options\">\r\n\t\t<rl-filter-option option=\"filterOption\" active=\"filterGroup.activeOption === filterOption\" activate=\"controller.selectOption(filterOption)\"></rl-filter-option>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var selectFilter_service_1 = __webpack_require__(72);
	var selectFilter_component_1 = __webpack_require__(73);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.selectFilter';
	__export(__webpack_require__(72));
	__export(__webpack_require__(73));
	angular.module(exports.moduleName, [])
	    .factory(selectFilter_service_1.factoryName, selectFilter_service_1.selectFilterFactory)
	    .directive(selectFilter_component_1.directiveName, selectFilter_component_1.selectFilter)
	    .controller(selectFilter_component_1.controllerName, selectFilter_component_1.SelectFilterController);
	//# sourceMappingURL=selectFilter.module.js.map

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	exports.factoryName = 'selectFilter';
	var SelectFilter = (function () {
	    function SelectFilter(valueSelector) {
	        this.valueSelector = valueSelector;
	        this.type = 'selectFilter';
	    }
	    SelectFilter.prototype.filter = function (item) {
	        if (this.selectedValue == null) {
	            return true;
	        }
	        return this.getValue(item) === this.selectedValue;
	    };
	    SelectFilter.prototype.getValue = function (item) {
	        if (_.isFunction(this.valueSelector)) {
	            var func = this.valueSelector;
	            return (func(item));
	        }
	        else {
	            var property = this.valueSelector;
	            return item[property];
	        }
	    };
	    return SelectFilter;
	})();
	function selectFilterFactory() {
	    return {
	        getInstance: function (valueSelector) {
	            return new SelectFilter(valueSelector);
	        },
	    };
	}
	exports.selectFilterFactory = selectFilterFactory;
	//# sourceMappingURL=selectFilter.service.js.map

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/commonjs.d.ts' />
	'use strict';
	exports.directiveName = 'rlSelectFilter';
	exports.controllerName = 'SelectFilterController';
	var SelectFilterController = (function () {
	    function SelectFilterController($scope) {
	        this.$scope = $scope;
	    }
	    Object.defineProperty(SelectFilterController.prototype, "selectedValue", {
	        get: function () {
	            return this.filter.selectedValue;
	        },
	        set: function (v) {
	            this.filter.selectedValue = v;
	            if (this.source != null) {
	                this.source.refresh();
	            }
	            else {
	                this.$scope.$emit('dataSource.requestRefresh'); //*event?
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SelectFilterController.$inject = ['$scope'];
	    return SelectFilterController;
	})();
	exports.SelectFilterController = SelectFilterController;
	function selectFilter() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(74),
	        controller: exports.controllerName,
	        controllerAs: 'filter',
	        scope: {},
	        bindToController: {
	            filter: '=',
	            options: '=',
	            getOptions: '&',
	            source: '=',
	            label: '@',
	            selector: '=',
	            nullOption: '@'
	        },
	    };
	}
	exports.selectFilter = selectFilter;
	//# sourceMappingURL=selectFilter.component.js.map

/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filter-group\">\r\n\t<rl-select ng-model=\"filter.selectedValue\" options=\"filter.options\" label=\"{{filter.label}}\"\r\n\t\t\t   selector=\"filter.selector\" get-options=\"filter.getOptions()\" null-option=\"{{filter.nullOption}}\"></rl-select>\r\n</div>"

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.itemCount';
	exports.directiveName = 'rlItemCount';
	function itemCount() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: '^^rlCardContainer',
	        template: __webpack_require__(76),
	        scope: {
	            containerService: '=',
	        },
	    };
	}
	exports.itemCount = itemCount;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, itemCount);
	//# sourceMappingURL=itemCount.js.map

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "<p ng-show=\"!containerService.dataSource.loadingDataSet\">\r\n\tShowing <strong>{{containerService.dataSource.dataSet.length}} of {{containerService.dataSource.count}}</strong> total items\r\n</p>"

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	exports.moduleName = 'rl.ui.components.cardContainer.pager';
	exports.directiveName = 'rlPager';
	exports.controllerName = 'PagerController';
	exports.defaultVisiblePageCount = 5;
	var PagerController = (function () {
	    function PagerController($scope) {
	        var _this = this;
	        this.canGoBack = false;
	        this.canGoForward = false;
	        this.hasPageFilter = true;
	        this.updatePageCount = function () {
	            var totalItems = _this.dataSource.count;
	            var newLastPage = Math.ceil(totalItems / _this.pager.pageSize);
	            if (newLastPage !== _this.lastPage) {
	                _this.lastPage = newLastPage;
	                _this.currentPage = 1;
	            }
	            _this.updatePaging();
	        };
	        if (this.containerService == null) {
	            return;
	        }
	        this.pager = this.containerService.pager;
	        if (this.pager == null) {
	            this.hasPageFilter = false;
	        }
	        else {
	            this.visiblePageCount = this.pageCount != null ? this.pageCount : exports.defaultVisiblePageCount;
	            this.lastPage = 1;
	            this.dataSource = this.containerService.dataSource;
	            $scope.$watch(function () { return _this.dataSource.count; }, this.updatePageCount);
	            $scope.$watch(function () { return _this.pager.pageSize; }, this.updatePageCount);
	            $scope.$watch(function () { return _this.currentPage; }, function (page) {
	                _this.updatePaging();
	                _this.pager.pageNumber = page;
	                _this.dataSource.refresh();
	            });
	        }
	    }
	    PagerController.prototype.updatePaging = function () {
	        var page = this.currentPage;
	        this.canGoBack = page > 1;
	        this.canGoForward = page < this.lastPage;
	        var nonCurrentVisiblePages = this.visiblePageCount - 1;
	        var before = Math.floor(nonCurrentVisiblePages / 2);
	        var after = Math.ceil(nonCurrentVisiblePages / 2);
	        var startPage = page - before;
	        var endPage = page + after;
	        if (startPage < 1) {
	            startPage = 1;
	            endPage = Math.min(this.visiblePageCount, this.lastPage);
	        }
	        else if (endPage > this.lastPage) {
	            endPage = this.lastPage;
	            startPage = Math.max(this.lastPage - nonCurrentVisiblePages, 1);
	        }
	        this.pages = _.range(startPage, endPage + 1);
	    };
	    PagerController.prototype.first = function () {
	        this.currentPage = 1;
	    };
	    PagerController.prototype.previous = function () {
	        if (this.currentPage > 1) {
	            this.currentPage--;
	        }
	    };
	    PagerController.prototype.goto = function (page) {
	        if (page >= 1 && page <= this.lastPage) {
	            this.currentPage = page;
	        }
	    };
	    PagerController.prototype.next = function () {
	        if (this.currentPage < this.lastPage) {
	            this.currentPage++;
	        }
	    };
	    PagerController.prototype.last = function () {
	        this.currentPage = this.lastPage;
	    };
	    PagerController.$inject = ['$scope'];
	    return PagerController;
	})();
	exports.PagerController = PagerController;
	function pager() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(78),
	        controller: exports.controllerName,
	        controllerAs: 'pager',
	        scope: {},
	        bindToController: {
	            pageCount: '=visiblePages',
	            containerService: '=',
	        },
	    };
	}
	exports.pager = pager;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, pager)
	    .controller(exports.controllerName, PagerController);
	//# sourceMappingURL=pager.js.map

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = "<nav ng-if=\"pager.hasPageFilter\">\r\n\t<ul class=\"pagination\">\r\n\t\t<li title=\"Go to first page\" ng-click=\"pager.first()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoBack }\">\r\n\t\t\t<a><i class=\"fa fa-angle-double-left\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to previous page\" ng-click=\"pager.previous()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoBack }\">\r\n\t\t\t<a><i class=\"fa fa-angle-left\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to page {{pager.page}}\" ng-click=\"pager.goto(page)\"\r\n\t\t\tng-repeat=\"page in pager.pages\"\r\n\t\t\tng-class=\"{ 'active': pager.currentPage == page }\">\r\n\t\t\t<a>{{page}}</a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to next page\" ng-click=\"pager.next()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoForward }\">\r\n\t\t\t<a><i class=\"fa fa-angle-right\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to last page\" ng-click=\"pager.last()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoForward }\">\r\n\t\t\t<a><i class=\"fa fa-angle-double-right\"></i></a>\r\n\t\t</li>\r\n\t</ul>\r\n</nav>\r\n"

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.pageSize';
	exports.directiveName = 'rlPageSize';
	exports.controllerName = 'PageSizeController';
	exports.availablePageSizes = [10, 25, 50, 100];
	exports.defaultPageSize = 10;
	var PageSizeController = (function () {
	    function PageSizeController($scope) {
	        var _this = this;
	        if (this.containerService == null) {
	            return;
	        }
	        this.selectedPageSize = exports.defaultPageSize;
	        this.pageSizes = exports.availablePageSizes;
	        this.hasPageFilter = true;
	        var pager = this.containerService.pager;
	        if (pager == null) {
	            this.hasPageFilter = false;
	        }
	        else {
	            $scope.$watch(function () { return _this.selectedPageSize; }, function (newPageSize) {
	                if (pager != null) {
	                    pager.pageSize = newPageSize;
	                    _this.containerService.dataSource.refresh();
	                }
	            });
	        }
	    }
	    PageSizeController.$inject = ['$scope'];
	    return PageSizeController;
	})();
	exports.PageSizeController = PageSizeController;
	function pageSize() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(80),
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            containerService: '=',
	        },
	    };
	}
	exports.pageSize = pageSize;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, pageSize)
	    .controller(exports.controllerName, PageSizeController);
	//# sourceMappingURL=pageSize.js.map

/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "<div ng-show=\"controller.hasPageFilter\">\r\n\t<select class=\"form-control\" title=\"Cards per page\" ng-model=\"controller.selectedPageSize\"\r\n\t\t\tng-options=\"pageSize for pageSize in controller.pageSizes\"></select>\r\n</div>\r\n"

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __boolean = typescript_angular_utilities_1.services.boolean;
	exports.moduleName = 'rl.ui.components.cardContainer.selectionControl';
	exports.directiveName = 'rlSelectionControl';
	exports.controllerName = 'SelectionControlController';
	var SelectionControlController = (function () {
	    function SelectionControlController($scope, bool) {
	        var _this = this;
	        this.$scope = $scope;
	        if (this.containerService == null) {
	            return;
	        }
	        this.selectedItems = this.containerService.numberSelected;
	        this.pagingEnabled = bool.toBool(this.containerService.pager);
	        this.dataSource = this.containerService.dataSource;
	        $scope.$watch(function () { return _this.containerService.numberSelected; }, function (value) {
	            _this.selectedItems = value;
	        });
	    }
	    SelectionControlController.prototype.selectPage = function () {
	        _.each(this.dataSource.dataSet, function (item) {
	            item.viewData.selected = true;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.selectAll = function () {
	        _.each(this.dataSource.filteredDataSet, function (item) {
	            item.viewData.selected = true;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.clearPage = function () {
	        _.each(this.dataSource.dataSet, function (item) {
	            item.viewData.selected = false;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.clearAll = function () {
	        _.each(this.dataSource.filteredDataSet, function (item) {
	            item.viewData.selected = false;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.$inject = ['$scope', __boolean.serviceName];
	    return SelectionControlController;
	})();
	exports.SelectionControlController = SelectionControlController;
	function selectionControl() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(82),
	        controller: exports.controllerName,
	        controllerAs: 'selection',
	        scope: {},
	        bindToController: {
	            containerService: '=',
	        },
	    };
	}
	exports.selectionControl = selectionControl;
	angular.module(exports.moduleName, [__boolean.moduleName])
	    .directive(exports.directiveName, selectionControl)
	    .controller(exports.controllerName, SelectionControlController);
	//# sourceMappingURL=selectionControl.js.map

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "<div>\r\n\t<div style=\"margin-bottom: 5px\">\r\n\t\t<span><strong>{{selection.selectedItems}}</strong> items selected</span>\r\n\t</div>\r\n\t<div style=\"margin-bottom: 5px\" ng-if=\"selection.pagingEnabled\">\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.selectPage()\">Select page</button>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.clearPage()\">Clear page</button>\r\n\t</div>\r\n\t<div>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.selectAll()\">Select all</button>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.clearAll()\">Clear all</button>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var __array = typescript_angular_utilities_1.services.array;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var dataSources_module_1 = __webpack_require__(49);
	var sorts_module_1 = __webpack_require__(50);
	var breakpoint_1 = __webpack_require__(43);
	var cardContainer_service_1 = __webpack_require__(84);
	exports.directiveName = 'rlCardContainer';
	exports.controllerName = 'CardContainerController';
	exports.defaultMaxColumnSorts = 2;
	exports.defaultSelectionTitle = 'Select card';
	var CardContainerController = (function () {
	    function CardContainerController($scope, $attrs, object, array, dataPagerFactory, parentChild) {
	        var _this = this;
	        this.$scope = $scope;
	        this.object = object;
	        this.array = array;
	        this.dataPagerFactory = dataPagerFactory;
	        this.parentChild = parentChild;
	        this.numberSelected = 0;
	        this.addViewData = function () {
	            _.each(_this.dataSource.rawDataSet, function (item) {
	                if (_.isUndefined(item.viewData)) {
	                    item.viewData = {
	                        selected: false,
	                    };
	                }
	            });
	            _this.updateDisabledSelections();
	        };
	        this.clearFilteredSelections = function () {
	            var nonVisibleItems = _.difference(_this.dataSource.rawDataSet, _this.dataSource.filteredDataSet);
	            _.each(nonVisibleItems, function (item) {
	                if (_.isUndefined(item.viewData)) {
	                    item.viewData = {
	                        selected: false,
	                    };
	                }
	                item.viewData.selected = false;
	                item.viewData.selectionTitle = exports.defaultSelectionTitle;
	            });
	            _this.updateSelected();
	        };
	        this.updateSelected = function () {
	            _this.numberSelected = _.filter(_this.dataSource.filteredDataSet, function (item) {
	                return item.viewData != null && item.viewData.selected;
	            }).length;
	        };
	        this.updateDisabledSelections = function () {
	            if (_this.disablingSelections) {
	                _.each(_this.dataSource.rawDataSet, function (item) {
	                    var disabledReason = _this.disableSelection({ item: item });
	                    item.viewData.disabledSelection = (disabledReason != null);
	                    item.viewData.selectionTitle = (item.viewData.disabledSelection ? disabledReason : exports.defaultSelectionTitle);
	                });
	            }
	        };
	        if (this.builder != null) {
	            this.builder.setCardContainerProperties(this);
	        }
	        this.dataSource = this.source;
	        this.permanentFooters = _.isUndefined(this.permanentFooters) ? false : this.permanentFooters;
	        this.maxColSorts = this.maxColumnSorts != null ? this.maxColumnSorts : exports.defaultMaxColumnSorts;
	        this.disablingSelections = object.isNullOrWhitespace($attrs.disableSelection) === false;
	        this.sortDirection = sorts_module_1.SortDirection;
	        this.syncFilters();
	        this.setupPaging();
	        this.buildColumnSizes();
	        if (this.selectableCards) {
	            //*use card container event service?
	            $scope.$on('selectionChanged', this.updateSelected);
	            $scope.$on('updateDisabledSelections', this.updateDisabledSelections);
	            this.dataSource.watch(this.addViewData, 'changed');
	            this.dataSource.watch(this.clearFilteredSelections, 'redrawing');
	            this.addViewData();
	            this.selectionColumn = {
	                label: null,
	                size: null,
	                getValue: function (item) {
	                    return item.viewData.selected;
	                },
	                flipSort: true,
	            };
	        }
	        if (this.dataSource.sorts == null) {
	            this.dataSource.sorts = [];
	        }
	        $scope.containerService = new cardContainer_service_1.CardContainerService(this);
	        $scope.containerData = this.containerData;
	    }
	    CardContainerController.prototype.sortSelected = function () {
	        this.sort(this.selectionColumn);
	    };
	    CardContainerController.prototype.openCard = function () {
	        var behaviors = this.parentChild.getAllChildBehaviors(this.dataSource.dataSet);
	        return _.all(_.map(behaviors, function (behavior) { return behavior.close(); }));
	    };
	    CardContainerController.prototype.sort = function (column) {
	        var sortList = this.dataSource.sorts;
	        var firstSort = sortList[0];
	        // If column is already the primary sort, change the direction
	        if (firstSort != null
	            && firstSort.column === column) {
	            firstSort.direction = sorts_module_1.SortDirection.toggle(firstSort.direction);
	            // Clear sort
	            if (firstSort.direction === sorts_module_1.SortDirection.none) {
	                this.clearVisualSortIndicator(firstSort);
	                firstSort = null;
	                // If the column has secondary sorts don't fall back to a
	                //  secondary sort, instead just clear all sorts
	                if (column.secondarySorts != null) {
	                    sortList.length = 0;
	                }
	                else {
	                    sortList.shift();
	                }
	            }
	        }
	        else {
	            // Else make column primary ascending sort
	            // Remove any existing non-primary sorts on column
	            this.array.remove(sortList, function (sort) {
	                return column === sort.column;
	            });
	            // Build ascending sort for column
	            var newSort = {
	                column: column,
	                direction: sorts_module_1.SortDirection.ascending,
	            };
	            sortList.unshift(newSort);
	            firstSort = newSort;
	        }
	        this.updateVisualColumnSorting();
	        // If column has secondary sorts, wipe the sort order and just apply the secondary sorts
	        if (firstSort != null && column.secondarySorts != null) {
	            sortList.length = 0;
	            var secondarySorts = this.buildSecondarySorts(firstSort.direction, column.secondarySorts);
	            sortList.push(firstSort);
	            sortList.push.apply(sortList, secondarySorts);
	        }
	        else {
	            // If not using column secondary sorts, limit the maximum number
	            //  of sorts applied to the maximum number of sorts
	            this.dataSource.sorts = _.take(sortList, this.maxColSorts);
	        }
	        this.dataSource.refresh();
	    };
	    CardContainerController.prototype.selectionChanged = function () {
	        this.updateSelected();
	        this.$scope.$emit('selectionChanged');
	    };
	    CardContainerController.prototype.syncFilters = function () {
	        if (this.filters != null) {
	            // Convert filter array to dictionary if necessary
	            if (_.isArray(this.filters)) {
	                this.filters = this.array.toDictionary(this.filters, function (filter) { return filter.type; });
	            }
	            this.dataSource.filters = this.filters;
	            this.dataSource.refresh();
	        }
	        else if (this.dataSource.filters != null) {
	            this.filters = this.dataSource.filters;
	        }
	    };
	    CardContainerController.prototype.setupPaging = function () {
	        // If paging flag is specified, card container controls pager instance
	        if (this.paging != null) {
	            if (this.paging === false) {
	                this.dataSource.pager = null;
	            }
	            else {
	                this.pager = this.dataPagerFactory.getInstance();
	                this.dataSource.pager = this.pager;
	            }
	        }
	        else if (this.dataSource.pager) {
	            // If the paging flag is not set and the dataSource has a pager, save a reference here
	            this.pager = this.dataSource.pager;
	        }
	    };
	    CardContainerController.prototype.buildColumnSizes = function () {
	        var _this = this;
	        _.each(this.columns, function (column) {
	            var sizes = column.size;
	            if (_.isObject(sizes)) {
	                sizes[breakpoint_1.xs] = _this.object.valueOrDefault(sizes[breakpoint_1.xs], 0);
	                sizes[breakpoint_1.sm] = _this.object.valueOrDefault(sizes[breakpoint_1.sm], sizes[breakpoint_1.xs]);
	                sizes[breakpoint_1.md] = _this.object.valueOrDefault(sizes[breakpoint_1.md], sizes[breakpoint_1.sm]);
	                sizes[breakpoint_1.lg] = _this.object.valueOrDefault(sizes[breakpoint_1.lg], sizes[breakpoint_1.md]);
	            }
	            else {
	                column.size = {
	                    xs: sizes,
	                    sm: sizes,
	                    md: sizes,
	                    lg: sizes,
	                };
	            }
	        });
	    };
	    CardContainerController.prototype.lookupColumn = function (label) {
	        return _.find(this.columns, function (column) {
	            return column.label === label;
	        });
	    };
	    CardContainerController.prototype.buildSecondarySorts = function (direction, secondarySorts) {
	        var _this = this;
	        var sortList = secondarySorts[sorts_module_1.SortDirection.getFullName(direction)];
	        return _.map(sortList, function (sort) {
	            return {
	                direction: sort.direction,
	                column: _this.lookupColumn(sort.column),
	            };
	        });
	    };
	    CardContainerController.prototype.updateVisualColumnSorting = function () {
	        var _this = this;
	        _.each(this.dataSource.sorts, function (sort, index) {
	            // Only first sort should have visible direction
	            if (index === 0) {
	                _this.updateVisualSortIndicator(sort);
	            }
	            else {
	                _this.clearVisualSortIndicator(sort);
	            }
	        });
	    };
	    CardContainerController.prototype.updateVisualSortIndicator = function (sort) {
	        sort.column.sortDirection = sort.direction;
	    };
	    CardContainerController.prototype.clearVisualSortIndicator = function (sort) {
	        sort.column.sortDirection = null;
	    };
	    CardContainerController.$inject = ['$scope', '$attrs', __object.serviceName, __array.serviceName, dataSources_module_1.dataPager.factoryName, __parentChild.serviceName];
	    return CardContainerController;
	})();
	exports.CardContainerController = CardContainerController;
	cardContainer.$inject = ['$compile'];
	function cardContainer($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(85),
	        controller: exports.controllerName,
	        controllerAs: 'cardContainer',
	        scope: {},
	        bindToController: {
	            // summary: a builder for the card container
	            builder: '=',
	            // summary: The data source for the card container
	            // remarks: Can be an array of objects, or an implementation of the data source contract: {
	            //     sorts: A list of sorts to apply to the data. Sorts should be in this format: {
	            //         column: The name of the column to sort on,
	            //         direction: Sort ascending or descending (sortDirection.js)
	            //     },
	            //     filters: A list of filters to apply to the data source,
	            //     pager: A pager that can be optionally used to page the data: {
	            //         filter: function(dataSet) {
	            //             Takes the data set and filters it down to pages
	            //         }
	            //     },
	            //     refresh: [function] Call to trigger the data source to refresh,
	            //     dataSet: Will contain the resulting data provided by the source, after sorts and filters are applied,
	            //     count: The number of items available in the data set (used for paging).
	            //     loadingDataSet: A boolean indicating if the dataSet is being refreshed / loaded,
	            // }
	            source: '=',
	            // summary: A list of filters to be applied to the data source
	            // remarks: Each filter should implement the data filter contract: {
	            //     type: A name that can be used to look up the filter,
	            //     filter: function(item) { takes an item and returns false if it should be removed from the data set },
	            // }
	            filters: '=',
	            // summary: Turn paging on or off (true / false)
	            paging: '=',
	            // summary: A list of the columns for building the column header and card headers.
	            // remarks: Each column object should be in the following format: {
	            //     label: The label for the column header,
	            //     description: A description for the column; shown in tooltips,
	            //     size: A description of the column size at breakpoints; either a constant int (for constant size) or breakpoint detail object: {
	            //         [xs]: optional size for xs breakpoint (defaults to 0),
	            //         [sm]: optional size for sm breakpoint (defaults to xs),
	            //         [md]: optional size for md breakpoint (defaults to sm),
	            //         [lg]: optional size for lg breakpoint (defaults to md),
	            //     },
	            //     getValue: A function that takes a data record and retrieves the value for the column,
	            //     headerTemplateUrl: The path to an HTML template for the column header,
	            //     headerTemplate: An HTML template string for the column header (overriden by headerTemplateUrl if present),
	            //     templateUrl: The path to an HTML template for the card header,
	            //     template: An HTML template string for the card header (overriden by templateUrl if present),
	            //     secondarySorts: A set of secondary sorts to apply on other columns when this column is sorted (ascending and / or descending): {
	            //        sortDirection.ascending ('asc'):  [
	            //             {
	            //                 column: The label of another column to sort on,
	            //                 direction: The direction to sort the column,
	            //             },
	            //             ...
	            //        ],
	            //        sortDirection.descending ('desc'): [
	            //             {
	            //                 column: The label of another column to sort on,
	            //                 direction: The direction to sort the column,
	            //             },
	            //             ...
	            //        ],
	            //     }
	            // }
	            columns: '=',
	            // summary: container-wide data available in cards
	            containerData: '=',
	            // summary: controller shared by all components on a card
	            // remarks: this controller cannot override any of the following variable names:
	            //          columns
	            //          item
	            //          contentTemplate
	            //          footerTemplate
	            //          clickable
	            //          cardController
	            //          cardControllerAs
	            //          cardAs
	            //          showContent
	            //          toggleContent
	            //          collapse
	            //          selected
	            //          setSelected
	            cardController: '@',
	            // summary: controller alias specified using controllerAs syntax
	            cardControllerAs: '@',
	            // summary: name used to access the card data
	            cardAs: '@',
	            // summary: Indicates if cards should show active state on mouse over
	            clickableCards: '=',
	            // summary: The number of sorts that can be applied at a time.
	            maxColumnSorts: '=',
	            permanentFooters: '=',
	            // summary: If true, turns on selection for cards via the cardData.viewData.selected property
	            selectableCards: '=',
	            // summary: Function called with each item. If true is returned selection is disabled for this item.
	            //          If function is not defined, selection is enabled for all by default.
	            disableSelection: '&',
	        },
	        link: function (scope, element, attrs, controller, transclude) {
	            var headerArea = element.find('.container-header-template');
	            var footerArea = element.find('.container-footer-template');
	            controller.makeCard = transclude;
	            transclude(scope, function (clone) {
	                var header = clone.filter('rl-container-header');
	                if (header.length === 0) {
	                    var defaultHeader = __webpack_require__(86);
	                    header = $compile(defaultHeader)(scope);
	                }
	                headerArea.append(header);
	                var footer = clone.filter('rl-container-footer');
	                if (footer.length === 0) {
	                    var defaultFooter = __webpack_require__(87);
	                    footer = $compile(defaultFooter)(scope);
	                }
	                footerArea.append(footer);
	            });
	        }
	    };
	}
	exports.cardContainer = cardContainer;
	//# sourceMappingURL=cardContainer.js.map

/***/ },
/* 84 */
/***/ function(module, exports) {

	var CardContainerService = (function () {
	    function CardContainerService(cardContainer) {
	        this.cardContainer = cardContainer;
	        this.pager = cardContainer.pager;
	        this.dataSource = cardContainer.dataSource;
	        this.filters = cardContainer.filters;
	    }
	    CardContainerService.prototype.lookupFilter = function (type) {
	        return this.filters[type];
	    };
	    Object.defineProperty(CardContainerService.prototype, "numberSelected", {
	        get: function () {
	            return this.cardContainer.numberSelected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CardContainerService;
	})();
	exports.CardContainerService = CardContainerService;
	//# sourceMappingURL=cardContainer.service.js.map

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = "<div class=\"card-container\">\r\n\t<div>\r\n\t\t<div class=\"card-container-header\">\r\n\t\t\t<div class=\"container-header-template\"></div>\r\n\t\t</div>\r\n\r\n\t\t<rl-generic-container selector=\"cardContainer.selectableCards\">\r\n\t\t\t<template when-selector=\"false\" default>\r\n\t\t\t\t<div class=\"card-columns-header\">\r\n\t\t\t\t\t<div ng-repeat=\"column in cardContainer.columns\">\r\n\t\t\t\t\t\t<rl-column-header sort=\"cardContainer.sort(column)\" sorting=\"column.sortDirection\" column=\"column\"></rl-column-header>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t</template>\r\n\t\t\t<template when-selector=\"true\">\r\n\t\t\t\t<div class=\"card-columns-header\">\r\n\t\t\t\t\t<div class=\"select-group\">\r\n\t\t\t\t\t\t<div class=\"select-column\">\r\n\t\t\t\t\t\t\t<i class=\"fa fa-check\" style=\"margin-left: 6px; cursor: pointer\" ng-click=\"cardContainer.sortSelected()\"></i>\r\n\t\t\t\t\t\t\t<i ng-show=\"cardContainer.sortColumn.sortDirection === cardContainer.sortDirection.ascending\" class=\"fa fa-sort-asc\"></i>\r\n\t\t\t\t\t\t\t<i ng-show=\"cardContainer.sortColumn.sortDirection === cardContainer.sortDirection.descending\" class=\"fa fa-sort-desc\"></i>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div class=\"select-content\">\r\n\t\t\t\t\t\t\t<div ng-repeat=\"column in cardContainer.columns\">\r\n\t\t\t\t\t\t\t\t<rl-column-header sort=\"cardContainer.sort(column)\" sorting=\"column.sortDirection\" column=\"column\"></rl-column-header>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t</template>\r\n\t\t</rl-generic-container>\r\n\r\n\t\t<div ng-repeat=\"card in cardContainer.dataSource.dataSet\">\r\n\t\t\t<rl-card columns=\"cardContainer.columns\" item=\"card\"\r\n\t\t\t\t\t clickable=\"cardContainer.clickableCards\"\r\n\t\t\t\t\t selectable=\"cardContainer.selectableCards\"\r\n\t\t\t\t\t selection-changed=\"cardContainer.selectionChanged()\"\r\n\t\t\t\t\t container-data=\"cardContainer.containerData\"\r\n\t\t\t\t\t source=\"cardContainer.dataSource\"\r\n\t\t\t\t\t permanent-footer=\"cardContainer.permanentFooters\"\r\n\t\t\t\t\t card-controller=\"cardContainer.cardController\"\r\n\t\t\t\t\t card-controller-as=\"cardContainer.cardControllerAs\"\r\n\t\t\t\t\t card-as=\"cardContainer.cardAs\"></rl-card>\r\n\t\t</div>\r\n\r\n\t\t<div>\r\n\t\t\t<rl-busy loading=\"cardContainer.dataSource.loadingDataSet\" size=\"2x\"></rl-busy>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"card-container-footer\">\r\n\t\t\t<div class=\"container-footer-template\"></div>\r\n\t\t</div>\r\n\t</div>\r\n</div>"

/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\r\n\t<div class=\"col-xs-12 col-sm-9\">\r\n\t\t<rl-card-search container-service=\"containerService\"></rl-card-search>\r\n\t</div>\r\n\t<div class=\"hidden-xs col-sm-3\">\r\n\t\t<rl-page-size container-service=\"containerService\"></rl-page-size>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 87 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\r\n\t<div ng-if=\"!cardContainer.selectableCards\" class=\"col-sm-6\">\r\n\t\t<rl-item-count container-service=\"containerService\"></rl-item-count>\r\n\t</div>\r\n\t<span ng-if=\"cardContainer.selectableCards\">\r\n\t\t<div class=\"col-sm-3\">\r\n\t\t\t<rl-selection-control container-service=\"containerService\"></rl-selection-control>\r\n\t\t</div>\r\n\t\t<div class=\"col-sm-3\">\r\n\t\t\t<rl-item-count container-service=\"containerService\"></rl-item-count>\r\n\t\t</div>\r\n\t</span>\r\n\t<div class=\"col-sm-6\">\r\n\t\t<rl-pager class=\"pull-right\" container-service=\"containerService\"></rl-pager>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __genericSearchFilter = typescript_angular_utilities_1.services.genericSearchFilter;
	var dataSources = __webpack_require__(49);
	var filterGroup = __webpack_require__(63);
	var selectFilter = __webpack_require__(71);
	var columnSearchFilter_service_1 = __webpack_require__(62);
	exports.factoryName = 'cardContainerBuilder';
	var CardContainerBuilder = (function () {
	    function CardContainerBuilder($injector) {
	        this.$injector = $injector;
	        this.dataSource = new DataSourceBuilder($injector, this);
	        this.filters = new FilterBuilder($injector, this);
	        this._columns = [];
	    }
	    CardContainerBuilder.prototype.useSearch = function (filter) {
	        if (filter == null) {
	            var factory = this.$injector.get(__genericSearchFilter.factoryName);
	            filter = factory.getInstance();
	        }
	        this._searchFilter = filter;
	        return this._searchFilter;
	    };
	    CardContainerBuilder.prototype.usePaging = function () {
	        this._paging = true;
	    };
	    CardContainerBuilder.prototype.addColumn = function (column) {
	        this._columns.push(column);
	    };
	    CardContainerBuilder.prototype.useClickableCards = function () {
	        this._clickableCards = true;
	    };
	    CardContainerBuilder.prototype.usePermanentFooters = function () {
	        this._permanentFooters = true;
	    };
	    CardContainerBuilder.prototype.useSelection = function () {
	        this._selectableCards = true;
	    };
	    Object.defineProperty(CardContainerBuilder.prototype, "disableSelection", {
	        set: function (value) {
	            if (!this._selectableCards) {
	                this.useSelection();
	            }
	            this._disableSelection = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CardContainerBuilder.prototype.setCardContainerProperties = function (cardContainer) {
	        if (this._searchFilter != null) {
	            this._filters.push(this._searchFilter);
	        }
	        cardContainer.source = this._dataSource;
	        cardContainer.filters = this._filters;
	        cardContainer.paging = this._paging;
	        cardContainer.columns = this._columns;
	        cardContainer.containerData = this.containerData;
	        cardContainer.cardController = this.cardController;
	        cardContainer.cardControllerAs = this.cardControllerAs;
	        cardContainer.cardAs = this.cardAs;
	        cardContainer.clickableCards = this._clickableCards;
	        cardContainer.maxColumnSorts = this.maxColumnSorts;
	        cardContainer.permanentFooters = this._permanentFooters;
	        cardContainer.selectableCards = this._selectableCards;
	        cardContainer.disableSelection = this._disableSelection;
	    };
	    return CardContainerBuilder;
	})();
	exports.CardContainerBuilder = CardContainerBuilder;
	var DataSourceBuilder = (function () {
	    function DataSourceBuilder($injector, parent) {
	        this.$injector = $injector;
	        this.parent = parent;
	        var factory = this.$injector.get(dataSources.simpleDataSource.factoryName);
	        parent._dataSource = factory.getInstance([]);
	    }
	    DataSourceBuilder.prototype.buildSimpleDataSource = function (data) {
	        var factory = this.$injector.get(dataSources.simpleDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(data);
	        return this.parent._dataSource;
	    };
	    DataSourceBuilder.prototype.buildDataServiceDataSource = function (getDataSet) {
	        var factory = this.$injector.get(dataSources.dataServiceDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(getDataSet);
	        return this.parent._dataSource;
	    };
	    DataSourceBuilder.prototype.buildServerSearchDataSource = function (getDataSet, getFilterModel, validateModel) {
	        if (_.isUndefined(this.parent._searchFilter)) {
	            this.parent.useSearch();
	        }
	        var factory = this.$injector.get(dataSources.serverSearchDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(getDataSet, this.parent._searchFilter, getFilterModel, validateModel);
	        return this.parent._dataSource;
	    };
	    return DataSourceBuilder;
	})();
	exports.DataSourceBuilder = DataSourceBuilder;
	var FilterBuilder = (function () {
	    function FilterBuilder($injector, parent) {
	        this.$injector = $injector;
	        this.parent = parent;
	        this.parent._filters = [];
	    }
	    FilterBuilder.prototype.buildFilterGroup = function (settings) {
	        var factory = this.$injector.get(filterGroup.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildModeFilterGroup = function (settings) {
	        var factory = this.$injector.get(filterGroup.modeFilterGroup.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildRangeFilterGroup = function (settings) {
	        var factory = this.$injector.get(filterGroup.rangeFilterGroup.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildSelectFilter = function (valueSelector) {
	        var factory = this.$injector.get(selectFilter.factoryName);
	        var filter = factory.getInstance(valueSelector);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildColumnSearchFilter = function () {
	        var factory = this.$injector.get(columnSearchFilter_service_1.factoryName);
	        var filter = factory.getInstance();
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.addCustomFilter = function (filter) {
	        this.parent._filters.push(filter);
	    };
	    return FilterBuilder;
	})();
	exports.FilterBuilder = FilterBuilder;
	cardContainerBuilderFactory.$inject = ['$injector'];
	function cardContainerBuilderFactory($injector) {
	    return {
	        getInstance: function () {
	            return new CardContainerBuilder($injector);
	        },
	    };
	}
	exports.cardContainerBuilderFactory = cardContainerBuilderFactory;
	//# sourceMappingURL=cardContainerBuilder.service.js.map

/***/ },
/* 89 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=column.js.map

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.checkbox';
	exports.directiveName = 'rlCheckbox';
	exports.controllerName = 'CheckboxController';
	var CheckboxController = (function () {
	    function CheckboxController($element) {
	        this.ngModel = $element.controller('ngModel');
	    }
	    Object.defineProperty(CheckboxController.prototype, "checked", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            this.ngModel.$setViewValue(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CheckboxController.$inject = ['$element'];
	    return CheckboxController;
	})();
	exports.CheckboxController = CheckboxController;
	function checkbox() {
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        transclude: true,
	        template: __webpack_require__(91),
	        controller: exports.controllerName,
	        controllerAs: 'checkbox',
	        scope: {},
	        bindToController: {
	            ngDisabled: '=',
	        },
	    };
	}
	exports.checkbox = checkbox;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, checkbox)
	    .controller(exports.controllerName, CheckboxController);
	//# sourceMappingURL=checkbox.js.map

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = "<label>\r\n\t<input type=\"checkbox\" ng-checked=\"checkbox.checked\" ng-disabled=\"checkbox.ngDisabled\" />\r\n\t<span ng-transclude></span>\r\n</label>"

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	exports.moduleName = 'rl.ui.components.commaList';
	exports.directiveName = 'rlCommaList';
	exports.controllerName = 'CommaListController';
	var CommaListController = (function () {
	    function CommaListController($attrs, object) {
	        this.remainingItems = 0;
	        this.hasTransform = object.isNullOrWhitespace($attrs.transform) === false;
	        this.list = this.getFirstItems(this.inList);
	    }
	    CommaListController.prototype.getFirstItems = function (list) {
	        var _this = this;
	        if (this.hasTransform) {
	            list = _.map(list, function (item) {
	                return _this.transform({ item: item });
	            });
	        }
	        ;
	        var newList;
	        if (this.max != null) {
	            newList = _.take(list, this.max);
	            this.remainingItems = list.length - this.max;
	        }
	        else {
	            newList = _.clone(list);
	        }
	        return newList;
	    };
	    CommaListController.$inject = ['$attrs', __object.serviceName];
	    return CommaListController;
	})();
	exports.CommaListController = CommaListController;
	function commaList() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<span>\n\t\t\t\t<span ng-repeat=\"item in commaList.list track by $index\">\n\t\t\t\t\t<span>{{item}}</span><span ng-hide=\"$last\">, </span>\n\t\t\t\t</span>\n\t\t\t\t<span ng-show=\"commaList.remainingItems > 0\">... {{commaList.remainingItems}} more items</span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'commaList',
	        scope: {},
	        bindToController: {
	            inList: '=list',
	            max: '=',
	            transform: '&',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, commaList)
	    .controller(exports.controllerName, CommaListController);
	//# sourceMappingURL=commaList.js.map

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// /// <reference path='../../../typings/bootstrapDateTimePicker.d.ts' />
	__webpack_require__(94);
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(13);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __dateTimeFormatStrings = typescript_angular_utilities_1.services.date;
	var __object = typescript_angular_utilities_1.services.object;
	var componentValidator_service_1 = __webpack_require__(99);
	exports.moduleName = 'rl.ui.components.dateTime';
	exports.directiveName = 'rlDateTime';
	exports.controllerName = 'DateTimeController';
	var DateTimeController = (function () {
	    function DateTimeController($scope, componentValidatorFactory) {
	        var _this = this;
	        var unregister = $scope.$watch(function () { return _this.ngModel; }, function (value) {
	            if (!_.isUndefined(_this.validator)) {
	                _this.dateTimeValidator = componentValidatorFactory.getInstance({
	                    ngModel: _this.ngModel,
	                    $scope: $scope,
	                    validators: [_this.validator],
	                });
	            }
	            unregister();
	        });
	    }
	    DateTimeController.$inject = ['$scope', componentValidator_service_1.factoryName];
	    return DateTimeController;
	})();
	exports.DateTimeController = DateTimeController;
	dateTime.$inject = [typescript_angular_utilities_1.services.moment.serviceName, __dateTimeFormatStrings.dateTimeFormatServiceName, __object.serviceName];
	function dateTime(moment, dateTimeFormatStrings, object) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(100),
	        require: '?^ngModel',
	        controller: exports.controllerName,
	        controllerAs: 'dateTime',
	        scope: {},
	        bindToController: {
	            minuteStepping: '=',
	            useDate: '=',
	            useTime: '=',
	            min: '=',
	            max: '=',
	            validator: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            var dateTime = scope.dateTime;
	            dateTime.ngModel = ngModel;
	            // defaults to true
	            var hasDate = _.isUndefined(dateTime.useDate) ? true : dateTime.useDate;
	            var hasTime = _.isUndefined(dateTime.useTime) ? true : dateTime.useTime;
	            var defaults = element.datetimepicker.defaults;
	            var min = dateTime.min != null ? dateTime.min : defaults.minDate;
	            var max = dateTime.max != null ? dateTime.max : defaults.maxDate;
	            scope.$watch(function () { return ngModel.$viewValue; }, function (newValue) {
	                dateTime.validFormat = object.isNullOrEmpty(newValue)
	                    ? true
	                    : moment(newValue).isValid();
	            });
	            // --- Implementation ---
	            element.datetimepicker({
	                stepping: dateTime.minuteStepping || 1,
	                format: dateTime.format || defaultFormat(hasDate, hasTime),
	                direction: 'bottom',
	                elementHeight: 32,
	                pickDate: hasDate,
	                pickTime: hasTime,
	                minDate: min,
	                maxDate: max,
	            }).on('change.dp', function () {
	                var newValue = $(this).find('input').val();
	                ngModel.$setViewValue(newValue);
	                scope.$apply();
	            });
	            function defaultFormat(hasDate, hasTime) {
	                if (hasDate && hasTime) {
	                    return dateTimeFormatStrings.dateTimeFormat;
	                }
	                else if (hasDate) {
	                    return dateTimeFormatStrings.dateFormat;
	                }
	                else if (hasTime) {
	                    return dateTimeFormatStrings.timeFormat;
	                }
	                else {
	                    // revert to default format
	                    return false;
	                }
	            }
	        },
	    };
	}
	angular.module(exports.moduleName, [typescript_angular_utilities_1.services.moment.moduleName, typescript_angular_utilities_1.services.date.moduleName, componentValidator_service_1.moduleName, __object.moduleName])
	    .directive(exports.directiveName, dateTime)
	    .controller(exports.controllerName, DateTimeController);
	//# sourceMappingURL=dateTime.js.map

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(95);
	__webpack_require__(97);

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(96);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(11)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./bootstrap-datetimepicker.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./bootstrap-datetimepicker.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(10)();
	// imports
	
	
	// module
	exports.push([module.id, "/*!\r\n * Datetimepicker for Bootstrap v3\r\n//! version : 3.1.3\r\n * https://github.com/Eonasdan/bootstrap-datetimepicker/\r\n */\r\n.bootstrap-datetimepicker-widget {\r\n  top: 0;\r\n  left: 0;\r\n  width: 250px;\r\n  padding: 4px;\r\n  margin-top: 1px;\r\n  z-index: 99999 !important;\r\n  border-radius: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget.timepicker-sbs {\r\n  width: 600px;\r\n}\r\n.bootstrap-datetimepicker-widget.bottom:before {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 7px solid transparent;\r\n  border-right: 7px solid transparent;\r\n  border-bottom: 7px solid #ccc;\r\n  border-bottom-color: rgba(0, 0, 0, 0.2);\r\n  position: absolute;\r\n  top: -7px;\r\n  left: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget.bottom:after {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 6px solid transparent;\r\n  border-right: 6px solid transparent;\r\n  border-bottom: 6px solid white;\r\n  position: absolute;\r\n  top: -6px;\r\n  left: 8px;\r\n}\r\n.bootstrap-datetimepicker-widget.top:before {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 7px solid transparent;\r\n  border-right: 7px solid transparent;\r\n  border-top: 7px solid #ccc;\r\n  border-top-color: rgba(0, 0, 0, 0.2);\r\n  position: absolute;\r\n  bottom: -7px;\r\n  left: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget.top:after {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 6px solid transparent;\r\n  border-right: 6px solid transparent;\r\n  border-top: 6px solid white;\r\n  position: absolute;\r\n  bottom: -6px;\r\n  left: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget .dow {\r\n  width: 14.2857%;\r\n}\r\n.bootstrap-datetimepicker-widget.pull-right:before {\r\n  left: auto;\r\n  right: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget.pull-right:after {\r\n  left: auto;\r\n  right: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget > ul {\r\n  list-style-type: none;\r\n  margin: 0;\r\n}\r\n.bootstrap-datetimepicker-widget a[data-action] {\r\n  padding: 0;\r\n}\r\n.bootstrap-datetimepicker-widget a[data-action]:active {\r\n  box-shadow: none;\r\n}\r\n.bootstrap-datetimepicker-widget .timepicker {\r\n  margin: 0 4px 4px 4px;\r\n}\r\n.bootstrap-datetimepicker-widget .timepicker-hour,\r\n.bootstrap-datetimepicker-widget .timepicker-minute,\r\n.bootstrap-datetimepicker-widget .timepicker-second {\r\n  width: 54px;\r\n  font-weight: bold;\r\n  font-size: 1.2em;\r\n  margin-top: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget button[data-action] {\r\n  padding: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget table[data-hour-format=\"12\"] .separator {\r\n  width: 4px;\r\n  padding: 0;\r\n  margin: 0;\r\n}\r\n.bootstrap-datetimepicker-widget .datepicker > div {\r\n  display: none;\r\n}\r\n.bootstrap-datetimepicker-widget .picker-switch {\r\n  text-align: center;\r\n}\r\n.bootstrap-datetimepicker-widget table {\r\n  width: 100%;\r\n  margin: 0;\r\n}\r\n.bootstrap-datetimepicker-widget td,\r\n.bootstrap-datetimepicker-widget th {\r\n  text-align: center;\r\n  border-radius: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget td {\r\n  height: 25px;\r\n  line-height: 25px;\r\n  width: 54px;\r\n}\r\n.bootstrap-datetimepicker-widget td.cw {\r\n  font-size: 10px;\r\n  height: 20px;\r\n  line-height: 20px;\r\n  color: #777777;\r\n}\r\n.bootstrap-datetimepicker-widget td.day {\r\n  height: 20px;\r\n  line-height: 20px;\r\n  width: 20px;\r\n}\r\n.bootstrap-datetimepicker-widget td.day:hover,\r\n.bootstrap-datetimepicker-widget td.hour:hover,\r\n.bootstrap-datetimepicker-widget td.minute:hover,\r\n.bootstrap-datetimepicker-widget td.second:hover {\r\n  background: #eeeeee;\r\n  cursor: pointer;\r\n}\r\n.bootstrap-datetimepicker-widget td.old,\r\n.bootstrap-datetimepicker-widget td.new {\r\n  color: #777777;\r\n}\r\n.bootstrap-datetimepicker-widget td.today {\r\n  position: relative;\r\n}\r\n.bootstrap-datetimepicker-widget td.today:before {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 7px solid transparent;\r\n  border-bottom: 7px solid #428bca;\r\n  border-top-color: rgba(0, 0, 0, 0.2);\r\n  position: absolute;\r\n  bottom: 4px;\r\n  right: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget td.active,\r\n.bootstrap-datetimepicker-widget td.active:hover {\r\n  background-color: #428bca;\r\n  color: #ffffff;\r\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\r\n}\r\n.bootstrap-datetimepicker-widget td.active.today:before {\r\n  border-bottom-color: #fff;\r\n}\r\n.bootstrap-datetimepicker-widget td.disabled,\r\n.bootstrap-datetimepicker-widget td.disabled:hover {\r\n  background: none;\r\n  color: #777777;\r\n  cursor: not-allowed;\r\n}\r\n.bootstrap-datetimepicker-widget td span {\r\n  display: inline-block;\r\n  width: 54px;\r\n  height: 25px;\r\n  line-height: 25px;\r\n  margin: 0px 1.5px;\r\n  cursor: pointer;\r\n  border-radius: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget td span:hover {\r\n  background: #eeeeee;\r\n}\r\n.bootstrap-datetimepicker-widget td span.active {\r\n  background-color: #428bca;\r\n  color: #ffffff;\r\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\r\n}\r\n.bootstrap-datetimepicker-widget td span.old {\r\n  color: #777777;\r\n}\r\n.bootstrap-datetimepicker-widget td span.disabled,\r\n.bootstrap-datetimepicker-widget td span.disabled:hover {\r\n  background: none;\r\n  color: #777777;\r\n  cursor: not-allowed;\r\n}\r\n.bootstrap-datetimepicker-widget th {\r\n  height: 20px;\r\n  line-height: 20px;\r\n  width: 20px;\r\n}\r\n.bootstrap-datetimepicker-widget th.picker-switch {\r\n  width: 145px;\r\n}\r\n.bootstrap-datetimepicker-widget th.next,\r\n.bootstrap-datetimepicker-widget th.prev {\r\n  font-size: 21px;\r\n}\r\n.bootstrap-datetimepicker-widget th.disabled,\r\n.bootstrap-datetimepicker-widget th.disabled:hover {\r\n  background: none;\r\n  color: #777777;\r\n  cursor: not-allowed;\r\n}\r\n.bootstrap-datetimepicker-widget thead tr:first-child th {\r\n  cursor: pointer;\r\n}\r\n.bootstrap-datetimepicker-widget thead tr:first-child th:hover {\r\n  background: #eeeeee;\r\n}\r\n.input-group.date .input-group-addon span {\r\n  display: block;\r\n  cursor: pointer;\r\n  width: 16px;\r\n  height: 16px;\r\n}\r\n.bootstrap-datetimepicker-widget.left-oriented:before {\r\n  left: auto;\r\n  right: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget.left-oriented:after {\r\n  left: auto;\r\n  right: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget ul.list-unstyled li div.timepicker div.timepicker-picker table.table-condensed tbody > tr > td {\r\n  padding: 0px !important;\r\n}\r\n@media screen and (max-width: 767px) {\r\n  .bootstrap-datetimepicker-widget.timepicker-sbs {\r\n    width: 283px;\r\n  }\r\n}\r\n", ""]);
	
	// exports


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	//! version : 3.1.3
	=========================================================
	bootstrap-datetimepicker.js
	https://github.com/Eonasdan/bootstrap-datetimepicker
	=========================================================
	The MIT License (MIT)
	
	Copyright (c) 2014 Jonathan Peterson
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/
	; (function (root, factory) {
		'use strict';
		if (true) {
			// AMD is used - Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(13), __webpack_require__(98)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			factory(require('jquery'), require('moment'));
		}
		else {
			// Neither AMD or CommonJS used. Use global variables.
			if (!jQuery) {
				throw new Error('bootstrap-datetimepicker requires jQuery to be loaded first');
			}
			if (!moment) {
				throw new Error('bootstrap-datetimepicker requires moment.js to be loaded first');
			}
			factory(root.jQuery, moment);
		}
	}(this, function ($, moment) {
		'use strict';
		if (typeof moment === 'undefined') {
			throw new Error('momentjs is required');
		}
	
		var dpgId = 0,
	
	    DateTimePicker = function (element, options) {
	    	var defaults = $.fn.datetimepicker.defaults,
	
	            icons = {
	            	time: 'fa fa-clock-o',
	            	date: 'fa fa-calendar',
	            	up: 'fa fa-chevron-up',
	            	down: 'fa fa-chevron-down'
	            },
	
	            picker = this,
	            errored = false,
	            dDate,
	
	        init = function () {
	        	var icon = false, localeData, rInterval;
	        	picker.options = $.extend({}, defaults, options);
	        	picker.options.icons = $.extend({}, icons, picker.options.icons);
	
	        	picker.element = $(element);
	
	        	dataToOptions();
	
	        	if (!(picker.options.pickTime || picker.options.pickDate)) {
	        		throw new Error('Must choose at least one picker');
	        	}
	
	        	picker.id = dpgId++;
	        	moment.locale(picker.options.language);
	        	picker.date = moment();
	        	picker.unset = false;
	        	picker.isInput = picker.element.is('input');
	        	picker.component = false;
	
	        	if (picker.element.hasClass('input-group')) {
	        		if (picker.element.find('.datepickerbutton').size() === 0) {//in case there is more then one 'input-group-addon' Issue #48
	        			picker.component = picker.element.find('[class^="input-group-"]');
	        		}
	        		else {
	        			picker.component = picker.element.find('.datepickerbutton');
	        		}
	        	}
	        	picker.format = picker.options.format;
	
	        	localeData = moment().localeData();
	
	        	if (!picker.format) {
	        		picker.format = (picker.options.pickDate ? localeData.longDateFormat('L') : '');
	        		if (picker.options.pickDate && picker.options.pickTime) {
	        			picker.format += ' ';
	        		}
	        		picker.format += (picker.options.pickTime ? localeData.longDateFormat('LT') : '');
	        		if (picker.options.useSeconds) {
	        			if (localeData.longDateFormat('LT').indexOf(' A') !== -1) {
	        				picker.format = picker.format.split(' A')[0] + ':ss A';
	        			}
	        			else {
	        				picker.format += ':ss';
	        			}
	        		}
	        	}
	        	picker.use24hours = (picker.format.toLowerCase().indexOf('a') < 0 && picker.format.indexOf('h') < 0);
	
	        	if (picker.component) {
	        		icon = picker.component.find('span');
	        	}
	
	        	if (picker.options.pickTime) {
	        		if (icon) {
	        			icon.addClass(picker.options.icons.time);
	        		}
	        	}
	        	if (picker.options.pickDate) {
	        		if (icon) {
	        			icon.removeClass(picker.options.icons.time);
	        			icon.addClass(picker.options.icons.date);
	        		}
	        	}
	
	        	picker.options.widgetParent =
	                typeof picker.options.widgetParent === 'string' && picker.options.widgetParent ||
	                picker.element.parents().filter(function () {
	                	return 'scroll' === $(this).css('overflow-y');
	                }).get(0) ||
	                'body';
	
	        	picker.widget = $(getTemplate()).appendTo(picker.options.widgetParent);
	
	        	picker.minViewMode = picker.options.minViewMode || 0;
	        	if (typeof picker.minViewMode === 'string') {
	        		switch (picker.minViewMode) {
	        			case 'months':
	        				picker.minViewMode = 1;
	        				break;
	        			case 'years':
	        				picker.minViewMode = 2;
	        				break;
	        			default:
	        				picker.minViewMode = 0;
	        				break;
	        		}
	        	}
	        	picker.viewMode = picker.options.viewMode || 0;
	        	if (typeof picker.viewMode === 'string') {
	        		switch (picker.viewMode) {
	        			case 'months':
	        				picker.viewMode = 1;
	        				break;
	        			case 'years':
	        				picker.viewMode = 2;
	        				break;
	        			default:
	        				picker.viewMode = 0;
	        				break;
	        		}
	        	}
	
	        	picker.viewMode = Math.max(picker.viewMode, picker.minViewMode);
	
	        	picker.options.disabledDates = indexGivenDates(picker.options.disabledDates);
	        	picker.options.enabledDates = indexGivenDates(picker.options.enabledDates);
	
	        	picker.startViewMode = picker.viewMode;
	        	picker.setMinDate(picker.options.minDate);
	        	picker.setMaxDate(picker.options.maxDate);
	        	fillDow();
	        	fillMonths();
	        	fillHours();
	        	fillMinutes();
	        	fillSeconds();
	        	update();
	        	showMode();
	        	if (!getPickerInput().prop('disabled')) {
	        		attachDatePickerEvents();
	        	}
	        	if (picker.options.defaultDate !== '' && getPickerInput().val() === '') {
	        		picker.setValue(picker.options.defaultDate);
	        	}
	        	if (picker.options.minuteStepping !== 1) {
	        		rInterval = picker.options.minuteStepping;
	        		picker.date.minutes((Math.round(picker.date.minutes() / rInterval) * rInterval) % 60).seconds(0);
	        	}
	        },
	
	        getPickerInput = function () {
	        	var input;
	
	        	if (picker.isInput) {
	        		return picker.element;
	        	}
	        	input = picker.element.find('.datepickerinput');
	        	if (input.size() === 0) {
	        		input = picker.element.find('input');
	        	}
	        	else if (!input.is('input')) {
	        		throw new Error('CSS class "datepickerinput" cannot be applied to non input element');
	        	}
	        	return input;
	        },
	
	        dataToOptions = function () {
	        	var eData;
	        	if (picker.element.is('input')) {
	        		eData = picker.element.data();
	        	}
	        	else {
	        		eData = picker.element.find('input').data();
	        	}
	        	if (eData.dateFormat !== undefined) {
	        		picker.options.format = eData.dateFormat;
	        	}
	        	if (eData.datePickdate !== undefined) {
	        		picker.options.pickDate = eData.datePickdate;
	        	}
	        	if (eData.datePicktime !== undefined) {
	        		picker.options.pickTime = eData.datePicktime;
	        	}
	        	if (eData.dateUseminutes !== undefined) {
	        		picker.options.useMinutes = eData.dateUseminutes;
	        	}
	        	if (eData.dateUseseconds !== undefined) {
	        		picker.options.useSeconds = eData.dateUseseconds;
	        	}
	        	if (eData.dateUsecurrent !== undefined) {
	        		picker.options.useCurrent = eData.dateUsecurrent;
	        	}
	        	if (eData.calendarWeeks !== undefined) {
	        		picker.options.calendarWeeks = eData.calendarWeeks;
	        	}
	        	if (eData.dateMinutestepping !== undefined) {
	        		picker.options.minuteStepping = eData.dateMinutestepping;
	        	}
	        	if (eData.dateMindate !== undefined) {
	        		picker.options.minDate = eData.dateMindate;
	        	}
	        	if (eData.dateMaxdate !== undefined) {
	        		picker.options.maxDate = eData.dateMaxdate;
	        	}
	        	if (eData.dateShowtoday !== undefined) {
	        		picker.options.showToday = eData.dateShowtoday;
	        	}
	        	if (eData.dateCollapse !== undefined) {
	        		picker.options.collapse = eData.dateCollapse;
	        	}
	        	if (eData.dateLanguage !== undefined) {
	        		picker.options.language = eData.dateLanguage;
	        	}
	        	if (eData.dateDefaultdate !== undefined) {
	        		picker.options.defaultDate = eData.dateDefaultdate;
	        	}
	        	if (eData.dateDisableddates !== undefined) {
	        		picker.options.disabledDates = eData.dateDisableddates;
	        	}
	        	if (eData.dateEnableddates !== undefined) {
	        		picker.options.enabledDates = eData.dateEnableddates;
	        	}
	        	if (eData.dateIcons !== undefined) {
	        		picker.options.icons = eData.dateIcons;
	        	}
	        	if (eData.dateUsestrict !== undefined) {
	        		picker.options.useStrict = eData.dateUsestrict;
	        	}
	        	if (eData.dateDirection !== undefined) {
	        		picker.options.direction = eData.dateDirection;
	        	}
	        	if (eData.dateSidebyside !== undefined) {
	        		picker.options.sideBySide = eData.dateSidebyside;
	        	}
	        	if (eData.dateDaysofweekdisabled !== undefined) {
	        		picker.options.daysOfWeekDisabled = eData.dateDaysofweekdisabled;
	        	}
	        },
	
	        place = function () {
	        	var position = 'absolute',
	                offset = picker.component ? picker.component.offset() : picker.element.offset(),
	                $window = $(window),
	                placePosition;
	
	        	picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
	        	offset.top = offset.top + picker.element.outerHeight();
	
	        	if (picker.options.direction === 'up') {
	        		placePosition = 'top';
	        	} else if (picker.options.direction === 'bottom') {
	        		placePosition = 'bottom';
	        	} else if (picker.options.direction === 'auto') {
	        		if (offset.top + picker.widget.height() > $window.height() + $window.scrollTop() && picker.widget.height() + picker.element.outerHeight() < offset.top) {
	        			placePosition = 'top';
	        		} else {
	        			placePosition = 'bottom';
	        		}
	        	}
	        	if (placePosition === 'top') {
	        		offset.bottom = $window.height() - offset.top + picker.element.outerHeight() + 3;
	        		picker.widget.addClass('top').removeClass('bottom');
	        	} else {
	        		offset.top += 1;
	        		offset.top += picker.options.elementHeight;
	        		picker.widget.addClass('bottom').removeClass('top');
	        	}
	
	        	if (picker.options.width !== undefined) {
	        		picker.widget.width(picker.options.width);
	        	}
	
	        	if (picker.options.orientation === 'left') {
	        		picker.widget.addClass('left-oriented');
	        		offset.left = offset.left - picker.widget.width() + 20;
	        	}
	
	        	if (isInFixed()) {
	        		position = 'fixed';
	        		offset.top -= $window.scrollTop();
	        		offset.left -= $window.scrollLeft();
	        	}
	
	        	if ($window.width() < offset.left + picker.widget.outerWidth()) {
	        		offset.right = $window.width() - offset.left - picker.width;
	        		offset.left = 'auto';
	        		picker.widget.addClass('pull-right');
	        	} else {
	        		offset.right = 'auto';
	        		picker.widget.removeClass('pull-right');
	        	}
	
	        	if (placePosition === 'top') {
	        		picker.widget.css({
	        			position: position,
	        			bottom: offset.bottom,
	        			top: 'auto',
	        			left: offset.left,
	        			right: offset.right
	        		});
	        	} else {
	        		picker.widget.css({
	        			position: position,
	        			top: offset.top,
	        			bottom: 'auto',
	        			left: offset.left,
	        			right: offset.right
	        		});
	        	}
	        },
	
	        notifyChange = function (oldDate, eventType) {
	        	if (moment(picker.date).isSame(moment(oldDate)) && !errored) {
	        		return;
	        	}
	        	errored = false;
	        	picker.element.trigger({
	        		type: 'dp.change',
	        		date: moment(picker.date),
	        		oldDate: moment(oldDate)
	        	});
	
	        	if (eventType !== 'change') {
	        		picker.element.change();
	        	}
	        },
	
	        notifyError = function (date) {
	        	errored = true;
	        	picker.element.trigger({
	        		type: 'dp.error',
	        		date: moment(date, picker.format, picker.options.useStrict)
	        	});
	        },
	
	        update = function (newDate) {
	        	moment.locale(picker.options.language);
	        	var dateStr = newDate;
	        	if (!dateStr) {
	        		dateStr = getPickerInput().val();
	        		if (dateStr) {
	        			picker.date = moment(dateStr, picker.format, picker.options.useStrict);
	        		}
	        		if (!picker.date) {
	        			picker.date = moment();
	        		}
	        	}
	        	picker.viewDate = moment(picker.date).startOf('month');
	        	fillDate();
	        	fillTime();
	        },
	
	        fillDow = function () {
	        	moment.locale(picker.options.language);
	        	var html = $('<tr>'), weekdaysMin = moment.weekdaysMin(), i;
	        	if (picker.options.calendarWeeks === true) {
	        		html.append('<th class="cw">#</th>');
	        	}
	        	if (moment().localeData()._week.dow === 0) { // starts on Sunday
	        		for (i = 0; i < 7; i++) {
	        			html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
	        		}
	        	} else {
	        		for (i = 1; i < 8; i++) {
	        			if (i === 7) {
	        				html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
	        			} else {
	        				html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
	        			}
	        		}
	        	}
	        	picker.widget.find('.datepicker-days thead').append(html);
	        },
	
	        fillMonths = function () {
	        	moment.locale(picker.options.language);
	        	var html = '', i, monthsShort = moment.monthsShort();
	        	for (i = 0; i < 12; i++) {
	        		html += '<span class="month">' + monthsShort[i] + '</span>';
	        	}
	        	picker.widget.find('.datepicker-months td').append(html);
	        },
	
	        fillDate = function () {
	        	if (!picker.options.pickDate) {
	        		return;
	        	}
	        	moment.locale(picker.options.language);
	        	var year = picker.viewDate.year(),
	                month = picker.viewDate.month(),
	                startYear = picker.options.minDate.year(),
	                startMonth = picker.options.minDate.month(),
	                endYear = picker.options.maxDate.year(),
	                endMonth = picker.options.maxDate.month(),
	                currentDate,
	                prevMonth, nextMonth, html = [], row, clsName, i, days, yearCont, currentYear, months = moment.months();
	
	        	picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
	        	picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
	        	picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');
	
	        	picker.widget.find('.datepicker-days th:eq(1)').text(
	                months[month] + ' ' + year);
	
	        	prevMonth = moment(picker.viewDate, picker.format, picker.options.useStrict).subtract(1, 'months');
	        	days = prevMonth.daysInMonth();
	        	prevMonth.date(days).startOf('week');
	        	if ((year === startYear && month <= startMonth) || year < startYear) {
	        		picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
	        	}
	        	if ((year === endYear && month >= endMonth) || year > endYear) {
	        		picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
	        	}
	
	        	nextMonth = moment(prevMonth).add(42, 'd');
	        	while (prevMonth.isBefore(nextMonth)) {
	        		if (prevMonth.weekday() === moment().startOf('week').weekday()) {
	        			row = $('<tr>');
	        			html.push(row);
	        			if (picker.options.calendarWeeks === true) {
	        				row.append('<td class="cw">' + prevMonth.week() + '</td>');
	        			}
	        		}
	        		clsName = '';
	        		if (prevMonth.year() < year || (prevMonth.year() === year && prevMonth.month() < month)) {
	        			clsName += ' old';
	        		} else if (prevMonth.year() > year || (prevMonth.year() === year && prevMonth.month() > month)) {
	        			clsName += ' new';
	        		}
	        		if (prevMonth.isSame(moment({ y: picker.date.year(), M: picker.date.month(), d: picker.date.date() }))) {
	        			clsName += ' active';
	        		}
	        		if (isInDisableDates(prevMonth, 'day') || !isInEnableDates(prevMonth)) {
	        			clsName += ' disabled';
	        		}
	        		if (picker.options.showToday === true) {
	        			if (prevMonth.isSame(moment(), 'day')) {
	        				clsName += ' today';
	        			}
	        		}
	        		if (picker.options.daysOfWeekDisabled) {
	        			for (i = 0; i < picker.options.daysOfWeekDisabled.length; i++) {
	        				if (prevMonth.day() === picker.options.daysOfWeekDisabled[i]) {
	        					clsName += ' disabled';
	        					break;
	        				}
	        			}
	        		}
	        		row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');
	
	        		currentDate = prevMonth.date();
	        		prevMonth.add(1, 'd');
	
	        		if (currentDate === prevMonth.date()) {
	        			prevMonth.add(1, 'd');
	        		}
	        	}
	        	picker.widget.find('.datepicker-days tbody').empty().append(html);
	        	currentYear = picker.date.year();
	        	months = picker.widget.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');
	        	if (currentYear === year) {
	        		months.eq(picker.date.month()).addClass('active');
	        	}
	        	if (year - 1 < startYear) {
	        		picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
	        	}
	        	if (year + 1 > endYear) {
	        		picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
	        	}
	        	for (i = 0; i < 12; i++) {
	        		if ((year === startYear && startMonth > i) || (year < startYear)) {
	        			$(months[i]).addClass('disabled');
	        		} else if ((year === endYear && endMonth < i) || (year > endYear)) {
	        			$(months[i]).addClass('disabled');
	        		}
	        	}
	
	        	html = '';
	        	year = parseInt(year / 10, 10) * 10;
	        	yearCont = picker.widget.find('.datepicker-years').find(
	                'th:eq(1)').text(year + '-' + (year + 9)).parents('table').find('td');
	        	picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
	        	if (startYear > year) {
	        		picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
	        	}
	        	if (endYear < year + 9) {
	        		picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
	        	}
	        	year -= 1;
	        	for (i = -1; i < 11; i++) {
	        		html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
	        		year += 1;
	        	}
	        	yearCont.html(html);
	        },
	
	        fillHours = function () {
	        	moment.locale(picker.options.language);
	        	var table = picker.widget.find('.timepicker .timepicker-hours table'), html = '', current, i, j;
	        	table.parent().hide();
	        	if (picker.use24hours) {
	        		current = 0;
	        		for (i = 0; i < 6; i += 1) {
	        			html += '<tr>';
	        			for (j = 0; j < 4; j += 1) {
	        				html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
	        				current++;
	        			}
	        			html += '</tr>';
	        		}
	        	}
	        	else {
	        		current = 1;
	        		for (i = 0; i < 3; i += 1) {
	        			html += '<tr>';
	        			for (j = 0; j < 4; j += 1) {
	        				html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
	        				current++;
	        			}
	        			html += '</tr>';
	        		}
	        	}
	        	table.html(html);
	        },
	
	        fillMinutes = function () {
	        	var table = picker.widget.find('.timepicker .timepicker-minutes table'), html = '', current = 0, i, j, step = picker.options.minuteStepping;
	        	table.parent().hide();
	        	if (step === 1) {
	        		step = 5;
	        	}
	        	for (i = 0; i < Math.ceil(60 / step / 4) ; i++) {
	        		html += '<tr>';
	        		for (j = 0; j < 4; j += 1) {
	        			if (current < 60) {
	        				html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
	        				current += step;
	        			} else {
	        				html += '<td></td>';
	        			}
	        		}
	        		html += '</tr>';
	        	}
	        	table.html(html);
	        },
	
	        fillSeconds = function () {
	        	var table = picker.widget.find('.timepicker .timepicker-seconds table'), html = '', current = 0, i, j;
	        	table.parent().hide();
	        	for (i = 0; i < 3; i++) {
	        		html += '<tr>';
	        		for (j = 0; j < 4; j += 1) {
	        			html += '<td class="second">' + padLeft(current.toString()) + '</td>';
	        			current += 5;
	        		}
	        		html += '</tr>';
	        	}
	        	table.html(html);
	        },
	
	        fillTime = function () {
	        	if (!picker.date) {
	        		return;
	        	}
	        	var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
	                hour = picker.date.hours(),
	                period = picker.date.format('A');
	        	if (!picker.use24hours) {
	        		if (hour === 0) {
	        			hour = 12;
	        		} else if (hour !== 12) {
	        			hour = hour % 12;
	        		}
	        		picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
	        	}
	        	timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
	        	timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
	        	timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
	        },
	
	        click = function (e) {
	        	e.stopPropagation();
	        	e.preventDefault();
	        	picker.unset = false;
	        	var target = $(e.target).closest('span, td, th'), month, year, step, day, oldDate = moment(picker.date);
	        	if (target.length === 1) {
	        		if (!target.is('.disabled')) {
	        			switch (target[0].nodeName.toLowerCase()) {
	        				case 'th':
	        					switch (target[0].className) {
	        						case 'picker-switch':
	        							showMode(1);
	        							break;
	        						case 'prev':
	        						case 'next':
	        							step = dpGlobal.modes[picker.viewMode].navStep;
	        							if (target[0].className === 'prev') {
	        								step = step * -1;
	        							}
	        							picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
	        							fillDate();
	        							break;
	        					}
	        					break;
	        				case 'span':
	        					if (target.is('.month')) {
	        						month = target.parent().find('span').index(target);
	        						picker.viewDate.month(month);
	        					} else {
	        						year = parseInt(target.text(), 10) || 0;
	        						picker.viewDate.year(year);
	        					}
	        					if (picker.viewMode === picker.minViewMode) {
	        						picker.date = moment({
	        							y: picker.viewDate.year(),
	        							M: picker.viewDate.month(),
	        							d: picker.viewDate.date(),
	        							h: picker.date.hours(),
	        							m: picker.date.minutes(),
	        							s: picker.date.seconds()
	        						});
	        						set();
	        						notifyChange(oldDate, e.type);
	        					}
	        					showMode(-1);
	        					fillDate();
	        					break;
	        				case 'td':
	        					if (target.is('.day')) {
	        						day = parseInt(target.text(), 10) || 1;
	        						month = picker.viewDate.month();
	        						year = picker.viewDate.year();
	        						if (target.is('.old')) {
	        							if (month === 0) {
	        								month = 11;
	        								year -= 1;
	        							} else {
	        								month -= 1;
	        							}
	        						} else if (target.is('.new')) {
	        							if (month === 11) {
	        								month = 0;
	        								year += 1;
	        							} else {
	        								month += 1;
	        							}
	        						}
	        						picker.date = moment({
	        							y: year,
	        							M: month,
	        							d: day,
	        							h: picker.date.hours(),
	        							m: picker.date.minutes(),
	        							s: picker.date.seconds()
	        						}
	                                );
	        						picker.viewDate = moment({
	        							y: year, M: month, d: Math.min(28, day)
	        						});
	        						fillDate();
	        						set();
	        						notifyChange(oldDate, e.type);
	        					}
	        					break;
	        			}
	        		}
	        	}
	        },
	
	        actions = {
	        	incrementHours: function () {
	        		checkDate('add', 'hours', 1);
	        	},
	
	        	incrementMinutes: function () {
	        		checkDate('add', 'minutes', picker.options.minuteStepping);
	        	},
	
	        	incrementSeconds: function () {
	        		checkDate('add', 'seconds', 1);
	        	},
	
	        	decrementHours: function () {
	        		checkDate('subtract', 'hours', 1);
	        	},
	
	        	decrementMinutes: function () {
	        		checkDate('subtract', 'minutes', picker.options.minuteStepping);
	        	},
	
	        	decrementSeconds: function () {
	        		checkDate('subtract', 'seconds', 1);
	        	},
	
	        	togglePeriod: function () {
	        		var hour = picker.date.hours();
	        		if (hour >= 12) {
	        			hour -= 12;
	        		} else {
	        			hour += 12;
	        		}
	        		picker.date.hours(hour);
	        	},
	
	        	showPicker: function () {
	        		picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
	        		picker.widget.find('.timepicker .timepicker-picker').show();
	        	},
	
	        	showHours: function () {
	        		picker.widget.find('.timepicker .timepicker-picker').hide();
	        		picker.widget.find('.timepicker .timepicker-hours').show();
	        	},
	
	        	showMinutes: function () {
	        		picker.widget.find('.timepicker .timepicker-picker').hide();
	        		picker.widget.find('.timepicker .timepicker-minutes').show();
	        	},
	
	        	showSeconds: function () {
	        		picker.widget.find('.timepicker .timepicker-picker').hide();
	        		picker.widget.find('.timepicker .timepicker-seconds').show();
	        	},
	
	        	selectHour: function (e) {
	        		var hour = parseInt($(e.target).text(), 10);
	        		if (!picker.use24hours) {
	        			if (picker.date.hours() >= 12) {
	        				if (hour !== 12) {
	        					hour += 12;
	        				}
	        			} else {
	        				if (hour === 12) {
	        					hour = 0;
	        				}
	        			}
	        		}
	        		picker.date.hours(hour);
	        		actions.showPicker.call(picker);
	        	},
	
	        	selectMinute: function (e) {
	        		picker.date.minutes(parseInt($(e.target).text(), 10));
	        		actions.showPicker.call(picker);
	        	},
	
	        	selectSecond: function (e) {
	        		picker.date.seconds(parseInt($(e.target).text(), 10));
	        		actions.showPicker.call(picker);
	        	}
	        },
	
	        doAction = function (e) {
	        	var oldDate = moment(picker.date),
	                action = $(e.currentTarget).data('action'),
	                rv = actions[action].apply(picker, arguments);
	        	stopEvent(e);
	        	if (!picker.date) {
	        		picker.date = moment({ y: 1970 });
	        	}
	        	set();
	        	fillTime();
	        	notifyChange(oldDate, e.type);
	        	return rv;
	        },
	
	        stopEvent = function (e) {
	        	e.stopPropagation();
	        	e.preventDefault();
	        },
	
	        keydown = function (e) {
	        	if (e.keyCode === 27) { // allow escape to hide picker
	        		picker.hide();
	        	}
	        },
	
	        change = function (e) {
	        	moment.locale(picker.options.language);
	        	var input = $(e.target), oldDate = moment(picker.date), newDate = moment(input.val(), picker.format, picker.options.useStrict);
	        	if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
	        		update();
	        		picker.setValue(newDate);
	        		notifyChange(oldDate, e.type);
	        		set();
	        	}
	        	else {
	        		picker.viewDate = oldDate;
	        		picker.unset = true;
	        		notifyChange(oldDate, e.type);
	        		notifyError(newDate);
	        	}
	        },
	
	        showMode = function (dir) {
	        	if (dir) {
	        		picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
	        	}
	        	picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
	        },
	
	        attachDatePickerEvents = function () {
	        	var $this, $parent, expanded, closed, collapseData;
	        	picker.widget.on('click', '.datepicker *', $.proxy(click, this)); // this handles date picker clicks
	        	picker.widget.on('click', '[data-action]', $.proxy(doAction, this)); // this handles time picker clicks
	        	picker.widget.on('mousedown', $.proxy(stopEvent, this));
	        	picker.element.on('keydown', $.proxy(keydown, this));
	        	if (picker.options.pickDate && picker.options.pickTime) {
	        		picker.widget.on('click.togglePicker', '.accordion-toggle', function (e) {
	        			e.stopPropagation();
	        			$this = $(this);
	        			$parent = $this.closest('ul');
	        			expanded = $parent.find('.in');
	        			closed = $parent.find('.collapse:not(.in)');
	
	        			if (expanded && expanded.length) {
	        				collapseData = expanded.data('collapse');
	        				if (collapseData && collapseData.transitioning) {
	        					return;
	        				}
	        				expanded.collapse('hide');
	        				closed.collapse('show');
	        				$this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
	        				if (picker.component) {
	        					picker.component.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
	        				}
	        			}
	        		});
	        	}
	        	if (picker.isInput) {
	        		picker.element.on({
	        			'click': $.proxy(picker.show, this),
	        			'focus': $.proxy(picker.show, this),
	        			'change': $.proxy(change, this),
	        			'blur': $.proxy(picker.hide, this)
	        		});
	        	} else {
	        		picker.element.on({
	        			'change': $.proxy(change, this)
	        		}, 'input');
	        		if (picker.component) {
	        			picker.component.on('click', $.proxy(picker.show, this));
	        			picker.component.on('mousedown', $.proxy(stopEvent, this));
	        		} else {
	        			picker.element.on('click', $.proxy(picker.show, this));
	        		}
	        	}
	        	picker.widget.on('click.togglePicker', '#today-button', function (e) {
	        		if (picker.options.minuteStepping !== 1) {
	        			var mDate = moment(),
							rInterval = picker.options.minuteStepping;
	        			mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60).seconds(0);
	        			picker.setValue(mDate.format(picker.format));
	        		} else {
	        			picker.setValue(moment().format(picker.format));
	        		}
	        		notifyChange('', e.type);
	        		set();
	        	});
	        	picker.widget.on('click.togglePicker', '#clear-button', function (e) {
	        		picker.setValue(null);
	        		notifyChange('', e.type);
	        	});
	        	picker.widget.on('click.togglePicker', '#close-button', function (e) {
	        		picker.hide();
	        	});
	        },
	
	        attachDatePickerGlobalEvents = function () {
	        	$(window).on(
	                'resize.datetimepicker' + picker.id, $.proxy(place, this));
	        	if (!picker.isInput) {
	        		$(document).on(
	                    'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
	        	}
	        },
	
	        detachDatePickerEvents = function () {
	        	picker.widget.off('click', '.datepicker *', picker.click);
	        	picker.widget.off('click', '[data-action]');
	        	picker.widget.off('mousedown', picker.stopEvent);
	        	if (picker.options.pickDate && picker.options.pickTime) {
	        		picker.widget.off('click.togglePicker');
	        	}
	        	if (picker.isInput) {
	        		picker.element.off({
	        			'focus': picker.show,
	        			'change': change,
	        			'click': picker.show,
	        			'blur': picker.hide
	        		});
	        	} else {
	        		picker.element.off({
	        			'change': change
	        		}, 'input');
	        		if (picker.component) {
	        			picker.component.off('click', picker.show);
	        			picker.component.off('mousedown', picker.stopEvent);
	        		} else {
	        			picker.element.off('click', picker.show);
	        		}
	        	}
	        },
	
	        detachDatePickerGlobalEvents = function () {
	        	$(window).off('resize.datetimepicker' + picker.id);
	        	if (!picker.isInput) {
	        		$(document).off('mousedown.datetimepicker' + picker.id);
	        	}
	        },
	
	        isInFixed = function () {
	        	if (picker.element) {
	        		var parents = picker.element.parents(), inFixed = false, i;
	        		for (i = 0; i < parents.length; i++) {
	        			if ($(parents[i]).css('position') === 'fixed') {
	        				inFixed = true;
	        				break;
	        			}
	        		}
	        		return inFixed;
	        	} else {
	        		return false;
	        	}
	        },
	
	        set = function () {
	        	moment.locale(picker.options.language);
	        	var formatted = '';
	        	if (!picker.unset) {
	        		formatted = moment(picker.date).format(picker.format);
	        	}
	        	getPickerInput().val(formatted);
	        	picker.element.data('date', formatted);
	        	if (!picker.options.pickTime) {
	        		picker.hide();
	        	}
	        },
	
	        checkDate = function (direction, unit, amount) {
	        	moment.locale(picker.options.language);
	        	var newDate;
	        	if (direction === 'add') {
	        		newDate = moment(picker.date);
	        		if (newDate.hours() === 23) {
	        			newDate.add(amount, unit);
	        		}
	        		newDate.add(amount, unit);
	        	}
	        	else {
	        		newDate = moment(picker.date).subtract(amount, unit);
	        	}
	        	if (isInDisableDates(moment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
	        		notifyError(newDate.format(picker.format));
	        		return;
	        	}
	
	        	if (direction === 'add') {
	        		picker.date.add(amount, unit);
	        	}
	        	else {
	        		picker.date.subtract(amount, unit);
	        	}
	        	picker.unset = false;
	        },
	
	        isInDisableDates = function (date, timeUnit) {
	        	moment.locale(picker.options.language);
	        	var maxDate = moment(picker.options.maxDate, picker.format, picker.options.useStrict),
	                minDate = moment(picker.options.minDate, picker.format, picker.options.useStrict);
	
	        	if (timeUnit) {
	        		maxDate = maxDate.endOf(timeUnit);
	        		minDate = minDate.startOf(timeUnit);
	        	}
	
	        	if (date.isAfter(maxDate) || date.isBefore(minDate)) {
	        		return true;
	        	}
	        	if (picker.options.disabledDates === false) {
	        		return false;
	        	}
	        	return picker.options.disabledDates[date.format('YYYY-MM-DD')] === true;
	        },
	        isInEnableDates = function (date) {
	        	moment.locale(picker.options.language);
	        	if (picker.options.enabledDates === false) {
	        		return true;
	        	}
	        	return picker.options.enabledDates[date.format('YYYY-MM-DD')] === true;
	        },
	
	        indexGivenDates = function (givenDatesArray) {
	        	// Store given enabledDates and disabledDates as keys.
	        	// This way we can check their existence in O(1) time instead of looping through whole array.
	        	// (for example: picker.options.enabledDates['2014-02-27'] === true)
	        	var givenDatesIndexed = {}, givenDatesCount = 0, i;
	        	for (i = 0; i < givenDatesArray.length; i++) {
	        		if (moment.isMoment(givenDatesArray[i]) || givenDatesArray[i] instanceof Date) {
	        			dDate = moment(givenDatesArray[i]);
	        		} else {
	        			dDate = moment(givenDatesArray[i], picker.format, picker.options.useStrict);
	        		}
	        		if (dDate.isValid()) {
	        			givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
	        			givenDatesCount++;
	        		}
	        	}
	        	if (givenDatesCount > 0) {
	        		return givenDatesIndexed;
	        	}
	        	return false;
	        },
	
	        padLeft = function (string) {
	        	string = string.toString();
	        	if (string.length >= 2) {
	        		return string;
	        	}
	        	return '0' + string;
	        },
	
	        getTemplate = function () {
	        	var
	                headTemplate =
	                        '<thead>' +
	                            '<tr>' +
	                                '<th class="prev">&lsaquo;</th><th colspan="' + (picker.options.calendarWeeks ? '6' : '5') + '" class="picker-switch"></th><th class="next">&rsaquo;</th>' +
	                            '</tr>' +
	                        '</thead>',
	                contTemplate =
	                        '<tbody><tr><td colspan="' + (picker.options.calendarWeeks ? '8' : '7') + '"></td></tr></tbody>',
	                template = '<div class="datepicker-days">' +
	                    '<table class="table-condensed">' + headTemplate + '<tbody></tbody></table>' +
	                '</div>' +
	                '<div class="datepicker-months">' +
	                    '<table class="table-condensed">' + headTemplate + contTemplate + '</table>' +
	                '</div>' +
	                '<div class="datepicker-years">' +
	                    '<table class="table-condensed">' + headTemplate + contTemplate + '</table>' +
	                '</div>',
	                ret = '';
	        	if (picker.options.pickDate && picker.options.pickTime) {
	        		ret = '<div class="bootstrap-datetimepicker-widget' + (picker.options.sideBySide ? ' timepicker-sbs' : '') + (picker.use24hours ? ' usetwentyfour' : '') + ' dropdown-menu" style="z-index:9999 !important;">';
	        		if (picker.options.sideBySide) {
	        			ret += '<div class="row">' +
	                       '<div class="col-sm-6 datepicker">' + template + '</div>' +
	                       '<div class="col-sm-6 timepicker">' + tpGlobal.getTemplate() + '</div>' +
	                     '</div>';
	        		} else {
	        			ret += '<ul class="list-unstyled">' +
	                        '<li' + (picker.options.collapse ? ' class="collapse in"' : '') + '>' +
	                            '<div class="datepicker">' + template + '</div>' +
	                        '</li>' +
							'<li>' +
							'<span class="btn-group" style="float:left; margin-left:4px">' +
							'<button class="btn btn-info"" id="today-button"> Now </button>' +
							'<button class="btn btn-danger" id="clear-button"> Clear </button>' +
							'</span>' +
							'<button class="btn btn-success" id="close-button" style="float:right; margin-right:4px;">Done</button>' +
							'<div style="clear:both; padding-bottom:5px;"></div>' +
							'</li>' +
	                        '<li' + (picker.options.collapse ? ' class="collapse"' : '') + '>' +
	                            '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
	                        '</li>' +
	                   '</ul>';
	        		}
	        		ret += '</div>';
	        		return ret;
	        	}
	        	if (picker.options.pickTime) {
	        		return (
	                    '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
	                        '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
	                    '</div>'
	                );
	        	}
	        	return (
	                '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
	                    '<div class="datepicker">' + template + '</div>' +
	                '</div>'
	            );
	        },
	
	        dpGlobal = {
	        	modes: [
	                {
	                	clsName: 'days',
	                	navFnc: 'month',
	                	navStep: 1
	                },
	                {
	                	clsName: 'months',
	                	navFnc: 'year',
	                	navStep: 1
	                },
	                {
	                	clsName: 'years',
	                	navFnc: 'year',
	                	navStep: 10
	                }
	        	]
	        },
	
	        tpGlobal = {
	        	hourTemplate: '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
	        	minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
	        	secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
	        };
	
	    	tpGlobal.getTemplate = function () {
	    		return (
	                '<div class="timepicker-picker">' +
	                    '<table class="table-condensed">' +
	                        '<tr>' +
	                            '<td><a href="#" class="btn" data-action="incrementHours"><span class="' + picker.options.icons.up + '"></span></a></td>' +
	                            '<td class="separator"></td>' +
	                            '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><span class="' + picker.options.icons.up + '"></span></a>' : '') + '</td>' +
	                            (picker.options.useSeconds ?
	                                '<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><span class="' + picker.options.icons.up + '"></span></a></td>' : '') +
	                            (picker.use24hours ? '' : '<td class="separator"></td>') + '<td></td>' +
	                        '</tr>' +
	                        '<tr>' +
	                            '<td>' + tpGlobal.hourTemplate + '</td> ' +
	                            '<td class="separator">:</td>' +
	                            '<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
	                            (picker.options.useSeconds ?
	                                '<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
	                            (picker.use24hours ? '' : '<td class="separator"></td>' +
	                            '<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
	                        '</tr>' +
	                        '<tr>' +
	                            '<td><a href="#" class="btn" data-action="decrementHours"><span class="' + picker.options.icons.down + '"></span></a></td>' +
	                            '<td class="separator"></td>' +
	                            '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><span class="' + picker.options.icons.down + '"></span></a>' : '') + '</td>' +
	                            (picker.options.useSeconds ?
	                                '<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><span class="' + picker.options.icons.down + '"></span></a></td>' : '') +
	                            (picker.use24hours ? '' : '<td class="separator"></td>') + '<td></td>' +
	                        '</tr>' +
	                    '</table>' +
	                '</div>' +
	                '<div class="timepicker-hours" data-action="selectHour">' +
	                    '<table class="table-condensed"></table>' +
	                '</div>' +
	                '<div class="timepicker-minutes" data-action="selectMinute">' +
	                    '<table class="table-condensed"></table>' +
	                '</div>' +
	                (picker.options.useSeconds ?
	                    '<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
	            );
	    	};
	
	    	picker.destroy = function () {
	    		detachDatePickerEvents();
	    		detachDatePickerGlobalEvents();
	    		picker.widget.remove();
	    		picker.element.removeData('DateTimePicker');
	    		if (picker.component) {
	    			picker.component.removeData('DateTimePicker');
	    		}
	    	};
	
	    	picker.show = function (e) {
	    		if (getPickerInput().prop('disabled')) {
	    			return;
	    		}
	    		if (picker.options.useCurrent) {
	    			if (getPickerInput().val() === '') {
	    				if (picker.options.fillEmpty) {
	    					if (picker.options.minuteStepping !== 1) {
	    						var mDate = moment(),
					                rInterval = picker.options.minuteStepping;
	    						mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60).seconds(0);
	    						picker.setValue(mDate.format(picker.format));
	    					} else {
	    						picker.setValue(moment().format(picker.format));
	    					}
	    					notifyChange('', e.type);
	    				}
	    			} else
	    				picker.setValue(getPickerInput().val());
	    		}
	    		// if this is a click event on the input field and picker is already open don't hide it
	    		if (e && e.type === 'click' && picker.isInput && picker.widget.hasClass('picker-open')) {
	    			return;
	    		}
	    		if (picker.widget.hasClass('picker-open')) {
	    			picker.widget.hide();
	    			picker.widget.removeClass('picker-open');
	    		}
	    		else {
	    			picker.widget.show();
	    			picker.widget.addClass('picker-open');
	    		}
	    		picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
	    		place();
	    		picker.element.trigger({
	    			type: 'dp.show',
	    			date: moment(picker.date)
	    		});
	    		attachDatePickerGlobalEvents();
	    		if (e) {
	    			stopEvent(e);
	    		}
	    	};
	
	    	picker.disable = function () {
	    		var input = getPickerInput();
	    		if (input.prop('disabled')) {
	    			return;
	    		}
	    		input.prop('disabled', true);
	    		detachDatePickerEvents();
	    	};
	
	    	picker.enable = function () {
	    		var input = getPickerInput();
	    		if (!input.prop('disabled')) {
	    			return;
	    		}
	    		input.prop('disabled', false);
	    		attachDatePickerEvents();
	    	};
	
	    	picker.hide = function () {
	    		// Ignore event if in the middle of a picker transition
	    		var collapse = picker.widget.find('.collapse'), i, collapseData;
	    		for (i = 0; i < collapse.length; i++) {
	    			collapseData = collapse.eq(i).data('collapse');
	    			if (collapseData && collapseData.transitioning) {
	    				return;
	    			}
	    		}
	    		picker.widget.hide();
	    		picker.widget.removeClass('picker-open');
	    		picker.viewMode = picker.startViewMode;
	    		showMode();
	    		picker.element.trigger({
	    			type: 'dp.hide',
	    			date: moment(picker.date)
	    		});
	    		detachDatePickerGlobalEvents();
	    	};
	
	    	picker.setValue = function (newDate) {
	    		moment.locale(picker.options.language);
	    		if (!newDate) {
	    			picker.unset = true;
	    			set();
	    		} else {
	    			picker.unset = false;
	    		}
	    		if (!moment.isMoment(newDate)) {
	    			newDate = (newDate instanceof Date) ? moment(newDate) : moment(newDate, picker.format, picker.options.useStrict);
	    		} else {
	    			newDate = newDate.locale(picker.options.language);
	    		}
	    		if (newDate.isValid()) {
	    			picker.date = newDate;
	    			set();
	    			picker.viewDate = moment({ y: picker.date.year(), M: picker.date.month() });
	    			fillDate();
	    			fillTime();
	    		}
	    		else {
	    			notifyError(newDate);
	    		}
	    	};
	
	    	picker.getDate = function () {
	    		if (picker.unset) {
	    			return null;
	    		}
	    		return moment(picker.date);
	    	};
	
	    	picker.setDate = function (date) {
	    		var oldDate = moment(picker.date);
	    		if (!date) {
	    			picker.setValue(null);
	    		} else {
	    			picker.setValue(date);
	    		}
	    		notifyChange(oldDate, 'function');
	    	};
	
	    	picker.setDisabledDates = function (dates) {
	    		picker.options.disabledDates = indexGivenDates(dates);
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	picker.setEnabledDates = function (dates) {
	    		picker.options.enabledDates = indexGivenDates(dates);
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	picker.setMaxDate = function (date) {
	    		if (date === undefined) {
	    			return;
	    		}
	    		if (moment.isMoment(date) || date instanceof Date) {
	    			picker.options.maxDate = moment(date);
	    		} else {
	    			picker.options.maxDate = moment(date, picker.format, picker.options.useStrict);
	    		}
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	picker.setMinDate = function (date) {
	    		if (date === undefined) {
	    			return;
	    		}
	    		if (moment.isMoment(date) || date instanceof Date) {
	    			picker.options.minDate = moment(date);
	    		} else {
	    			picker.options.minDate = moment(date, picker.format, picker.options.useStrict);
	    		}
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	init();
	    };
	
		$.fn.datetimepicker = function (options) {
			return this.each(function () {
				var $this = $(this),
	                data = $this.data('DateTimePicker');
				if (!data) {
					$this.data('DateTimePicker', new DateTimePicker(this, options));
				}
			});
		};
	
		$.fn.datetimepicker.defaults = {
			format: false,
			pickDate: true,
			pickTime: true,
			useMinutes: true,
			useSeconds: false,
			useCurrent: true,
			calendarWeeks: false,
			minuteStepping: 1,
			minDate: moment({ y: 1900 }),
			maxDate: moment().add(100, 'y'),
			showToday: true,
			collapse: false,
			language: moment.locale(),
			defaultDate: '',
			disabledDates: false,
			enabledDates: false,
			icons: {},
			useStrict: false,
			direction: 'auto',
			sideBySide: false,
			daysOfWeekDisabled: [],
			widgetParent: false,
			fillEmpty: false
		};
	}));


/***/ },
/* 98 */
/***/ function(module, exports) {

	(function() { module.exports = this["moment"]; }());

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __validation = typescript_angular_utilities_1.services.validation;
	exports.moduleName = 'rl.ui.services.componentValidator';
	exports.factoryName = 'componentValidator';
	var ComponentValidator = (function () {
	    function ComponentValidator(validationService, options) {
	        var _this = this;
	        this.$scope = options.$scope;
	        this.ngModel = options.ngModel;
	        this.form = options.form;
	        this.validator = validationService.buildCustomValidator(function (error) {
	            _this.error = error;
	        });
	        _.each(options.validators, function (customValidator) {
	            _this.validator.registerValidationHandler(customValidator);
	        });
	        this.setValidator();
	    }
	    ComponentValidator.prototype.setValidator = function () {
	        var _this = this;
	        return this.$scope.$watch(this.validator.validate.bind(this.validator), function (value) {
	            if (!_.isUndefined(_this.ngModel)) {
	                _this.ngModel.$setValidity('customValidation', value);
	            }
	            else if (!_.isUndefined(_this.form)) {
	                _this.form.$setValidity('customValidation', value, 'group');
	            }
	            else if (_.isFunction(_this.setValidity)) {
	                _this.setValidity(value);
	            }
	            if (value) {
	                _this.error = null;
	            }
	        });
	    };
	    return ComponentValidator;
	})();
	exports.ComponentValidator = ComponentValidator;
	componentValidatorFactory.$inject = [__validation.serviceName];
	function componentValidatorFactory(validationService) {
	    return {
	        getInstance: function (options) {
	            return new ComponentValidator(validationService, options);
	        },
	    };
	}
	exports.componentValidatorFactory = componentValidatorFactory;
	angular.module(exports.moduleName, [__validation.moduleName])
	    .factory(exports.factoryName, componentValidatorFactory);
	//# sourceMappingURL=componentValidator.service.js.map

/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = "<div class=\"validation-input-group\">\r\n\t<div class=\"input-group validation-input\" ng-class=\"{ 'has-warning': !dateTime.validFormat, 'error': dateTime.ngModel.$invalid, 'required-error': dateTime.ngModel.$error.required }\">\r\n\t\t<input type=\"text\" class=\"form-control\" ng-model=\"dateTime.ngModel.$viewValue\" />\r\n\t\t<span class=\"input-group-btn\">\r\n\t\t\t<button class=\"btn btn-default show-date-picker\" ng-click=\"toggle()\"><i class=\"fa fa-calendar\"></i></button>\r\n\t\t</span>\r\n\t\t<span class=\"error-string\" ng-hide=\"dateTime.dateTimeValidator.error | isEmpty\">{{dateTime.dateTimeValidator.error}}</span>\r\n\t</div>\r\n</div>"

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var jquery_service_1 = __webpack_require__(102);
	var templateLoader_service_1 = __webpack_require__(103);
	exports.moduleName = 'rl.ui.components.genericContainer';
	exports.directiveName = 'rlGenericContainer';
	exports.controllerName = 'GenericContainerController';
	var __object = typescript_angular_utilities_1.services.object;
	var GenericContainerController = (function () {
	    function GenericContainerController($scope, object) {
	        var _this = this;
	        this.object = object;
	        $scope.$watch(function () { return _this.selector; }, function (newType, oldType) {
	            if (_this.object.areEqual(newType, oldType)) {
	                return;
	            }
	            var template = _this.resolveTemplate(newType);
	            _this.swapTemplates(template);
	        });
	    }
	    GenericContainerController.prototype.refresh = function () {
	        var template = this.resolveTemplate(this.selector);
	        this.swapTemplates(template);
	    };
	    GenericContainerController.prototype.resolveTemplate = function (type) {
	        if (_.has(this.templates, type)) {
	            return this.templates[type];
	        }
	        else {
	            return this.default;
	        }
	    };
	    GenericContainerController.$inject = ['$scope', __object.serviceName];
	    return GenericContainerController;
	})();
	exports.GenericContainerController = GenericContainerController;
	genericContainer.$inject = [
	    '$compile',
	    '$interpolate',
	    jquery_service_1.serviceName,
	    templateLoader_service_1.serviceName,
	    __object.serviceName,
	];
	function genericContainer($compile, $interpolate, jquery, templateLoader, object) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: '<div id="container"></div>',
	        transclude: true,
	        controller: exports.controllerName,
	        controllerAs: 'genericContainer',
	        scope: {},
	        bindToController: {
	            selector: '=',
	            configuredTemplates: '=templates',
	            defaultTemplate: '=',
	        },
	        link: function (scope, element, attributes, controller, transclude) {
	            initDefaults(controller);
	            var container = element.find('#container');
	            var templateResult = templateLoader.loadTemplates(transclude);
	            controller.templates = _.extend(controller.templates, templateResult.templates);
	            controller.default = templateResult.default;
	            var templateScope = templateResult.transclusionScope;
	            if (!controller.default) {
	                controller.default = angular.element('<div></div>');
	            }
	            controller.refresh();
	            function initDefaults(controller) {
	                controller.default = controller.defaultTemplate;
	                controller.templates = controller.configuredTemplates
	                    ? _.map(controller.configuredTemplates, function (template) { return angular.element(template); })
	                    : {};
	                controller.swapTemplates = swapTemplates;
	            }
	            function swapTemplates(template) {
	                jquery.replaceContent(container, template);
	                var content = $compile(template)(templateScope);
	            }
	        }
	    };
	}
	angular.module(exports.moduleName, [jquery_service_1.moduleName, __object.moduleName, templateLoader_service_1.moduleName])
	    .directive(exports.directiveName, genericContainer)
	    .controller(exports.controllerName, GenericContainerController);
	//# sourceMappingURL=genericContainer.js.map

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path="../../../typings/jquery/jquery.d.ts" />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.utilities.services.jquery';
	exports.serviceName = 'jqueryUtility';
	var JQueryUtility = (function () {
	    function JQueryUtility() {
	    }
	    JQueryUtility.prototype.replaceContent = function (contentArea, newContent) {
	        contentArea.empty();
	        contentArea.append(newContent);
	    };
	    return JQueryUtility;
	})();
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, JQueryUtility);
	//# sourceMappingURL=jquery.service.js.map

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	exports.moduleName = 'rl.utilities.services.templateLoader';
	exports.serviceName = 'templateLoader';
	var TemplateLoader = (function () {
	    function TemplateLoader($interpolate, templateSelectorValue, objectUtility) {
	        this.$interpolate = $interpolate;
	        this.templateSelectorValue = templateSelectorValue;
	        this.objectUtility = objectUtility;
	    }
	    TemplateLoader.prototype.loadTemplates = function (transclude) {
	        var _this = this;
	        var result = {
	            templates: {},
	            default: null,
	            transclusionScope: null,
	        };
	        // Load templates from the DOM
	        transclude(function (clone, transclusionScope) {
	            var templates = clone.filter(_this.templateSelectorValue);
	            templates.each(function (index, template) {
	                var templateElement = angular.element(template);
	                var templateHtml = templateElement.html();
	                var childElement = angular.element(templateHtml);
	                var triggerAttribute = templateElement.attr('when-selector');
	                if (!_this.objectUtility.isNullOrWhitespace(triggerAttribute)) {
	                    var trigger = _this.$interpolate(triggerAttribute)(transclusionScope);
	                    result.templates[trigger] = childElement;
	                }
	                var isDefault = templateElement.attr('default');
	                if (!_.isUndefined(isDefault) && isDefault.toLowerCase() !== 'false') {
	                    result.default = childElement;
	                }
	            });
	            result.transclusionScope = transclusionScope;
	        });
	        return result;
	    };
	    TemplateLoader.$inject = ['$interpolate', 'templateSelectorValue', __object.serviceName];
	    return TemplateLoader;
	})();
	angular.module(exports.moduleName, [__object.moduleName])
	    .value('templateSelectorValue', 'template')
	    .service(exports.serviceName, TemplateLoader);
	//# sourceMappingURL=templateLoader.service.js.map

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.lazyLoad';
	exports.directiveName = 'rlLazyLoad';
	exports.controllerName = 'LazyLoadController';
	var LazyLoadController = (function () {
	    function LazyLoadController($scope) {
	        var _this = this;
	        this.init = false;
	        var unbind = $scope.$watch(function () { return _this.show; }, function (value) {
	            if (value) {
	                _this.init = true;
	                unbind();
	            }
	        });
	    }
	    LazyLoadController.$inject = ['$scope'];
	    return LazyLoadController;
	})();
	exports.LazyLoadController = LazyLoadController;
	function lazyLoad() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: "\n\t\t\t<div ng-if=\"lazyLoad.init\">\n\t\t\t\t<div ng-show=\"lazyLoad.show\">\n\t\t\t\t\t<div ng-transclude></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'lazyLoad',
	        scope: {},
	        bindToController: {
	            show: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, lazyLoad)
	    .controller(exports.controllerName, LazyLoadController);
	//# sourceMappingURL=lazyLoad.js.map

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(13);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __promise = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.longClickButton';
	exports.directiveName = 'rlLongClickButton';
	exports.controllerName = 'LongClickButtonController';
	var __object = typescript_angular_utilities_1.services.object;
	var LongClickButtonController = (function () {
	    function LongClickButtonController($scope, $interval, $timeout, objectUtility, promise) {
	        var _this = this;
	        this.$interval = $interval;
	        this.$timeout = $timeout;
	        this.objectUtility = objectUtility;
	        this.promise = promise;
	        this.interval = 25;
	        this.duration = 1500;
	        this.buttonText = this.text;
	        this.type = this.type != null ? this.type : 'default';
	        this.size = this.size != null ? 'btn-' + this.size : null;
	        $scope.$watch(function () { return _this.buttonText; }, function () {
	            $timeout(function () {
	                _this.width = $('#actionButton').outerWidth();
	            });
	        });
	    }
	    LongClickButtonController.prototype.startAction = function () {
	        var _this = this;
	        if (this.active || this.busy) {
	            return;
	        }
	        this.actionProgress = 0;
	        this.active = true;
	        this.actionInterval = this.$interval(function () {
	            _this.actionProgress += _this.interval;
	            if (_this.actionProgress >= _this.duration) {
	                _this.cleanup();
	                _this.buttonText = _this.text;
	                _this.trigger();
	            }
	        }, this.interval);
	    };
	    LongClickButtonController.prototype.stopAction = function () {
	        if (this.active) {
	            if (this.actionProgress < this.duration) {
	                this.warn();
	            }
	            this.cleanup();
	        }
	    };
	    LongClickButtonController.prototype.cleanup = function () {
	        this.$interval.cancel(this.actionInterval);
	        this.actionProgress = 0;
	        this.active = false;
	    };
	    LongClickButtonController.prototype.warn = function () {
	        if (this.objectUtility.isNullOrEmpty(this.onShortClickText) === false) {
	            this.buttonText = this.onShortClickText;
	        }
	    };
	    LongClickButtonController.prototype.trigger = function () {
	        var _this = this;
	        if (!this.busy) {
	            this.busy = true;
	            var result = this.action();
	            if (this.promise.isPromise(result) && _.isFunction(result.finally)) {
	                result.finally(function () {
	                    _this.busy = false;
	                });
	            }
	        }
	    };
	    LongClickButtonController.$inject = ['$scope', '$interval', '$timeout', __object.serviceName, __promise.serviceName];
	    return LongClickButtonController;
	})();
	exports.LongClickButtonController = LongClickButtonController;
	function longClickButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(106),
	        controller: exports.controllerName,
	        controllerAs: 'button',
	        scope: {},
	        bindToController: {
	            action: '&',
	            text: '@',
	            onShortClickText: '@',
	            icon: '@',
	            busy: '=',
	            rightAligned: '=',
	            type: '@',
	            ngDisabled: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, longClickButton)
	    .controller(exports.controllerName, LongClickButtonController);
	//# sourceMappingURL=longClickButton.js.map

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "<div class=\"long-click-button\">\r\n\t<button id=\"actionButton\" class=\"btn btn-{{button.type}} {{button.size}}\" ng-mousedown=\"button.startAction()\" ng-mouseleave=\"button.stopAction()\" ng-mouseup=\"button.stopAction()\" ng-disabled=\"button.busy || button.ngDisabled\">\r\n\t\t<rl-busy loading=\"button.busy\" ng-if=\"button.rightAligned\"></rl-busy>\r\n\t\t<i ng-show=\"button.icon != null\" class=\"fa fa-{{button.icon}}\"></i> {{button.buttonText}}\r\n\t\t<rl-busy loading=\"button.busy\" ng-if=\"!button.rightAligned\"></rl-busy>\r\n\t</button>\r\n\t<rl-rating-bar ng-if=\"button.active\" width=\"button.width\" height=\"5\" min=\"0\" max=\"button.duration\"\r\n\t\t\t\tvalue=\"button.actionProgress\" background=\"transparent\"></rl-rating-bar>\r\n</div>"

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var jquery_service_1 = __webpack_require__(102);
	var messageLog_service_1 = __webpack_require__(108);
	var messageLog_directive_1 = __webpack_require__(109);
	var editableMessageLog_1 = __webpack_require__(111);
	var templateLoader_service_1 = __webpack_require__(103);
	__export(__webpack_require__(108));
	__export(__webpack_require__(109));
	exports.moduleName = 'rl.ui.components.messageLog';
	angular.module(exports.moduleName, [__object.moduleName, jquery_service_1.moduleName, templateLoader_service_1.moduleName])
	    .factory(messageLog_service_1.factoryName, messageLog_service_1.messageLogFactory)
	    .directive(messageLog_directive_1.directiveName, messageLog_directive_1.messageLog)
	    .controller(messageLog_directive_1.controllerName, messageLog_directive_1.MessageLogController)
	    .directive(editableMessageLog_1.directiveName, editableMessageLog_1.editableMessageLog)
	    .controller(editableMessageLog_1.controllerName, editableMessageLog_1.EditableMessageLogController);
	//# sourceMappingURL=messageLog.module.js.map

/***/ },
/* 108 */
/***/ function(module, exports) {

	'use strict';
	exports.factoryName = 'messageLog';
	exports.defaultPageSize = 10;
	var MessageLog = (function () {
	    function MessageLog() {
	        this.currentStartingMessage = 0;
	        this._hasForwardMessages = false;
	        this._hasBackwardMessages = false;
	        this._pageSize = exports.defaultPageSize;
	    }
	    Object.defineProperty(MessageLog.prototype, "pageSize", {
	        get: function () {
	            return this._pageSize;
	        },
	        /* tslint:disable */
	        set: function (value) {
	            this._pageSize = value;
	            this.updateCurrentPage();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "hasForwardMessages", {
	        /* tslint:enable */
	        get: function () {
	            return this._hasForwardMessages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "hasBackwardMessages", {
	        get: function () {
	            return this._hasBackwardMessages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "dataService", {
	        get: function () {
	            return this._dataService;
	        },
	        /* tslint:disable */
	        set: function (value) {
	            this._dataService = value;
	            if (value != null) {
	                this.visibleMessages = null;
	                this.updateCurrentPage();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /* tslint:enable */
	    MessageLog.prototype.addMessage = function (message) {
	        var _this = this;
	        return this.dataService.saveMessage(message).then(function () {
	            _this.getTopPage();
	        });
	    };
	    MessageLog.prototype.getNextPage = function () {
	        if (!this.hasForwardMessages) {
	            return;
	        }
	        this.currentStartingMessage += this.pageSize;
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.getPreviousPage = function () {
	        if (!this.hasBackwardMessages) {
	            return;
	        }
	        this.currentStartingMessage -= this.pageSize;
	        if (this.currentStartingMessage < 0) {
	            this.currentStartingMessage = 0;
	        }
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.getTopPage = function () {
	        this.currentStartingMessage = 0;
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.refresh = function () {
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.updateCurrentPage = function () {
	        var _this = this;
	        if (this.dataService == null) {
	            return null;
	        }
	        this.busy = true;
	        return this.dataService.getMessages(this.currentStartingMessage, this.pageSize).then(function (result) {
	            _this.visibleMessages = result.messages;
	            _this._hasForwardMessages = result.hasMoreMessages;
	            _this._hasBackwardMessages = (_this.currentStartingMessage > 0);
	            _this.busy = false;
	        });
	    };
	    return MessageLog;
	})();
	exports.MessageLog = MessageLog;
	function messageLogFactory() {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new MessageLog();
	        },
	    };
	}
	exports.messageLogFactory = messageLogFactory;
	//# sourceMappingURL=messageLog.service.js.map

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var jquery_service_1 = __webpack_require__(102);
	var messageLog_service_1 = __webpack_require__(108);
	var templateLoader_service_1 = __webpack_require__(103);
	exports.directiveName = 'rlMessageLog';
	exports.controllerName = 'MessageLogController';
	var MessageLogController = (function () {
	    function MessageLogController($scope, messageLogFactory) {
	        var _this = this;
	        this.messageLog = this.messageLogBinding || messageLogFactory.getInstance();
	        $scope.$watch(function () { return _this.messageLog.visibleMessages; }, function (value) {
	            _this.messages = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.hasForwardMessages; }, function (value) {
	            _this.hasNextPage = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.hasBackwardMessages; }, function (value) {
	            _this.hasPreviousPage = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.busy; }, function (value) {
	            if (!value) {
	                _this.loading = false;
	                _this.loadingInitial = false;
	            }
	            else {
	                _this.loading = true;
	            }
	        });
	        $scope.$watch(function () { return _this.service; }, function (service) {
	            _this.messageLog.dataService = service;
	            _this.loadingInitial = true;
	        });
	        this.messageLog.pageSize = this.pageSize != null ? this.pageSize : 8;
	    }
	    MessageLogController.prototype.getEntrySelector = function (entry) {
	        if (_.isString(this.selector)) {
	            return entry[this.selector];
	        }
	        else if (_.isFunction(this.selector)) {
	            return this.selector(entry);
	        }
	    };
	    MessageLogController.prototype.getOlder = function () {
	        return this.messageLog.getNextPage();
	    };
	    MessageLogController.prototype.getTop = function () {
	        return this.messageLog.getTopPage();
	    };
	    MessageLogController.$inject = ['$scope', messageLog_service_1.factoryName];
	    return MessageLogController;
	})();
	exports.MessageLogController = MessageLogController;
	messageLog.$inject = [
	    '$interpolate',
	    jquery_service_1.serviceName,
	    templateLoader_service_1.serviceName,
	    __object.serviceName,
	];
	function messageLog($interpolate, jquery, templateLoader, object) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(110),
	        transclude: true,
	        controller: exports.controllerName,
	        controllerAs: 'log',
	        scope: {
	            messageData: "=",
	        },
	        bindToController: {
	            service: '=',
	            selector: '=',
	            pageSize: '=',
	            messageLogBinding: '=messageLog',
	            messageAs: "@",
	        },
	        link: function (scope, element, attributes, controller, transclude) {
	            controller.templates = templateLoader.loadTemplates(transclude).templates;
	        }
	    };
	}
	exports.messageLog = messageLog;
	//# sourceMappingURL=messageLog.directive.js.map

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "<div>\r\n\t<rl-busy loading=\"log.loadingInitial\" size=\"2x\"></rl-busy>\r\n\t<div class=\"content-group\" ng-repeat=\"entry in log.messages\" rl-alias=\"entry as {{log.messageAs}}\">\r\n\t\t<rl-generic-container selector=\"log.getEntrySelector(entry)\" templates=\"log.templates\">\r\n\t\t\t<template default>\r\n\t\t\t\t<div ng-bind-html=\"entry.message\"></div>\r\n\t\t\t\t<div class=\"byline\">{{entry.createdBy}}</div>\r\n\t\t\t\t<div class=\"byline\">{{entry.createdDate | date:'short'}} UTC</div>\r\n\t\t\t</template>\r\n\t\t</rl-generic-container>\r\n\t</div>\r\n\t<div class=\"content-group\" ng-if=\"(log.messages | isEmpty) && !log.loadingInitial\">No existing messages</div>\r\n\t<div class=\"row\">\r\n\t\t<div class=\"col-xs-12\">\r\n\t\t\t<div class=\"text-center\">\r\n\t\t\t\t<rl-button-async type=\"default\" action=\"log.getTop()\" ng-disabled=\"log.loading\" button-right-aligned=\"true\">\r\n\t\t\t\t\t<span ng-show=\"log.hasPreviousPage\">Top</span>\r\n\t\t\t\t\t<span ng-hide=\"log.hasPreviousPage\">Refresh</span>\r\n\t\t\t\t</rl-button-async>\r\n\t\t\t\t<rl-button-async type=\"default\" ng-disabled=\"log.hasNextPage == false || log.loading\" action=\"log.getOlder()\">\r\n\t\t\t\t\tOlder <i class=\"fa fa-chevron-right\"></i>\r\n\t\t\t\t</rl-button-async>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n</div>"

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var messageLog_service_1 = __webpack_require__(108);
	exports.directiveName = 'rlEditableMessageLog';
	exports.controllerName = 'EditableMessageLogController';
	var __object = typescript_angular_utilities_1.services.object;
	;
	var EditableMessageLogController = (function () {
	    function EditableMessageLogController($scope, messageLogFactory, object) {
	        var _this = this;
	        this.object = object;
	        this.messageLogService = messageLogFactory.getInstance();
	        $scope.$watch(function () { return _this.messageLogService.busy; }, function (value) {
	            if (value === false) {
	                _this.busy = false;
	                _this.savingMessage = false;
	            }
	            else {
	                _this.busy = true;
	            }
	        });
	    }
	    EditableMessageLogController.prototype.add = function () {
	        if (this.object.isNullOrWhitespace(this.newMessage)) {
	            return null;
	        }
	        this.savingMessage = true;
	        var message = this.newMessage;
	        this.newMessage = '';
	        return this.messageLogService.addMessage({ message: message });
	    };
	    EditableMessageLogController.$inject = ['$scope', messageLog_service_1.factoryName, __object.serviceName];
	    return EditableMessageLogController;
	})();
	exports.EditableMessageLogController = EditableMessageLogController;
	function editableMessageLog() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<form ng-submit=\"log.add()\">\n\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t<input type=\"text\" class=\"form-control\" ng-model=\"log.newMessage\" placeholder=\"Enter log message\" />\n\t\t\t\t\t<span class=\"input-group-btn\">\n\t\t\t\t\t\t<button class=\"btn btn-default\" type=\"submit\" ng-disabled=\"log.busy\">\n\t\t\t\t\t\t\t<rl-busy loading=\"log.savingMessage\"></rl-busy> Add\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"message-log\">\n\t\t\t\t\t<rl-message-log service=\"log.service\" page-size=\"log.pageSize\" message-log=\"log.messageLogService\"></rl-message-log>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'log',
	        scope: {},
	        bindToController: {
	            service: '=',
	            pageSize: '=',
	        },
	    };
	}
	exports.editableMessageLog = editableMessageLog;
	//# sourceMappingURL=editableMessageLog.js.map

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	exports.moduleName = 'rl.ui.components.multiStepIndicator';
	exports.directiveName = 'rlMultiStepIndicator';
	exports.controllerName = 'MultiStepIndicatorController';
	var __object = typescript_angular_utilities_1.services.object;
	var MultiStepIndicatorController = (function () {
	    function MultiStepIndicatorController($state, $q, object) {
	        this.$state = $state;
	        this.$q = $q;
	        this.object = object;
	        this.configureSteps();
	    }
	    MultiStepIndicatorController.prototype.onClick = function (step) {
	        if (!this.anyLoading()) {
	            step.loading = true;
	            this.$q.when(step.onClick()).then(function () {
	                step.loading = false;
	            });
	        }
	    };
	    MultiStepIndicatorController.prototype.anyLoading = function () {
	        return _.any(this.steps, function (step) {
	            return step.loading;
	        });
	    };
	    MultiStepIndicatorController.prototype.configureSteps = function () {
	        var _this = this;
	        _.each(this.steps, function (step) {
	            step.hasCount = _.isFunction(step.count);
	            step.getCompleted = function () { return _this.getIsCompleted(step); };
	            step.getValid = function () { return _this.getIsValid(step); };
	            if (!_.isFunction(step.onClick)) {
	                if (_this.object.isNullOrWhitespace(step.stateName)) {
	                    step.inactive = true;
	                }
	                else {
	                    step.onClick = function () { return _this.redirectToState(step); };
	                    if (_this.$state.includes(step.stateName)) {
	                        step.isCurrent = true;
	                    }
	                }
	            }
	        });
	    };
	    MultiStepIndicatorController.prototype.redirectToState = function (step) {
	        var _this = this;
	        return this.$state.go(step.stateName).then(function () {
	            _this.clearCurrentState();
	            step.isCurrent = true;
	        });
	    };
	    MultiStepIndicatorController.prototype.clearCurrentState = function () {
	        _.each(this.steps, function (step) {
	            step.isCurrent = false;
	        });
	    };
	    MultiStepIndicatorController.prototype.getIsCompleted = function (step) {
	        return _.isFunction(step.isCompleted)
	            ? step.isCompleted()
	            : step.isCompleted;
	    };
	    MultiStepIndicatorController.prototype.setIsCompleted = function (step, isCompleted) {
	        if (!_.isFunction(step.isCompleted)) {
	            step.isCompleted = isCompleted;
	        }
	    };
	    MultiStepIndicatorController.prototype.getIsValid = function (step) {
	        if (_.isFunction(step.isValid)) {
	            return step.isValid();
	        }
	        else if (!_.isUndefined(step.isValid != null)) {
	            return step.isValid;
	        }
	        else {
	            return true;
	        }
	    };
	    MultiStepIndicatorController.$inject = ['$state', '$q', __object.serviceName];
	    return MultiStepIndicatorController;
	})();
	exports.MultiStepIndicatorController = MultiStepIndicatorController;
	function multiStepIndicator() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(113),
	        controller: exports.controllerName,
	        controllerAs: 'breadcrumb',
	        scope: {},
	        bindToController: {
	            steps: '=',
	            numbered: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, multiStepIndicator)
	    .controller(exports.controllerName, MultiStepIndicatorController);
	//# sourceMappingURL=multiStepIndicator.js.map

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "<div class=\"multi-step checked\" ng-class=\"{ 'numbered': breadcrumb.numbered }\">\r\n\t<ol>\r\n\t\t<li ng-repeat=\"step in breadcrumb.steps\" ng-click=\"breadcrumb.onClick(step)\"\r\n\t\t\tng-class=\"{ 'completed': step.getCompleted(), 'current': step.isCurrent, 'active': !step.inactive && !breadcrumb.anyLoading() }\">\r\n\t\t\t<div class=\"wrap\">\r\n\t\t\t\t<p class=\"badge\" ng-show=\"step.hasCount\">{{step.count()}}</p>\r\n\t\t\t\t<p class=\"error\" ng-if=\"!step.getValid()\"></p>\r\n\t\t\t\t<p class=\"title\">{{step.title}} <rl-busy loading=\"step.loading\"></rl-busy></p>\r\n\t\t\t\t<p class=\"subtitle\">{{step.subtitle}}</p>\r\n\t\t\t</div>\r\n\t\t</li>\r\n\t</ol>\r\n</div>"

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var radioGroup_1 = __webpack_require__(115);
	exports.radioGroupDirectiveName = radioGroup_1.directiveName;
	exports.radioGroup = radioGroup_1.radioGroup;
	exports.radioGroupControllerName = radioGroup_1.controllerName;
	exports.RadioGroupController = radioGroup_1.RadioGroupController;
	var radio_1 = __webpack_require__(116);
	exports.radioDirectiveName = radio_1.directiveName;
	exports.radio = radio_1.radio;
	exports.radioControllerName = radio_1.controllerName;
	exports.RadioController = radio_1.RadioController;
	exports.moduleName = 'rl21.components.radio';
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(radioGroup_1.directiveName, radioGroup_1.radioGroup)
	    .controller(radioGroup_1.controllerName, radioGroup_1.RadioGroupController)
	    .directive(radio_1.directiveName, radio_1.radio)
	    .controller(radio_1.controllerName, radio_1.RadioController);
	//# sourceMappingURL=radio.module.js.map

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	exports.directiveName = 'rlRadioGroup';
	exports.controllerName = 'RadioGroupController';
	var RadioGroup = (function () {
	    function RadioGroup($scope, ngModel, name) {
	        var _this = this;
	        this.name = name;
	        $scope.$watch(function () { return ngModel.$viewValue; }, function (value) {
	            _this.selection = value;
	        });
	        $scope.$watch(function () { return _this.selection; }, function (value) {
	            ngModel.$setViewValue(value);
	        });
	    }
	    return RadioGroup;
	})();
	exports.RadioGroup = RadioGroup;
	var RadioGroupController = (function () {
	    function RadioGroupController($scope, $attrs, $element, object) {
	        var name;
	        if (!object.isNullOrWhitespace($attrs.rlRadioGroup)) {
	            name = $attrs.rlRadioGroup;
	        }
	        else if (!object.isNullOrWhitespace($attrs.name)) {
	            name = $attrs.name;
	        }
	        else {
	            name = 'RadioGroup' + this.getNextId();
	        }
	        var ngModel = $element.controller('ngModel');
	        this.group = new RadioGroup($scope, ngModel, name);
	    }
	    RadioGroupController.prototype.registerButton = function () {
	        return this.group;
	    };
	    RadioGroupController.prototype.getNextId = function () {
	        var nextId = RadioGroupController.nextId.toString();
	        RadioGroupController.nextId++;
	        return nextId;
	    };
	    RadioGroupController.nextId = 1;
	    RadioGroupController.$inject = ['$scope', '$attrs', '$element', __object.serviceName];
	    return RadioGroupController;
	})();
	exports.RadioGroupController = RadioGroupController;
	function radioGroup() {
	    'use strict';
	    return {
	        restrict: 'AE',
	        require: 'ngModel',
	        controller: exports.controllerName,
	    };
	}
	exports.radioGroup = radioGroup;
	//# sourceMappingURL=radioGroup.js.map

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var radioGroup_1 = __webpack_require__(115);
	exports.directiveName = 'rlRadio';
	exports.controllerName = 'RadioController';
	var RadioController = (function () {
	    function RadioController($scope, $element) {
	        var radioGroupController = $element.controller('rlRadioGroup');
	        if (radioGroupController != null) {
	            this.radioGroup = radioGroupController.registerButton();
	        }
	        else {
	            var ngModel = $element.controller('ngModel');
	            this.radioGroup = new radioGroup_1.RadioGroup($scope, ngModel);
	        }
	    }
	    RadioController.$inject = ['$scope', '$element'];
	    return RadioController;
	})();
	exports.RadioController = RadioController;
	function radio() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: ['?^^rlRadioGroup', '?ngModel'],
	        transclude: true,
	        template: "\n\t\t\t<label>\n\t\t\t\t<input id=\"radio\" type=\"radio\" name=\"{{radio.radioGroup.name}}\" ng-model=\"radio.radioGroup.selection\" ng-value=\"radio.value\" />\n\t\t\t\t<span ng-transclude></div>\n\t\t\t</label>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'radio',
	        scope: true,
	        bindToController: {
	            value: '=',
	        },
	    };
	}
	exports.radio = radio;
	//# sourceMappingURL=radio.js.map

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var ratingBarBackgrounds_service_1 = __webpack_require__(118);
	var ratingBarClass_service_1 = __webpack_require__(119);
	exports.moduleName = 'rl.ui.components.ratingBar';
	exports.directiveName = 'rlRatingBar';
	exports.controllerName = 'RatingBarController';
	var RatingBarController = (function () {
	    function RatingBarController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        var ratingBarBackgrounds = new ratingBarBackgrounds_service_1.RatingBarBackgroundService;
	        this.ratingBarClass = new ratingBarClass_service_1.RatingBarClassService;
	        this.backgroundClass = ratingBarBackgrounds.getBackground(this.background);
	        if (this.value == null) {
	            this.value = 0;
	        }
	        $scope.$watch(function () { return _this.value; }, function (newValue) {
	            _this.updateValue(newValue);
	        });
	        $scope.$watch(function () { return _this.totalWidth; }, function (newWidth) {
	            _this.dimensions = {
	                width: newWidth + 2,
	                height: _this.height + 2,
	            };
	            _this.updateValue(_this.value);
	        });
	    }
	    RatingBarController.prototype.updateValue = function (newValue) {
	        var confidenceScore = (newValue - this.min) / (this.max - this.min);
	        this.barClass = this.ratingBarClass.getClass(confidenceScore);
	        this.width = Math.round(confidenceScore * this.totalWidth);
	    };
	    RatingBarController.$inject = ['$scope'];
	    return RatingBarController;
	})();
	exports.RatingBarController = RatingBarController;
	function ratingBar() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div class=\"rating-bar\">\n\t\t\t\t<div class=\"{{ratingBar.backgroundClass}}\" ng-class=\"{ empty: ratingBar.value == min }\" ng-style=\"ratingBar.dimensions\">\n\t\t\t\t\t<div ng-class=\"ratingBar.barClass\" ng-style=\"{ width: ratingBar.width, height: ratingBar.height }\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'ratingBar',
	        scope: {},
	        bindToController: {
	            totalWidth: '=width',
	            height: '=',
	            value: '=',
	            min: '=',
	            max: '=',
	            background: '=',
	        },
	    };
	}
	exports.ratingBar = ratingBar;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, ratingBar)
	    .controller(exports.controllerName, RatingBarController);
	//# sourceMappingURL=ratingBar.js.map

/***/ },
/* 118 */
/***/ function(module, exports) {

	'use strict';
	var RatingBarBackgroundService = (function () {
	    function RatingBarBackgroundService() {
	        this.standard = {
	            type: 'standard',
	            class: 'background',
	        };
	        this.dark = {
	            type: 'dark',
	            class: 'background-dark',
	        };
	        this.transparent = {
	            type: 'transparent',
	            class: 'background-transparent',
	        };
	    }
	    RatingBarBackgroundService.prototype.getBackground = function (type) {
	        if (type === this.dark.type) {
	            return this.dark.class;
	        }
	        else if (type === this.transparent.type) {
	            return this.transparent.class;
	        }
	        else {
	            return this.standard.class;
	        }
	    };
	    return RatingBarBackgroundService;
	})();
	exports.RatingBarBackgroundService = RatingBarBackgroundService;
	//# sourceMappingURL=ratingBarBackgrounds.service.js.map

/***/ },
/* 119 */
/***/ function(module, exports) {

	'use strict';
	var RatingBarClassService = (function () {
	    function RatingBarClassService() {
	    }
	    RatingBarClassService.prototype.getClass = function (confidence) {
	        if (confidence >= 0.8) {
	            return 'very-high';
	        }
	        else if (confidence >= 0.6) {
	            return 'high';
	        }
	        else if (confidence >= 0.4) {
	            return 'medium';
	        }
	        else if (confidence >= 0.2) {
	            return 'low';
	        }
	        else {
	            return 'very-low';
	        }
	    };
	    return RatingBarClassService;
	})();
	exports.RatingBarClassService = RatingBarClassService;
	//# sourceMappingURL=ratingBarClass.service.js.map

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	__webpack_require__(121);
	__webpack_require__(123);
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var richTextEditor_config_1 = __webpack_require__(124);
	var headerButton_1 = __webpack_require__(125);
	var paragraphButton_1 = __webpack_require__(126);
	var externalProviderName = richTextEditor_config_1.providerName + 'Provider';
	exports.providerName = externalProviderName;
	exports.moduleName = 'rl.ui.components.richTextEditor';
	exports.directiveName = 'rlRichTextEditor';
	exports.controllerName = 'RichTextEditorController';
	var RichTextEditorController = (function () {
	    function RichTextEditorController(object, provider) {
	        this.toolbar = 'h1, paragraph, bold, italic, underline, list1, list2, indent, outdent';
	        if (!object.isNullOrEmpty(this.customButtons)) {
	            this.toolbar += ', ' + this.customButtons;
	        }
	    }
	    RichTextEditorController.$inject = [__object.serviceName, richTextEditor_config_1.providerName];
	    return RichTextEditorController;
	})();
	exports.RichTextEditorController = RichTextEditorController;
	function richTextEditor() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(127),
	        controller: exports.controllerName,
	        controllerAs: 'editor',
	        scope: {},
	        bindToController: {
	            ngModel: '=',
	            customButtons: '=',
	        },
	    };
	}
	exports.richTextEditor = richTextEditor;
	angular.module(exports.moduleName, ['ngWig', __object.moduleName])
	    .directive(exports.directiveName, richTextEditor)
	    .controller(exports.controllerName, RichTextEditorController)
	    .directive(headerButton_1.headerButtonDirectiveName, headerButton_1.headerButton)
	    .directive(paragraphButton_1.paragraphButtonDirectiveName, paragraphButton_1.paragraphButton)
	    .provider(richTextEditor_config_1.providerName, richTextEditor_config_1.richTextEditorProvider);
	//# sourceMappingURL=richTextEditor.js.map

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(122);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(11)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./ng-wig.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./ng-wig.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(10)();
	// imports
	exports.push([module.id, "@import url(https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css);", ""]);
	
	// module
	exports.push([module.id, "/* -------- NG-WIG -------- */\n/**\n *\n *  RESET BOX MODEL\n *\n */\n.ng-wig,\n[class^=\"nw-\"] {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -o-box-sizing: border-box;\n  -ms-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n\n/**\n *   main wrapper for the editor\n *\n *  .ng-wig\n *\n */\n.ng-wig {\n  display: block;\n  padding: 0;\n  margin: 0;\n}\n\n\n/**\n *  styling for toolbar and its items\n *\n *  .nw-toolbar\n *    &__item\n *\n */\n.nw-toolbar {\n  display: block;\n  margin: 0 !important;\n  padding: 0 !important;\n  list-style: none !important;\n  font-size: 12px;\n  color: #6B7277;\n\n  background: -webkit-linear-gradient(90deg, #ffffff 0%, #f9f9f9 100%);\n  background:    -moz-linear-gradient(90deg, #ffffff 0%, #f9f9f9 100%);\n  background:         linear-gradient(180deg, #ffffff 0%, #f9f9f9 100%);\n  border: 1px solid #CCCCCC;\n  border-radius: 3px 3px 0 0;\n}\n\n.nw-toolbar__item {\n  display: inline-block;\n  vertical-align: top;\n\n  border-right: 1px solid #DEDEDE;\n}\n\n.nw-toolbar label {\n  line-height: 30px;\n  display: inline-block;\n  padding: 0 6px 0 3px;\n}\n\n.nw-toolbar input[type=checkbox] {\n  vertical-align: -3px;\n  margin-right: -1px;\n}\n\n/**\n *  styling for the editor part: source code (original textarea) and resulting div\n *\n *  .nw-editor\n *    &__src\n *    &__res\n *\n */\n.nw-editor {\n  display: block;\n  position: relative;\n  overflow-y: auto;\n  padding: 0 8px;\n  /* Default when height is not set */\n  min-height: 300px;\n  background: #fff;\n  cursor: text;\n}\n\n.nw-invisible {\n  display: none;\n}\n\n.nw-editor-container {\n  border: 1px solid #CCCCCC;\n  border-top: none;\n  border-radius: 0 0 3px 3px;\n}\n\n.nw-editor__res {\n  min-height: 100%;\n  margin: -1px 0;\n  padding: 1px 0;\n}\n\n.nw-editor__src,\n.nw-editor__res {\n  width: 100%;\n  outline: none;\n  box-sizing: border-box;\n  border: none;\n}\n\n.nw-editor__src {\n  resize: none;\n  display: block;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  padding: 8px;\n}\n\n\n/**\n *  styling for toolbar button, has two modifiers: active and type of icon for background\n *\n *  .nw-button\n *    &--active\n *    &--{button type}\n *\n */\n.nw-button {\n  -webkit-appearance: none;\n  -moz-appearance:    none;\n  appearance:         none;\n\n  display: block;\n  width: 30px;\n  height: 30px;\n  margin: 0;\n  padding: 0;\n  opacity: 0.5;\n\n  background-color: transparent;\n  background-position: center center;\n  background-repeat: no-repeat;\n  border: none;\n  border-radius: 2px;\n\n  cursor: pointer;\n}\n\n.nw-button:focus {\n  outline: none;\n}\n\n.nw-button:hover,\n.nw-button.nw-button--active {\n  opacity: 1\n}\n\n.nw-button--active {\n  background-color: #EEEEEE;\n}\n\n/**\n *  styling & formatting of content inside contenteditable div\n *\n *  .nw-content\n *\n */\n.nw-content {\n  padding: 12px;\n  margin: 0;\n\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 24px;\n}\n\n.nw-select {\n  height: 30px;\n  padding: 6px;\n  color: #555;\n  background-color: inherit;\n  border: 0;\n}\n\n.nw-select:focus { outline: none; }\n\n", ""]);
	
	// exports


/***/ },
/* 123 */
/***/ function(module, exports) {

	/**
	 * version: 2.2.0
	 */
	angular.module('ngWig', ['ngwig-app-templates']);
	
	angular.module('ngWig')
	  .directive('ngWig', ["$window", "$document", "ngWigToolbar", function ($window, $document, ngWigToolbar) {
	
	    return {
	      scope: {
	        content: '=ngWig',
	        onPaste: '='
	      },
	      restrict: 'A',
	      replace: true,
	      templateUrl: 'ng-wig/views/ng-wig.html',
	      link: function (scope, element, attrs) {
	
	        scope.editMode = false;
	        scope.autoexpand = !('autoexpand' in attrs) || attrs['autoexpand'] !== 'off';
	        scope.toolbarButtons = ngWigToolbar.getToolbarButtons(attrs.buttons && string2array(attrs.buttons));
	
	        function string2array(keysString){
	          return keysString.split(',').map(Function.prototype.call, String.prototype.trim);
	        }
	
	        scope.toggleEditMode = function () {
	          scope.editMode = !scope.editMode;
	
	          if ($window.getSelection().removeAllRanges) {
	            $window.getSelection().removeAllRanges();
	          }
	        };
	
	        scope.execCommand = function (command, options) {
	          if(scope.editMode ) return false;
	
	          if (command === 'createlink') {
	            options = prompt('Please enter the URL', 'http://');
	            if(!options) {
	              return;
	            }
	          }
	          scope.$broadcast('execCommand', {command: command, options: options});
	        };
	      }
	    }
	  }]
	);
	
	
	angular.module('ngWig')
	  .directive('ngWigEditable', ["$document", function ($document) {
	    function init(scope, $element, attrs, ngModelController) {
	
	      $element.attr('contenteditable', true);
	
	      //model --> view
	      ngModelController.$render = function () {
	        $element.html(ngModelController.$viewValue || '');
	      };
	
	      //view --> model
	      function viewToModel() {
	        ngModelController.$setViewValue($element.html());
	      }
	
	      var eventsToBind = [
	        'blur',
	        'keyup',
	        'change',
	        'focus',
	        'click'
	      ];
	
	      if (angular.isFunction(scope.onPaste)) {
	        $element.on('paste', function(e) {
	          scope.onPaste(e, $element.html()).then(function(val) {
	            $element.html(val);
	          })
	        });
	      }else{
	        eventsToBind.push('paste');
	      }
	
	      $element.bind(eventsToBind.join(' '), function() {
	        viewToModel();
	        scope.$applyAsync();
	      });
	
	      scope.isEditorActive = function () {
	        return $element[0] === $document[0].activeElement;
	      };
	
	      scope.$on('execCommand', function (event, params) {
	        $element[0].focus();
	
	        var ieStyleTextSelection = $document[0].selection,
	          command = params.command,
	          options = params.options;
	
	        if (ieStyleTextSelection) {
	          var textRange = ieStyleTextSelection.createRange();
	        }
	
	        if ($document[0].queryCommandSupported && !$document[0].queryCommandSupported(command)) {
	          throw 'The command "' + command + '" is not supported';
	        }
	
	        $document[0].execCommand(command, false, options);
	
	        if (ieStyleTextSelection) {
	          textRange.collapse(false);
	          textRange.select();
	        }
	
	        viewToModel();
	      });
	    }
	
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      replace: true,
	      link: init
	    }
	  }]
	);
	
	angular.module('ngWig')
	    .directive('ngWigPlugin', ["$compile", function ($compile) {
	        return {
	            restrict: 'E',
	            link: function(scope, element) {
	                var template = '<' + scope.button.pluginName + ' />',
	                    compiled = $compile(template)(scope);
	
	                element.replaceWith(compiled);
	            }
	        }
	    }]);
	
	angular.module('ngWig').provider('ngWigToolbar', function () {
	
	  var buttonLibrary = {
	    list1: {title: 'Unordered List', command: 'insertunorderedlist', styleClass: 'fa-list-ul'},
	    list2: {title: 'Ordered List', command: 'insertorderedlist', styleClass: 'fa-list-ol'},
	    bold: {title: 'Bold', command: 'bold', styleClass: 'fa-bold'},
	    italic: {title: 'Italic', command: 'italic', styleClass: 'fa-italic'},
	    link: {title: 'Link', command: 'createlink', styleClass: 'fa-link'}
	  };
	
	  var defaultButtonsList = ['list1', 'list2', 'bold', 'italic', 'link'];
	
	  var isButtonActive = function () {
	    return this.command && document.queryCommandState(this.command);
	  };
	
	  this.setButtons = function(buttons) {
	    if(!angular.isArray(buttons)) {
	      throw 'Argument "buttons" should be an array';
	    }
	
	    defaultButtonsList = buttons;
	  };
	
	  this.addStandardButton = function (name, title, command, styleClass) {
	    if(!name || !title || !command) {
	      throw 'Arguments "name", "title" and "command" are required';
	    }
	
	    styleClass = styleClass || '';
	    buttonLibrary[name] = {title: title, command: command, styleClass: styleClass}
	    defaultButtonsList.push(name);
	  };
	
	  this.addCustomButton = function (name, pluginName) {
	    if(!name || !pluginName) {
	      throw 'Arguments "name" and "pluginName" are required';
	    }
	
	    buttonLibrary[name] = {pluginName: pluginName, isComplex: true};
	    defaultButtonsList.push(name);
	  };
	
	  this.$get = function () {
	    return {
	      getToolbarButtons: function(list) {
	        var toolbarButtons = [];
	        (list || defaultButtonsList).forEach(function(buttonKey) {
	          if(!buttonLibrary[buttonKey]) {
	            throw 'There is no "' + buttonKey + '" in your library. Possible variants: ' + Object.keys(buttonLibrary);
	          }
	
	          var button = angular.copy(buttonLibrary[buttonKey]);
	
	          if(!angular.isFunction(button.isActive)) {
	            button.isActive = isButtonActive;
	          }
	
	          toolbarButtons.push(button);
	        });
	        return toolbarButtons;
	      }
	    };
	  };
	
	
	});
	angular.module('ngWig')
	    .config(['ngWigToolbarProvider', function (ngWigToolbarProvider) {
	       ngWigToolbarProvider.addCustomButton('formats', 'nw-formats-button');
	    }])
	    .directive('nwFormatsButton', function() {
	        return {
	            restrict: 'E',
	            replace: true,
	            template: '<select class="nw-select" ng-model="format" ng-change="execCommand(\'formatblock\', format.value)" ng-options="format.name for format in formats" ng-disabled="editMode"></select>',
	            link: function (scope) {
	                scope.formats = [
	                    {name: 'Normal text', value: 'p'},
	                    {name: 'Header 1', value: 'h1'},
	                    {name: 'Header 2', value: 'h2'},
	                    {name: 'Header 3', value: 'h3'}
	                ];
	
	                scope.format = scope.formats[0];
	            }
	        };
	    });
	
	
	angular.module('ngwig-app-templates', ['ng-wig/views/ng-wig.html']);
	
	angular.module("ng-wig/views/ng-wig.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("ng-wig/views/ng-wig.html",
	    "<div class=\"ng-wig\">\n" +
	    "  <ul class=\"nw-toolbar\">\n" +
	    "    <li class=\"nw-toolbar__item\" ng-repeat=\"button in toolbarButtons\" >\n" +
	    "        <div ng-if=\"!button.isComplex\">\n" +
	    "          <button type=\"button\" class=\"nw-button\" title=\"{{button.title}}\" ng-click=\"execCommand(button.command)\" ng-class=\"{ 'nw-button--active': isEditorActive() && button.isActive() }\" ng-disabled=\"editMode\">\n" +
	    "            <i class=\"fa {{button.styleClass}}\"></i>\n" +
	    "          </button>\n" +
	    "        </div>\n" +
	    "        <div ng-if=\"button.isComplex\">\n" +
	    "          <ng-wig-plugin plugin=\"{{button}}\"></ng-wig-plugin>\n" +
	    "        </div>\n" +
	    "    </li><!--\n" +
	    "    --><li class=\"nw-toolbar__item\">\n" +
	    "      <button type=\"button\" class=\"nw-button nw-button--source\" ng-class=\"{ 'nw-button--active': editMode }\" ng-click=\"toggleEditMode()\"><i class=\"fa fa-pencil\"></i></button>\n" +
	    "    </li>\n" +
	    "  </ul>\n" +
	    "\n" +
	    "  <div class=\"nw-editor-container\">\n" +
	    "    <div class=\"nw-editor\">\n" +
	    "      <textarea  class=\"nw-editor__src\" ng-show=\"editMode\" ng-model=\"content\"></textarea>\n" +
	    "      <div tabindex=\"-1\" ng-class=\"{'nw-invisible': editMode, 'nw-autoexpand': autoexpand}\" class=\"nw-editor__res\" ng-model=\"content\" ng-wig-editable on-paste=\"onPaste\"></div>\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);


/***/ },
/* 124 */
/***/ function(module, exports) {

	'use strict';
	exports.providerName = 'richTextEditor';
	richTextEditorProvider.$inject = ['ngWigToolbarProvider'];
	function richTextEditorProvider(ngWigToolbarProvider) {
	    'use strict';
	    return {
	        addCustomButton: function (name, component) {
	            ngWigToolbarProvider.addCustomButton(name, component);
	        },
	        addStandardButton: function (name, tooltip, command, icon) {
	            ngWigToolbarProvider.addStandardButton(name, toolbar, command, 'fa-' + icon);
	        },
	        $get: function () {
	            ngWigToolbarProvider.addCustomButton('paragraph', 'rl-paragraph-button');
	            ngWigToolbarProvider.addCustomButton('h1', 'rl-header-button');
	            ngWigToolbarProvider.addStandardButton('underline', 'Underline', 'underline', 'fa-underline');
	            ngWigToolbarProvider.addStandardButton('indent', 'Indent', 'indent', 'fa-indent');
	            ngWigToolbarProvider.addStandardButton('outdent', 'Outdent', 'outdent', 'fa-outdent');
	        },
	    };
	}
	exports.richTextEditorProvider = richTextEditorProvider;
	//# sourceMappingURL=richTextEditor.config.js.map

/***/ },
/* 125 */
/***/ function(module, exports) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.headerButtonDirectiveName = 'rlHeaderButton';
	function headerButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<button type=\"button\" class=\"nw-button\" ng-click=\"trigger()\" ng-disabled=\"editMode\" title=\"Header 1\">\n\t\t\t\t<i class=\"fa fa-header\"></i>\n\t\t\t</button>\n\t\t",
	        link: function (scope) {
	            scope.trigger = function () {
	                scope.execCommand('formatblock', 'h1');
	            };
	        },
	    };
	}
	exports.headerButton = headerButton;
	//# sourceMappingURL=headerButton.js.map

/***/ },
/* 126 */
/***/ function(module, exports) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.paragraphButtonDirectiveName = 'rlParagraphButton';
	function paragraphButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<button type=\"button\" class=\"nw-button\" ng-click=\"trigger()\" ng-disabled=\"editMode\" title=\"paragraph\">\n\t\t\t\t<i class=\"fa fa-paragraph\"></i>\n\t\t\t</button>\n\t\t",
	        link: function (scope) {
	            scope.trigger = function () {
	                scope.execCommand('formatblock', 'p');
	            };
	        },
	    };
	}
	exports.paragraphButton = paragraphButton;
	//# sourceMappingURL=paragraphButton.js.map

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = "<textarea class=\"rich-text-editor\" ng-wig=\"editor.ngModel\" buttons=\"{{editor.toolbar}}\"></textarea>"

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	__webpack_require__(129);
	__webpack_require__(130);
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	var componentValidator_service_1 = __webpack_require__(99);
	exports.moduleName = 'rl.ui.components.select';
	exports.directiveName = 'rlSelect';
	exports.controllerName = 'SelectController';
	var SelectController = (function () {
	    function SelectController($element, $scope, $q, componentValidatorFactory, object) {
	        var _this = this;
	        this.$q = $q;
	        this.object = object;
	        this._nullOption = {
	            __isNullOption: true,
	        };
	        this.ngModel = $element.controller('ngModel');
	        if (_.isUndefined(this.options)) {
	            this.loading = true;
	            this.loadItems().then(function (options) {
	                _this.options = options;
	                _this.loading = false;
	            });
	        }
	        else {
	            this.options = this.configureOptions(this.options);
	        }
	        if (!_.isUndefined(this.validator)) {
	            this.selectValidator = componentValidatorFactory.getInstance({
	                ngModel: this.ngModel,
	                $scope: $scope,
	                validators: [this.validator],
	            });
	        }
	    }
	    Object.defineProperty(SelectController.prototype, "selection", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            if (value.__isNullOption) {
	                this.ngModel.$setViewValue(null);
	            }
	            else {
	                this.ngModel.$setViewValue(value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SelectController.prototype.getDisplayName = function (item) {
	        if (item == null) {
	            return null;
	        }
	        if (item.__isNullOption) {
	            return this.nullOption;
	        }
	        return _.isFunction(this.selector)
	            ? this.selector(item)
	            : item[this.selector];
	    };
	    SelectController.prototype.loadItems = function () {
	        var _this = this;
	        var promise;
	        if (_.isFunction(this.getOptions)) {
	            promise = this.getOptions();
	        }
	        else {
	            promise = this.$q.when(this.options);
	        }
	        return promise.then(function (options) { return _this.configureOptions(options); });
	    };
	    SelectController.prototype.configureOptions = function (options) {
	        if (!this.object.isNullOrWhitespace(this.nullOption)) {
	            options.unshift(this._nullOption);
	        }
	        return options;
	    };
	    SelectController.$inject = ['$element', '$scope', '$q', componentValidator_service_1.factoryName, __object.serviceName];
	    return SelectController;
	})();
	exports.SelectController = SelectController;
	function select() {
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: __webpack_require__(132),
	        controller: exports.controllerName,
	        controllerAs: 'select',
	        scope: {},
	        bindToController: {
	            options: '=',
	            getOptions: '&',
	            selector: '=',
	            validator: '=',
	            label: '@',
	            ngDisabled: '=',
	            nullOption: '@',
	        },
	    };
	}
	exports.select = select;
	angular.module(exports.moduleName, ['ui.select', componentValidator_service_1.moduleName, __object.moduleName])
	    .directive(exports.directiveName, select)
	    .controller(exports.controllerName, SelectController);
	//# sourceMappingURL=select.js.map

/***/ },
/* 129 */
/***/ function(module, exports) {

	/*!
	 * ui-select
	 * http://github.com/angular-ui/ui-select
	 * Version: 0.13.2 - 2015-10-09T15:34:24.040Z
	 * License: MIT
	 */
	
	
	(function () { 
	"use strict";
	
	var KEY = {
	    TAB: 9,
	    ENTER: 13,
	    ESC: 27,
	    SPACE: 32,
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40,
	    SHIFT: 16,
	    CTRL: 17,
	    ALT: 18,
	    PAGE_UP: 33,
	    PAGE_DOWN: 34,
	    HOME: 36,
	    END: 35,
	    BACKSPACE: 8,
	    DELETE: 46,
	    COMMAND: 91,
	
	    MAP: { 91 : "COMMAND", 8 : "BACKSPACE" , 9 : "TAB" , 13 : "ENTER" , 16 : "SHIFT" , 17 : "CTRL" , 18 : "ALT" , 19 : "PAUSEBREAK" , 20 : "CAPSLOCK" , 27 : "ESC" , 32 : "SPACE" , 33 : "PAGE_UP", 34 : "PAGE_DOWN" , 35 : "END" , 36 : "HOME" , 37 : "LEFT" , 38 : "UP" , 39 : "RIGHT" , 40 : "DOWN" , 43 : "+" , 44 : "PRINTSCREEN" , 45 : "INSERT" , 46 : "DELETE", 48 : "0" , 49 : "1" , 50 : "2" , 51 : "3" , 52 : "4" , 53 : "5" , 54 : "6" , 55 : "7" , 56 : "8" , 57 : "9" , 59 : ";", 61 : "=" , 65 : "A" , 66 : "B" , 67 : "C" , 68 : "D" , 69 : "E" , 70 : "F" , 71 : "G" , 72 : "H" , 73 : "I" , 74 : "J" , 75 : "K" , 76 : "L", 77 : "M" , 78 : "N" , 79 : "O" , 80 : "P" , 81 : "Q" , 82 : "R" , 83 : "S" , 84 : "T" , 85 : "U" , 86 : "V" , 87 : "W" , 88 : "X" , 89 : "Y" , 90 : "Z", 96 : "0" , 97 : "1" , 98 : "2" , 99 : "3" , 100 : "4" , 101 : "5" , 102 : "6" , 103 : "7" , 104 : "8" , 105 : "9", 106 : "*" , 107 : "+" , 109 : "-" , 110 : "." , 111 : "/", 112 : "F1" , 113 : "F2" , 114 : "F3" , 115 : "F4" , 116 : "F5" , 117 : "F6" , 118 : "F7" , 119 : "F8" , 120 : "F9" , 121 : "F10" , 122 : "F11" , 123 : "F12", 144 : "NUMLOCK" , 145 : "SCROLLLOCK" , 186 : ";" , 187 : "=" , 188 : "," , 189 : "-" , 190 : "." , 191 : "/" , 192 : "`" , 219 : "[" , 220 : "\\" , 221 : "]" , 222 : "'"
	    },
	
	    isControl: function (e) {
	        var k = e.which;
	        switch (k) {
	        case KEY.COMMAND:
	        case KEY.SHIFT:
	        case KEY.CTRL:
	        case KEY.ALT:
	            return true;
	        }
	
	        if (e.metaKey) return true;
	
	        return false;
	    },
	    isFunctionKey: function (k) {
	        k = k.which ? k.which : k;
	        return k >= 112 && k <= 123;
	    },
	    isVerticalMovement: function (k){
	      return ~[KEY.UP, KEY.DOWN].indexOf(k);
	    },
	    isHorizontalMovement: function (k){
	      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);
	    }
	  };
	
	/**
	 * Add querySelectorAll() to jqLite.
	 *
	 * jqLite find() is limited to lookups by tag name.
	 * TODO This will change with future versions of AngularJS, to be removed when this happens
	 *
	 * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586
	 * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598
	 */
	if (angular.element.prototype.querySelectorAll === undefined) {
	  angular.element.prototype.querySelectorAll = function(selector) {
	    return angular.element(this[0].querySelectorAll(selector));
	  };
	}
	
	/**
	 * Add closest() to jqLite.
	 */
	if (angular.element.prototype.closest === undefined) {
	  angular.element.prototype.closest = function( selector) {
	    var elem = this[0];
	    var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;
	
	    while (elem) {
	      if (matchesSelector.bind(elem)(selector)) {
	        return elem;
	      } else {
	        elem = elem.parentElement;
	      }
	    }
	    return false;
	  };
	}
	
	var latestId = 0;
	
	var uis = angular.module('ui.select', [])
	
	.constant('uiSelectConfig', {
	  theme: 'bootstrap',
	  searchEnabled: true,
	  sortable: false,
	  placeholder: '', // Empty by default, like HTML tag <select>
	  refreshDelay: 1000, // In milliseconds
	  closeOnSelect: true,
	  dropdownPosition: 'auto',
	  generateId: function() {
	    return latestId++;
	  },
	  appendToBody: false
	})
	
	// See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913
	.service('uiSelectMinErr', function() {
	  var minErr = angular.$$minErr('ui.select');
	  return function() {
	    var error = minErr.apply(this, arguments);
	    var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
	    return new Error(message);
	  };
	})
	
	// Recreates old behavior of ng-transclude. Used internally.
	.directive('uisTranscludeAppend', function () {
	  return {
	    link: function (scope, element, attrs, ctrl, transclude) {
	        transclude(scope, function (clone) {
	          element.append(clone);
	        });
	      }
	    };
	})
	
	/**
	 * Highlights text that matches $select.search.
	 *
	 * Taken from AngularUI Bootstrap Typeahead
	 * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340
	 */
	.filter('highlight', function() {
	  function escapeRegexp(queryToEscape) {
	    return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	  }
	
	  return function(matchItem, query) {
	    return query && matchItem ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
	  };
	})
	
	/**
	 * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/
	 *
	 * Taken from AngularUI Bootstrap Position:
	 * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70
	 */
	.factory('uisOffset',
	  ['$document', '$window',
	  function ($document, $window) {
	
	  return function(element) {
	    var boundingClientRect = element[0].getBoundingClientRect();
	    return {
	      width: boundingClientRect.width || element.prop('offsetWidth'),
	      height: boundingClientRect.height || element.prop('offsetHeight'),
	      top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
	      left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
	    };
	  };
	}]);
	
	uis.directive('uiSelectChoices',
	  ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile',
	  function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile) {
	
	  return {
	    restrict: 'EA',
	    require: '^uiSelect',
	    replace: true,
	    transclude: true,
	    templateUrl: function(tElement) {
	      // Gets theme attribute from parent (ui-select)
	      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
	      return theme + '/choices.tpl.html';
	    },
	
	    compile: function(tElement, tAttrs) {
	
	      if (!tAttrs.repeat) throw uiSelectMinErr('repeat', "Expected 'repeat' expression.");
	
	      return function link(scope, element, attrs, $select, transcludeFn) {
	
	        // var repeat = RepeatParser.parse(attrs.repeat);
	        var groupByExp = attrs.groupBy;
	        var groupFilterExp = attrs.groupFilter;
	
	        $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult
	
	        $select.disableChoiceExpression = attrs.uiDisableChoice;
	        $select.onHighlightCallback = attrs.onHighlight;
	
	        $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;
	
	        if(groupByExp) {
	          var groups = element.querySelectorAll('.ui-select-choices-group');
	          if (groups.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
	          groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
	        }
	
	        var choices = element.querySelectorAll('.ui-select-choices-row');
	        if (choices.length !== 1) {
	          throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
	        }
	
	        choices.attr('ng-repeat', $select.parserResult.repeatExpression(groupByExp))
	            .attr('ng-if', '$select.open') //Prevent unnecessary watches when dropdown is closed
	            .attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',false,$event)');
	
	        var rowsInner = element.querySelectorAll('.ui-select-choices-row-inner');
	        if (rowsInner.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
	        rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat
	
	        $compile(element, transcludeFn)(scope); //Passing current transcludeFn to be able to append elements correctly from uisTranscludeAppend
	
	        scope.$watch('$select.search', function(newValue) {
	          if(newValue && !$select.open && $select.multiple) $select.activate(false, true);
	          $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
	          $select.refresh(attrs.refresh);
	        });
	
	        attrs.$observe('refreshDelay', function() {
	          // $eval() is needed otherwise we get a string instead of a number
	          var refreshDelay = scope.$eval(attrs.refreshDelay);
	          $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
	        });
	      };
	    }
	  };
	}]);
	
	/**
	 * Contains ui-select "intelligence".
	 *
	 * The goal is to limit dependency on the DOM whenever possible and
	 * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.
	 */
	uis.controller('uiSelectCtrl',
	  ['$scope', '$element', '$timeout', '$filter', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse',
	  function($scope, $element, $timeout, $filter, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse) {
	
	  var ctrl = this;
	
	  var EMPTY_SEARCH = '';
	
	  ctrl.placeholder = uiSelectConfig.placeholder;
	  ctrl.searchEnabled = uiSelectConfig.searchEnabled;
	  ctrl.sortable = uiSelectConfig.sortable;
	  ctrl.refreshDelay = uiSelectConfig.refreshDelay;
	
	  ctrl.removeSelected = false; //If selected item(s) should be removed from dropdown list
	  ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function
	  ctrl.search = EMPTY_SEARCH;
	
	  ctrl.activeIndex = 0; //Dropdown of choices
	  ctrl.items = []; //All available choices
	
	  ctrl.open = false;
	  ctrl.focus = false;
	  ctrl.disabled = false;
	  ctrl.selected = undefined;
	
	  ctrl.dropdownPosition = 'auto';
	
	  ctrl.focusser = undefined; //Reference to input element used to handle focus events
	  ctrl.resetSearchInput = true;
	  ctrl.multiple = undefined; // Initialized inside uiSelect directive link function
	  ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function
	  ctrl.tagging = {isActivated: false, fct: undefined};
	  ctrl.taggingTokens = {isActivated: false, tokens: undefined};
	  ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function
	  ctrl.clickTriggeredSelect = false;
	  ctrl.$filter = $filter;
	
	  ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
	  if (ctrl.searchInput.length !== 1) {
	    throw uiSelectMinErr('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
	  }
	  
	  ctrl.isEmpty = function() {
	    return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '';
	  };
	
	  // Most of the time the user does not want to empty the search input when in typeahead mode
	  function _resetSearchInput() {
	    if (ctrl.resetSearchInput || (ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput)) {
	      ctrl.search = EMPTY_SEARCH;
	      //reset activeIndex
	      if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
	        ctrl.activeIndex = ctrl.items.indexOf(ctrl.selected);
	      }
	    }
	  }
	
	    function _groupsFilter(groups, groupNames) {
	      var i, j, result = [];
	      for(i = 0; i < groupNames.length ;i++){
	        for(j = 0; j < groups.length ;j++){
	          if(groups[j].name == [groupNames[i]]){
	            result.push(groups[j]);
	          }
	        }
	      }
	      return result;
	    }
	
	  // When the user clicks on ui-select, displays the dropdown list
	  ctrl.activate = function(initSearchValue, avoidReset) {
	    if (!ctrl.disabled  && !ctrl.open) {
	      if(!avoidReset) _resetSearchInput();
	
	      $scope.$broadcast('uis:activate');
	
	      ctrl.open = true;
	
	      ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;
	
	      // ensure that the index is set to zero for tagging variants
	      // that where first option is auto-selected
	      if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {
	        ctrl.activeIndex = 0;
	      }
	
	      // Give it time to appear before focus
	      $timeout(function() {
	        ctrl.search = initSearchValue || ctrl.search;
	        ctrl.searchInput[0].focus();
	        if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {
	          _ensureHighlightVisible();
	        }
	      });
	    }
	  };
	
	  ctrl.findGroupByName = function(name) {
	    return ctrl.groups && ctrl.groups.filter(function(group) {
	      return group.name === name;
	    })[0];
	  };
	
	  ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {
	    function updateGroups(items) {
	      var groupFn = $scope.$eval(groupByExp);
	      ctrl.groups = [];
	      angular.forEach(items, function(item) {
	        var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
	        var group = ctrl.findGroupByName(groupName);
	        if(group) {
	          group.items.push(item);
	        }
	        else {
	          ctrl.groups.push({name: groupName, items: [item]});
	        }
	      });
	      if(groupFilterExp){
	        var groupFilterFn = $scope.$eval(groupFilterExp);
	        if( angular.isFunction(groupFilterFn)){
	          ctrl.groups = groupFilterFn(ctrl.groups);
	        } else if(angular.isArray(groupFilterFn)){
	          ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
	        }
	      }
	      ctrl.items = [];
	      ctrl.groups.forEach(function(group) {
	        ctrl.items = ctrl.items.concat(group.items);
	      });
	    }
	
	    function setPlainItems(items) {
	      ctrl.items = items;
	    }
	
	    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;
	
	    ctrl.parserResult = RepeatParser.parse(repeatAttr);
	
	    ctrl.isGrouped = !!groupByExp;
	    ctrl.itemProperty = ctrl.parserResult.itemName;
	
	    //If collection is an Object, convert it to Array
	
	    var originalSource = ctrl.parserResult.source;
	    
	    //When an object is used as source, we better create an array and use it as 'source'
	    var createArrayFromObject = function(){
	      var origSrc = originalSource($scope);
	      $scope.$uisSource = Object.keys(origSrc).map(function(v){
	        var result = {};
	        result[ctrl.parserResult.keyName] = v;
	        result.value = origSrc[v];
	        return result;
	      });
	    };
	
	    if (ctrl.parserResult.keyName){ // Check for (key,value) syntax
	      createArrayFromObject();
	      ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);
	      $scope.$watch(originalSource, function(newVal, oldVal){
	        if (newVal !== oldVal) createArrayFromObject();
	      }, true);
	    }
	
	    ctrl.refreshItems = function (data){
	      data = data || ctrl.parserResult.source($scope);
	      var selectedItems = ctrl.selected;
	      //TODO should implement for single mode removeSelected
	      if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.removeSelected) {
	        ctrl.setItemsFn(data);
	      }else{
	        if ( data !== undefined ) {
	          var filteredItems = data.filter(function(i) {return selectedItems && selectedItems.indexOf(i) < 0;});
	          ctrl.setItemsFn(filteredItems);
	        }
	      }
	      if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){
	        $scope.calculateDropdownPos();
	      }
	    };
	
	    // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259
	    $scope.$watchCollection(ctrl.parserResult.source, function(items) {
	      if (items === undefined || items === null) {
	        // If the user specifies undefined or null => reset the collection
	        // Special case: items can be undefined if the user did not initialized the collection on the scope
	        // i.e $scope.addresses = [] is missing
	        ctrl.items = [];
	      } else {
	        if (!angular.isArray(items)) {
	          throw uiSelectMinErr('items', "Expected an array but got '{0}'.", items);          
	        } else {
	          //Remove already selected items (ex: while searching)
	          //TODO Should add a test
	          ctrl.refreshItems(items);
	          ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
	        }
	      }
	    });
	
	  };
	
	  var _refreshDelayPromise;
	
	  /**
	   * Typeahead mode: lets the user refresh the collection using his own function.
	   *
	   * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31
	   */
	  ctrl.refresh = function(refreshAttr) {
	    if (refreshAttr !== undefined) {
	
	      // Debounce
	      // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155
	      // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177
	      if (_refreshDelayPromise) {
	        $timeout.cancel(_refreshDelayPromise);
	      }
	      _refreshDelayPromise = $timeout(function() {
	        $scope.$eval(refreshAttr);
	      }, ctrl.refreshDelay);
	    }
	  };
	
	  ctrl.isActive = function(itemScope) {
	    if ( !ctrl.open ) {
	      return false;
	    }
	    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
	    var isActive =  itemIndex === ctrl.activeIndex;
	
	    if ( !isActive || ( itemIndex < 0 && ctrl.taggingLabel !== false ) ||( itemIndex < 0 && ctrl.taggingLabel === false) ) {
	      return false;
	    }
	
	    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
	      itemScope.$eval(ctrl.onHighlightCallback);
	    }
	
	    return isActive;
	  };
	
	  ctrl.isDisabled = function(itemScope) {
	
	    if (!ctrl.open) return;
	
	    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
	    var isDisabled = false;
	    var item;
	
	    if (itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression)) {
	      item = ctrl.items[itemIndex];
	      isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression)); // force the boolean value
	      item._uiSelectChoiceDisabled = isDisabled; // store this for later reference
	    }
	
	    return isDisabled;
	  };
	
	
	  // When the user selects an item with ENTER or clicks the dropdown
	  ctrl.select = function(item, skipFocusser, $event) {
	    if (item === undefined || !item._uiSelectChoiceDisabled) {
	
	      if ( ! ctrl.items && ! ctrl.search ) return;
	
	      if (!item || !item._uiSelectChoiceDisabled) {
	        if(ctrl.tagging.isActivated) {
	          // if taggingLabel is disabled, we pull from ctrl.search val
	          if ( ctrl.taggingLabel === false ) {
	            if ( ctrl.activeIndex < 0 ) {
	              item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
	              if (!item || angular.equals( ctrl.items[0], item ) ) {
	                return;
	              }
	            } else {
	              // keyboard nav happened first, user selected from dropdown
	              item = ctrl.items[ctrl.activeIndex];
	            }
	          } else {
	            // tagging always operates at index zero, taggingLabel === false pushes
	            // the ctrl.search value without having it injected
	            if ( ctrl.activeIndex === 0 ) {
	              // ctrl.tagging pushes items to ctrl.items, so we only have empty val
	              // for `item` if it is a detected duplicate
	              if ( item === undefined ) return;
	
	              // create new item on the fly if we don't already have one;
	              // use tagging function if we have one
	              if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {
	                item = ctrl.tagging.fct(ctrl.search);
	                if (!item) return;
	              // if item type is 'string', apply the tagging label
	              } else if ( typeof item === 'string' ) {
	                // trim the trailing space
	                item = item.replace(ctrl.taggingLabel,'').trim();
	              }
	            }
	          }
	          // search ctrl.selected for dupes potentially caused by tagging and return early if found
	          if ( ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter( function (selection) { return angular.equals(selection, item); }).length > 0 ) {
	            ctrl.close(skipFocusser);
	            return;
	          }
	        }
	
	        $scope.$broadcast('uis:select', item);
	
	        var locals = {};
	        locals[ctrl.parserResult.itemName] = item;
	
	        $timeout(function(){
	          ctrl.onSelectCallback($scope, {
	            $item: item,
	            $model: ctrl.parserResult.modelMapper($scope, locals)
	          });
	        });
	
	        if (ctrl.closeOnSelect) {
	          ctrl.close(skipFocusser);
	        }
	        if ($event && $event.type === 'click') {
	          ctrl.clickTriggeredSelect = true;
	        }
	      }
	    }
	  };
	
	  // Closes the dropdown
	  ctrl.close = function(skipFocusser) {
	    if (!ctrl.open) return;
	    if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();
	    _resetSearchInput();
	    ctrl.open = false;
	
	    $scope.$broadcast('uis:close', skipFocusser);
	
	  };
	
	  ctrl.setFocus = function(){
	    if (!ctrl.focus) ctrl.focusInput[0].focus();
	  };
	
	  ctrl.clear = function($event) {
	    ctrl.select(undefined);
	    $event.stopPropagation();
	    $timeout(function() {
	      ctrl.focusser[0].focus();
	    }, 0, false);
	  };
	
	  // Toggle dropdown
	  ctrl.toggle = function(e) {
	    if (ctrl.open) {
	      ctrl.close();
	      e.preventDefault();
	      e.stopPropagation();
	    } else {
	      ctrl.activate();
	    }
	  };
	
	  ctrl.isLocked = function(itemScope, itemIndex) {
	      var isLocked, item = ctrl.selected[itemIndex];
	
	      if (item && !angular.isUndefined(ctrl.lockChoiceExpression)) {
	          isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression)); // force the boolean value
	          item._uiSelectChoiceLocked = isLocked; // store this for later reference
	      }
	
	      return isLocked;
	  };
	
	  var sizeWatch = null;
	  ctrl.sizeSearchInput = function() {
	
	    var input = ctrl.searchInput[0],
	        container = ctrl.searchInput.parent().parent()[0],
	        calculateContainerWidth = function() {
	          // Return the container width only if the search input is visible
	          return container.clientWidth * !!input.offsetParent;
	        },
	        updateIfVisible = function(containerWidth) {
	          if (containerWidth === 0) {
	            return false;
	          }
	          var inputWidth = containerWidth - input.offsetLeft - 10;
	          if (inputWidth < 50) inputWidth = containerWidth;
	          ctrl.searchInput.css('width', inputWidth+'px');
	          return true;
	        };
	
	    ctrl.searchInput.css('width', '10px');
	    $timeout(function() { //Give tags time to render correctly
	      if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
	        sizeWatch = $scope.$watch(calculateContainerWidth, function(containerWidth) {
	          if (updateIfVisible(containerWidth)) {
	            sizeWatch();
	            sizeWatch = null;
	          }
	        });
	      }
	    });
	  };
	
	  function _handleDropDownSelection(key) {
	    var processed = true;
	    switch (key) {
	      case KEY.DOWN:
	        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        else if (ctrl.activeIndex < ctrl.items.length - 1) { ctrl.activeIndex++; }
	        break;
	      case KEY.UP:
	        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) { ctrl.activeIndex--; }
	        break;
	      case KEY.TAB:
	        if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);
	        break;
	      case KEY.ENTER:
	        if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){
	          ctrl.select(ctrl.items[ctrl.activeIndex]); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode
	        } else {
	          ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        }
	        break;
	      case KEY.ESC:
	        ctrl.close();
	        break;
	      default:
	        processed = false;
	    }
	    return processed;
	  }
	
	  // Bind to keyboard shortcuts
	  ctrl.searchInput.on('keydown', function(e) {
	
	    var key = e.which;
	
	    // if(~[KEY.ESC,KEY.TAB].indexOf(key)){
	    //   //TODO: SEGURO?
	    //   ctrl.close();
	    // }
	
	    $scope.$apply(function() {
	
	      var tagged = false;
	
	      if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
	        _handleDropDownSelection(key);
	        if ( ctrl.taggingTokens.isActivated ) {
	          for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
	            if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {
	              // make sure there is a new value to push via tagging
	              if ( ctrl.search.length > 0 ) {
	                tagged = true;
	              }
	            }
	          }
	          if ( tagged ) {
	            $timeout(function() {
	              ctrl.searchInput.triggerHandler('tagged');
	              var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();
	              if ( ctrl.tagging.fct ) {
	                newItem = ctrl.tagging.fct( newItem );
	              }
	              if (newItem) ctrl.select(newItem, true);
	            });
	          }
	        }
	      }
	
	    });
	
	    if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){
	      _ensureHighlightVisible();
	    }
	
	    if (key === KEY.ENTER || key === KEY.ESC) {
	      e.preventDefault();
	      e.stopPropagation();
	    }
	
	  });
	
	  // If tagging try to split by tokens and add items
	  ctrl.searchInput.on('paste', function (e) {
	    var data = e.originalEvent.clipboardData.getData('text/plain');
	    if (data && data.length > 0 && ctrl.taggingTokens.isActivated && ctrl.tagging.fct) {
	      var items = data.split(ctrl.taggingTokens.tokens[0]); // split by first token only
	      if (items && items.length > 0) {
	        angular.forEach(items, function (item) {
	          var newItem = ctrl.tagging.fct(item);
	          if (newItem) {
	            ctrl.select(newItem, true);
	          }
	        });
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    }
	  });
	
	  ctrl.searchInput.on('tagged', function() {
	    $timeout(function() {
	      _resetSearchInput();
	    });
	  });
	
	  // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431
	  function _ensureHighlightVisible() {
	    var container = $element.querySelectorAll('.ui-select-choices-content');
	    var choices = container.querySelectorAll('.ui-select-choices-row');
	    if (choices.length < 1) {
	      throw uiSelectMinErr('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
	    }
	
	    if (ctrl.activeIndex < 0) {
	      return;
	    }
	
	    var highlighted = choices[ctrl.activeIndex];
	    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
	    var height = container[0].offsetHeight;
	
	    if (posY > height) {
	      container[0].scrollTop += posY - height;
	    } else if (posY < highlighted.clientHeight) {
	      if (ctrl.isGrouped && ctrl.activeIndex === 0)
	        container[0].scrollTop = 0; //To make group header visible when going all the way up
	      else
	        container[0].scrollTop -= highlighted.clientHeight - posY;
	    }
	  }
	
	  $scope.$on('$destroy', function() {
	    ctrl.searchInput.off('keyup keydown tagged blur paste');
	  });
	
	}]);
	
	uis.directive('uiSelect',
	  ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',
	  function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {
	
	  return {
	    restrict: 'EA',
	    templateUrl: function(tElement, tAttrs) {
	      var theme = tAttrs.theme || uiSelectConfig.theme;
	      return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
	    },
	    replace: true,
	    transclude: true,
	    require: ['uiSelect', '^ngModel'],
	    scope: true,
	
	    controller: 'uiSelectCtrl',
	    controllerAs: '$select',
	    compile: function(tElement, tAttrs) {
	
	      //Multiple or Single depending if multiple attribute presence
	      if (angular.isDefined(tAttrs.multiple))
	        tElement.append('<ui-select-multiple/>').removeAttr('multiple');
	      else
	        tElement.append('<ui-select-single/>');
	
	      if (tAttrs.inputId)
	        tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;
	
	      return function(scope, element, attrs, ctrls, transcludeFn) {
	
	        var $select = ctrls[0];
	        var ngModel = ctrls[1];
	
	        $select.generatedId = uiSelectConfig.generateId();
	        $select.baseTitle = attrs.title || 'Select box';
	        $select.focusserTitle = $select.baseTitle + ' focus';
	        $select.focusserId = 'focusser-' + $select.generatedId;
	
	        $select.closeOnSelect = function() {
	          if (angular.isDefined(attrs.closeOnSelect)) {
	            return $parse(attrs.closeOnSelect)();
	          } else {
	            return uiSelectConfig.closeOnSelect;
	          }
	        }();
	
	        $select.onSelectCallback = $parse(attrs.onSelect);
	        $select.onRemoveCallback = $parse(attrs.onRemove);
	
	        //Limit the number of selections allowed
	        $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;
	
	        //Set reference to ngModel from uiSelectCtrl
	        $select.ngModel = ngModel;
	
	        $select.choiceGrouped = function(group){
	          return $select.isGrouped && group && group.name;
	        };
	
	        if(attrs.tabindex){
	          attrs.$observe('tabindex', function(value) {
	            $select.focusInput.attr('tabindex', value);
	            element.removeAttr('tabindex');
	          });
	        }
	
	        scope.$watch('searchEnabled', function() {
	            var searchEnabled = scope.$eval(attrs.searchEnabled);
	            $select.searchEnabled = searchEnabled !== undefined ? searchEnabled : uiSelectConfig.searchEnabled;
	        });
	
	        scope.$watch('sortable', function() {
	            var sortable = scope.$eval(attrs.sortable);
	            $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
	        });
	
	        attrs.$observe('disabled', function() {
	          // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string
	          $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
	        });
	
	        attrs.$observe('resetSearchInput', function() {
	          // $eval() is needed otherwise we get a string instead of a boolean
	          var resetSearchInput = scope.$eval(attrs.resetSearchInput);
	          $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
	        });
	
	        attrs.$observe('tagging', function() {
	          if(attrs.tagging !== undefined)
	          {
	            // $eval() is needed otherwise we get a string instead of a boolean
	            var taggingEval = scope.$eval(attrs.tagging);
	            $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};
	          }
	          else
	          {
	            $select.tagging = {isActivated: false, fct: undefined};
	          }
	        });
	
	        attrs.$observe('taggingLabel', function() {
	          if(attrs.tagging !== undefined )
	          {
	            // check eval for FALSE, in this case, we disable the labels
	            // associated with tagging
	            if ( attrs.taggingLabel === 'false' ) {
	              $select.taggingLabel = false;
	            }
	            else
	            {
	              $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
	            }
	          }
	        });
	
	        attrs.$observe('taggingTokens', function() {
	          if (attrs.tagging !== undefined) {
	            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];
	            $select.taggingTokens = {isActivated: true, tokens: tokens };
	          }
	        });
	
	        //Automatically gets focus when loaded
	        if (angular.isDefined(attrs.autofocus)){
	          $timeout(function(){
	            $select.setFocus();
	          });
	        }
	
	        //Gets focus based on scope event name (e.g. focus-on='SomeEventName')
	        if (angular.isDefined(attrs.focusOn)){
	          scope.$on(attrs.focusOn, function() {
	              $timeout(function(){
	                $select.setFocus();
	              });
	          });
	        }
	
	        function onDocumentClick(e) {
	          if (!$select.open) return; //Skip it if dropdown is close
	
	          var contains = false;
	
	          if (window.jQuery) {
	            // Firefox 3.6 does not support element.contains()
	            // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
	            contains = window.jQuery.contains(element[0], e.target);
	          } else {
	            contains = element[0].contains(e.target);
	          }
	
	          if (!contains && !$select.clickTriggeredSelect) {
	            //Will lose focus only with certain targets
	            var focusableControls = ['input','button','textarea'];
	            var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select
	            var skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select
	            if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea
	            $select.close(skipFocusser);
	            scope.$digest();
	          }
	          $select.clickTriggeredSelect = false;
	        }
	
	        // See Click everywhere but here event http://stackoverflow.com/questions/12931369
	        $document.on('click', onDocumentClick);
	
	        scope.$on('$destroy', function() {
	          $document.off('click', onDocumentClick);
	        });
	
	        // Move transcluded elements to their correct position in main template
	        transcludeFn(scope, function(clone) {
	          // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html
	
	          // One day jqLite will be replaced by jQuery and we will be able to write:
	          // var transcludedElement = clone.filter('.my-class')
	          // instead of creating a hackish DOM element:
	          var transcluded = angular.element('<div>').append(clone);
	
	          var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
	          transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr
	          transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes
	          if (transcludedMatch.length !== 1) {
	            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
	          }
	          element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);
	
	          var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
	          transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr
	          transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes
	          if (transcludedChoices.length !== 1) {
	            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
	          }
	          element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);
	        });
	
	        // Support for appending the select field to the body when its open
	        var appendToBody = scope.$eval(attrs.appendToBody);
	        if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
	          scope.$watch('$select.open', function(isOpen) {
	            if (isOpen) {
	              positionDropdown();
	            } else {
	              resetDropdown();
	            }
	          });
	
	          // Move the dropdown back to its original location when the scope is destroyed. Otherwise
	          // it might stick around when the user routes away or the select field is otherwise removed
	          scope.$on('$destroy', function() {
	            resetDropdown();
	          });
	        }
	
	        // Hold on to a reference to the .ui-select-container element for appendToBody support
	        var placeholder = null,
	            originalWidth = '';
	
	        function positionDropdown() {
	          // Remember the absolute position of the element
	          var offset = uisOffset(element);
	
	          // Clone the element into a placeholder element to take its original place in the DOM
	          placeholder = angular.element('<div class="ui-select-placeholder"></div>');
	          placeholder[0].style.width = offset.width + 'px';
	          placeholder[0].style.height = offset.height + 'px';
	          element.after(placeholder);
	
	          // Remember the original value of the element width inline style, so it can be restored
	          // when the dropdown is closed
	          originalWidth = element[0].style.width;
	
	          // Now move the actual dropdown element to the end of the body
	          $document.find('body').append(element);
	
	          element[0].style.position = 'absolute';
	          element[0].style.left = offset.left + 'px';
	          element[0].style.top = offset.top + 'px';
	          element[0].style.width = offset.width + 'px';
	        }
	
	        function resetDropdown() {
	          if (placeholder === null) {
	            // The dropdown has not actually been display yet, so there's nothing to reset
	            return;
	          }
	
	          // Move the dropdown element back to its original location in the DOM
	          placeholder.replaceWith(element);
	          placeholder = null;
	
	          element[0].style.position = '';
	          element[0].style.left = '';
	          element[0].style.top = '';
	          element[0].style.width = originalWidth;
	        }
	
	        // Hold on to a reference to the .ui-select-dropdown element for direction support.
	        var dropdown = null,
	            directionUpClassName = 'direction-up';
	
	        // Support changing the direction of the dropdown if there isn't enough space to render it.
	        scope.$watch('$select.open', function() {
	
	          if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){
	            scope.calculateDropdownPos();
	          }
	
	        });
	
	        var setDropdownPosUp = function(offset, offsetDropdown){
	
	          offset = offset || uisOffset(element);
	          offsetDropdown = offsetDropdown || uisOffset(dropdown);
	
	          dropdown[0].style.position = 'absolute';
	          dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';
	          element.addClass(directionUpClassName);
	
	        };
	
	        var setDropdownPosDown = function(offset, offsetDropdown){
	
	          element.removeClass(directionUpClassName);
	
	          offset = offset || uisOffset(element);
	          offsetDropdown = offsetDropdown || uisOffset(dropdown);
	
	          dropdown[0].style.position = '';
	          dropdown[0].style.top = '';
	
	        };
	
	        scope.calculateDropdownPos = function(){
	
	          if ($select.open) {
	            dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');
	            if (dropdown.length === 0) {
	              return;
	            }
	
	            // Hide the dropdown so there is no flicker until $timeout is done executing.
	            dropdown[0].style.opacity = 0;
	
	            // Delay positioning the dropdown until all choices have been added so its height is correct.
	            $timeout(function(){
	
	              if ($select.dropdownPosition === 'up'){
	                  //Go UP
	                  setDropdownPosUp(offset, offsetDropdown);
	
	              }else{ //AUTO
	
	                element.removeClass(directionUpClassName);
	
	                var offset = uisOffset(element);
	                var offsetDropdown = uisOffset(dropdown);
	
	                //https://code.google.com/p/chromium/issues/detail?id=342307#c4
	                var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).
	
	                // Determine if the direction of the dropdown needs to be changed.
	                if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {
	                  //Go UP
	                  setDropdownPosUp(offset, offsetDropdown);
	                }else{
	                  //Go DOWN
	                  setDropdownPosDown(offset, offsetDropdown);
	                }
	
	              }
	
	              // Display the dropdown once it has been positioned.
	              dropdown[0].style.opacity = 1;
	            });
	          } else {
	              if (dropdown === null || dropdown.length === 0) {
	                return;
	              }
	
	              // Reset the position of the dropdown.
	              dropdown[0].style.position = '';
	              dropdown[0].style.top = '';
	              element.removeClass(directionUpClassName);
	          }
	        };
	      };
	    }
	  };
	}]);
	
	uis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {
	  return {
	    restrict: 'EA',
	    require: '^uiSelect',
	    replace: true,
	    transclude: true,
	    templateUrl: function(tElement) {
	      // Gets theme attribute from parent (ui-select)
	      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
	      var multi = tElement.parent().attr('multiple');
	      return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');
	    },
	    link: function(scope, element, attrs, $select) {
	      $select.lockChoiceExpression = attrs.uiLockChoice;
	      attrs.$observe('placeholder', function(placeholder) {
	        $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
	      });
	
	      function setAllowClear(allow) {
	        $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;
	      }
	
	      attrs.$observe('allowClear', setAllowClear);
	      setAllowClear(attrs.allowClear);
	
	      if($select.multiple){
	        $select.sizeSearchInput();
	      }
	
	    }
	  };
	}]);
	
	uis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {
	  return {
	    restrict: 'EA',
	    require: ['^uiSelect', '^ngModel'],
	
	    controller: ['$scope','$timeout', function($scope, $timeout){
	
	      var ctrl = this,
	          $select = $scope.$select,
	          ngModel;
	
	      //Wait for link fn to inject it 
	      $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });
	
	      ctrl.activeMatchIndex = -1;
	
	      ctrl.updateModel = function(){
	        ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes
	        ctrl.refreshComponent();
	      };
	
	      ctrl.refreshComponent = function(){
	        //Remove already selected items
	        //e.g. When user clicks on a selection, the selected array changes and 
	        //the dropdown should remove that item
	        $select.refreshItems();
	        $select.sizeSearchInput();
	      };
	
	      // Remove item from multiple select
	      ctrl.removeChoice = function(index){
	
	        var removedChoice = $select.selected[index];
	
	        // if the choice is locked, can't remove it
	        if(removedChoice._uiSelectChoiceLocked) return;
	
	        var locals = {};
	        locals[$select.parserResult.itemName] = removedChoice;
	
	        $select.selected.splice(index, 1);
	        ctrl.activeMatchIndex = -1;
	        $select.sizeSearchInput();
	
	        // Give some time for scope propagation.
	        $timeout(function(){
	          $select.onRemoveCallback($scope, {
	            $item: removedChoice,
	            $model: $select.parserResult.modelMapper($scope, locals)
	          });
	        });
	
	        ctrl.updateModel();
	
	      };
	
	      ctrl.getPlaceholder = function(){
	        //Refactor single?
	        if($select.selected && $select.selected.length) return;
	        return $select.placeholder;
	      };
	
	
	    }],
	    controllerAs: '$selectMultiple',
	
	    link: function(scope, element, attrs, ctrls) {
	
	      var $select = ctrls[0];
	      var ngModel = scope.ngModel = ctrls[1];
	      var $selectMultiple = scope.$selectMultiple;
	
	      //$select.selected = raw selected objects (ignoring any property binding)
	
	      $select.multiple = true;
	      $select.removeSelected = true;
	
	      //Input that will handle focus
	      $select.focusInput = $select.searchInput;
	
	      //From view --> model
	      ngModel.$parsers.unshift(function () {
	        var locals = {},
	            result,
	            resultMultiple = [];
	        for (var j = $select.selected.length - 1; j >= 0; j--) {
	          locals = {};
	          locals[$select.parserResult.itemName] = $select.selected[j];
	          result = $select.parserResult.modelMapper(scope, locals);
	          resultMultiple.unshift(result);
	        }
	        return resultMultiple;
	      });
	
	      // From model --> view
	      ngModel.$formatters.unshift(function (inputValue) {
	        var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
	            locals = {},
	            result;
	        if (!data) return inputValue;
	        var resultMultiple = [];
	        var checkFnMultiple = function(list, value){
	          if (!list || !list.length) return;
	          for (var p = list.length - 1; p >= 0; p--) {
	            locals[$select.parserResult.itemName] = list[p];
	            result = $select.parserResult.modelMapper(scope, locals);
	            if($select.parserResult.trackByExp){
	                var matches = /\.(.+)/.exec($select.parserResult.trackByExp);
	                if(matches.length>0 && result[matches[1]] == value[matches[1]]){
	                    resultMultiple.unshift(list[p]);
	                    return true;
	                }
	            }
	            if (angular.equals(result,value)){
	              resultMultiple.unshift(list[p]);
	              return true;
	            }
	          }
	          return false;
	        };
	        if (!inputValue) return resultMultiple; //If ngModel was undefined
	        for (var k = inputValue.length - 1; k >= 0; k--) {
	          //Check model array of currently selected items 
	          if (!checkFnMultiple($select.selected, inputValue[k])){
	            //Check model array of all items available
	            if (!checkFnMultiple(data, inputValue[k])){
	              //If not found on previous lists, just add it directly to resultMultiple
	              resultMultiple.unshift(inputValue[k]);
	            }
	          }
	        }
	        return resultMultiple;
	      });
	      
	      //Watch for external model changes 
	      scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {
	        if (oldValue != newValue){
	          ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
	          $selectMultiple.refreshComponent();
	        }
	      });
	
	      ngModel.$render = function() {
	        // Make sure that model value is array
	        if(!angular.isArray(ngModel.$viewValue)){
	          // Have tolerance for null or undefined values
	          if(angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null){
	            $select.selected = [];
	          } else {
	            throw uiSelectMinErr('multiarr', "Expected model value to be array but got '{0}'", ngModel.$viewValue);
	          }
	        }
	        $select.selected = ngModel.$viewValue;
	        scope.$evalAsync(); //To force $digest
	      };
	
	      scope.$on('uis:select', function (event, item) {
	        if($select.selected.length >= $select.limit) {
	          return;
	        }
	        $select.selected.push(item);
	        $selectMultiple.updateModel();
	      });
	
	      scope.$on('uis:activate', function () {
	        $selectMultiple.activeMatchIndex = -1;
	      });
	
	      scope.$watch('$select.disabled', function(newValue, oldValue) {
	        // As the search input field may now become visible, it may be necessary to recompute its size
	        if (oldValue && !newValue) $select.sizeSearchInput();
	      });
	
	      $select.searchInput.on('keydown', function(e) {
	        var key = e.which;
	        scope.$apply(function() {
	          var processed = false;
	          // var tagged = false; //Checkme
	          if(KEY.isHorizontalMovement(key)){
	            processed = _handleMatchSelection(key);
	          }
	          if (processed  && key != KEY.TAB) {
	            //TODO Check si el tab selecciona aun correctamente
	            //Crear test
	            e.preventDefault();
	            e.stopPropagation();
	          }
	        });
	      });
	      function _getCaretPosition(el) {
	        if(angular.isNumber(el.selectionStart)) return el.selectionStart;
	        // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise
	        else return el.value.length;
	      }
	      // Handles selected options in "multiple" mode
	      function _handleMatchSelection(key){
	        var caretPosition = _getCaretPosition($select.searchInput[0]),
	            length = $select.selected.length,
	            // none  = -1,
	            first = 0,
	            last  = length-1,
	            curr  = $selectMultiple.activeMatchIndex,
	            next  = $selectMultiple.activeMatchIndex+1,
	            prev  = $selectMultiple.activeMatchIndex-1,
	            newIndex = curr;
	
	        if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;
	
	        $select.close();
	
	        function getNewActiveMatchIndex(){
	          switch(key){
	            case KEY.LEFT:
	              // Select previous/first item
	              if(~$selectMultiple.activeMatchIndex) return prev;
	              // Select last item
	              else return last;
	              break;
	            case KEY.RIGHT:
	              // Open drop-down
	              if(!~$selectMultiple.activeMatchIndex || curr === last){
	                $select.activate();
	                return false;
	              }
	              // Select next/last item
	              else return next;
	              break;
	            case KEY.BACKSPACE:
	              // Remove selected item and select previous/first
	              if(~$selectMultiple.activeMatchIndex){
	                $selectMultiple.removeChoice(curr);
	                return prev;
	              }
	              // Select last item
	              else return last;
	              break;
	            case KEY.DELETE:
	              // Remove selected item and select next item
	              if(~$selectMultiple.activeMatchIndex){
	                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
	                return curr;
	              }
	              else return false;
	          }
	        }
	
	        newIndex = getNewActiveMatchIndex();
	
	        if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;
	        else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));
	
	        return true;
	      }
	
	      $select.searchInput.on('keyup', function(e) {
	
	        if ( ! KEY.isVerticalMovement(e.which) ) {
	          scope.$evalAsync( function () {
	            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
	          });
	        }
	        // Push a "create new" item into array if there is a search string
	        if ( $select.tagging.isActivated && $select.search.length > 0 ) {
	
	          // return early with these keys
	          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {
	            return;
	          }
	          // always reset the activeIndex to the first item when tagging
	          $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
	          // taggingLabel === false bypasses all of this
	          if ($select.taggingLabel === false) return;
	
	          var items = angular.copy( $select.items );
	          var stashArr = angular.copy( $select.items );
	          var newItem;
	          var item;
	          var hasTag = false;
	          var dupeIndex = -1;
	          var tagItems;
	          var tagItem;
	
	          // case for object tagging via transform `$select.tagging.fct` function
	          if ( $select.tagging.fct !== undefined) {
	            tagItems = $select.$filter('filter')(items,{'isTag': true});
	            if ( tagItems.length > 0 ) {
	              tagItem = tagItems[0];
	            }
	            // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous
	            if ( items.length > 0 && tagItem ) {
	              hasTag = true;
	              items = items.slice(1,items.length);
	              stashArr = stashArr.slice(1,stashArr.length);
	            }
	            newItem = $select.tagging.fct($select.search);
	            newItem.isTag = true;
	            // verify the the tag doesn't match the value of an existing item
	            if ( stashArr.filter( function (origItem) { return angular.equals( origItem, $select.tagging.fct($select.search) ); } ).length > 0 ) {
	              return;
	            }
	            newItem.isTag = true;
	          // handle newItem string and stripping dupes in tagging string context
	          } else {
	            // find any tagging items already in the $select.items array and store them
	            tagItems = $select.$filter('filter')(items,function (item) {
	              return item.match($select.taggingLabel);
	            });
	            if ( tagItems.length > 0 ) {
	              tagItem = tagItems[0];
	            }
	            item = items[0];
	            // remove existing tag item if found (should only ever be one tag item)
	            if ( item !== undefined && items.length > 0 && tagItem ) {
	              hasTag = true;
	              items = items.slice(1,items.length);
	              stashArr = stashArr.slice(1,stashArr.length);
	            }
	            newItem = $select.search+' '+$select.taggingLabel;
	            if ( _findApproxDupe($select.selected, $select.search) > -1 ) {
	              return;
	            }
	            // verify the the tag doesn't match the value of an existing item from
	            // the searched data set or the items already selected
	            if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {
	              // if there is a tag from prev iteration, strip it / queue the change
	              // and return early
	              if ( hasTag ) {
	                items = stashArr;
	                scope.$evalAsync( function () {
	                  $select.activeIndex = 0;
	                  $select.items = items;
	                });
	              }
	              return;
	            }
	            if ( _findCaseInsensitiveDupe(stashArr) ) {
	              // if there is a tag from prev iteration, strip it
	              if ( hasTag ) {
	                $select.items = stashArr.slice(1,stashArr.length);
	              }
	              return;
	            }
	          }
	          if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);
	          // dupe found, shave the first item
	          if ( dupeIndex > -1 ) {
	            items = items.slice(dupeIndex+1,items.length-1);
	          } else {
	            items = [];
	            items.push(newItem);
	            items = items.concat(stashArr);
	          }
	          scope.$evalAsync( function () {
	            $select.activeIndex = 0;
	            $select.items = items;
	          });
	        }
	      });
	      function _findCaseInsensitiveDupe(arr) {
	        if ( arr === undefined || $select.search === undefined ) {
	          return false;
	        }
	        var hasDupe = arr.filter( function (origItem) {
	          if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {
	            return false;
	          }
	          return origItem.toUpperCase() === $select.search.toUpperCase();
	        }).length > 0;
	
	        return hasDupe;
	      }
	      function _findApproxDupe(haystack, needle) {
	        var dupeIndex = -1;
	        if(angular.isArray(haystack)) {
	          var tempArr = angular.copy(haystack);
	          for (var i = 0; i <tempArr.length; i++) {
	            // handle the simple string version of tagging
	            if ( $select.tagging.fct === undefined ) {
	              // search the array for the match
	              if ( tempArr[i]+' '+$select.taggingLabel === needle ) {
	              dupeIndex = i;
	              }
	            // handle the object tagging implementation
	            } else {
	              var mockObj = tempArr[i];
	              mockObj.isTag = true;
	              if ( angular.equals(mockObj, needle) ) {
	              dupeIndex = i;
	              }
	            }
	          }
	        }
	        return dupeIndex;
	      }
	
	      $select.searchInput.on('blur', function() {
	        $timeout(function() {
	          $selectMultiple.activeMatchIndex = -1;
	        });
	      });
	
	    }
	  };
	}]);
	
	uis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {
	  return {
	    restrict: 'EA',
	    require: ['^uiSelect', '^ngModel'],
	    link: function(scope, element, attrs, ctrls) {
	
	      var $select = ctrls[0];
	      var ngModel = ctrls[1];
	
	      //From view --> model
	      ngModel.$parsers.unshift(function (inputValue) {
	        var locals = {},
	            result;
	        locals[$select.parserResult.itemName] = inputValue;
	        result = $select.parserResult.modelMapper(scope, locals);
	        return result;
	      });
	
	      //From model --> view
	      ngModel.$formatters.unshift(function (inputValue) {
	        var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
	            locals = {},
	            result;
	        if (data){
	          var checkFnSingle = function(d){
	            locals[$select.parserResult.itemName] = d;
	            result = $select.parserResult.modelMapper(scope, locals);
	            return result == inputValue;
	          };
	          //If possible pass same object stored in $select.selected
	          if ($select.selected && checkFnSingle($select.selected)) {
	            return $select.selected;
	          }
	          for (var i = data.length - 1; i >= 0; i--) {
	            if (checkFnSingle(data[i])) return data[i];
	          }
	        }
	        return inputValue;
	      });
	
	      //Update viewValue if model change
	      scope.$watch('$select.selected', function(newValue) {
	        if (ngModel.$viewValue !== newValue) {
	          ngModel.$setViewValue(newValue);
	        }
	      });
	
	      ngModel.$render = function() {
	        $select.selected = ngModel.$viewValue;
	      };
	
	      scope.$on('uis:select', function (event, item) {
	        $select.selected = item;
	      });
	
	      scope.$on('uis:close', function (event, skipFocusser) {
	        $timeout(function(){
	          $select.focusser.prop('disabled', false);
	          if (!skipFocusser) $select.focusser[0].focus();
	        },0,false);
	      });
	
	      scope.$on('uis:activate', function () {
	        focusser.prop('disabled', true); //Will reactivate it on .close()
	      });
	
	      //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954
	      var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
	      $compile(focusser)(scope);
	      $select.focusser = focusser;
	
	      //Input that will handle focus
	      $select.focusInput = focusser;
	
	      element.parent().append(focusser);
	      focusser.bind("focus", function(){
	        scope.$evalAsync(function(){
	          $select.focus = true;
	        });
	      });
	      focusser.bind("blur", function(){
	        scope.$evalAsync(function(){
	          $select.focus = false;
	        });
	      });
	      focusser.bind("keydown", function(e){
	
	        if (e.which === KEY.BACKSPACE) {
	          e.preventDefault();
	          e.stopPropagation();
	          $select.select(undefined);
	          scope.$apply();
	          return;
	        }
	
	        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
	          return;
	        }
	
	        if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){
	          e.preventDefault();
	          e.stopPropagation();
	          $select.activate();
	        }
	
	        scope.$digest();
	      });
	
	      focusser.bind("keyup input", function(e){
	
	        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
	          return;
	        }
	
	        $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input
	        focusser.val('');
	        scope.$digest();
	
	      });
	
	
	    }
	  };
	}]);
	// Make multiple matches sortable
	uis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {
	  return {
	    require: '^uiSelect',
	    link: function(scope, element, attrs, $select) {
	      if (scope[attrs.uiSelectSort] === null) {
	        throw uiSelectMinErr('sort', "Expected a list to sort");
	      }
	
	      var options = angular.extend({
	          axis: 'horizontal'
	        },
	        scope.$eval(attrs.uiSelectSortOptions));
	
	      var axis = options.axis,
	        draggingClassName = 'dragging',
	        droppingClassName = 'dropping',
	        droppingBeforeClassName = 'dropping-before',
	        droppingAfterClassName = 'dropping-after';
	
	      scope.$watch(function(){
	        return $select.sortable;
	      }, function(n){
	        if (n) {
	          element.attr('draggable', true);
	        } else {
	          element.removeAttr('draggable');
	        }
	      });
	
	      element.on('dragstart', function(e) {
	        element.addClass(draggingClassName);
	
	        (e.dataTransfer || e.originalEvent.dataTransfer).setData('text/plain', scope.$index);
	      });
	
	      element.on('dragend', function() {
	        element.removeClass(draggingClassName);
	      });
	
	      var move = function(from, to) {
	        /*jshint validthis: true */
	        this.splice(to, 0, this.splice(from, 1)[0]);
	      };
	
	      var dragOverHandler = function(e) {
	        e.preventDefault();
	
	        var offset = axis === 'vertical' ? e.offsetY || e.layerY || (e.originalEvent ? e.originalEvent.offsetY : 0) : e.offsetX || e.layerX || (e.originalEvent ? e.originalEvent.offsetX : 0);
	
	        if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {
	          element.removeClass(droppingAfterClassName);
	          element.addClass(droppingBeforeClassName);
	
	        } else {
	          element.removeClass(droppingBeforeClassName);
	          element.addClass(droppingAfterClassName);
	        }
	      };
	
	      var dropTimeout;
	
	      var dropHandler = function(e) {
	        e.preventDefault();
	
	        var droppedItemIndex = parseInt((e.dataTransfer || e.originalEvent.dataTransfer).getData('text/plain'), 10);
	
	        // prevent event firing multiple times in firefox
	        $timeout.cancel(dropTimeout);
	        dropTimeout = $timeout(function() {
	          _dropHandler(droppedItemIndex);
	        }, 20);
	      };
	
	      var _dropHandler = function(droppedItemIndex) {
	        var theList = scope.$eval(attrs.uiSelectSort),
	          itemToMove = theList[droppedItemIndex],
	          newIndex = null;
	
	        if (element.hasClass(droppingBeforeClassName)) {
	          if (droppedItemIndex < scope.$index) {
	            newIndex = scope.$index - 1;
	          } else {
	            newIndex = scope.$index;
	          }
	        } else {
	          if (droppedItemIndex < scope.$index) {
	            newIndex = scope.$index;
	          } else {
	            newIndex = scope.$index + 1;
	          }
	        }
	
	        move.apply(theList, [droppedItemIndex, newIndex]);
	
	        scope.$apply(function() {
	          scope.$emit('uiSelectSort:change', {
	            array: theList,
	            item: itemToMove,
	            from: droppedItemIndex,
	            to: newIndex
	          });
	        });
	
	        element.removeClass(droppingClassName);
	        element.removeClass(droppingBeforeClassName);
	        element.removeClass(droppingAfterClassName);
	
	        element.off('drop', dropHandler);
	      };
	
	      element.on('dragenter', function() {
	        if (element.hasClass(draggingClassName)) {
	          return;
	        }
	
	        element.addClass(droppingClassName);
	
	        element.on('dragover', dragOverHandler);
	        element.on('drop', dropHandler);
	      });
	
	      element.on('dragleave', function(e) {
	        if (e.target != element) {
	          return;
	        }
	        element.removeClass(droppingClassName);
	        element.removeClass(droppingBeforeClassName);
	        element.removeClass(droppingAfterClassName);
	
	        element.off('dragover', dragOverHandler);
	        element.off('drop', dropHandler);
	      });
	    }
	  };
	}]);
	
	/**
	 * Parses "repeat" attribute.
	 *
	 * Taken from AngularJS ngRepeat source code
	 * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211
	 *
	 * Original discussion about parsing "repeat" attribute instead of fully relying on ng-repeat:
	 * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697
	 */
	
	uis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {
	  var self = this;
	
	  /**
	   * Example:
	   * expression = "address in addresses | filter: {street: $select.search} track by $index"
	   * itemName = "address",
	   * source = "addresses | filter: {street: $select.search}",
	   * trackByExp = "$index",
	   */
	  self.parse = function(expression) {
	
	
	    var match;
	    var isObjectCollection = /\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(expression);
	    // If an array is used as collection
	
	    // if (isObjectCollection){
	      //00000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000556666660000077777777777755000000000000000000000088888880000000
	    match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(([\w\.]+)?\s*(|\s*[\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);      
	
	    // 1 Alias
	    // 2 Item
	    // 3 Key on (key,value)
	    // 4 Value on (key,value)
	    // 5 Collection expresion (only used when using an array collection)
	    // 6 Object that will be converted to Array when using (key,value) syntax
	    // 7 Filters that will be applied to #6 when using (key,value) syntax
	    // 8 Track by
	
	    if (!match) {
	      throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
	              expression);
	    }
	    if (!match[6] && isObjectCollection) {
	      throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ as (_key_, _item_) in _ObjCollection_ [ track by _id_]' but got '{0}'.",
	              expression);
	    }
	
	    return {
	      itemName: match[4] || match[2], // (lhs) Left-hand side,
	      keyName: match[3], //for (key, value) syntax
	      source: $parse(!match[3] ? match[5] : match[6]),
	      sourceName: match[6],
	      filters: match[7],
	      trackByExp: match[8],
	      modelMapper: $parse(match[1] || match[4] || match[2]),
	      repeatExpression: function (grouped) {
	        var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');
	        if (this.trackByExp) {
	          expression += ' track by ' + this.trackByExp;
	        }
	        return expression;
	      } 
	    };
	
	  };
	
	  self.getGroupNgRepeatExpression = function() {
	    return '$group in $select.groups';
	  };
	
	}]);
	
	}());
	angular.module("ui.select").run(["$templateCache", function($templateCache) {$templateCache.put("bootstrap/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" role=\"listbox\" ng-show=\"$select.items.length > 0\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><a href=\"javascript:void(0)\" class=\"ui-select-choices-row-inner\"></a></div></li></ul>");
	$templateCache.put("bootstrap/match-multiple.tpl.html","<span class=\"ui-select-match\"><span ng-repeat=\"$item in $select.selected\"><span class=\"ui-select-match-item btn btn-default btn-xs\" tabindex=\"-1\" type=\"button\" ng-disabled=\"$select.disabled\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span class=\"close ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&nbsp;&times;</span> <span uis-transclude-append=\"\"></span></span></span></span>");
	$templateCache.put("bootstrap/match.tpl.html","<div class=\"ui-select-match\" ng-hide=\"$select.open\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty()\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i></a></span></div>");
	$templateCache.put("bootstrap/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\" ng-class=\"{open: $select.open}\"><div><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"false\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" class=\"ui-select-search input-xs\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-click=\"$select.activate()\" ng-model=\"$select.search\" role=\"combobox\" aria-label=\"{{ $select.baseTitle }}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div></div>");
	$templateCache.put("bootstrap/select.tpl.html","<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"false\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"form-control ui-select-search\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.searchEnabled && $select.open\"><div class=\"ui-select-choices\"></div></div>");
	$templateCache.put("selectize/choices.tpl.html","<div ng-show=\"$select.open\" class=\"ui-select-choices ui-select-dropdown selectize-dropdown single\"><div class=\"ui-select-choices-content selectize-dropdown-content\"><div class=\"ui-select-choices-group optgroup\" role=\"listbox\"><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label optgroup-header\" ng-bind=\"$group.name\"></div><div role=\"option\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\"><div class=\"option ui-select-choices-row-inner\" data-selectable=\"\"></div></div></div></div></div>");
	$templateCache.put("selectize/match.tpl.html","<div ng-hide=\"($select.open || $select.isEmpty())\" class=\"ui-select-match\" ng-transclude=\"\"></div>");
	$templateCache.put("selectize/select.tpl.html","<div class=\"ui-select-container selectize-control single\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.activate()\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"false\" tabindex=\"-1\" class=\"ui-select-search ui-select-toggle\" ng-click=\"$select.toggle($event)\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-hide=\"!$select.searchEnabled || ($select.selected && !$select.open)\" ng-disabled=\"$select.disabled\" aria-label=\"{{ $select.baseTitle }}\"></div><div class=\"ui-select-choices\"></div></div>");
	$templateCache.put("select2/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{\'select2-result-with-children\': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }\"><li role=\"option\" id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>");
	$templateCache.put("select2/match-multiple.tpl.html","<span class=\"ui-select-match\"><li class=\"ui-select-match-item select2-search-choice\" ng-repeat=\"$item in $select.selected\" ng-class=\"{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span uis-transclude-append=\"\"></span> <a href=\"javascript:;\" class=\"ui-select-match-close select2-search-choice-close\" ng-click=\"$selectMultiple.removeChoice($index)\" tabindex=\"-1\"></a></li></span>");
	$templateCache.put("select2/match.tpl.html","<a class=\"select2-choice ui-select-match\" ng-class=\"{\'select2-default\': $select.isEmpty()}\" ng-click=\"$select.toggle($event)\" aria-label=\"{{ $select.baseTitle }} select\"><span ng-show=\"$select.isEmpty()\" class=\"select2-chosen\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"select2-chosen\" ng-transclude=\"\"></span> <abbr ng-if=\"$select.allowClear && !$select.isEmpty()\" class=\"select2-search-choice-close\" ng-click=\"$select.clear($event)\"></abbr> <span class=\"select2-arrow ui-select-toggle\"><b></b></span></a>");
	$templateCache.put("select2/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}\"><ul class=\"select2-choices\"><span class=\"ui-select-match\"></span><li class=\"select2-search-field\"><input type=\"text\" autocomplete=\"false\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"select2-input ui-select-search\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-model=\"$select.search\" ng-click=\"$select.activate()\" style=\"width: 34px;\" ondrop=\"return false;\"></li></ul><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"ui-select-choices\"></div></div></div>");
	$templateCache.put("select2/select.tpl.html","<div class=\"ui-select-container select2 select2-container\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"select2-search\" ng-show=\"$select.searchEnabled\"><input type=\"text\" autocomplete=\"false\" autocorrect=\"false\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div></div></div>");}]);

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(131);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(11)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./select.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./select.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(10)();
	// imports
	
	
	// module
	exports.push([module.id, "/*!\n * ui-select\n * http://github.com/angular-ui/ui-select\n * Version: 0.13.2 - 2015-10-09T15:34:24.045Z\n * License: MIT\n */\n\n\n/* Style when highlighting a search. */\n.ui-select-highlight {\n  font-weight: bold;\n}\n\n.ui-select-offscreen {\n  clip: rect(0 0 0 0) !important;\n  width: 1px !important;\n  height: 1px !important;\n  border: 0 !important;\n  margin: 0 !important;\n  padding: 0 !important;\n  overflow: hidden !important;\n  position: absolute !important;\n  outline: 0 !important;\n  left: 0px !important;\n  top: 0px !important;\n}\n\n\n.ui-select-choices-row:hover {\n  background-color: #f5f5f5;\n}\n\n/* Select2 theme */\n\n/* Mark invalid Select2 */\n.ng-dirty.ng-invalid > a.select2-choice {\n    border-color: #D44950;\n}\n\n.select2-result-single {\n  padding-left: 0;\n}\n\n.select2-locked > .select2-search-choice-close{\n  display:none;\n}\n\n.select-locked > .ui-select-match-close{\n    display:none;\n}\n\nbody > .select2-container.open {\n  z-index: 9999; /* The z-index Select2 applies to the select2-drop */\n}\n\n/* Handle up direction Select2 */\n.ui-select-container[theme=\"select2\"].direction-up .ui-select-match {\n    border-radius: 4px; /* FIXME hardcoded value :-/ */\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n}\n.ui-select-container[theme=\"select2\"].direction-up .ui-select-dropdown {\n    border-radius: 4px; /* FIXME hardcoded value :-/ */\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n\n    border-top-width: 1px;  /* FIXME hardcoded value :-/ */\n    border-top-style: solid;\n\n    box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.25);\n\n    margin-top: -4px; /* FIXME hardcoded value :-/ */\n}\n.ui-select-container[theme=\"select2\"].direction-up .ui-select-dropdown .select2-search {\n    margin-top: 4px; /* FIXME hardcoded value :-/ */\n}\n.ui-select-container[theme=\"select2\"].direction-up.select2-dropdown-open .ui-select-match {\n    border-bottom-color: #5897fb;\n}\n\n/* Selectize theme */\n\n/* Helper class to show styles when focus */\n.selectize-input.selectize-focus{\n  border-color: #007FBB !important;\n}\n\n/* Fix input width for Selectize theme */\n.selectize-control > .selectize-input > input {\n  width: 100%;\n}\n\n/* Fix dropdown width for Selectize theme */\n.selectize-control > .selectize-dropdown {\n  width: 100%;\n}\n\n/* Mark invalid Selectize */\n.ng-dirty.ng-invalid > div.selectize-input {\n    border-color: #D44950;\n}\n\n/* Handle up direction Selectize */\n.ui-select-container[theme=\"selectize\"].direction-up .ui-select-dropdown {\n    box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.25);\n\n    margin-top: -2px; /* FIXME hardcoded value :-/ */\n}\n\n/* Bootstrap theme */\n\n/* Helper class to show styles when focus */\n.btn-default-focus {\n  color: #333;\n  background-color: #EBEBEB;\n  border-color: #ADADAD;\n  text-decoration: none;\n  outline: 5px auto -webkit-focus-ring-color;\n  outline-offset: -2px;\n  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);\n}\n\n.ui-select-bootstrap .ui-select-toggle {\n  position: relative;\n}\n\n.ui-select-bootstrap .ui-select-toggle > .caret {\n  position: absolute;\n  height: 10px;\n  top: 50%;\n  right: 10px;\n  margin-top: -2px;\n}\n\n/* Fix Bootstrap dropdown position when inside a input-group */\n.input-group > .ui-select-bootstrap.dropdown {\n  /* Instead of relative */\n  position: static;\n}\n\n.input-group > .ui-select-bootstrap > input.ui-select-search.form-control {\n  border-radius: 4px; /* FIXME hardcoded value :-/ */\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.input-group > .ui-select-bootstrap > input.ui-select-search.form-control.direction-up {\n  border-radius: 4px !important; /* FIXME hardcoded value :-/ */\n  border-top-right-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n\n.ui-select-bootstrap > .ui-select-match > .btn{\n  /* Instead of center because of .btn */\n  text-align: left !important;\n}\n\n.ui-select-bootstrap > .ui-select-match > .caret {\n  position: absolute;\n  top: 45%;\n  right: 15px;\n}\n\n/* See Scrollable Menu with Bootstrap 3 http://stackoverflow.com/questions/19227496 */\n.ui-select-bootstrap > .ui-select-choices {\n  width: 100%;\n  height: auto;\n  max-height: 200px;\n  overflow-x: hidden;\n  margin-top: -1px;\n}\n\nbody > .ui-select-bootstrap.open {\n  z-index: 1000; /* Standard Bootstrap dropdown z-index */\n}\n\n.ui-select-multiple.ui-select-bootstrap {\n  height: auto;\n  padding: 3px 3px 0 3px;\n}\n\n.ui-select-multiple.ui-select-bootstrap input.ui-select-search {\n  background-color: transparent !important; /* To prevent double background when disabled */\n  border: none;\n  outline: none;\n  height: 1.666666em;\n  margin-bottom: 3px;\n}\n\n.ui-select-multiple.ui-select-bootstrap .ui-select-match .close {\n  font-size: 1.6em;\n  line-height: 0.75;\n}\n\n.ui-select-multiple.ui-select-bootstrap .ui-select-match-item {\n  outline: 0;\n  margin: 0 3px 3px 0;\n}\n\n.ui-select-multiple .ui-select-match-item {\n  position: relative;\n}\n\n.ui-select-multiple .ui-select-match-item.dropping-before:before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  right: 100%;\n  height: 100%;\n  margin-right: 2px;\n  border-left: 1px solid #428bca;\n}\n\n.ui-select-multiple .ui-select-match-item.dropping-after:after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 100%;\n  height: 100%;\n  margin-left: 2px;\n  border-right: 1px solid #428bca;\n}\n\n.ui-select-bootstrap .ui-select-choices-row>a {\n    display: block;\n    padding: 3px 20px;\n    clear: both;\n    font-weight: 400;\n    line-height: 1.42857143;\n    color: #333;\n    white-space: nowrap;\n}\n\n.ui-select-bootstrap .ui-select-choices-row>a:hover, .ui-select-bootstrap .ui-select-choices-row>a:focus {\n    text-decoration: none;\n    color: #262626;\n    background-color: #f5f5f5;\n}\n\n.ui-select-bootstrap .ui-select-choices-row.active>a {\n    color: #fff;\n    text-decoration: none;\n    outline: 0;\n    background-color: #428bca;\n}\n\n.ui-select-bootstrap .ui-select-choices-row.disabled>a,\n.ui-select-bootstrap .ui-select-choices-row.active.disabled>a {\n    color: #777;\n    cursor: not-allowed;\n    background-color: #fff;\n}\n\n/* fix hide/show angular animation */\n.ui-select-match.ng-hide-add,\n.ui-select-search.ng-hide-add {\n    display: none !important;\n}\n\n/* Mark invalid Bootstrap */\n.ui-select-bootstrap.ng-dirty.ng-invalid > button.btn.ui-select-match {\n    border-color: #D44950;\n}\n\n/* Handle up direction Bootstrap */\n.ui-select-container[theme=\"bootstrap\"].direction-up .ui-select-dropdown {\n    box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.25);\n}\n", ""]);
	
	// exports


/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = "<div class=\"validation-input-group\">\r\n\t<div class=\"field validation-input\" ng-class=\"{ 'has-error': select.ngModel.$invalid }\">\r\n\t\t<label ng-show=\"select.selection\" class=\"show-hide angular-animate\">\r\n\t\t\t{{select.label}} <span class=\"pull-right error-string\">{{select.selectValidator.error}}</span>\r\n\t\t</label>\r\n\t\t<ui-select ng-model=\"select.selection\" search-enabled=\"false\" theme=\"bootstrap\" ng-disabled=\"select.ngDisabled\">\r\n\t\t\t<ui-select-match placeholder=\"{{select.label}}\">{{select.getDisplayName($select.selected)}}</ui-select-match>\r\n\t\t\t<ui-select-choices repeat=\"option in select.options\">\r\n\t\t\t\t{{select.getDisplayName(option)}}\r\n\t\t\t</ui-select-choices>\r\n\t\t</ui-select>\r\n\t\t<rl-busy loading=\"select.loading\"></rl-busy>\r\n\t</div>\r\n\t<i class=\"fa fa-exclamation-triangle text-danger\" ng-show=\"select.ngModel.$error.required\"></i>\r\n</div>"

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var SignaturePad = __webpack_require__(14);
	exports.moduleName = 'rl.ui.components.signaturePad';
	exports.directiveName = 'rlSignaturePad';
	function signaturePad() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: "\n\t\t\t<canvas class=\"signature-pad\" ng-if=\"!ngDisabled\"></canvas>\n\t\t\t<img ng-src=\"{{ngModel.$viewValue}}\" ng-style=\"style\" ng-if=\"ngDisabled\" />\n\t\t",
	        scope: {
	            pad: '=',
	            height: '=',
	            width: '=',
	            ngDisabled: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.$watch('ngDisabled', function (disabled) {
	                scope.ngModel = ngModel;
	                if (disabled) {
	                    scope.style = {
	                        height: scope.height != null ? scope.height : 100,
	                        width: scope.width != null ? scope.width : 200,
	                    };
	                }
	                else {
	                    var canvas = element.find('.signature-pad').get(0);
	                    var options = {
	                        backgroundColor: 'rgb(255, 255, 255)',
	                    };
	                    scope.pad = new SignaturePad(canvas, options);
	                    canvas.height = scope.height != null ? scope.height : 100;
	                    canvas.width = scope.width != null ? scope.width : 200;
	                    scope.$watch(function () { return ngModel.$viewValue; }, function (value) {
	                        if (value != null) {
	                            scope.pad.fromDataURL(value);
	                        }
	                    });
	                    scope.$watch(function () { return scope.pad.toDataURL(); }, function (value) {
	                        if (value != null) {
	                            ngModel.$setViewValue(value);
	                        }
	                    });
	                }
	            });
	        },
	    };
	}
	exports.signaturePad = signaturePad;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, signaturePad);
	//# sourceMappingURL=signaturePad.js.map

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var card = __webpack_require__(135);
	exports.simpleCard = card;
	var list = __webpack_require__(137);
	exports.simpleCardList = list;
	exports.moduleName = 'rl.ui.components.simpleCardList';
	angular.module(exports.moduleName, [__observable.moduleName, __parentChild.moduleName])
	    .directive(list.directiveName, list.simpleCardList)
	    .controller(list.controllerName, list.SimpleCardListController)
	    .directive(card.directiveName, card.simpleCard)
	    .controller(card.controllerName, card.SimpleCardController);
	//# sourceMappingURL=simpleCardList.module.js.map

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	exports.directiveName = 'rlSimpleCard';
	exports.controllerName = 'SimpleCardController';
	var SimpleCardController = (function () {
	    function SimpleCardController($scope, $element, parentChild) {
	        var _this = this;
	        this.$scope = $scope;
	        this.parentChild = parentChild;
	        this.showContent = false;
	        this.autosaveLink = {};
	        this.close = function () {
	            if (_this.showContent === false || _this.alwaysOpen) {
	                return true;
	            }
	            return _this.autosave();
	        };
	        if (this.canOpen == null) {
	            this.canOpen = true;
	        }
	        this.listController = $element.controller('rlSimpleCardList');
	        if (this.listController == null) {
	            this.listController = this.noList();
	        }
	        var behavior = {
	            autosave: this.autosave.bind(this),
	            close: this.close,
	            setAlwaysOpen: function (value) {
	                _this.alwaysOpen = value;
	            },
	        };
	        this.listController.registerCard(behavior);
	        parentChild.registerChildBehavior(this.childLink, behavior);
	        $scope.$watch(function () { return _this.alwaysOpen; }, function (value) {
	            if (value) {
	                _this.showContent = true;
	            }
	            else {
	                _this.close();
	            }
	        });
	    }
	    SimpleCardController.prototype.toggleContent = function () {
	        if (this.showContent) {
	            this.close();
	        }
	        else {
	            this.open();
	        }
	    };
	    SimpleCardController.prototype.open = function () {
	        if (this.canOpen && this.listController.openCard()) {
	            this.showContent = true;
	            this.onOpen();
	        }
	    };
	    SimpleCardController.prototype.autosave = function () {
	        var _this = this;
	        return this.parentChild.triggerChildBehavior(this.autosaveLink, function (behavior) {
	            var canClose = behavior.autosave();
	            if (canClose) {
	                _this.showContent = false;
	            }
	            return canClose;
	        });
	    };
	    SimpleCardController.prototype.noList = function () {
	        return {
	            openCard: function () {
	                return true;
	            },
	            registerCard: function (behavior) {
	                return null;
	            },
	        };
	    };
	    SimpleCardController.$inject = ['$scope', '$element', __parentChild.serviceName];
	    return SimpleCardController;
	})();
	exports.SimpleCardController = SimpleCardController;
	function simpleCard() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        require: '?^^rlSimpleCardList',
	        template: __webpack_require__(136),
	        controller: exports.controllerName,
	        controllerAs: 'card',
	        scope: {},
	        bindToController: {
	            onOpen: '&',
	            canOpen: '=',
	            alwaysOpen: '=',
	            childLink: '=',
	            validate: '&',
	            save: '&',
	        },
	        link: function (scope, element, attrs, controller, transclude) {
	            transclude(function (clone) {
	                var header = clone.filter('rl-card-header');
	                var content = clone.filter('rl-card-content');
	                var footer = clone.filter('rl-card-footer');
	                var headerArea = element.find('.header-template');
	                headerArea.append(header);
	                var contentArea = element.find('.content-template');
	                contentArea.append(content);
	                scope.hasFooter = (footer.length > 0);
	                if (scope.hasFooter) {
	                    var footerArea = element.find('.footer-template');
	                    footerArea.append(footer);
	                }
	            });
	        },
	    };
	}
	exports.simpleCard = simpleCard;
	//# sourceMappingURL=simpleCard.js.map

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "<div class=\"card col-xs-12\">\r\n\t<div class=\"header row\" ng-class=\"{ 'active': card.canOpen && !card.alwaysOpen, 'error': cardForm.$invalid }\" ng-click=\"card.toggleContent()\">\r\n\t\t<div class=\"header-template\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n\r\n\t<ng-form name=\"cardForm\" rl-autosave=\"card.autosaveLink\" validate=\"card.validate()\" save=\"card.save()\">\r\n\t\t<div ng-show=\"card.showContent || card.alwaysOpen\">\r\n\t\t\t<div class=\"body row\">\r\n\t\t\t\t<div class=\"content-template\"></div>\r\n\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</ng-form>\r\n\t<div ng-show=\"hasFooter && card.showContent\">\r\n\t\t<div class=\"footer row\">\r\n\t\t\t<div class=\"footer-template\"></div>\r\n\t\t\t<div class=\"clearfix\"></div>\r\n\t\t</div>\r\n\t</div>\r\n</div>"

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __observable = typescript_angular_utilities_1.services.observable;
	exports.directiveName = 'rlSimpleCardList';
	exports.controllerName = 'SimpleCardListController';
	var SimpleCardListController = (function () {
	    function SimpleCardListController($scope, $attrs, $parse, observableFactory) {
	        var _this = this;
	        this.observable = observableFactory.getInstance();
	        $scope.$watch(function () { return $parse($attrs.alwaysOpen)($scope); }, function (value) {
	            _this.alwaysOpen = value;
	            _this.observable.fire('alwaysOpen', value);
	        });
	    }
	    SimpleCardListController.prototype.registerCard = function (behavior) {
	        behavior.setAlwaysOpen(this.alwaysOpen);
	        var unregisterFunctions = [];
	        unregisterFunctions.push(this.observable.register(behavior.close, 'close'));
	        unregisterFunctions.push(this.observable.register(behavior.setAlwaysOpen, 'alwaysOpen'));
	        return function () {
	            _.each(unregisterFunctions, function (unregister) {
	                unregister();
	            });
	        };
	    };
	    SimpleCardListController.prototype.openCard = function () {
	        return _.all(this.observable.fire('close'));
	    };
	    SimpleCardListController.$inject = ['$scope', '$attrs', '$parse', __observable.factoryName];
	    return SimpleCardListController;
	})();
	exports.SimpleCardListController = SimpleCardListController;
	function simpleCardList() {
	    'use strict';
	    return {
	        restrict: 'AE',
	        controller: exports.controllerName,
	    };
	}
	exports.simpleCardList = simpleCardList;
	//# sourceMappingURL=simpleCardList.js.map

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/bootstrap-touchspin/bootstrap-touchspin.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	__webpack_require__(139);
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __string = typescript_angular_utilities_1.services.string;
	var __number = typescript_angular_utilities_1.services.number;
	var componentValidator_service_1 = __webpack_require__(99);
	exports.moduleName = 'rl.ui.components.spinner';
	exports.directiveName = 'rlSpinner';
	exports.controllerName = 'SpinnerController';
	exports.defaultMaxValue = 100000000000000000000;
	var SpinnerController = (function () {
	    function SpinnerController($scope, componentValidatorFactory) {
	        var _this = this;
	        var unregister = $scope.$watch(function () { return _this.ngModel; }, function (value) {
	            if (!_.isUndefined(_this.validator)) {
	                _this.spinnerValidator = componentValidatorFactory.getInstance({
	                    ngModel: _this.ngModel,
	                    $scope: $scope,
	                    validators: [_this.validator],
	                });
	            }
	            unregister();
	        });
	    }
	    SpinnerController.$inject = ['$scope', componentValidator_service_1.factoryName];
	    return SpinnerController;
	})();
	exports.SpinnerController = SpinnerController;
	spinner.$inject = ['$timeout', __string.serviceName, __number.serviceName];
	function spinner($timeout, stringUtility, numberUtility) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(143),
	        require: '?^ngModel',
	        controller: exports.controllerName,
	        controllerAs: 'spinner',
	        scope: {},
	        bindToController: {
	            min: '=',
	            max: '=',
	            step: '=',
	            decimals: '=',
	            prefix: '@',
	            postfix: '@',
	            roundToStep: '=',
	            ngDisabled: '=',
	            spinnerId: '@',
	            name: '@',
	            validator: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            var spinner = scope.spinner;
	            spinner.ngModel = ngModel;
	            var unbindWatches;
	            scope.$watch('ngDisabled', function (disabled) {
	                if (disabled) {
	                    if (_.isFunction(unbindWatches)) {
	                        unbindWatches();
	                    }
	                }
	                else {
	                    // Initialize the spinner after $timeout to give angular a chance initialize ngModel
	                    $timeout(function () {
	                        var touchspin = element.find('input.spinner').TouchSpin({
	                            min: (spinner.min != null ? spinner.min : 0),
	                            max: (spinner.max != null ? spinner.max : exports.defaultMaxValue),
	                            step: spinner.step,
	                            prefix: spinner.prefix,
	                            postfix: spinner.postfix,
	                            decimals: spinner.decimals,
	                            initval: ngModel.$viewValue,
	                            forcestepdivisibility: spinner.roundToStep ? 'round' : 'none',
	                        });
	                        touchspin.on('change', function () {
	                            scope.$apply(function () {
	                                var spinValue = touchspin.val();
	                                ngModel.$setViewValue(stringUtility.toNumber(spinValue));
	                            });
	                        });
	                        var unbindViewWatch = scope.$watch(function () {
	                            return ngModel.$viewValue;
	                        }, function (newValue) {
	                            touchspin.val(newValue != null ? newValue.toString() : '');
	                        });
	                        var unbindModelWatch = scope.$watch(function () {
	                            return ngModel.$modelValue;
	                        }, function (newModel) {
	                            ngModel.$modelValue = round(newModel);
	                        });
	                        unbindWatches = function () {
	                            unbindViewWatch();
	                            unbindModelWatch();
	                        };
	                    });
	                }
	            });
	            function round(num) {
	                if (num != null && spinner.roundToStep) {
	                    num = numberUtility.roundToStep(num, spinner.step);
	                    num = numberUtility.preciseRound(num, spinner.decimals);
	                }
	                return num;
	            }
	        }
	    };
	}
	angular.module(exports.moduleName, [__string.moduleName, componentValidator_service_1.moduleName, __number.moduleName])
	    .directive(exports.directiveName, spinner)
	    .controller(exports.controllerName, SpinnerController);
	//# sourceMappingURL=spinner.js.map

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	jQuery = __webpack_require__(13);
	
	__webpack_require__(140);
	__webpack_require__(142);

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(141);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(11)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./jquery.bootstrap-touchspin.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./jquery.bootstrap-touchspin.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(10)();
	// imports
	
	
	// module
	exports.push([module.id, "/*\r\n *  Bootstrap TouchSpin - v3.0.1\r\n *  A mobile and touch friendly input spinner component for Bootstrap 3.\r\n *  http://www.virtuosoft.eu/code/bootstrap-touchspin/\r\n *\r\n *  Made by Istvn Ujj-Mszros\r\n *  Under Apache License v2.0 License\r\n */\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical {\r\n  position: relative;\r\n  white-space: nowrap;\r\n  width: 1%;\r\n  vertical-align: middle;\r\n  display: table-cell;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical > .btn {\r\n  display: block;\r\n  float: none;\r\n  width: 100%;\r\n  max-width: 100%;\r\n  padding: 8px 10px;\r\n  margin-left: -1px;\r\n  position: relative;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical .bootstrap-touchspin-up {\r\n  border-radius: 0;\r\n  border-top-right-radius: 4px;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical .bootstrap-touchspin-down {\r\n  margin-top: -2px;\r\n  border-radius: 0;\r\n  border-bottom-right-radius: 4px;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical i {\r\n  position: absolute;\r\n  top: 3px;\r\n  left: 5px;\r\n  font-size: 9px;\r\n  font-weight: normal;\r\n}\r\n", ""]);
	
	// exports


/***/ },
/* 142 */
/***/ function(module, exports) {

	/*
	 *  Bootstrap TouchSpin - v3.0.1
	 *  A mobile and touch friendly input spinner component for Bootstrap 3.
	 *  http://www.virtuosoft.eu/code/bootstrap-touchspin/
	 *
	 *  Made by Istvn Ujj-Mszros
	 *  Under Apache License v2.0 License
	 */
	(function($) {
	  'use strict';
	
	  var _currentSpinnerId = 0;
	
	  function _scopedEventName(name, id) {
	    return name + '.touchspin_' + id;
	  }
	
	  function _scopeEventNames(names, id) {
	    return $.map(names, function(name) {
	      return _scopedEventName(name, id);
	    });
	  }
	
	  $.fn.TouchSpin = function(options) {
	
	    if (options === 'destroy') {
	      this.each(function() {
	        var originalinput = $(this),
	            originalinput_data = originalinput.data();
	        $(document).off(_scopeEventNames([
	          'mouseup',
	          'touchend',
	          'touchcancel',
	          'mousemove',
	          'touchmove',
	          'scroll',
	          'scrollstart'], originalinput_data.spinnerid).join(' '));
	      });
	      return;
	    }
	
	    var defaults = {
	      min: 0,
	      max: 100,
	      initval: '',
	      step: 1,
	      decimals: 0,
	      stepinterval: 100,
	      forcestepdivisibility: 'round', // none | floor | round | ceil
	      stepintervaldelay: 500,
	      verticalbuttons: false,
	      verticalupclass: 'glyphicon glyphicon-chevron-up',
	      verticaldownclass: 'glyphicon glyphicon-chevron-down',
	      prefix: '',
	      postfix: '',
	      prefix_extraclass: '',
	      postfix_extraclass: '',
	      booster: true,
	      boostat: 10,
	      maxboostedstep: false,
	      mousewheel: true,
	      buttondown_class: 'btn btn-default',
	      buttonup_class: 'btn btn-default',
		  buttondown_txt: '-',
		  buttonup_txt: '+'
	    };
	
	    var attributeMap = {
	      min: 'min',
	      max: 'max',
	      initval: 'init-val',
	      step: 'step',
	      decimals: 'decimals',
	      stepinterval: 'step-interval',
	      verticalbuttons: 'vertical-buttons',
	      verticalupclass: 'vertical-up-class',
	      verticaldownclass: 'vertical-down-class',
	      forcestepdivisibility: 'force-step-divisibility',
	      stepintervaldelay: 'step-interval-delay',
	      prefix: 'prefix',
	      postfix: 'postfix',
	      prefix_extraclass: 'prefix-extra-class',
	      postfix_extraclass: 'postfix-extra-class',
	      booster: 'booster',
	      boostat: 'boostat',
	      maxboostedstep: 'max-boosted-step',
	      mousewheel: 'mouse-wheel',
	      buttondown_class: 'button-down-class',
	      buttonup_class: 'button-up-class',
		  buttondown_txt: 'button-down-txt',
		  buttonup_txt: 'button-up-txt'
	    };
	
	    return this.each(function() {
	
	      var settings,
	          originalinput = $(this),
	          originalinput_data = originalinput.data(),
	          container,
	          elements,
	          value,
	          downSpinTimer,
	          upSpinTimer,
	          downDelayTimeout,
	          upDelayTimeout,
	          spincount = 0,
	          spinning = false;
	
	      init();
	
	
	      function init() {
	        if (originalinput.data('alreadyinitialized')) {
	          return;
	        }
	
	        originalinput.data('alreadyinitialized', true);
	        _currentSpinnerId += 1;
	        originalinput.data('spinnerid', _currentSpinnerId);
	
	
	        if (!originalinput.is('input')) {
	          console.log('Must be an input.');
	          return;
	        }
	
	        _initSettings();
	        _setInitval();
	        _checkValue();
	        _buildHtml();
	        _initElements();
	        _hideEmptyPrefixPostfix();
	        _bindEvents();
	        _bindEventsInterface();
	        elements.input.css('display', 'block');
	      }
	
	      function _setInitval() {
	        if (settings.initval !== '' && originalinput.val() === '') {
	          originalinput.val(settings.initval);
	        }
	      }
	
	      function changeSettings(newsettings) {
	        _updateSettings(newsettings);
	        _checkValue();
	
	        var value = elements.input.val();
	
	        if (value !== '') {
	          value = Number(elements.input.val());
	          elements.input.val(value.toFixed(settings.decimals));
	        }
	      }
	
	      function _initSettings() {
	        settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
	      }
	
	      function _parseAttributes() {
	        var data = {};
	        $.each(attributeMap, function(key, value) {
	          var attrName = 'bts-' + value + '';
	          if (originalinput.is('[data-' + attrName + ']')) {
	            data[key] = originalinput.data(attrName);
	          }
	        });
	        return data;
	      }
	
	      function _updateSettings(newsettings) {
	        settings = $.extend({}, settings, newsettings);
	      }
	
	      function _buildHtml() {
	        var initval = originalinput.val(),
	            parentelement = originalinput.parent();
	
	        if (initval !== '') {
	          initval = Number(initval).toFixed(settings.decimals);
	        }
	
	        originalinput.data('initvalue', initval).val(initval);
	        originalinput.addClass('form-control');
	
	        if (parentelement.hasClass('input-group')) {
	          _advanceInputGroup(parentelement);
	        }
	        else {
	          _buildInputGroup();
	        }
	      }
	
	      function _advanceInputGroup(parentelement) {
	        parentelement.addClass('bootstrap-touchspin');
	
	        var prev = originalinput.prev(),
	            next = originalinput.next();
	
	        var downhtml,
	            uphtml,
	            prefixhtml = '<span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span>',
	            postfixhtml = '<span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span>';
	
	        if (prev.hasClass('input-group-btn')) {
	          downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button>';
	          prev.append(downhtml);
	        }
	        else {
	          downhtml = '<span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span>';
	          $(downhtml).insertBefore(originalinput);
	        }
	
	        if (next.hasClass('input-group-btn')) {
	          uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button>';
	          next.prepend(uphtml);
	        }
	        else {
	          uphtml = '<span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span>';
	          $(uphtml).insertAfter(originalinput);
	        }
	
	        $(prefixhtml).insertBefore(originalinput);
	        $(postfixhtml).insertAfter(originalinput);
	
	        container = parentelement;
	      }
	
	      function _buildInputGroup() {
	        var html;
	
	        if (settings.verticalbuttons) {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-up" type="button"><i class="' + settings.verticalupclass + '"></i></button><button class="' + settings.buttonup_class + ' bootstrap-touchspin-down" type="button"><i class="' + settings.verticaldownclass + '"></i></button></span></div>';
	        }
	        else {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span></div>';
	        }
	
	        container = $(html).insertBefore(originalinput);
	
	        $('.bootstrap-touchspin-prefix', container).after(originalinput);
	
	        if (originalinput.hasClass('input-sm')) {
	          container.addClass('input-group-sm');
	        }
	        else if (originalinput.hasClass('input-lg')) {
	          container.addClass('input-group-lg');
	        }
	      }
	
	      function _initElements() {
	        elements = {
	          down: $('.bootstrap-touchspin-down', container),
	          up: $('.bootstrap-touchspin-up', container),
	          input: $('input', container),
	          prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),
	          postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)
	        };
	      }
	
	      function _hideEmptyPrefixPostfix() {
	        if (settings.prefix === '') {
	          elements.prefix.hide();
	        }
	
	        if (settings.postfix === '') {
	          elements.postfix.hide();
	        }
	      }
	
	      function _bindEvents() {
	        originalinput.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 38) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	          else if (code === 40) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        originalinput.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 38) {
	            stopSpin();
	          }
	          else if (code === 40) {
	            stopSpin();
	          }
	        });
	
	        originalinput.on('blur', function() {
	          _checkValue();
	        });
	
	        elements.down.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        elements.down.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });
	
	        elements.up.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        elements.up.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });
	
	        elements.down.on('mousedown.touchspin', function(ev) {
	          elements.down.off('touchstart.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          downOnce();
	          startDownSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.down.on('touchstart.touchspin', function(ev) {
	          elements.down.off('mousedown.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          downOnce();
	          startDownSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('mousedown.touchspin', function(ev) {
	          elements.up.off('touchstart.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          upOnce();
	          startUpSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('touchstart.touchspin', function(ev) {
	          elements.up.off('mousedown.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          upOnce();
	          startUpSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          stopSpin();
	        });
	
	        elements.down.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          stopSpin();
	        });
	
	        elements.down.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          ev.preventDefault();
	        });
	
	        elements.up.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          ev.preventDefault();
	        });
	
	        $(document).on(_scopeEventNames(['mouseup', 'touchend', 'touchcancel'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.preventDefault();
	          stopSpin();
	        });
	
	        $(document).on(_scopeEventNames(['mousemove', 'touchmove', 'scroll', 'scrollstart'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.preventDefault();
	          stopSpin();
	        });
	
	        originalinput.on('mousewheel DOMMouseScroll', function(ev) {
	          if (!settings.mousewheel || !originalinput.is(':focus')) {
	            return;
	          }
	
	          var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;
	
	          ev.stopPropagation();
	          ev.preventDefault();
	
	          if (delta < 0) {
	            downOnce();
	          }
	          else {
	            upOnce();
	          }
	        });
	      }
	
	      function _bindEventsInterface() {
	        originalinput.on('touchspin.uponce', function() {
	          stopSpin();
	          upOnce();
	        });
	
	        originalinput.on('touchspin.downonce', function() {
	          stopSpin();
	          downOnce();
	        });
	
	        originalinput.on('touchspin.startupspin', function() {
	          startUpSpin();
	        });
	
	        originalinput.on('touchspin.startdownspin', function() {
	          startDownSpin();
	        });
	
	        originalinput.on('touchspin.stopspin', function() {
	          stopSpin();
	        });
	
	        originalinput.on('touchspin.updatesettings', function(e, newsettings) {
	          changeSettings(newsettings);
	        });
	      }
	
	      function _forcestepdivisibility(value) {
	        switch (settings.forcestepdivisibility) {
	          case 'round':
	            return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'floor':
	            return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'ceil':
	            return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);
	          default:
	            return value;
	        }
	      }
	
	      function _checkValue() {
	        var val, parsedval, returnval;
	
	        val = originalinput.val();
	
	        if (val === '') {
	          return;
	        }
	
	        if (settings.decimals > 0 && val === '.') {
	          return;
	        }
	
	        parsedval = parseFloat(val);
	
	        if (isNaN(parsedval)) {
	          parsedval = 0;
	        }
	
	        returnval = parsedval;
	
	        if (parsedval.toString() !== val) {
	          returnval = parsedval;
	        }
	
	        if (parsedval < settings.min) {
	          returnval = settings.min;
	        }
	
	        if (parsedval > settings.max) {
	          returnval = settings.max;
	        }
	
	        returnval = _forcestepdivisibility(returnval);
	
	        if (Number(val).toString() !== returnval.toString()) {
	          originalinput.val(returnval);
	          originalinput.trigger('change');
	        }
	      }
	
	      function _getBoostedStep() {
	        if (!settings.booster) {
	          return settings.step;
	        }
	        else {
	          var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;
	
	          if (settings.maxboostedstep) {
	            if (boosted > settings.maxboostedstep) {
	              boosted = settings.maxboostedstep;
	              value = Math.round((value / boosted)) * boosted;
	            }
	          }
	
	          return Math.max(settings.step, boosted);
	        }
	      }
	
	      function upOnce() {
	        _checkValue();
	
	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }
	
	        var initvalue = value,
	            boostedstep = _getBoostedStep();
	
	        value = value + boostedstep;
	
	        if (value > settings.max) {
	          value = settings.max;
	          originalinput.trigger('touchspin.on.max');
	          stopSpin();
	        }
	
	        elements.input.val(Number(value).toFixed(settings.decimals));
	
	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }
	
	      function downOnce() {
	        _checkValue();
	
	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }
	
	        var initvalue = value,
	            boostedstep = _getBoostedStep();
	
	        value = value - boostedstep;
	
	        if (value < settings.min) {
	          value = settings.min;
	          originalinput.trigger('touchspin.on.min');
	          stopSpin();
	        }
	
	        elements.input.val(value.toFixed(settings.decimals));
	
	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }
	
	      function startDownSpin() {
	        stopSpin();
	
	        spincount = 0;
	        spinning = 'down';
	
	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startdownspin');
	
	        downDelayTimeout = setTimeout(function() {
	          downSpinTimer = setInterval(function() {
	            spincount++;
	            downOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }
	
	      function startUpSpin() {
	        stopSpin();
	
	        spincount = 0;
	        spinning = 'up';
	
	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startupspin');
	
	        upDelayTimeout = setTimeout(function() {
	          upSpinTimer = setInterval(function() {
	            spincount++;
	            upOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }
	
	      function stopSpin() {
	        clearTimeout(downDelayTimeout);
	        clearTimeout(upDelayTimeout);
	        clearInterval(downSpinTimer);
	        clearInterval(upSpinTimer);
	
	        switch (spinning) {
	          case 'up':
	            originalinput.trigger('touchspin.on.stopupspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	          case 'down':
	            originalinput.trigger('touchspin.on.stopdownspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	        }
	
	        spincount = 0;
	        spinning = false;
	      }
	
	    });
	
	  };
	
	})(jQuery);


/***/ },
/* 143 */
/***/ function(module, exports) {

	module.exports = "<rl-generic-container selector=\"spinner.ngDisabled\">\r\n\t<template default>\r\n\t\t<div class=\"validation-input-group\">\r\n\t\t\t<div class=\"validation-input\" ng-class=\"{ 'error': spinner.ngModel.$invalid, 'required-error': spinner.ngModel.$error.required }\">\r\n\t\t\t\t<input name=\"{{spinner.name}}\" class=\"spinner\" id=\"{{spinner.spinnerId}}\" type=\"text\" />\r\n                <span class=\"error-string\" ng-hide=\"spinner.spinnerValidator.error | isEmpty\">{{spinner.spinnerValidator.error}}</span>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</template>\r\n\t<template when-selector=\"true\">\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix != null && spinner.postfix != null\">\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.prefix}}</span>\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.postfix}}</span>\r\n\t\t</div>\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix != null && spinner.postfix == null\">\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.prefix}}</span>\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t</div>\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix == null && spinner.postfix != null\">\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.postfix}}</span>\r\n\t\t</div>\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix == null && spinner.postfix == null\">\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t</div>\r\n\t</template>\r\n</rl-generic-container>"

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __object = typescript_angular_utilities_1.services.object;
	exports.moduleName = 'rl.ui.components.stringWithWatermark';
	exports.directiveName = 'rlStringWithWatermark';
	exports.controllerName = 'StringWithWatermarkController';
	var StringWithWatermarkController = (function () {
	    function StringWithWatermarkController($scope, objectUtility) {
	        var _this = this;
	        $scope.$watch(function () { return _this.string; }, function (value) {
	            _this.hasString = objectUtility.isNullOrEmpty(value) === false;
	        });
	    }
	    StringWithWatermarkController.$inject = ['$scope', __object.serviceName];
	    return StringWithWatermarkController;
	})();
	exports.StringWithWatermarkController = StringWithWatermarkController;
	function stringWithWatermark() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<span>\n\t\t\t\t<span ng-show=\"controller.hasString\">{{controller.string}}</span>\n\t\t\t\t<span ng-hide=\"controller.hasString\" class=\"watermark\">{{controller.watermark}}</span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            string: '@',
	            watermark: '@',
	        }
	    };
	}
	exports.stringWithWatermark = stringWithWatermark;
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, stringWithWatermark)
	    .controller(exports.controllerName, StringWithWatermarkController);
	//# sourceMappingURL=stringWithWatermark.js.map

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var tab_1 = __webpack_require__(146);
	exports.tabDirectiveName = tab_1.directiveName;
	exports.tab = tab_1.tab;
	exports.tabControllerName = tab_1.controllerName;
	exports.TabController = tab_1.TabController;
	var tabset_1 = __webpack_require__(148);
	exports.tabsetDirectiveName = tabset_1.directiveName;
	exports.tabset = tabset_1.tabset;
	exports.tabsetControllerName = tabset_1.controllerName;
	exports.TabsetController = tabset_1.TabsetController;
	exports.moduleName = 'rl.ui.components.tabs';
	angular.module(exports.moduleName, [])
	    .directive(tab_1.directiveName, tab_1.tab)
	    .controller(tab_1.controllerName, tab_1.TabController)
	    .directive(tabset_1.directiveName, tabset_1.tabset)
	    .controller(tabset_1.controllerName, tabset_1.TabsetController);
	//# sourceMappingURL=tabs.module.js.map

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.directiveName = 'rlTab';
	exports.controllerName = 'rlTabController';
	var TabController = (function () {
	    function TabController($scope) {
	        var _this = this;
	        $scope.$watch('tabForm.$valid', function (isValid) {
	            _this.header.isValid = isValid != null ? isValid : true;
	        });
	    }
	    TabController.$inject = ['$scope'];
	    return TabController;
	})();
	exports.TabController = TabController;
	function tab() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        require: ['^^rlTabset', 'rlTab'],
	        template: __webpack_require__(147),
	        controller: exports.controllerName,
	        controllerAs: 'tab',
	        scope: {},
	        bindToController: {},
	        link: function (scope, element, attrs, controllers, transclude) {
	            transclude(function (clone) {
	                var header = clone.filter('rl-tab-header');
	                var content = clone.filter('rl-tab-content');
	                var footer = clone.filter('rl-tab-footer');
	                var tabset = controllers[0];
	                var tab = controllers[1];
	                tab.header = {
	                    template: header.html(),
	                    isValid: true,
	                };
	                tabset.registerTab(element, tab.header);
	                var contentArea = element.find('.content-template');
	                contentArea.append(content);
	                scope.hasFooter = (footer.length > 0);
	                if (scope.hasFooter) {
	                    var footerArea = element.find('.footer-template');
	                    footerArea.append(footer);
	                }
	            });
	        },
	    };
	}
	exports.tab = tab;
	//# sourceMappingURL=tab.js.map

/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tab-pane\" ng-class=\"{ 'active': tab.header.isVisible }\">\r\n\t<div class=\"tab-body\">\r\n\t\t<div class=\"content-template\" ng-form=\"tabForm\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n\t<div class=\"tab-footer\" ng-show=\"hasFooter\">\r\n\t\t<div class=\"footer-template\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n</div>"

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var _ = __webpack_require__(19);
	exports.directiveName = 'rlTabset';
	exports.controllerName = 'rlTabsetController';
	var TabsetController = (function () {
	    function TabsetController() {
	        this.tabHeaders = [];
	    }
	    TabsetController.prototype.registerTab = function (element, header) {
	        var index = this.findPosition(element);
	        this.tabHeaders[index] = header;
	        header.isVisible = (index === 0);
	    };
	    TabsetController.prototype.select = function (tab) {
	        _.each(this.tabHeaders, function (otherTab) {
	            otherTab.isVisible = false;
	        });
	        tab.isVisible = true;
	    };
	    return TabsetController;
	})();
	exports.TabsetController = TabsetController;
	function tabset() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(149),
	        controller: exports.controllerName,
	        controllerAs: 'tabset',
	        scope: {},
	        link: {
	            pre: function (scope, element, attrs, tabset) {
	                tabset.findPosition = function (tabElement) {
	                    // find the position of the specified element by iterating over the tabs and finding a matching element
	                    var tabs = element.find('rl-tab');
	                    var num;
	                    _.each(tabs, function (elem, index) {
	                        if (tabElement[0] === elem) {
	                            num = index;
	                            return false;
	                        }
	                    });
	                    return num;
	                };
	            },
	        },
	    };
	}
	exports.tabset = tabset;
	//# sourceMappingURL=tabset.js.map

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = "<div class=\"nav-tabs-dropshadow\">\r\n\t<ul class=\"nav nav-tabs\">\r\n\t\t<li ng-repeat=\"tabHeader in tabset.tabHeaders\" ng-click=\"tabset.select(tabHeader)\"\r\n\t\t\tng-class=\"{ 'active': tabHeader.isVisible, 'error': !tabHeader.isValid }\">\r\n\t\t\t<a><span ng-bind-html=\"tabHeader.template\"></span></a>\r\n\t\t</li>\r\n\t</ul>\r\n\t<div class=\"tab-content\">\r\n\t\t<div ng-transclude></div>\r\n\t</div>\r\n</div>"

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var componentValidator_service_1 = __webpack_require__(99);
	exports.moduleName = 'rl.ui.components.textarea';
	exports.directiveName = 'rlTextarea';
	exports.controllerName = 'TextareaController';
	var TextareaController = (function () {
	    function TextareaController($element, $scope, componentValidatorFactory) {
	        this.ngModel = $element.controller('ngModel');
	        if (!_.isUndefined(this.validator)) {
	            this.textareaValidator = componentValidatorFactory.getInstance({
	                ngModel: this.ngModel,
	                $scope: $scope,
	                validators: [this.validator],
	            });
	        }
	    }
	    Object.defineProperty(TextareaController.prototype, "text", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            this.ngModel.$setViewValue(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextareaController.$inject = ['$element', '$scope', componentValidator_service_1.factoryName];
	    return TextareaController;
	})();
	exports.TextareaController = TextareaController;
	function textarea() {
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: __webpack_require__(151),
	        controller: exports.controllerName,
	        controllerAs: 'textarea',
	        scope: {},
	        bindToController: {
	            name: '@',
	            rows: '=',
	            ngDisabled: '=',
	            label: '@',
	            validator: '=',
	        },
	    };
	}
	exports.textarea = textarea;
	angular.module(exports.moduleName, [componentValidator_service_1.moduleName])
	    .directive(exports.directiveName, textarea)
	    .controller(exports.controllerName, TextareaController);
	//# sourceMappingURL=textarea.js.map

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports = "<div class=\"validation-input-group\">\r\n\t<div class=\"field validation-input\" ng-class=\"{ 'error': textarea.ngModel.$invalid, 'required-error': textarea.ngModel.$error.required }\">\r\n\t\t<label ng-show=\"textarea.text\" class=\"show-hide angular-animate\">{{textarea.label}}</label>\r\n\t\t<textarea class=\"form-control\" ng-model=\"textarea.text\" name=\"{{textarea.name}}\" rows=\"{{textarea.rows}}\" ng-disabled=\"textarea.ngDisabled\" placeholder=\"{{textarea.label}}\"></textarea>\r\n        <span class=\"error-string\" ng-hide=\"textarea.textareaValidator.error | isEmpty\">{{textarea.textareaValidator.error}}</span>\r\n\t</div>\r\n</div>"

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var componentValidator_service_1 = __webpack_require__(99);
	exports.moduleName = 'rl.ui.components.textbox';
	exports.directiveName = 'rlTextbox';
	exports.controllerName = 'TextboxController';
	var TextboxController = (function () {
	    function TextboxController($element, $scope, componentValidatorFactory) {
	        this.ngModel = $element.controller('ngModel');
	        if (!_.isUndefined(this.validator)) {
	            this.textboxValidator = componentValidatorFactory.getInstance({
	                ngModel: this.ngModel,
	                $scope: $scope,
	                validators: [this.validator],
	            });
	        }
	    }
	    Object.defineProperty(TextboxController.prototype, "text", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            this.ngModel.$setViewValue(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextboxController.$inject = ['$element', '$scope', componentValidator_service_1.factoryName];
	    return TextboxController;
	})();
	exports.TextboxController = TextboxController;
	function textbox() {
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: __webpack_require__(153),
	        controller: exports.controllerName,
	        controllerAs: 'textbox',
	        scope: {},
	        bindToController: {
	            validator: '=',
	            label: '@',
	        },
	    };
	}
	exports.textbox = textbox;
	angular.module(exports.moduleName, [componentValidator_service_1.moduleName])
	    .directive(exports.directiveName, textbox)
	    .controller(exports.controllerName, TextboxController);
	//# sourceMappingURL=textbox.js.map

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = "<div class=\"validation-input-group\">\r\n\t<div class=\"field validation-input\" ng-class=\"{ 'error': textbox.ngModel.$invalid, 'required-error': textbox.ngModel.$error.required }\">\r\n\t\t<label ng-show=\"textbox.text\" class=\"show-hide angular-animate\">{{textbox.label}}</label>\r\n\t\t<input  type=\"text\" class=\"form-control angular-animate\" ng-model=\"textbox.text\" placeholder=\"{{textbox.label}}\"/>\r\n        <span class=\"error-string\" ng-hide=\"textbox.textboxValidator.error | isEmpty\">{{textbox.textboxValidator.error}}</span>\r\n\t</div>\r\n</div>"

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __genericSearch = typescript_angular_utilities_1.services.genericSearchFilter;
	var __objectUtility = typescript_angular_utilities_1.services.object;
	var __arrayUtility = typescript_angular_utilities_1.services.array;
	var __promiseUtility = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.typeahead';
	exports.directiveName = 'rlTypeahead';
	exports.controllerName = 'TypeaheadController';
	var TypeaheadController = (function () {
	    function TypeaheadController($scope, $attrs, $q, parentChild, genericSearchFactory, object, array, promise) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.parentChild = parentChild;
	        this.array = array;
	        this.promise = promise;
	        this.loading = false;
	        this.addItem = function (item) {
	            if (_this.cachedItems != null) {
	                _this.cachedItems.push(item);
	            }
	        };
	        this.removeItem = function (item) {
	            if (_this.cachedItems != null) {
	                _this.array.remove(_this.cachedItems, item);
	            }
	        };
	        this.searchFilter = genericSearchFactory.getInstance();
	        this.loadDelay = this.useClientSearching ? 100 : 500;
	        this.selection = this.selectionBinding;
	        if (this.hasSelection == null) {
	            this.hasSelection = false;
	        }
	        if (this.placeholder == null) {
	            this.placeholder = 'Search';
	        }
	        if (this.showSearch == null) {
	            this.showSearch = true;
	        }
	        this.useScopeSelection = object.isNullOrEmpty($attrs.selection) === false;
	        this.hasTransform = object.isNullOrEmpty($attrs.transform) === false;
	        this.useApply = object.isNullOrEmpty($attrs.apply) === false;
	        this.parentChild.registerChildBehavior(this.childLink, {
	            add: this.addItem,
	            remove: this.removeItem,
	        });
	        $scope.$watch(function () { return _this.selection; }, function (value) {
	            _this.hasSelection = _.isObject(value);
	            _this.setSelection(value);
	        });
	        $scope.$watch(function () { return _this.selectionBinding; }, function (value) {
	            if (value == null) {
	                _this.selection = null;
	            }
	        });
	    }
	    TypeaheadController.prototype.setSelection = function (object) {
	        if (this.useScopeSelection) {
	            this.selection = object;
	        }
	        if (_.isFunction(this.select)) {
	            this.select({ value: object, hasSelection: this.hasSelection });
	        }
	    };
	    TypeaheadController.prototype.transform = function (object) {
	        if (this.hasTransform && object != null) {
	            return this.transformInParent({
	                value: object,
	            });
	        }
	        return object;
	    };
	    TypeaheadController.prototype.getItems = function (search) {
	        var _this = this;
	        if (!this.useClientSearching) {
	            return this.getItemsInParent({
	                search: search,
	            });
	        }
	        else {
	            this.searchFilter.searchText = search;
	            if (this.cachedItems != null) {
	                return this.$q.when(this.filter(this.cachedItems));
	            }
	            else {
	                return this.$q.when(this.getItemsInParent()).then(function (data) {
	                    _this.cachedItems = data;
	                    return _this.filter(data);
	                });
	            }
	        }
	    };
	    TypeaheadController.prototype.applyItem = function () {
	        var _this = this;
	        if (this.useApply && this.hasSelection) {
	            var request = this.apply({ value: this.selection });
	            if (this.promise.isPromise(request)) {
	                return request.then(function () {
	                    _this.removeItem(_this.selection);
	                    _this.selection = null;
	                });
	            }
	            else if (!_.isUndefined(request)) {
	                this.removeItem(this.selection);
	                this.selection = null;
	            }
	        }
	        return this.$q.when();
	    };
	    TypeaheadController.prototype.filter = function (list) {
	        var _this = this;
	        return _.filter(list, function (item) { return _this.searchFilter.filter(item); });
	    };
	    TypeaheadController.$inject = ['$scope',
	        '$attrs',
	        '$q',
	        __parentChild.serviceName,
	        __genericSearch.factoryName,
	        __objectUtility.serviceName,
	        __arrayUtility.serviceName,
	        __promiseUtility.serviceName];
	    return TypeaheadController;
	})();
	exports.TypeaheadController = TypeaheadController;
	function typeahead() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(155),
	        controller: exports.controllerName,
	        controllerAs: 'typeahead',
	        scope: {},
	        bindToController: {
	            childLink: '=',
	            selectionBinding: '=selection',
	            hasSelection: '=',
	            select: '&',
	            transformInParent: '&transform',
	            getItemsInParent: '&getItems',
	            placeholder: '@',
	            useClientSearching: '=',
	            hasError: '=',
	            showSearch: '=',
	            apply: '&',
	        },
	    };
	}
	exports.typeahead = typeahead;
	angular.module(exports.moduleName, [
	    __parentChild.moduleName,
	    __genericSearch.moduleName,
	    __objectUtility.moduleName,
	    __arrayUtility.moduleName,
	    __promiseUtility.moduleName])
	    .directive(exports.directiveName, typeahead)
	    .controller(exports.controllerName, TypeaheadController);
	//# sourceMappingURL=typeahead.js.map

/***/ },
/* 155 */
/***/ function(module, exports) {

	module.exports = "<div class=\"input-group\" ng-class=\"{ 'has-error': typeahead.hasError }\">\r\n\t<input type=\"text\" ng-model=\"typeahead.selection\" class=\"form-control\"\r\n\t\tplaceholder=\"{{typeahead.placeholder}}\" typeahead=\"object as typeahead.transform(object) for object in typeahead.getItems($viewValue)\"\r\n\t\ttypeahead-loading=\"typeahead.loading\" typeahead-wait-ms=\"typeahead.loadDelay\" />\r\n\t<div class=\"input-group-addon\" ng-if=\"typeahead.showSearch\">\r\n\t\t<rl-busy loading=\"typeahead.loading\"></rl-busy>\r\n\t\t<span ng-hide=\"typeahead.loading\">\r\n\t\t\t<i class=\"fa fa-search\" ng-hide=\"typeahead.hasSelection\"></i>\r\n\t\t\t<i class=\"fa fa-check\" ng-show=\"typeahead.hasSelection\"></i>\r\n\t\t</span>\r\n\t</div>\r\n\t<div class=\"input-group-btn\" ng-if=\"typeahead.useApply\">\r\n\t\t<rl-button-async type=\"default\" action=\"typeahead.applyItem()\" right-aligned=\"true\" ng-disabled=\"!typeahead.hasSelection\">\r\n\t\t\t<i class=\"fa fa-plus new\"></i>\r\n\t\t</rl-button-async>\r\n\t</div>\r\n</div>"

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	exports.moduleName = 'rl.components.userRating';
	exports.directiveName = 'rlUserRating';
	exports.controllerName = 'UserRatingController';
	var UserRatingController = (function () {
	    function UserRatingController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        this.stars = [];
	        var rangeSize = this.$scope.range != null ? this.$scope.range : 5;
	        // css style requires the stars to show right to left. Reverse the list so the highest value is first
	        var range = _.range(1, rangeSize + 1).reverse();
	        _.each(range, function (rating) {
	            _this.stars.push({
	                value: rating,
	                filled: false,
	            });
	        });
	        var unbind = this.$scope.$watch('ngModel', function (value) {
	            _this.updateStarView(_this.$scope.ngModel.$viewValue);
	            unbind();
	        });
	    }
	    UserRatingController.prototype.setRating = function (rating) {
	        this.$scope.ngModel.$setViewValue(rating);
	        this.updateStarView(rating);
	    };
	    UserRatingController.prototype.updateStarView = function (rating) {
	        _.each(this.stars, function (star) {
	            if (star.value <= rating) {
	                star.filled = true;
	            }
	            else {
	                star.filled = false;
	            }
	        });
	    };
	    UserRatingController.$inject = ['$scope'];
	    return UserRatingController;
	})();
	exports.UserRatingController = UserRatingController;
	function userRating() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: "\n\t\t\t<span class=\"rating\">\n\t\t\t\t<span class=\"star\" ng-repeat=\"star in userRating.stars\" ng-class=\"{ 'filled': star.filled }\" ng-click=\"userRating.setRating(star.value)\"></span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'userRating',
	        scope: {
	            range: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.ngModel = ngModel;
	        },
	    };
	}
	exports.userRating = userRating;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, userRating)
	    .controller(exports.controllerName, UserRatingController);
	//# sourceMappingURL=userRating.js.map

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var componentValidator_service_1 = __webpack_require__(99);
	exports.moduleName = 'rl.ui.components.validationGroup';
	exports.directiveName = 'rlValidationGroup';
	exports.controllerName = 'ValidationGroupController';
	var ValidationGroupController = (function () {
	    function ValidationGroupController($scope, componentValidatorFactory) {
	        var _this = this;
	        var unbind = $scope.$watch('validationGroupForm', function (form) {
	            if (!_.isUndefined(_this.validator)) {
	                _this.groupValidator = componentValidatorFactory.getInstance({
	                    form: $scope.validationGroupForm,
	                    $scope: $scope,
	                    validators: [_this.validator],
	                });
	            }
	            unbind();
	        });
	    }
	    ValidationGroupController.$inject = ['$scope', componentValidator_service_1.factoryName];
	    return ValidationGroupController;
	})();
	exports.ValidationGroupController = ValidationGroupController;
	function validationGroup() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(158),
	        controller: exports.controllerName,
	        controllerAs: 'group',
	        scope: {},
	        bindToController: {
	            validator: '=',
	        },
	    };
	}
	exports.validationGroup = validationGroup;
	angular.module(exports.moduleName, [componentValidator_service_1.moduleName])
	    .directive(exports.directiveName, validationGroup)
	    .controller(exports.controllerName, ValidationGroupController);
	//# sourceMappingURL=validationGroup.js.map

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = "<div class=\"content-group\" ng-form=\"validationGroupForm\">\r\n\t<div class=\"error\" ng-show=\"validationGroupForm.$error.customValidation\">\r\n\t\t<label>{{group.groupValidator.error}}</label>\r\n\t</div>\r\n\t<div ng-transclude></div>\r\n</div>"

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var autosave = __webpack_require__(18);
	exports.autosave = autosave;
	var autosaveAction = __webpack_require__(20);
	exports.autosaveAction = autosaveAction;
	var autosaveDialog = __webpack_require__(160);
	exports.autosaveDialog = autosaveDialog;
	var breakpoints = __webpack_require__(167);
	exports.breakpoints = breakpoints;
	var componentValidator = __webpack_require__(99);
	exports.componentValidator = componentValidator;
	var contentProvider = __webpack_require__(171);
	exports.contentProvider = contentProvider;
	var dialog = __webpack_require__(162);
	exports.dialog = dialog;
	var documentWrapper = __webpack_require__(172);
	exports.documentWrapper = documentWrapper;
	var jquery = __webpack_require__(102);
	exports.jquery = jquery;
	var templateLoader = __webpack_require__(103);
	exports.templateLoader = templateLoader;
	var windowWrapper = __webpack_require__(168);
	exports.windowWrapper = windowWrapper;
	exports.moduleName = 'rl.ui.services';
	angular.module(exports.moduleName, [
	    autosave.moduleName,
	    autosaveAction.moduleName,
	    autosaveDialog.moduleName,
	    breakpoints.moduleName,
	    componentValidator.moduleName,
	    contentProvider.moduleName,
	    dialog.moduleName,
	    documentWrapper.moduleName,
	    jquery.moduleName,
	    templateLoader.moduleName,
	    windowWrapper.moduleName,
	]);
	//# sourceMappingURL=services.module.js.map

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __promise = typescript_angular_utilities_1.services.promise;
	var autosave_service_1 = __webpack_require__(18);
	var autosaveDialog_service_1 = __webpack_require__(161);
	var autosaveDialog_controller_1 = __webpack_require__(166);
	__export(__webpack_require__(161));
	__export(__webpack_require__(166));
	exports.moduleName = 'rl.ui.services.autosaveDialog';
	angular.module(exports.moduleName, [__promise.moduleName, autosave_service_1.moduleName])
	    .service(autosaveDialog_service_1.serviceName, autosaveDialog_service_1.AutosaveDialogService)
	    .controller(autosaveDialog_controller_1.controllerName, autosaveDialog_controller_1.AutosaveDialogController);
	//# sourceMappingURL=autosaveDialog.module.js.map

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __promise = typescript_angular_utilities_1.services.promise;
	var dialog_service_1 = __webpack_require__(162);
	var autosave_service_1 = __webpack_require__(18);
	var autosaveDialog_controller_1 = __webpack_require__(166);
	exports.serviceName = 'autosaveDialog';
	var AutosaveDialogService = (function () {
	    function AutosaveDialogService($rootScope, dialog, autosaveFactory, promise) {
	        var _this = this;
	        this.$rootScope = $rootScope;
	        this.dialog = dialog;
	        this.autosaveFactory = autosaveFactory;
	        this.promise = promise;
	        this.autosaveCloseHandler = function (explicit) {
	            if (explicit) {
	                return true;
	            }
	            return _this.autosave.autosave(_this.data);
	        };
	        this.setForm = function (form) {
	            _this.autosave.contentForm = form;
	        };
	    }
	    AutosaveDialogService.prototype.open = function (options) {
	        var _this = this;
	        this.promise.resolvePromises(options.resolve).then(function (resolveData) {
	            var scope = options.scope;
	            if (scope == null) {
	                scope = _this.$rootScope.$new();
	                options.scope = scope;
	            }
	            if (options.data == null) {
	                options.data = {};
	            }
	            if (options.triggers == null) {
	                options.triggers = 'none';
	            }
	            _this.autosave = _this.autosaveFactory.getInstance({
	                save: options.save,
	                validate: options.validate,
	                triggers: options.triggers,
	            });
	            scope.form = options.form;
	            scope.formGetter = options.formGetter;
	            scope.setForm = _this.setForm;
	            _this.data = _.extend(options.data, resolveData);
	            scope.dialog = _this.data;
	            var dialogOptions = options;
	            dialogOptions.controller = autosaveDialog_controller_1.controllerName;
	            dialogOptions.controllerAs = 'controller';
	            _this.dialog.open(options, _this.autosaveCloseHandler);
	        });
	    };
	    AutosaveDialogService.$inject = ['$rootScope', dialog_service_1.serviceName, autosave_service_1.factoryName, __promise.serviceName];
	    return AutosaveDialogService;
	})();
	exports.AutosaveDialogService = AutosaveDialogService;
	//# sourceMappingURL=autosaveDialog.service.js.map

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ng = __webpack_require__(1);
	var baseDialog = __webpack_require__(163);
	exports.baseDialog = baseDialog;
	exports.moduleName = 'rl.ui.services.dialog';
	exports.serviceName = 'dialog';
	var DialogService = (function () {
	    function DialogService(dialog) {
	        this.dialog = dialog;
	    }
	    DialogService.prototype.open = function (options, closeHandler) {
	        return this.dialog.open(options, closeHandler);
	    };
	    return DialogService;
	})();
	exports.DialogService = DialogService;
	function dialogServiceProvider() {
	    'use strict';
	    var _this = this;
	    var provider = {
	        setImplementation: function (dialogImplementation) {
	            _this.dialogImplementation = dialogImplementation;
	        },
	        $get: function (baseDialog) {
	            var dialogImplementation = _this.dialogImplementation != null
	                ? _this.dialogImplementation
	                : baseDialog;
	            return new DialogService(dialogImplementation);
	        },
	    };
	    provider.$get.$inject = [baseDialog.serviceName];
	    return provider;
	}
	exports.dialogServiceProvider = dialogServiceProvider;
	ng.module(exports.moduleName, [baseDialog.moduleName])
	    .provider(exports.serviceName, dialogServiceProvider);
	//# sourceMappingURL=dialog.service.js.map

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __promise = typescript_angular_utilities_1.services.promise;
	var baseDialog_controller_1 = __webpack_require__(164);
	var baseDialog_service_1 = __webpack_require__(165);
	__export(__webpack_require__(164));
	__export(__webpack_require__(165));
	exports.moduleName = 'rl.ui.services.dialog.baseDialog';
	angular.module(exports.moduleName, [__promise.moduleName])
	    .controller(baseDialog_controller_1.controllerName, baseDialog_controller_1.BaseDialogController)
	    .service(baseDialog_service_1.serviceName, baseDialog_service_1.BaseDialogService);
	//# sourceMappingURL=baseDialog.module.js.map

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var baseDialog_service_1 = __webpack_require__(165);
	exports.controllerName = 'BaseDialogController';
	var BaseDialogController = (function () {
	    function BaseDialogController($scope, $controller, baseDialog) {
	        var controller;
	        if ($scope.modalController != null) {
	            var locals = $scope.resolveData || {};
	            $scope.resolveData = null;
	            locals.$scope = $scope;
	            controller = $controller($scope.modalController, locals);
	        }
	        $scope.$on('modal.closing', baseDialog.modalClosing);
	        return controller;
	    }
	    BaseDialogController.$inject = ['$scope', '$controller', baseDialog_service_1.serviceName];
	    return BaseDialogController;
	})();
	exports.BaseDialogController = BaseDialogController;
	//# sourceMappingURL=baseDialog.controller.js.map

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __promise = typescript_angular_utilities_1.services.promise;
	var baseDialog_controller_1 = __webpack_require__(164);
	exports.serviceName = 'baseDialog';
	var BaseDialogService = (function () {
	    function BaseDialogService($modal, $rootScope, promise) {
	        var _this = this;
	        this.$modal = $modal;
	        this.$rootScope = $rootScope;
	        this.promise = promise;
	        this.modalClosing = function (event, reason, explicitlyClosed) {
	            var canClose = true;
	            if (_.isFunction(_this.closeHandler)) {
	                canClose = _this.closeHandler(explicitlyClosed);
	            }
	            if (!canClose) {
	                event.preventDefault();
	            }
	        };
	    }
	    BaseDialogService.prototype.open = function (options, closeHandler) {
	        var _this = this;
	        if (options == null) {
	            options = {};
	        }
	        var dialogInstance = {
	            close: function () { },
	            dismiss: function () { },
	        };
	        this.promise.resolvePromises(options.resolve).then(function (results) {
	            _this.closeHandler = closeHandler;
	            options = _this.configureModalSettings(options, results);
	            var modalInstance = _this.$modal.open(options);
	            dialogInstance.close = modalInstance.close;
	            dialogInstance.dismiss = modalInstance.dismiss;
	        });
	        return dialogInstance;
	    };
	    BaseDialogService.prototype.configureModalSettings = function (options, resolveData) {
	        var modalScope = options.scope;
	        if (modalScope == null) {
	            modalScope = this.$rootScope.$new();
	        }
	        if (options.resolveToDialog) {
	            if (options.dialogAs != null) {
	                modalScope[options.dialogAs] = resolveData;
	            }
	            else {
	                modalScope = _.extend(modalScope, resolveData);
	            }
	        }
	        else {
	            modalScope.resolveData = resolveData;
	        }
	        modalScope.modalController = options.controller;
	        options.resolve = null;
	        options.controller = baseDialog_controller_1.controllerName;
	        options.scope = modalScope;
	        return options;
	    };
	    BaseDialogService.$inject = ['$modal', '$rootScope', __promise.serviceName];
	    return BaseDialogService;
	})();
	exports.BaseDialogService = BaseDialogService;
	//# sourceMappingURL=baseDialog.service.js.map

/***/ },
/* 166 */
/***/ function(module, exports) {

	'use strict';
	exports.controllerName = 'AutosaveDialogController';
	var AutosaveDialogController = (function () {
	    function AutosaveDialogController($scope) {
	        this.$scope = $scope;
	        if ($scope.form != null) {
	            var unbind = $scope.$watch($scope.form, function (form) {
	                if (form != null) {
	                    $scope.setForm(form);
	                    unbind();
	                }
	            });
	        }
	        else if ($scope.formGetter != null) {
	            var unbind = $scope.$watch(function () { return $scope.formGetter($scope); }, function (form) {
	                if (form != null) {
	                    $scope.setForm(form);
	                    unbind();
	                }
	            });
	        }
	    }
	    AutosaveDialogController.$inject = ['$scope'];
	    return AutosaveDialogController;
	})();
	exports.AutosaveDialogController = AutosaveDialogController;
	//# sourceMappingURL=autosaveDialog.controller.js.map

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var windowWrapper_service_1 = __webpack_require__(168);
	var visibleBreakpoint_service_1 = __webpack_require__(169);
	var breakpoints_service_1 = __webpack_require__(170);
	__export(__webpack_require__(43));
	__export(__webpack_require__(169));
	__export(__webpack_require__(170));
	exports.moduleName = 'rl.ui.services.breakpoints';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.observable.moduleName,
	    windowWrapper_service_1.moduleName,
	])
	    .constant('resizeDebounceMilliseconds', 500)
	    .service(visibleBreakpoint_service_1.visibleBreakpointServiceName, visibleBreakpoint_service_1.VisibleBreakpointService)
	    .service(breakpoints_service_1.breakpointServiceName, breakpoints_service_1.BreakpointService);
	//# sourceMappingURL=breakpoints.module.js.map

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(13);
	exports.moduleName = 'rl.ui.services.windowWrapper';
	exports.serviceName = 'windowWrapper';
	var WindowService = (function () {
	    function WindowService() {
	        this.windowControl = $(window);
	    }
	    WindowService.prototype.resize = function (callback) {
	        this.windowControl.resize(callback);
	    };
	    WindowService.prototype.scrollTop = function () {
	        return this.windowControl.scrollTop();
	    };
	    WindowService.prototype.scroll = function (handler) {
	        this.windowControl.scroll(handler);
	    };
	    WindowService.prototype.height = function () {
	        return this.windowControl.height();
	    };
	    return WindowService;
	})();
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, WindowService);
	//# sourceMappingURL=windowWrapper.service.js.map

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $ = __webpack_require__(13);
	/*
	 * Implementation also requires the following elements to be inserted on the page:
	 *   <div class="device-xs visible-xs"></div>
	 *   <div class="device-sm visible-sm"></div>
	 *   <div class="device-md visible-md"></div>
	 *   <div class="device-lg visible-lg"></div>
	 * They have been inserted into index.html for your convenience.
	 */
	exports.visibleBreakpointServiceName = 'visibleBreakpoint';
	var VisibleBreakpointService = (function () {
	    function VisibleBreakpointService() {
	    }
	    VisibleBreakpointService.prototype.isVisible = function (breakpoint) {
	        // jquery gets the breakpoint trigger directives listed above on line 3
	        return $('.device-' + breakpoint).is(':visible');
	    };
	    return VisibleBreakpointService;
	})();
	exports.VisibleBreakpointService = VisibleBreakpointService;
	//# sourceMappingURL=visibleBreakpoint.service.js.map

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var windowWrapper_service_1 = __webpack_require__(168);
	var visibleBreakpoint_service_1 = __webpack_require__(169);
	var breakpoint_1 = __webpack_require__(43);
	exports.breakpointServiceName = 'breakpoints';
	var __observable = typescript_angular_utilities_1.services.observable;
	var BreakpointService = (function () {
	    function BreakpointService($rootScope, visibleBreakpoints, resizeDebounceMilliseconds, windowService, observableFactory) {
	        var _this = this;
	        this.$rootScope = $rootScope;
	        this.visibleBreakpoints = visibleBreakpoints;
	        this.updateBreakpoint = function () {
	            var newBreakPoint = _this.getBreakpoint();
	            if (newBreakPoint !== _this.currentBreakpoint) {
	                _this.$rootScope.$apply(function () {
	                    _this.currentBreakpoint = newBreakPoint;
	                    _this.observable.fire('window.breakpointChanged', _this.currentBreakpoint);
	                });
	            }
	        };
	        this.currentBreakpoint = this.getBreakpoint();
	        this.observable = observableFactory.getInstance();
	        var efficientResize = _.debounce(this.updateBreakpoint, resizeDebounceMilliseconds, {
	            leading: true,
	            trailing: true,
	            maxWait: resizeDebounceMilliseconds,
	        });
	        windowService.resize(efficientResize);
	    }
	    BreakpointService.prototype.getBreakpoint = function () {
	        if (this.visibleBreakpoints.isVisible(breakpoint_1.lg)) {
	            return breakpoint_1.lg;
	        }
	        else if (this.visibleBreakpoints.isVisible(breakpoint_1.md)) {
	            return breakpoint_1.md;
	        }
	        else if (this.visibleBreakpoints.isVisible(breakpoint_1.sm)) {
	            return breakpoint_1.sm;
	        }
	        else {
	            return breakpoint_1.xs;
	        }
	    };
	    BreakpointService.prototype.isBreakpoint = function (breakpoint) {
	        return this.currentBreakpoint === breakpoint;
	    };
	    BreakpointService.prototype.register = function (action) {
	        return this.observable.register(action, 'window.breakpointChanged');
	    };
	    BreakpointService.$inject = ['$rootScope', visibleBreakpoint_service_1.visibleBreakpointServiceName, 'resizeDebounceMilliseconds', windowWrapper_service_1.serviceName, __observable.factoryName];
	    return BreakpointService;
	})();
	exports.BreakpointService = BreakpointService;
	//# sourceMappingURL=breakpoints.service.js.map

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path="../../../typings/jquery/jquery.d.ts" />
	'use strict';
	var ng = __webpack_require__(1);
	var _ = __webpack_require__(19);
	var typescript_angular_utilities_1 = __webpack_require__(6);
	var __observable = typescript_angular_utilities_1.services.observable;
	exports.moduleName = 'rl.utilities.services.contentProvider';
	exports.serviceName = 'contentProviderFactory';
	var ContentProviderService = (function () {
	    function ContentProviderService(observableFactory) {
	        var _this = this;
	        this.setTranscludeContent = function (transcludeFunction) {
	            if (_.isFunction(transcludeFunction)) {
	                transcludeFunction(function (clone) {
	                    _this.setContent(clone);
	                });
	            }
	            else {
	                _this.setContent(null);
	            }
	        };
	        this.observable = observableFactory.getInstance();
	    }
	    ContentProviderService.prototype.setContent = function (content) {
	        this.content = content;
	        this.observable.fire('contentChanged');
	    };
	    ContentProviderService.prototype.register = function (action, selector) {
	        var _this = this;
	        if (this.content != null) {
	            action(this.getContent(selector));
	        }
	        return this.observable.register(function () {
	            action(_this.getContent(selector));
	        }, 'contentChanged');
	    };
	    ContentProviderService.prototype.getContent = function (selector) {
	        if (selector != null) {
	            return this.content.filter(selector);
	        }
	        return this.content;
	    };
	    return ContentProviderService;
	})();
	contentProviderServiceFactory.$inject = [__observable.factoryName];
	function contentProviderServiceFactory(observableFactory) {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new ContentProviderService(observableFactory);
	        }
	    };
	}
	ng.module(exports.moduleName, [__observable.moduleName])
	    .factory(exports.serviceName, contentProviderServiceFactory);
	//# sourceMappingURL=contentProvider.service.js.map

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(13);
	exports.moduleName = 'rl.ui.services.documentWrapper';
	exports.serviceName = 'documentWrapper';
	var DocumentService = (function () {
	    function DocumentService() {
	        this.documentControl = $(document);
	    }
	    DocumentService.prototype.height = function () {
	        return this.documentControl.height();
	    };
	    return DocumentService;
	})();
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, DocumentService);
	//# sourceMappingURL=documentWrapper.service.js.map

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var viewData = __webpack_require__(174);
	exports.viewData = viewData;
	//# sourceMappingURL=types.module.js.map

/***/ },
/* 174 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=viewData.js.map

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMGI0NmViMGNhODc3Nzc2ZGNiMGIiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3VpLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhbmd1bGFyXCIiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyLXVpLWJvb3RzdHJhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhci1zYW5pdGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItc2FuaXRpemUvYW5ndWxhci1zYW5pdGl6ZS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJybF91dGlsaXRpZXNcIiIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL3NsaWRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL2Jvb3RzdHJhcC1zbGlkZXIubWluLmNzcz8wYzNlIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiJFwiIiwid2VicGFjazovLy8uL34vc2lnbmF0dXJlX3BhZC9zaWduYXR1cmVfcGFkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9iZWhhdmlvcnMvYmVoYXZpb3JzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvYmVoYXZpb3JzL2FsaWFzL2FsaWFzLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9iZWhhdmlvcnMvYXV0b3NhdmUvYXV0b3NhdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL2F1dG9zYXZlLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiX1wiIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZUFjdGlvbi9hdXRvc2F2ZUFjdGlvbi5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZS90cmlnZ2Vycy90cmlnZ2Vycy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZS90cmlnZ2Vycy9vbkNoYW5nZVRyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL3RyaWdnZXJzL3RyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY29tcG9uZW50cy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYXV0b3NhdmVEaWFsb2dGb290ZXIvYXV0b3NhdmVEaWFsb2dGb290ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYXV0b3NhdmVEaWFsb2dGb290ZXIvYXV0b3NhdmVEaWFsb2dGb290ZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXN5L2J1c3kuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnVzeS9idXN5LmNzcz85M2UwIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2J1c3kvYnVzeS5jc3MiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b24vYnV0dG9uLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uQXN5bmMvYnV0dG9uQXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uQXN5bmMvYnV0dG9uQXN5bmMuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25MaW5rL2J1dHRvbkxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uTGluay9idXR0b25MaW5rLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uVG9nZ2xlL2J1dHRvblRvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Ub2dnbGUvYnV0dG9uVG9nZ2xlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvY2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvaGVhZGVyQ29sdW1uL2hlYWRlckNvbHVtbi5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9oZWFkZXJDb2x1bW4uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9zaXplRm9yQnJlYWtwb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2NhcmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY29sdW1uSGVhZGVyL2NvbHVtbkhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnREaXJlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0cy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9tZXJnZVNvcnQvbWVyZ2VTb3J0LnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0ZXIvc29ydGVyLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVBhZ2VyL2RhdGFQYWdlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNlcnZpY2VEYXRhU291cmNlL2RhdGFTZXJ2aWNlRGF0YVNvdXJjZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNvdXJjZUJhc2Uuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL3NpbXBsZURhdGFTb3VyY2Uvc2ltcGxlRGF0YVNvdXJjZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvc2VydmVyU2VhcmNoRGF0YVNvdXJjZS9zZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJHcm91cC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlck9wdGlvbi9maWx0ZXJPcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlck9wdGlvbi9maWx0ZXJPcHRpb24uaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvbW9kZUZpbHRlckdyb3VwL21vZGVGaWx0ZXJHcm91cC5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJHcm91cC5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9yYW5nZUZpbHRlckdyb3VwL3JhbmdlRmlsdGVyR3JvdXAuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAuZGlyZWN0aXZlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJHcm91cC5kaXJlY3RpdmUuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL3NlbGVjdEZpbHRlci9zZWxlY3RGaWx0ZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL3NlbGVjdEZpbHRlci9zZWxlY3RGaWx0ZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2l0ZW1Db3VudC9pdGVtQ291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9pdGVtQ291bnQvaXRlbUNvdW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlci9wYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3BhZ2VyL3BhZ2VyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlU2l6ZS9wYWdlU2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3BhZ2VTaXplL3BhZ2VTaXplLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kZWZhdWx0Q2FyZENvbnRhaW5lckhlYWRlci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGVmYXVsdENhcmRDb250YWluZXJGb290ZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXJCdWlsZGVyLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jb2x1bW4uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2hlY2tib3gvY2hlY2tib3guanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2hlY2tib3gvY2hlY2tib3guaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jb21tYUxpc3QvY29tbWFMaXN0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2RhdGVUaW1lL2RhdGVUaW1lLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzPzYzNGUiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIm1vbWVudFwiIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvZGF0ZVRpbWUvZGF0ZVRpbWUuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9nZW5lcmljQ29udGFpbmVyL2dlbmVyaWNDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9sYXp5TG9hZC9sYXp5TG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9sb25nQ2xpY2tCdXR0b24vbG9uZ0NsaWNrQnV0dG9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2xvbmdDbGlja0J1dHRvbi9sb25nQ2xpY2tCdXR0b24uaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9tZXNzYWdlTG9nL21lc3NhZ2VMb2cubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5kaXJlY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9lZGl0YWJsZU1lc3NhZ2VMb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9tdWx0aVN0ZXBJbmRpY2F0b3IvbXVsdGlTdGVwSW5kaWNhdG9yLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8ubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JhZGlvL3JhZGlvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmF0aW5nQmFyL3JhdGluZ0Jhci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyQmFja2dyb3VuZHMuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyQ2xhc3Muc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L25nLXdpZy9kaXN0L2Nzcy9uZy13aWcuY3NzP2JmYjQiLCJ3ZWJwYWNrOi8vLy4vfi9uZy13aWcvZGlzdC9jc3Mvbmctd2lnLmNzcyIsIndlYnBhY2s6Ly8vLi9+L25nLXdpZy9kaXN0L25nLXdpZy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvaGVhZGVyQnV0dG9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3BhcmFncmFwaEJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuY3NzP2QyNzQiLCJ3ZWJwYWNrOi8vLy4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuY3NzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zaWduYXR1cmVQYWQvc2lnbmF0dXJlUGFkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmRMaXN0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zcGlubmVyL3NwaW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzPzRjNzEiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3N0cmluZ1dpdGhXYXRlcm1hcmsvc3RyaW5nV2l0aFdhdGVybWFyay5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90YWJzL3RhYnMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFiLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFiLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdGFicy90YWJzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdGFicy90YWJzZXQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0YXJlYS90ZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0YXJlYS90ZXh0YXJlYS5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3RleHRib3gvdGV4dGJveC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0Ym94L3RleHRib3guaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy91c2VyUmF0aW5nL3VzZXJSYXRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdmFsaWRhdGlvbkdyb3VwL3ZhbGlkYXRpb25Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy92YWxpZGF0aW9uR3JvdXAvdmFsaWRhdGlvbkdyb3VwLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL3NlcnZpY2VzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmVEaWFsb2cvYXV0b3NhdmVEaWFsb2cubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZURpYWxvZy9hdXRvc2F2ZURpYWxvZy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvZGlhbG9nLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9iYXNlRGlhbG9nL2Jhc2VEaWFsb2cubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvYmFzZURpYWxvZy9iYXNlRGlhbG9nLmNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9iYXNlRGlhbG9nL2Jhc2VEaWFsb2cuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmVEaWFsb2cvYXV0b3NhdmVEaWFsb2cuY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy93aW5kb3dXcmFwcGVyL3dpbmRvd1dyYXBwZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvdmlzaWJsZUJyZWFrcG9pbnQuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvY29udGVudFByb3ZpZGVyL2NvbnRlbnRQcm92aWRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9kb2N1bWVudFdyYXBwZXIvZG9jdW1lbnRXcmFwcGVyLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3R5cGVzL3R5cGVzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvdHlwZXMvdmlld0RhdGEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLHNCQUFxQiwrQkFB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RUFBMEU7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFFBQVE7O0FBRTdCLDJEQUEwRCxTQUFTOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCLGlCQUFpQjtBQUNoRDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLGtDQUFrQyxFQUFFLGNBQWMsa0NBQWtDLEVBQUU7QUFDdEg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUEsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiw4QkFBOEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFn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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxvSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDLG1DQUFrQyxXQUFXLEdBQUcsMEVBQTBFO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixhQUFhO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRLDRFQUE0RSx3REFBd0Q7QUFDdkosWUFBVyxRQUFRO0FBQ25CLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLHVFQUFzRSxnREFBZ0Q7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxvREFBb0Q7QUFDN0QsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLHNCQUFxQiw4QkFBOEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxRQUFPLDJCQUEyQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsUUFBTywyQkFBMkI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0RBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFdBQVc7QUFDdkIsYUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLCtDQUErQztBQUNqRSxtQkFBa0IsK0NBQStDOztBQUVqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsaUNBQWlDOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEOztBQUVBLEVBQUM7Ozs7Ozs7QUM5WEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCw0QkFBNEIsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsd0JBQXdCLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7O0FDL0VBLGNBQWEsNEJBQTRCLEVBQUUsSTs7Ozs7O0FDQTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsbUQ7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSw0Qzs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLG9DOzs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLDBDOzs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0M7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDJDOzs7Ozs7QUN6REE7QUFDQSxpQzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRDs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxtRDs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELGdEQUFnRCxFQUFFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRTtBQUMxRTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0Esd0Q7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRDs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFrRSxhQUFhO0FBQy9FLGlFQUFnRSxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRDs7Ozs7O0FDbkdBO0FBQ0EsdUM7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5RDs7Ozs7O0FDckpBO0FBQ0EsbUM7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDLDRDQUEyQzs7QUFFM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtB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O0FBQzFFLDhFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFdBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1YsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsV0FBVTtBQUNWO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQyxxQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTBELDBIQUEwSDtBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzTkFBcU47QUFDck47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDZFQUE0RSxrQkFBa0I7QUFDOUYsK0JBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLGdEQUFnRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsbWRBQW1kLHFxQkFBcXFCO0FBQ2xvQyxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEwRixFQUFFO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2YsWUFBVztBQUNYOztBQUVBO0FBQ0EscUNBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFGQUFvRjtBQUNwRixpRkFBZ0Y7QUFDaEYsMkdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBeUQ7QUFDekQsK0RBQThEO0FBQzlEO0FBQ0Esd0ZBQXVGLEVBQUU7QUFDekY7QUFDQTs7QUFFQTtBQUNBLDhEQUE2RDtBQUM3RCxtRUFBa0U7QUFDbEU7QUFDQSwwRkFBeUYsRUFBRTtBQUMzRjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFlLEtBQUs7O0FBRXBCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1R0FBc0c7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DLDBCQUEwQixFQUFFOztBQUUvRDs7QUFFQTtBQUNBLDJDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0Esb0RBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG1EQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxrREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1B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Q0Esb0xBQW1MLDRCQUE0Qiw4RDs7Ozs7O0FDQS9NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0Q7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsbUQ7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0Esa0Q7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxFQUFFO0FBQ2xDLG1DQUFrQyxFQUFFO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSwrQzs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLHFEQUFvRCxrQ0FBa0MsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLHNEOzs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDOzs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEOzs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxzRDs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsZ0Q7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EOzs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLG9EOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7OztBQ0hBO0FBQ0EscUMiLCJmaWxlIjoiY29tcG9uZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIm91dHB1dFwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMGI0NmViMGNhODc3Nzc2ZGNiMGJcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgKiBhcyBhbmd1bGFyIGZyb20gJ2FuZ3VsYXInO1xyXG5cclxuaW1wb3J0ICdhbmd1bGFyLXVpLWJvb3RzdHJhcCc7XHJcbmltcG9ydCAnYW5ndWxhci1zYW5pdGl6ZSc7XHJcblxyXG5pbXBvcnQgeyBuYW1lIGFzIHV0aWxpdGllc01vZHVsZSB9IGZyb20gJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnO1xyXG5cclxuaW1wb3J0ICcuLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL3NsaWRlcic7XHJcblxyXG5pbXBvcnQgJ3NpZ25hdHVyZV9wYWQnO1xyXG5cclxuaW1wb3J0ICogYXMgYmVoYXZpb3JzIGZyb20gJy4vYmVoYXZpb3JzL2JlaGF2aW9ycy5tb2R1bGUnO1xyXG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vY29tcG9uZW50cy9jb21wb25lbnRzLm1vZHVsZSc7XHJcbmltcG9ydCAqIGFzIHNlcnZpY2VzIGZyb20gJy4vc2VydmljZXMvc2VydmljZXMubW9kdWxlJztcclxuaW1wb3J0ICogYXMgdHlwZXMgZnJvbSAnLi90eXBlcy90eXBlcy5tb2R1bGUnO1xyXG5cclxuZXhwb3J0IHsgYmVoYXZpb3JzLCBjb21wb25lbnRzLCBzZXJ2aWNlcywgdHlwZXMgfTtcclxuXHJcbmV4cG9ydCB2YXIgbW9kdWxlTmFtZTogc3RyaW5nID0gJ3JsLnVpJztcclxuXHJcbmFuZ3VsYXIubW9kdWxlKG1vZHVsZU5hbWUsIFtcclxuXHQndWkuYm9vdHN0cmFwJyxcclxuXHQndWkuYm9vdHN0cmFwLXNsaWRlcicsXHJcblx0J25nU2FuaXRpemUnLFxyXG5cdHV0aWxpdGllc01vZHVsZSxcclxuXHJcblx0YmVoYXZpb3JzLm1vZHVsZU5hbWUsXHJcblx0Y29tcG9uZW50cy5tb2R1bGVOYW1lLFxyXG5cdHNlcnZpY2VzLm1vZHVsZU5hbWUsXHJcbl0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NvdXJjZS91aS5tb2R1bGUudHNcbiAqKi8iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcImFuZ3VsYXJcIl07IH0oKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImFuZ3VsYXJcIlxuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vdWktYm9vdHN0cmFwLXRwbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gJ3VpLmJvb3RzdHJhcCc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9hbmd1bGFyLXVpLWJvb3RzdHJhcC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBhbmd1bGFyLXVpLWJvb3RzdHJhcFxuICogaHR0cDovL2FuZ3VsYXItdWkuZ2l0aHViLmlvL2Jvb3RzdHJhcC9cblxuICogVmVyc2lvbjogMC4xMy40IC0gMjAxNS0wOS0wM1xuICogTGljZW5zZTogTUlUXG4gKi9cbmFuZ3VsYXIubW9kdWxlKFwidWkuYm9vdHN0cmFwXCIsIFtcInVpLmJvb3RzdHJhcC50cGxzXCIsIFwidWkuYm9vdHN0cmFwLmNvbGxhcHNlXCIsXCJ1aS5ib290c3RyYXAuYWNjb3JkaW9uXCIsXCJ1aS5ib290c3RyYXAuYWxlcnRcIixcInVpLmJvb3RzdHJhcC5iaW5kSHRtbFwiLFwidWkuYm9vdHN0cmFwLmJ1dHRvbnNcIixcInVpLmJvb3RzdHJhcC5jYXJvdXNlbFwiLFwidWkuYm9vdHN0cmFwLmRhdGVwYXJzZXJcIixcInVpLmJvb3RzdHJhcC5wb3NpdGlvblwiLFwidWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJcIixcInVpLmJvb3RzdHJhcC5kcm9wZG93blwiLFwidWkuYm9vdHN0cmFwLm1vZGFsXCIsXCJ1aS5ib290c3RyYXAucGFnaW5hdGlvblwiLFwidWkuYm9vdHN0cmFwLnRvb2x0aXBcIixcInVpLmJvb3RzdHJhcC5wb3BvdmVyXCIsXCJ1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXJcIixcInVpLmJvb3RzdHJhcC5yYXRpbmdcIixcInVpLmJvb3RzdHJhcC50YWJzXCIsXCJ1aS5ib290c3RyYXAudGltZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLnRyYW5zaXRpb25cIixcInVpLmJvb3RzdHJhcC50eXBlYWhlYWRcIl0pO1xuYW5ndWxhci5tb2R1bGUoXCJ1aS5ib290c3RyYXAudHBsc1wiLCBbXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIixcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbFwiLFwidGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLFwidGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFwiLFwidGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcIixcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcIixcInRlbXBsYXRlL2RhdGVwaWNrZXIvbW9udGguaHRtbFwiLFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFwiLFwidGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbFwiLFwidGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcIixcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnZXIuaHRtbFwiLFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcIixcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWxcIixcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXVuc2FmZS1wb3B1cC5odG1sXCIsXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcIixcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWxcIixcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS5odG1sXCIsXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIixcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcIixcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcIixcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFwidGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLFwidGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLFwidGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIixcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCJdKTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuY29sbGFwc2UnLCBbXSlcblxuICAuZGlyZWN0aXZlKCdjb2xsYXBzZScsIFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgZnVuY3Rpb24gZXhwYW5kKCkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG5cbiAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCAnaW4nLCB7XG4gICAgICAgICAgICB0bzogeyBoZWlnaHQ6IGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4JyB9XG4gICAgICAgICAgfSkudGhlbihleHBhbmREb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGFuZERvbmUoKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpO1xuICAgICAgICAgIGVsZW1lbnQuY3NzKHtoZWlnaHQ6ICdhdXRvJ30pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29sbGFwc2UoKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0NsYXNzKCdjb2xsYXBzZScpICYmICFlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGFwc2VEb25lKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBUaGUgaGVpZ2h0IG11c3QgYmUgc2V0IGJlZm9yZSBhZGRpbmcgXCJjb2xsYXBzaW5nXCIgY2xhc3MuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBicm93c2VyIGF0dGVtcHRzIHRvIGFuaW1hdGUgZnJvbSBoZWlnaHQgMCAoaW5cbiAgICAgICAgICAgIC8vIGNvbGxhcHNpbmcgY2xhc3MpIHRvIHRoZSBnaXZlbiBoZWlnaHQgaGVyZS5cbiAgICAgICAgICAgIC5jc3Moe2hlaWdodDogZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgKyAncHgnfSlcbiAgICAgICAgICAgIC8vIGluaXRpYWxseSBhbGwgcGFuZWwgY29sbGFwc2UgaGF2ZSB0aGUgY29sbGFwc2UgY2xhc3MsIHRoaXMgcmVtb3ZhbFxuICAgICAgICAgICAgLy8gcHJldmVudHMgdGhlIGFuaW1hdGlvbiBmcm9tIGp1bXBpbmcgdG8gY29sbGFwc2VkIHN0YXRlXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAgICAgICAkYW5pbWF0ZS5yZW1vdmVDbGFzcyhlbGVtZW50LCAnaW4nLCB7XG4gICAgICAgICAgICB0bzoge2hlaWdodDogJzAnfVxuICAgICAgICAgIH0pLnRoZW4oY29sbGFwc2VEb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbGxhcHNlRG9uZSgpIHtcbiAgICAgICAgICBlbGVtZW50LmNzcyh7aGVpZ2h0OiAnMCd9KTsgLy8gUmVxdWlyZWQgc28gdGhhdCBjb2xsYXBzZSB3b3JrcyB3aGVuIGFuaW1hdGlvbiBpcyBkaXNhYmxlZFxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKTtcbiAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdjb2xsYXBzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLmNvbGxhcHNlLCBmdW5jdGlvbihzaG91bGRDb2xsYXBzZSkge1xuICAgICAgICAgIGlmIChzaG91bGRDb2xsYXBzZSkge1xuICAgICAgICAgICAgY29sbGFwc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwYW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWNjb3JkaW9uJywgWyd1aS5ib290c3RyYXAuY29sbGFwc2UnXSlcblxuLmNvbnN0YW50KCdhY2NvcmRpb25Db25maWcnLCB7XG4gIGNsb3NlT3RoZXJzOiB0cnVlXG59KVxuXG4uY29udHJvbGxlcignQWNjb3JkaW9uQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICdhY2NvcmRpb25Db25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgYWNjb3JkaW9uQ29uZmlnKSB7XG4gIC8vIFRoaXMgYXJyYXkga2VlcHMgdHJhY2sgb2YgdGhlIGFjY29yZGlvbiBncm91cHNcbiAgdGhpcy5ncm91cHMgPSBbXTtcblxuICAvLyBFbnN1cmUgdGhhdCBhbGwgdGhlIGdyb3VwcyBpbiB0aGlzIGFjY29yZGlvbiBhcmUgY2xvc2VkLCB1bmxlc3MgY2xvc2Utb3RoZXJzIGV4cGxpY2l0bHkgc2F5cyBub3QgdG9cbiAgdGhpcy5jbG9zZU90aGVycyA9IGZ1bmN0aW9uKG9wZW5Hcm91cCkge1xuICAgIHZhciBjbG9zZU90aGVycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5jbG9zZU90aGVycykgP1xuICAgICAgJHNjb3BlLiRldmFsKCRhdHRycy5jbG9zZU90aGVycykgOiBhY2NvcmRpb25Db25maWcuY2xvc2VPdGhlcnM7XG4gICAgaWYgKGNsb3NlT3RoZXJzKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCAhPT0gb3Blbkdyb3VwKSB7XG4gICAgICAgICAgZ3JvdXAuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIHRvIGFkZCBpdHNlbGYgdG8gdGhlIGFjY29yZGlvblxuICB0aGlzLmFkZEdyb3VwID0gZnVuY3Rpb24oZ3JvdXBTY29wZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmdyb3Vwcy5wdXNoKGdyb3VwU2NvcGUpO1xuXG4gICAgZ3JvdXBTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoYXQucmVtb3ZlR3JvdXAoZ3JvdXBTY29wZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBjYWxsZWQgZnJvbSB0aGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSB3aGVuIHRvIHJlbW92ZSBpdHNlbGZcbiAgdGhpcy5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5ncm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH07XG5cbn1dKVxuXG4vLyBUaGUgYWNjb3JkaW9uIGRpcmVjdGl2ZSBzaW1wbHkgc2V0cyB1cCB0aGUgZGlyZWN0aXZlIGNvbnRyb2xsZXJcbi8vIGFuZCBhZGRzIGFuIGFjY29yZGlvbiBDU1MgY2xhc3MgdG8gaXRzZWxmIGVsZW1lbnQuXG4uZGlyZWN0aXZlKCdhY2NvcmRpb24nLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICBjb250cm9sbGVyOiAnQWNjb3JkaW9uQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnYWNjb3JkaW9uJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcGxhY2U6IGZhbHNlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWwnO1xuICAgIH1cbiAgfTtcbn0pXG5cbi8vIFRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIGluZGljYXRlcyBhIGJsb2NrIG9mIGh0bWwgdGhhdCB3aWxsIGV4cGFuZCBhbmQgY29sbGFwc2UgaW4gYW4gYWNjb3JkaW9uXG4uZGlyZWN0aXZlKCdhY2NvcmRpb25Hcm91cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdeYWNjb3JkaW9uJywgICAgICAgICAvLyBXZSBuZWVkIHRoaXMgZGlyZWN0aXZlIHRvIGJlIGluc2lkZSBhbiBhY2NvcmRpb25cbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLCAgICAgICAgICAgICAgLy8gSXQgdHJhbnNjbHVkZXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBkaXJlY3RpdmUgaW50byB0aGUgdGVtcGxhdGVcbiAgICByZXBsYWNlOiB0cnVlLCAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBkaXJlY3RpdmUgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSB0ZW1wbGF0ZVxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWwnO1xuICAgIH0sXG4gICAgc2NvcGU6IHtcbiAgICAgIGhlYWRpbmc6ICdAJywgICAgICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZSB0aGUgaGVhZGluZyBhdHRyaWJ1dGUgb250byB0aGlzIHNjb3BlXG4gICAgICBpc09wZW46ICc9PycsXG4gICAgICBpc0Rpc2FibGVkOiAnPT8nXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gZWxlbWVudDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGFjY29yZGlvbkN0cmwpIHtcbiAgICAgIGFjY29yZGlvbkN0cmwuYWRkR3JvdXAoc2NvcGUpO1xuXG4gICAgICBzY29wZS5vcGVuQ2xhc3MgPSBhdHRycy5vcGVuQ2xhc3MgfHwgJ3BhbmVsLW9wZW4nO1xuICAgICAgc2NvcGUucGFuZWxDbGFzcyA9IGF0dHJzLnBhbmVsQ2xhc3M7XG4gICAgICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3Moc2NvcGUub3BlbkNsYXNzLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGFjY29yZGlvbkN0cmwuY2xvc2VPdGhlcnMoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUudG9nZ2xlT3BlbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBpZiAoIXNjb3BlLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICBpZiAoISRldmVudCB8fCAkZXZlbnQud2hpY2ggPT09IDMyKSB7XG4gICAgICAgICAgICBzY29wZS5pc09wZW4gPSAhc2NvcGUuaXNPcGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59KVxuXG4vLyBVc2UgYWNjb3JkaW9uLWhlYWRpbmcgYmVsb3cgYW4gYWNjb3JkaW9uLWdyb3VwIHRvIHByb3ZpZGUgYSBoZWFkaW5nIGNvbnRhaW5pbmcgSFRNTFxuLy8gPGFjY29yZGlvbi1ncm91cD5cbi8vICAgPGFjY29yZGlvbi1oZWFkaW5nPkhlYWRpbmcgY29udGFpbmluZyBIVE1MIC0gPGltZyBzcmM9XCIuLi5cIj48L2FjY29yZGlvbi1oZWFkaW5nPlxuLy8gPC9hY2NvcmRpb24tZ3JvdXA+XG4uZGlyZWN0aXZlKCdhY2NvcmRpb25IZWFkaW5nJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSwgICAvLyBHcmFiIHRoZSBjb250ZW50cyB0byBiZSB1c2VkIGFzIHRoZSBoZWFkaW5nXG4gICAgdGVtcGxhdGU6ICcnLCAgICAgICAvLyBJbiBlZmZlY3QgcmVtb3ZlIHRoaXMgZWxlbWVudCFcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHJlcXVpcmU6ICdeYWNjb3JkaW9uR3JvdXAnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBhY2NvcmRpb25Hcm91cEN0cmwsIHRyYW5zY2x1ZGUpIHtcbiAgICAgIC8vIFBhc3MgdGhlIGhlYWRpbmcgdG8gdGhlIGFjY29yZGlvbi1ncm91cCBjb250cm9sbGVyXG4gICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSB0cmFuc2NsdWRlZCBpbnRvIHRoZSByaWdodCBwbGFjZSBpbiB0aGUgdGVtcGxhdGVcbiAgICAgIC8vIFtUaGUgc2Vjb25kIHBhcmFtZXRlciB0byB0cmFuc2NsdWRlIGNhdXNlcyB0aGUgZWxlbWVudHMgdG8gYmUgY2xvbmVkIHNvIHRoYXQgdGhleSB3b3JrIGluIG5nLXJlcGVhdF1cbiAgICAgIGFjY29yZGlvbkdyb3VwQ3RybC5zZXRIZWFkaW5nKHRyYW5zY2x1ZGUoc2NvcGUsIGFuZ3VsYXIubm9vcCkpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi8vIFVzZSBpbiB0aGUgYWNjb3JkaW9uLWdyb3VwIHRlbXBsYXRlIHRvIGluZGljYXRlIHdoZXJlIHlvdSB3YW50IHRoZSBoZWFkaW5nIHRvIGJlIHRyYW5zY2x1ZGVkXG4vLyBZb3UgbXVzdCBwcm92aWRlIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXIgdGhhdCB3aWxsIGhvbGQgdGhlIHRyYW5zY2x1ZGVkIGVsZW1lbnRcbi8vIDxkaXYgY2xhc3M9XCJhY2NvcmRpb24tZ3JvdXBcIj5cbi8vICAgPGRpdiBjbGFzcz1cImFjY29yZGlvbi1oZWFkaW5nXCIgPjxhIC4uLiBhY2NvcmRpb24tdHJhbnNjbHVkZT1cImhlYWRpbmdcIj4uLi48L2E+PC9kaXY+XG4vLyAgIC4uLlxuLy8gPC9kaXY+XG4uZGlyZWN0aXZlKCdhY2NvcmRpb25UcmFuc2NsdWRlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ15hY2NvcmRpb25Hcm91cCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGNvbnRyb2xsZXIpIHtcbiAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnRyb2xsZXJbYXR0ci5hY2NvcmRpb25UcmFuc2NsdWRlXTsgfSwgZnVuY3Rpb24oaGVhZGluZykge1xuICAgICAgICBpZiAoaGVhZGluZykge1xuICAgICAgICAgIGVsZW1lbnQuZmluZCgnc3BhbicpLmh0bWwoJycpO1xuICAgICAgICAgIGVsZW1lbnQuZmluZCgnc3BhbicpLmFwcGVuZChoZWFkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSlcblxuO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmFsZXJ0JywgW10pXG5cbi5jb250cm9sbGVyKCdBbGVydENvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycykge1xuICAkc2NvcGUuY2xvc2VhYmxlID0gISEkYXR0cnMuY2xvc2U7XG4gIHRoaXMuY2xvc2UgPSAkc2NvcGUuY2xvc2U7XG59XSlcblxuLmRpcmVjdGl2ZSgnYWxlcnQnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sbGVyOiAnQWxlcnRDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdhbGVydCcsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWwnO1xuICAgIH0sXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7XG4gICAgICB0eXBlOiAnQCcsXG4gICAgICBjbG9zZTogJyYnXG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgnZGlzbWlzc09uVGltZW91dCcsIFsnJHRpbWVvdXQnLCBmdW5jdGlvbigkdGltZW91dCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdhbGVydCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBhbGVydEN0cmwpIHtcbiAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBhbGVydEN0cmwuY2xvc2UoKTtcbiAgICAgIH0sIHBhcnNlSW50KGF0dHJzLmRpc21pc3NPblRpbWVvdXQsIDEwKSk7XG4gICAgfVxuICB9O1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmJpbmRIdG1sJywgW10pXG5cbiAgLnZhbHVlKCckYmluZEh0bWxVbnNhZmVTdXBwcmVzc0RlcHJlY2F0ZWQnLCBmYWxzZSlcblxuICAuZGlyZWN0aXZlKCdiaW5kSHRtbFVuc2FmZScsIFsnJGxvZycsICckYmluZEh0bWxVbnNhZmVTdXBwcmVzc0RlcHJlY2F0ZWQnLCBmdW5jdGlvbiAoJGxvZywgJGJpbmRIdG1sVW5zYWZlU3VwcHJlc3NEZXByZWNhdGVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cikge1xuICAgICAgaWYgKCEkYmluZEh0bWxVbnNhZmVTdXBwcmVzc0RlcHJlY2F0ZWQpIHtcbiAgICAgICAgJGxvZy53YXJuKCdiaW5kSHRtbFVuc2FmZSBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIG5nQmluZEh0bWwgaW5zdGVhZCcpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hZGRDbGFzcygnbmctYmluZGluZycpLmRhdGEoJyRiaW5kaW5nJywgYXR0ci5iaW5kSHRtbFVuc2FmZSk7XG4gICAgICBzY29wZS4kd2F0Y2goYXR0ci5iaW5kSHRtbFVuc2FmZSwgZnVuY3Rpb24gYmluZEh0bWxVbnNhZmVXYXRjaEFjdGlvbih2YWx1ZSkge1xuICAgICAgICBlbGVtZW50Lmh0bWwodmFsdWUgfHwgJycpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfV0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5idXR0b25zJywgW10pXG5cbi5jb25zdGFudCgnYnV0dG9uQ29uZmlnJywge1xuICBhY3RpdmVDbGFzczogJ2FjdGl2ZScsXG4gIHRvZ2dsZUV2ZW50OiAnY2xpY2snXG59KVxuXG4uY29udHJvbGxlcignQnV0dG9uc0NvbnRyb2xsZXInLCBbJ2J1dHRvbkNvbmZpZycsIGZ1bmN0aW9uKGJ1dHRvbkNvbmZpZykge1xuICB0aGlzLmFjdGl2ZUNsYXNzID0gYnV0dG9uQ29uZmlnLmFjdGl2ZUNsYXNzIHx8ICdhY3RpdmUnO1xuICB0aGlzLnRvZ2dsZUV2ZW50ID0gYnV0dG9uQ29uZmlnLnRvZ2dsZUV2ZW50IHx8ICdjbGljayc7XG59XSlcblxuLmRpcmVjdGl2ZSgnYnRuUmFkaW8nLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiBbJ2J0blJhZGlvJywgJ25nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnQnV0dG9uc0NvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2J1dHRvbnMnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBidXR0b25zQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBlbGVtZW50LmZpbmQoJ2lucHV0JykuY3NzKHtkaXNwbGF5OiAnbm9uZSd9KTtcblxuICAgICAgLy9tb2RlbCAtPiBVSVxuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LnRvZ2dsZUNsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzLCBhbmd1bGFyLmVxdWFscyhuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSwgc2NvcGUuJGV2YWwoYXR0cnMuYnRuUmFkaW8pKSk7XG4gICAgICB9O1xuXG4gICAgICAvL3VpLT5tb2RlbFxuICAgICAgZWxlbWVudC5iaW5kKGJ1dHRvbnNDdHJsLnRvZ2dsZUV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzQWN0aXZlID0gZWxlbWVudC5oYXNDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcyk7XG5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy51bmNoZWNrYWJsZSkpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGlzQWN0aXZlID8gbnVsbCA6IHNjb3BlLiRldmFsKGF0dHJzLmJ0blJhZGlvKSk7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ2J0bkNoZWNrYm94JywgWyckZG9jdW1lbnQnLCBmdW5jdGlvbigkZG9jdW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiBbJ2J0bkNoZWNrYm94JywgJ25nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnQnV0dG9uc0NvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2J1dHRvbicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIGJ1dHRvbnNDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGVsZW1lbnQuZmluZCgnaW5wdXQnKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuXG4gICAgICBmdW5jdGlvbiBnZXRUcnVlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGF0dHJzLmJ0bkNoZWNrYm94VHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZhbHNlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGF0dHJzLmJ0bkNoZWNrYm94RmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShhdHRyaWJ1dGVWYWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHZhciB2YWwgPSBzY29wZS4kZXZhbChhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZCh2YWwpID8gdmFsIDogZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvL21vZGVsIC0+IFVJXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBnZXRUcnVlVmFsdWUoKSkpO1xuICAgICAgfTtcblxuICAgICAgLy91aS0+bW9kZWxcbiAgICAgIGVsZW1lbnQuYmluZChidXR0b25zQ3RybC50b2dnbGVFdmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGVsZW1lbnQuaGFzQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MpID8gZ2V0RmFsc2VWYWx1ZSgpIDogZ2V0VHJ1ZVZhbHVlKCkpO1xuICAgICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy9hY2Nlc3NpYmlsaXR5XG4gICAgICBlbGVtZW50Lm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGVkIHx8IGUud2hpY2ggIT09IDMyIHx8ICRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ICE9PSBlbGVtZW50WzBdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZWxlbWVudC5oYXNDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcykgPyBnZXRGYWxzZVZhbHVlKCkgOiBnZXRUcnVlVmFsdWUoKSk7XG4gICAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyoqXG4qIEBuZ2RvYyBvdmVydmlld1xuKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWxcbipcbiogQGRlc2NyaXB0aW9uXG4qIEFuZ3VsYXJKUyB2ZXJzaW9uIG9mIGFuIGltYWdlIGNhcm91c2VsLlxuKlxuKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuY2Fyb3VzZWwnLCBbXSlcbi5jb250cm9sbGVyKCdDYXJvdXNlbENvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckaW50ZXJ2YWwnLCAnJGFuaW1hdGUnLCBmdW5jdGlvbiAoJHNjb3BlLCAkZWxlbWVudCwgJGludGVydmFsLCAkYW5pbWF0ZSkge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgc2xpZGVzID0gc2VsZi5zbGlkZXMgPSAkc2NvcGUuc2xpZGVzID0gW10sXG4gICAgTkVXX0FOSU1BVEUgPSBhbmd1bGFyLnZlcnNpb24ubWlub3IgPj0gNCxcbiAgICBOT19UUkFOU0lUSU9OID0gJ3VpYi1ub1RyYW5zaXRpb24nLFxuICAgIFNMSURFX0RJUkVDVElPTiA9ICd1aWItc2xpZGVEaXJlY3Rpb24nLFxuICAgIGN1cnJlbnRJbmRleCA9IC0xLFxuICAgIGN1cnJlbnRJbnRlcnZhbCwgaXNQbGF5aW5nO1xuICBzZWxmLmN1cnJlbnRTbGlkZSA9IG51bGw7XG5cbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICAvKiBkaXJlY3Rpb246IFwicHJldlwiIG9yIFwibmV4dFwiICovXG4gIHNlbGYuc2VsZWN0ID0gJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKG5leHRTbGlkZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG5leHRJbmRleCA9ICRzY29wZS5pbmRleE9mU2xpZGUobmV4dFNsaWRlKTtcbiAgICAvL0RlY2lkZSBkaXJlY3Rpb24gaWYgaXQncyBub3QgZ2l2ZW5cbiAgICBpZiAoZGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRpcmVjdGlvbiA9IG5leHRJbmRleCA+IHNlbGYuZ2V0Q3VycmVudEluZGV4KCkgPyAnbmV4dCcgOiAncHJldic7XG4gICAgfVxuICAgIC8vUHJldmVudCB0aGlzIHVzZXItdHJpZ2dlcmVkIHRyYW5zaXRpb24gZnJvbSBvY2N1cnJpbmcgaWYgdGhlcmUgaXMgYWxyZWFkeSBvbmUgaW4gcHJvZ3Jlc3NcbiAgICBpZiAobmV4dFNsaWRlICYmIG5leHRTbGlkZSAhPT0gc2VsZi5jdXJyZW50U2xpZGUgJiYgISRzY29wZS4kY3VycmVudFRyYW5zaXRpb24pIHtcbiAgICAgIGdvTmV4dChuZXh0U2xpZGUsIG5leHRJbmRleCwgZGlyZWN0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ29OZXh0KHNsaWRlLCBpbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgLy8gU2NvcGUgaGFzIGJlZW4gZGVzdHJveWVkLCBzdG9wIGhlcmUuXG4gICAgaWYgKGRlc3Ryb3llZCkgeyByZXR1cm47IH1cblxuICAgIGFuZ3VsYXIuZXh0ZW5kKHNsaWRlLCB7ZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGFjdGl2ZTogdHJ1ZX0pO1xuICAgIGFuZ3VsYXIuZXh0ZW5kKHNlbGYuY3VycmVudFNsaWRlIHx8IHt9LCB7ZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGFjdGl2ZTogZmFsc2V9KTtcbiAgICBpZiAoJGFuaW1hdGUuZW5hYmxlZCgpICYmICEkc2NvcGUubm9UcmFuc2l0aW9uICYmICEkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uICYmXG4gICAgICBzbGlkZS4kZWxlbWVudCAmJiBzZWxmLnNsaWRlcy5sZW5ndGggPiAxKSB7XG4gICAgICBzbGlkZS4kZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTiwgc2xpZGUuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChzZWxmLmN1cnJlbnRTbGlkZSAmJiBzZWxmLmN1cnJlbnRTbGlkZS4kZWxlbWVudCkge1xuICAgICAgICBzZWxmLmN1cnJlbnRTbGlkZS4kZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTiwgc2xpZGUuZGlyZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICBpZiAoTkVXX0FOSU1BVEUpIHtcbiAgICAgICAgJGFuaW1hdGUub24oJ2FkZENsYXNzJywgc2xpZGUuJGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtZW50LCBwaGFzZSkge1xuICAgICAgICAgIGlmIChwaGFzZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAkYW5pbWF0ZS5vZmYoJ2FkZENsYXNzJywgZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRlLiRlbGVtZW50Lm9uZSgnJGFuaW1hdGU6Y2xvc2UnLCBmdW5jdGlvbiBjbG9zZUZuKCkge1xuICAgICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmN1cnJlbnRTbGlkZSA9IHNsaWRlO1xuICAgIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuXG4gICAgLy9ldmVyeSB0aW1lIHlvdSBjaGFuZ2Ugc2xpZGVzLCByZXNldCB0aGUgdGltZXJcbiAgICByZXN0YXJ0VGltZXIoKTtcbiAgfVxuXG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldFNsaWRlQnlJbmRleChpbmRleCkge1xuICAgIGlmIChhbmd1bGFyLmlzVW5kZWZpbmVkKHNsaWRlc1tpbmRleF0uaW5kZXgpKSB7XG4gICAgICByZXR1cm4gc2xpZGVzW2luZGV4XTtcbiAgICB9XG4gICAgdmFyIGksIGxlbiA9IHNsaWRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHNsaWRlc1tpXS5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gc2xpZGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNlbGYuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuY3VycmVudFNsaWRlICYmIGFuZ3VsYXIuaXNEZWZpbmVkKHNlbGYuY3VycmVudFNsaWRlLmluZGV4KSkge1xuICAgICAgcmV0dXJuICtzZWxmLmN1cnJlbnRTbGlkZS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgfTtcblxuICAvKiBBbGxvdyBvdXRzaWRlIHBlb3BsZSB0byBjYWxsIGluZGV4T2Ygb24gc2xpZGVzIGFycmF5ICovXG4gICRzY29wZS5pbmRleE9mU2xpZGUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZChzbGlkZS5pbmRleCkgPyArc2xpZGUuaW5kZXggOiBzbGlkZXMuaW5kZXhPZihzbGlkZSk7XG4gIH07XG5cbiAgJHNjb3BlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3SW5kZXggPSAoc2VsZi5nZXRDdXJyZW50SW5kZXgoKSArIDEpICUgc2xpZGVzLmxlbmd0aDtcblxuICAgIGlmIChuZXdJbmRleCA9PT0gMCAmJiAkc2NvcGUubm9XcmFwKCkpIHtcbiAgICAgICRzY29wZS5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnNlbGVjdChnZXRTbGlkZUJ5SW5kZXgobmV3SW5kZXgpLCAnbmV4dCcpO1xuICB9O1xuXG4gICRzY29wZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gc2VsZi5nZXRDdXJyZW50SW5kZXgoKSAtIDEgPCAwID8gc2xpZGVzLmxlbmd0aCAtIDEgOiBzZWxmLmdldEN1cnJlbnRJbmRleCgpIC0gMTtcblxuICAgIGlmICgkc2NvcGUubm9XcmFwKCkgJiYgbmV3SW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKXtcbiAgICAgICRzY29wZS5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnNlbGVjdChnZXRTbGlkZUJ5SW5kZXgobmV3SW5kZXgpLCAncHJldicpO1xuICB9O1xuXG4gICRzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKHNsaWRlKSB7XG4gICAgIHJldHVybiBzZWxmLmN1cnJlbnRTbGlkZSA9PT0gc2xpZGU7XG4gIH07XG5cbiAgJHNjb3BlLiR3YXRjaCgnaW50ZXJ2YWwnLCByZXN0YXJ0VGltZXIpO1xuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIHJlc2V0VGltZXIpO1xuXG4gIGZ1bmN0aW9uIHJlc3RhcnRUaW1lcigpIHtcbiAgICByZXNldFRpbWVyKCk7XG4gICAgdmFyIGludGVydmFsID0gKyRzY29wZS5pbnRlcnZhbDtcbiAgICBpZiAoIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDApIHtcbiAgICAgIGN1cnJlbnRJbnRlcnZhbCA9ICRpbnRlcnZhbCh0aW1lckZuLCBpbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUaW1lcigpIHtcbiAgICBpZiAoY3VycmVudEludGVydmFsKSB7XG4gICAgICAkaW50ZXJ2YWwuY2FuY2VsKGN1cnJlbnRJbnRlcnZhbCk7XG4gICAgICBjdXJyZW50SW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRm4oKSB7XG4gICAgdmFyIGludGVydmFsID0gKyRzY29wZS5pbnRlcnZhbDtcbiAgICBpZiAoaXNQbGF5aW5nICYmICFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwICYmIHNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICRzY29wZS5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gICRzY29wZS5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpc1BsYXlpbmcpIHtcbiAgICAgIGlzUGxheWluZyA9IHRydWU7XG4gICAgICByZXN0YXJ0VGltZXIoKTtcbiAgICB9XG4gIH07XG4gICRzY29wZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vUGF1c2UpIHtcbiAgICAgIGlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgcmVzZXRUaW1lcigpO1xuICAgIH1cbiAgfTtcblxuICBzZWxmLmFkZFNsaWRlID0gZnVuY3Rpb24oc2xpZGUsIGVsZW1lbnQpIHtcbiAgICBzbGlkZS4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgc2xpZGVzLnB1c2goc2xpZGUpO1xuICAgIC8vaWYgdGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGUgb3IgdGhlIHNsaWRlIGlzIHNldCB0byBhY3RpdmUsIHNlbGVjdCBpdFxuICAgIGlmKHNsaWRlcy5sZW5ndGggPT09IDEgfHwgc2xpZGUuYWN0aXZlKSB7XG4gICAgICBzZWxmLnNlbGVjdChzbGlkZXNbc2xpZGVzLmxlbmd0aC0xXSk7XG4gICAgICBpZiAoc2xpZGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICRzY29wZS5wbGF5KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsaWRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBzZWxmLnJlbW92ZVNsaWRlID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoc2xpZGUuaW5kZXgpKSB7XG4gICAgICBzbGlkZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiArYS5pbmRleCA+ICtiLmluZGV4O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vZ2V0IHRoZSBpbmRleCBvZiB0aGUgc2xpZGUgaW5zaWRlIHRoZSBjYXJvdXNlbFxuICAgIHZhciBpbmRleCA9IHNsaWRlcy5pbmRleE9mKHNsaWRlKTtcbiAgICBzbGlkZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpZiAoc2xpZGVzLmxlbmd0aCA+IDAgJiYgc2xpZGUuYWN0aXZlKSB7XG4gICAgICBpZiAoaW5kZXggPj0gc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXgtMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50SW5kZXggPiBpbmRleCkge1xuICAgICAgY3VycmVudEluZGV4LS07XG4gICAgfVxuICAgIFxuICAgIC8vY2xlYW4gdGhlIGN1cnJlbnRTbGlkZSB3aGVuIG5vIG1vcmUgc2xpZGVcbiAgICBpZiAoc2xpZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5jdXJyZW50U2xpZGUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuJHdhdGNoKCdub1RyYW5zaXRpb24nLCBmdW5jdGlvbihub1RyYW5zaXRpb24pIHtcbiAgICAkZWxlbWVudC5kYXRhKE5PX1RSQU5TSVRJT04sIG5vVHJhbnNpdGlvbik7XG4gIH0pO1xuXG59XSlcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOmNhcm91c2VsXG4gKiBAcmVzdHJpY3QgRUFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENhcm91c2VsIGlzIHRoZSBvdXRlciBjb250YWluZXIgZm9yIGEgc2V0IG9mIGltYWdlICdzbGlkZXMnIHRvIHNob3djYXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaW50ZXJ2YWwgVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgdGhhdCBpdCB3aWxsIHRha2UgdGhlIGNhcm91c2VsIHRvIGdvIHRvIHRoZSBuZXh0IHNsaWRlLlxuICogQHBhcmFtIHtib29sZWFuPX0gbm9UcmFuc2l0aW9uIFdoZXRoZXIgdG8gZGlzYWJsZSB0cmFuc2l0aW9ucyBvbiB0aGUgY2Fyb3VzZWwuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub1BhdXNlIFdoZXRoZXIgdG8gZGlzYWJsZSBwYXVzaW5nIG9uIHRoZSBjYXJvdXNlbCAoYnkgZGVmYXVsdCwgdGhlIGNhcm91c2VsIGludGVydmFsIHBhdXNlcyBvbiBob3ZlcikuXG4gKlxuICogQGV4YW1wbGVcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgIDxjYXJvdXNlbD5cbiAgICAgIDxzbGlkZT5cbiAgICAgICAgPGltZyBzcmM9XCJodHRwOi8vcGxhY2VraXR0ZW4uY29tLzE1MC8xNTBcIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxuICAgICAgICAgIDxwPkJlYXV0aWZ1bCE8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9zbGlkZT5cbiAgICAgIDxzbGlkZT5cbiAgICAgICAgPGltZyBzcmM9XCJodHRwOi8vcGxhY2VraXR0ZW4uY29tLzEwMC8xNTBcIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxuICAgICAgICAgIDxwPkQnYXd3ITwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3NsaWRlPlxuICAgIDwvY2Fyb3VzZWw+XG4gIDwvZmlsZT5cbiAgPGZpbGUgbmFtZT1cImRlbW8uY3NzXCI+XG4gICAgLmNhcm91c2VsLWluZGljYXRvcnMge1xuICAgICAgdG9wOiBhdXRvO1xuICAgICAgYm90dG9tOiAxNXB4O1xuICAgIH1cbiAgPC9maWxlPlxuPC9leGFtcGxlPlxuICovXG4uZGlyZWN0aXZlKCdjYXJvdXNlbCcsIFtmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ0Nhcm91c2VsQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnY2Fyb3VzZWwnLFxuICAgIHJlcXVpcmU6ICdjYXJvdXNlbCcsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWwnO1xuICAgIH0sXG4gICAgc2NvcGU6IHtcbiAgICAgIGludGVydmFsOiAnPScsXG4gICAgICBub1RyYW5zaXRpb246ICc9JyxcbiAgICAgIG5vUGF1c2U6ICc9JyxcbiAgICAgIG5vV3JhcDogJyYnXG4gICAgfVxuICB9O1xufV0pXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkuYm9vdHN0cmFwLmNhcm91c2VsLmRpcmVjdGl2ZTpzbGlkZVxuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGEgc2xpZGUgaW5zaWRlIGEge0BsaW5rIHVpLmJvb3RzdHJhcC5jYXJvdXNlbC5kaXJlY3RpdmU6Y2Fyb3VzZWwgY2Fyb3VzZWx9LiAgTXVzdCBiZSBwbGFjZWQgYXMgYSBjaGlsZCBvZiBhIGNhcm91c2VsIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtib29sZWFuPX0gYWN0aXZlIE1vZGVsIGJpbmRpbmcsIHdoZXRoZXIgb3Igbm90IHRoaXMgc2xpZGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBzbGlkZS4gVGhlIHNsaWRlcyB3aWxsIGJlIHNvcnRlZCBieSB0aGlzIHBhcmFtZXRlci5cbiAqXG4gKiBAZXhhbXBsZVxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XG4gIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG48ZGl2IG5nLWNvbnRyb2xsZXI9XCJDYXJvdXNlbERlbW9DdHJsXCI+XG4gIDxjYXJvdXNlbD5cbiAgICA8c2xpZGUgbmctcmVwZWF0PVwic2xpZGUgaW4gc2xpZGVzXCIgYWN0aXZlPVwic2xpZGUuYWN0aXZlXCIgaW5kZXg9XCIkaW5kZXhcIj5cbiAgICAgIDxpbWcgbmctc3JjPVwie3tzbGlkZS5pbWFnZX19XCIgc3R5bGU9XCJtYXJnaW46YXV0bztcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XG4gICAgICAgIDxoND5TbGlkZSB7eyRpbmRleH19PC9oND5cbiAgICAgICAgPHA+e3tzbGlkZS50ZXh0fX08L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L3NsaWRlPlxuICA8L2Nhcm91c2VsPlxuICBJbnRlcnZhbCwgaW4gbWlsbGlzZWNvbmRzOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5nLW1vZGVsPVwibXlJbnRlcnZhbFwiPlxuICA8YnIgLz5FbnRlciBhIG5lZ2F0aXZlIG51bWJlciB0byBzdG9wIHRoZSBpbnRlcnZhbC5cbjwvZGl2PlxuICA8L2ZpbGU+XG4gIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbmZ1bmN0aW9uIENhcm91c2VsRGVtb0N0cmwoJHNjb3BlKSB7XG4gICRzY29wZS5teUludGVydmFsID0gNTAwMDtcbn1cbiAgPC9maWxlPlxuICA8ZmlsZSBuYW1lPVwiZGVtby5jc3NcIj5cbiAgICAuY2Fyb3VzZWwtaW5kaWNhdG9ycyB7XG4gICAgICB0b3A6IGF1dG87XG4gICAgICBib3R0b206IDE1cHg7XG4gICAgfVxuICA8L2ZpbGU+XG48L2V4YW1wbGU+XG4qL1xuXG4uZGlyZWN0aXZlKCdzbGlkZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdeY2Fyb3VzZWwnLFxuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgYWN0aXZlOiAnPT8nLFxuICAgICAgYWN0dWFsOiAnPT8nLFxuICAgICAgaW5kZXg6ICc9PydcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNhcm91c2VsQ3RybCkge1xuICAgICAgY2Fyb3VzZWxDdHJsLmFkZFNsaWRlKHNjb3BlLCBlbGVtZW50KTtcbiAgICAgIC8vd2hlbiB0aGUgc2NvcGUgaXMgZGVzdHJveWVkIHRoZW4gcmVtb3ZlIHRoZSBzbGlkZSBmcm9tIHRoZSBjdXJyZW50IHNsaWRlcyBhcnJheVxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYXJvdXNlbEN0cmwucmVtb3ZlU2xpZGUoc2NvcGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICBjYXJvdXNlbEN0cmwuc2VsZWN0KHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSlcblxuLmFuaW1hdGlvbignLml0ZW0nLCBbXG4gICAgICAgICAnJGluamVjdG9yJywgJyRhbmltYXRlJyxcbmZ1bmN0aW9uICgkaW5qZWN0b3IsICRhbmltYXRlKSB7XG4gIHZhciBOT19UUkFOU0lUSU9OID0gJ3VpYi1ub1RyYW5zaXRpb24nLFxuICAgIFNMSURFX0RJUkVDVElPTiA9ICd1aWItc2xpZGVEaXJlY3Rpb24nLFxuICAgICRhbmltYXRlQ3NzID0gbnVsbDtcblxuICBpZiAoJGluamVjdG9yLmhhcygnJGFuaW1hdGVDc3MnKSkge1xuICAgICRhbmltYXRlQ3NzID0gJGluamVjdG9yLmdldCgnJGFuaW1hdGVDc3MnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2FsbGJhY2spIHtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmVmb3JlQWRkQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHtcbiAgICAgIC8vIER1ZSB0byB0cmFuc2NsdXNpb24sIG5vVHJhbnNpdGlvbiBwcm9wZXJ0eSBpcyBvbiBwYXJlbnQncyBzY29wZVxuICAgICAgaWYgKGNsYXNzTmFtZSA9PSAnYWN0aXZlJyAmJiBlbGVtZW50LnBhcmVudCgpICYmXG4gICAgICAgICAgIWVsZW1lbnQucGFyZW50KCkuZGF0YShOT19UUkFOU0lUSU9OKSkge1xuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTik7XG4gICAgICAgIHZhciBkaXJlY3Rpb25DbGFzcyA9IGRpcmVjdGlvbiA9PSAnbmV4dCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB2YXIgcmVtb3ZlQ2xhc3NGbiA9IHJlbW92ZUNsYXNzLmJpbmQodGhpcywgZWxlbWVudCxcbiAgICAgICAgICBkaXJlY3Rpb25DbGFzcyArICcgJyArIGRpcmVjdGlvbiwgZG9uZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7YWRkQ2xhc3M6IGRpcmVjdGlvbkNsYXNzfSlcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuZG9uZShyZW1vdmVDbGFzc0ZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCBkaXJlY3Rpb25DbGFzcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9LFxuICAgIGJlZm9yZVJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lKSB7XG4gICAgICAvLyBEdWUgdG8gdHJhbnNjbHVzaW9uLCBub1RyYW5zaXRpb24gcHJvcGVydHkgaXMgb24gcGFyZW50J3Mgc2NvcGVcbiAgICAgIGlmIChjbGFzc05hbWUgPT09ICdhY3RpdmUnICYmIGVsZW1lbnQucGFyZW50KCkgJiZcbiAgICAgICAgICAhZWxlbWVudC5wYXJlbnQoKS5kYXRhKE5PX1RSQU5TSVRJT04pKSB7XG4gICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbkNsYXNzID0gZGlyZWN0aW9uID09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIHZhciByZW1vdmVDbGFzc0ZuID0gcmVtb3ZlQ2xhc3MuYmluZCh0aGlzLCBlbGVtZW50LCBkaXJlY3Rpb25DbGFzcywgZG9uZSk7XG5cbiAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge2FkZENsYXNzOiBkaXJlY3Rpb25DbGFzc30pXG4gICAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgICAgLmRvbmUocmVtb3ZlQ2xhc3NGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MoZWxlbWVudCwgZGlyZWN0aW9uQ2xhc3MpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzRm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfTtcblxufV0pXG5cblxuO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwYXJzZXInLCBbXSlcblxuLnNlcnZpY2UoJ2RhdGVQYXJzZXInLCBbJyRsb2cnLCAnJGxvY2FsZScsICdvcmRlckJ5RmlsdGVyJywgZnVuY3Rpb24oJGxvZywgJGxvY2FsZSwgb3JkZXJCeUZpbHRlcikge1xuICAvLyBQdWxsZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvYmxvYi9tYXN0ZXIvc3JjL2Zvcm1hdC9yZXF1b3RlLmpzXG4gIHZhciBTUEVDSUFMX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuXG4gIHRoaXMucGFyc2VycyA9IHt9O1xuXG4gIHZhciBmb3JtYXRDb2RlVG9SZWdleCA9IHtcbiAgICAneXl5eSc6IHtcbiAgICAgIHJlZ2V4OiAnXFxcXGR7NH0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMueWVhciA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ3l5Jzoge1xuICAgICAgcmVnZXg6ICdcXFxcZHsyfScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy55ZWFyID0gK3ZhbHVlICsgMjAwMDsgfVxuICAgIH0sXG4gICAgJ3knOiB7XG4gICAgICByZWdleDogJ1xcXFxkezEsNH0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMueWVhciA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ01NTU0nOiB7XG4gICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLk1PTlRILmpvaW4oJ3wnKSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLk1PTlRILmluZGV4T2YodmFsdWUpOyB9XG4gICAgfSxcbiAgICAnTU1NJzoge1xuICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5TSE9SVE1PTlRILmpvaW4oJ3wnKSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNIT1JUTU9OVEguaW5kZXhPZih2YWx1ZSk7IH1cbiAgICB9LFxuICAgICdNTSc6IHtcbiAgICAgIHJlZ2V4OiAnMFsxLTldfDFbMC0yXScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9IHZhbHVlIC0gMTsgfVxuICAgIH0sXG4gICAgJ00nOiB7XG4gICAgICByZWdleDogJ1sxLTldfDFbMC0yXScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9IHZhbHVlIC0gMTsgfVxuICAgIH0sXG4gICAgJ2RkJzoge1xuICAgICAgcmVnZXg6ICdbMC0yXVswLTldezF9fDNbMC0xXXsxfScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5kYXRlID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnZCc6IHtcbiAgICAgIHJlZ2V4OiAnWzEtMl0/WzAtOV17MX18M1swLTFdezF9JyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmRhdGUgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdFRUVFJzoge1xuICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5EQVkuam9pbignfCcpXG4gICAgfSxcbiAgICAnRUVFJzoge1xuICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5TSE9SVERBWS5qb2luKCd8JylcbiAgICB9LFxuICAgICdISCc6IHtcbiAgICAgIHJlZ2V4OiAnKD86MHwxKVswLTldfDJbMC0zXScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ2hoJzoge1xuICAgICAgcmVnZXg6ICcwWzAtOV18MVswLTJdJyxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnSCc6IHtcbiAgICAgIHJlZ2V4OiAnMT9bMC05XXwyWzAtM10nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdoJzoge1xuICAgICAgcmVnZXg6ICdbMC05XXwxWzAtMl0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH1cbiAgICB9LFxuICAgICdtbSc6IHtcbiAgICAgIHJlZ2V4OiAnWzAtNV1bMC05XScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taW51dGVzID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnbSc6IHtcbiAgICAgIHJlZ2V4OiAnWzAtOV18WzEtNV1bMC05XScsXG4gICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taW51dGVzID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnc3NzJzoge1xuICAgICAgcmVnZXg6ICdbMC05XVswLTldWzAtOV0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubWlsbGlzZWNvbmRzID0gK3ZhbHVlOyB9XG4gICAgfSxcbiAgICAnc3MnOiB7XG4gICAgICByZWdleDogJ1swLTVdWzAtOV0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuc2Vjb25kcyA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ3MnOiB7XG4gICAgICByZWdleDogJ1swLTldfFsxLTVdWzAtOV0nLFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuc2Vjb25kcyA9ICt2YWx1ZTsgfVxuICAgIH0sXG4gICAgJ2EnOiB7XG4gICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkFNUE1TLmpvaW4oJ3wnKSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5ob3VycyA9PT0gMTIpIHtcbiAgICAgICAgICB0aGlzLmhvdXJzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ1BNJykge1xuICAgICAgICAgIHRoaXMuaG91cnMgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGFyc2VyKGZvcm1hdCkge1xuICAgIHZhciBtYXAgPSBbXSwgcmVnZXggPSBmb3JtYXQuc3BsaXQoJycpO1xuXG4gICAgYW5ndWxhci5mb3JFYWNoKGZvcm1hdENvZGVUb1JlZ2V4LCBmdW5jdGlvbihkYXRhLCBjb2RlKSB7XG4gICAgICB2YXIgaW5kZXggPSBmb3JtYXQuaW5kZXhPZihjb2RlKTtcblxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNwbGl0KCcnKTtcblxuICAgICAgICByZWdleFtpbmRleF0gPSAnKCcgKyBkYXRhLnJlZ2V4ICsgJyknO1xuICAgICAgICBmb3JtYXRbaW5kZXhdID0gJyQnOyAvLyBDdXN0b20gc3ltYm9sIHRvIGRlZmluZSBjb25zdW1lZCBwYXJ0IG9mIGZvcm1hdFxuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxLCBuID0gaW5kZXggKyBjb2RlLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHJlZ2V4W2ldID0gJyc7XG4gICAgICAgICAgZm9ybWF0W2ldID0gJyQnO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5qb2luKCcnKTtcblxuICAgICAgICBtYXAucHVzaCh7IGluZGV4OiBpbmRleCwgYXBwbHk6IGRhdGEuYXBwbHkgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVnZXg6IG5ldyBSZWdFeHAoJ14nICsgcmVnZXguam9pbignJykgKyAnJCcpLFxuICAgICAgbWFwOiBvcmRlckJ5RmlsdGVyKG1hcCwgJ2luZGV4JylcbiAgICB9O1xuICB9XG5cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBmb3JtYXQsIGJhc2VEYXRlKSB7XG4gICAgaWYgKCFhbmd1bGFyLmlzU3RyaW5nKGlucHV0KSB8fCAhZm9ybWF0KSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTW2Zvcm1hdF0gfHwgZm9ybWF0O1xuICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFNQRUNJQUxfQ0hBUkFDVEVSU19SRUdFWFAsICdcXFxcJCYnKTtcblxuICAgIGlmICghdGhpcy5wYXJzZXJzW2Zvcm1hdF0pIHtcbiAgICAgIHRoaXMucGFyc2Vyc1tmb3JtYXRdID0gY3JlYXRlUGFyc2VyKGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IHRoaXMucGFyc2Vyc1tmb3JtYXRdLFxuICAgICAgICByZWdleCA9IHBhcnNlci5yZWdleCxcbiAgICAgICAgbWFwID0gcGFyc2VyLm1hcCxcbiAgICAgICAgcmVzdWx0cyA9IGlucHV0Lm1hdGNoKHJlZ2V4KTtcblxuICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZmllbGRzLCBkdDtcbiAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZShiYXNlRGF0ZSkgJiYgIWlzTmFOKGJhc2VEYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgZmllbGRzID0ge1xuICAgICAgICAgIHllYXI6IGJhc2VEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgbW9udGg6IGJhc2VEYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgZGF0ZTogYmFzZURhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgIGhvdXJzOiBiYXNlRGF0ZS5nZXRIb3VycygpLFxuICAgICAgICAgIG1pbnV0ZXM6IGJhc2VEYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgICBzZWNvbmRzOiBiYXNlRGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgICAgbWlsbGlzZWNvbmRzOiBiYXNlRGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJhc2VEYXRlKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCdkYXRlcGFyc2VyOicsICdiYXNlRGF0ZSBpcyBub3QgYSB2YWxpZCBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzID0geyB5ZWFyOiAxOTAwLCBtb250aDogMCwgZGF0ZTogMSwgaG91cnM6IDAsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbiA9IHJlc3VsdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBtYXBwZXIgPSBtYXBbaS0xXTtcbiAgICAgICAgaWYgKG1hcHBlci5hcHBseSkge1xuICAgICAgICAgIG1hcHBlci5hcHBseS5jYWxsKGZpZWxkcywgcmVzdWx0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzVmFsaWQoZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRhdGUpKSB7XG4gICAgICAgIGR0ID0gbmV3IERhdGUoZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRhdGUsXG4gICAgICAgICAgZmllbGRzLmhvdXJzLCBmaWVsZHMubWludXRlcywgZmllbGRzLnNlY29uZHMsXG4gICAgICAgICAgZmllbGRzLm1pbGxpc2Vjb25kcyB8fCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR0O1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGVjayBpZiBkYXRlIGlzIHZhbGlkIGZvciBzcGVjaWZpYyBtb250aCAoYW5kIHllYXIgZm9yIEZlYnJ1YXJ5KS5cbiAgLy8gTW9udGg6IDAgPSBKYW4sIDEgPSBGZWIsIGV0Y1xuICBmdW5jdGlvbiBpc1ZhbGlkKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gICAgaWYgKGRhdGUgPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG1vbnRoID09PSAxICYmIGRhdGUgPiAyOCkge1xuICAgICAgcmV0dXJuIGRhdGUgPT09IDI5ICYmICgoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKG1vbnRoID09PSAzIHx8IG1vbnRoID09PSA1IHx8IG1vbnRoID09PSA4IHx8IG1vbnRoID09PSAxMCkge1xuICAgICAgcmV0dXJuIGRhdGUgPCAzMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBvc2l0aW9uJywgW10pXG5cbi8qKlxuICogQSBzZXQgb2YgdXRpbGl0eSBtZXRob2RzIHRoYXQgY2FuIGJlIHVzZSB0byByZXRyaWV2ZSBwb3NpdGlvbiBvZiBET00gZWxlbWVudHMuXG4gKiBJdCBpcyBtZWFudCB0byBiZSB1c2VkIHdoZXJlIHdlIG5lZWQgdG8gYWJzb2x1dGUtcG9zaXRpb24gRE9NIGVsZW1lbnRzIGluXG4gKiByZWxhdGlvbiB0byBvdGhlciwgZXhpc3RpbmcgZWxlbWVudHMgKHRoaXMgaXMgdGhlIGNhc2UgZm9yIHRvb2x0aXBzLCBwb3BvdmVycyxcbiAqIHR5cGVhaGVhZCBzdWdnZXN0aW9ucyBldGMuKS5cbiAqL1xuICAuZmFjdG9yeSgnJHBvc2l0aW9uJywgWyckZG9jdW1lbnQnLCAnJHdpbmRvdycsIGZ1bmN0aW9uKCRkb2N1bWVudCwgJHdpbmRvdykge1xuICAgIGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBjc3Nwcm9wKSB7XG4gICAgICBpZiAoZWwuY3VycmVudFN0eWxlKSB7IC8vSUVcbiAgICAgICAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtjc3Nwcm9wXTtcbiAgICAgIH0gZWxzZSBpZiAoJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgIHJldHVybiAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpW2Nzc3Byb3BdO1xuICAgICAgfVxuICAgICAgLy8gZmluYWxseSB0cnkgYW5kIGdldCBpbmxpbmUgc3R5bGVcbiAgICAgIHJldHVybiBlbC5zdHlsZVtjc3Nwcm9wXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHN0YXRpY2FsbHkgcG9zaXRpb25lZFxuICAgICAqIEBwYXJhbSBlbGVtZW50IC0gcmF3IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAoZ2V0U3R5bGUoZWxlbWVudCwgJ3Bvc2l0aW9uJykgfHwgJ3N0YXRpYycgKSA9PT0gJ3N0YXRpYyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgY2xvc2VzdCwgbm9uLXN0YXRpY2FsbHkgcG9zaXRpb25lZCBwYXJlbnRPZmZzZXQgb2YgYSBnaXZlbiBlbGVtZW50XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICB2YXIgcGFyZW50T2Zmc2V0RWwgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgZG9jRG9tRWwgPSAkZG9jdW1lbnRbMF07XG4gICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgZG9jRG9tRWw7XG4gICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZG9jRG9tRWwgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgKSB7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0RvbUVsO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBwb3NpdGlvbiBmdW5jdGlvbjpcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9wb3NpdGlvbi9cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVsQkNSID0gdGhpcy5vZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRCQ1IgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50RWwgPSBwYXJlbnRPZmZzZXRFbChlbGVtZW50WzBdKTtcbiAgICAgICAgaWYgKG9mZnNldFBhcmVudEVsICE9ICRkb2N1bWVudFswXSkge1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUiA9IHRoaXMub2Zmc2V0KGFuZ3VsYXIuZWxlbWVudChvZmZzZXRQYXJlbnRFbCkpO1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUi50b3AgKz0gb2Zmc2V0UGFyZW50RWwuY2xpZW50VG9wIC0gb2Zmc2V0UGFyZW50RWwuc2Nyb2xsVG9wO1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUi5sZWZ0ICs9IG9mZnNldFBhcmVudEVsLmNsaWVudExlZnQgLSBvZmZzZXRQYXJlbnRFbC5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCB8fCBlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXG4gICAgICAgICAgdG9wOiBlbEJDUi50b3AgLSBvZmZzZXRQYXJlbnRCQ1IudG9wLFxuICAgICAgICAgIGxlZnQ6IGVsQkNSLmxlZnQgLSBvZmZzZXRQYXJlbnRCQ1IubGVmdFxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBvZmZzZXQgZnVuY3Rpb246XG4gICAgICAgKiBodHRwOi8vYXBpLmpxdWVyeS5jb20vb2Zmc2V0L1xuICAgICAgICovXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCB8fCBlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXG4gICAgICAgICAgdG9wOiBib3VuZGluZ0NsaWVudFJlY3QudG9wICsgKCR3aW5kb3cucGFnZVlPZmZzZXQgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgKCR3aW5kb3cucGFnZVhPZmZzZXQgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBjb29yZGluYXRlcyBmb3IgdGhlIHRhcmdldEVsIGluIHJlbGF0aW9uIHRvIGhvc3RFbFxuICAgICAgICovXG4gICAgICBwb3NpdGlvbkVsZW1lbnRzOiBmdW5jdGlvbihob3N0RWwsIHRhcmdldEVsLCBwb3NpdGlvblN0ciwgYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgIHZhciBwb3NpdGlvblN0clBhcnRzID0gcG9zaXRpb25TdHIuc3BsaXQoJy0nKTtcbiAgICAgICAgdmFyIHBvczAgPSBwb3NpdGlvblN0clBhcnRzWzBdLCBwb3MxID0gcG9zaXRpb25TdHJQYXJ0c1sxXSB8fCAnY2VudGVyJztcblxuICAgICAgICB2YXIgaG9zdEVsUG9zLFxuICAgICAgICAgIHRhcmdldEVsV2lkdGgsXG4gICAgICAgICAgdGFyZ2V0RWxIZWlnaHQsXG4gICAgICAgICAgdGFyZ2V0RWxQb3M7XG5cbiAgICAgICAgaG9zdEVsUG9zID0gYXBwZW5kVG9Cb2R5ID8gdGhpcy5vZmZzZXQoaG9zdEVsKSA6IHRoaXMucG9zaXRpb24oaG9zdEVsKTtcblxuICAgICAgICB0YXJnZXRFbFdpZHRoID0gdGFyZ2V0RWwucHJvcCgnb2Zmc2V0V2lkdGgnKTtcbiAgICAgICAgdGFyZ2V0RWxIZWlnaHQgPSB0YXJnZXRFbC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcblxuICAgICAgICB2YXIgc2hpZnRXaWR0aCA9IHtcbiAgICAgICAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvc3RFbFBvcy5sZWZ0ICsgaG9zdEVsUG9zLndpZHRoIC8gMiAtIHRhcmdldEVsV2lkdGggLyAyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLmxlZnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLmxlZnQgKyBob3N0RWxQb3Mud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzaGlmdEhlaWdodCA9IHtcbiAgICAgICAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvc3RFbFBvcy50b3AgKyBob3N0RWxQb3MuaGVpZ2h0IC8gMiAtIHRhcmdldEVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLnRvcDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvdHRvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLnRvcCArIGhvc3RFbFBvcy5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAocG9zMCkge1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHRhcmdldEVsUG9zID0ge1xuICAgICAgICAgICAgICB0b3A6IHNoaWZ0SGVpZ2h0W3BvczFdKCksXG4gICAgICAgICAgICAgIGxlZnQ6IHNoaWZ0V2lkdGhbcG9zMF0oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgdGFyZ2V0RWxQb3MgPSB7XG4gICAgICAgICAgICAgIHRvcDogc2hpZnRIZWlnaHRbcG9zMV0oKSxcbiAgICAgICAgICAgICAgbGVmdDogaG9zdEVsUG9zLmxlZnQgLSB0YXJnZXRFbFdpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHRhcmdldEVsUG9zID0ge1xuICAgICAgICAgICAgICB0b3A6IHNoaWZ0SGVpZ2h0W3BvczBdKCksXG4gICAgICAgICAgICAgIGxlZnQ6IHNoaWZ0V2lkdGhbcG9zMV0oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRFbFBvcyA9IHtcbiAgICAgICAgICAgICAgdG9wOiBob3N0RWxQb3MudG9wIC0gdGFyZ2V0RWxIZWlnaHQsXG4gICAgICAgICAgICAgIGxlZnQ6IHNoaWZ0V2lkdGhbcG9zMV0oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldEVsUG9zO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kYXRlcGlja2VyJywgWyd1aS5ib290c3RyYXAuZGF0ZXBhcnNlcicsICd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcblxuLnZhbHVlKCckZGF0ZXBpY2tlclN1cHByZXNzRXJyb3InLCBmYWxzZSlcblxuLmNvbnN0YW50KCdkYXRlcGlja2VyQ29uZmlnJywge1xuICBmb3JtYXREYXk6ICdkZCcsXG4gIGZvcm1hdE1vbnRoOiAnTU1NTScsXG4gIGZvcm1hdFllYXI6ICd5eXl5JyxcbiAgZm9ybWF0RGF5SGVhZGVyOiAnRUVFJyxcbiAgZm9ybWF0RGF5VGl0bGU6ICdNTU1NIHl5eXknLFxuICBmb3JtYXRNb250aFRpdGxlOiAneXl5eScsXG4gIGRhdGVwaWNrZXJNb2RlOiAnZGF5JyxcbiAgbWluTW9kZTogJ2RheScsXG4gIG1heE1vZGU6ICd5ZWFyJyxcbiAgc2hvd1dlZWtzOiB0cnVlLFxuICBzdGFydGluZ0RheTogMCxcbiAgeWVhclJhbmdlOiAyMCxcbiAgbWluRGF0ZTogbnVsbCxcbiAgbWF4RGF0ZTogbnVsbCxcbiAgc2hvcnRjdXRQcm9wYWdhdGlvbjogZmFsc2Vcbn0pXG5cbi5jb250cm9sbGVyKCdEYXRlcGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCAnJGludGVycG9sYXRlJywgJyRsb2cnLCAnZGF0ZUZpbHRlcicsICdkYXRlcGlja2VyQ29uZmlnJywgJyRkYXRlcGlja2VyU3VwcHJlc3NFcnJvcicsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSwgJGxvZywgZGF0ZUZpbHRlciwgZGF0ZXBpY2tlckNvbmZpZywgJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIG5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfTsgLy8gbnVsbE1vZGVsQ3RybDtcblxuICAvLyBNb2RlcyBjaGFpblxuICB0aGlzLm1vZGVzID0gWydkYXknLCAnbW9udGgnLCAneWVhciddO1xuXG4gIC8vIENvbmZpZ3VyYXRpb24gYXR0cmlidXRlc1xuICBhbmd1bGFyLmZvckVhY2goWydmb3JtYXREYXknLCAnZm9ybWF0TW9udGgnLCAnZm9ybWF0WWVhcicsICdmb3JtYXREYXlIZWFkZXInLCAnZm9ybWF0RGF5VGl0bGUnLCAnZm9ybWF0TW9udGhUaXRsZScsXG4gICAgICAgICAgICAgICAgICAgJ3Nob3dXZWVrcycsICdzdGFydGluZ0RheScsICd5ZWFyUmFuZ2UnLCAnc2hvcnRjdXRQcm9wYWdhdGlvbiddLCBmdW5jdGlvbihrZXksIGluZGV4KSB7XG4gICAgc2VsZltrZXldID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzW2tleV0pID8gKGluZGV4IDwgNiA/ICRpbnRlcnBvbGF0ZSgkYXR0cnNba2V5XSkoJHNjb3BlLiRwYXJlbnQpIDogJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzW2tleV0pKSA6IGRhdGVwaWNrZXJDb25maWdba2V5XTtcbiAgfSk7XG5cbiAgLy8gV2F0Y2hhYmxlIGRhdGUgYXR0cmlidXRlc1xuICBhbmd1bGFyLmZvckVhY2goWydtaW5EYXRlJywgJ21heERhdGUnXSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCRhdHRyc1trZXldKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRyc1trZXldKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2VsZltrZXldID0gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBudWxsO1xuICAgICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZltrZXldID0gZGF0ZXBpY2tlckNvbmZpZ1trZXldID8gbmV3IERhdGUoZGF0ZXBpY2tlckNvbmZpZ1trZXldKSA6IG51bGw7XG4gICAgfVxuICB9KTtcblxuICBhbmd1bGFyLmZvckVhY2goWydtaW5Nb2RlJywgJ21heE1vZGUnXSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCRhdHRyc1trZXldKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRyc1trZXldKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2VsZltrZXldID0gYW5ndWxhci5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiAkYXR0cnNba2V5XTtcbiAgICAgICAgJHNjb3BlW2tleV0gPSBzZWxmW2tleV07XG4gICAgICAgIGlmICgoa2V5ID09ICdtaW5Nb2RlJyAmJiBzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSA8IHNlbGYubW9kZXMuaW5kZXhPZihzZWxmW2tleV0pKSB8fCAoa2V5ID09ICdtYXhNb2RlJyAmJiBzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSA+IHNlbGYubW9kZXMuaW5kZXhPZihzZWxmW2tleV0pKSkge1xuICAgICAgICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IHNlbGZba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGZba2V5XSA9IGRhdGVwaWNrZXJDb25maWdba2V5XSB8fCBudWxsO1xuICAgICAgJHNjb3BlW2tleV0gPSBzZWxmW2tleV07XG4gICAgfVxuICB9KTtcblxuICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPSAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgfHwgZGF0ZXBpY2tlckNvbmZpZy5kYXRlcGlja2VyTW9kZTtcbiAgJHNjb3BlLnVuaXF1ZUlkID0gJ2RhdGVwaWNrZXItJyArICRzY29wZS4kaWQgKyAnLScgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG5cbiAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5pbml0RGF0ZSkpIHtcbiAgICB0aGlzLmFjdGl2ZURhdGUgPSAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuaW5pdERhdGUpIHx8IG5ldyBEYXRlKCk7XG4gICAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRhdHRycy5pbml0RGF0ZSwgZnVuY3Rpb24oaW5pdERhdGUpIHtcbiAgICAgIGlmIChpbml0RGF0ZSAmJiAobmdNb2RlbEN0cmwuJGlzRW1wdHkobmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUpIHx8IG5nTW9kZWxDdHJsLiRpbnZhbGlkKSkge1xuICAgICAgICBzZWxmLmFjdGl2ZURhdGUgPSBpbml0RGF0ZTtcbiAgICAgICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICAkc2NvcGUuaXNBY3RpdmUgPSBmdW5jdGlvbihkYXRlT2JqZWN0KSB7XG4gICAgaWYgKHNlbGYuY29tcGFyZShkYXRlT2JqZWN0LmRhdGUsIHNlbGYuYWN0aXZlRGF0ZSkgPT09IDApIHtcbiAgICAgICRzY29wZS5hY3RpdmVEYXRlSWQgPSBkYXRlT2JqZWN0LnVpZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfKSB7XG4gICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XG5cbiAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnJlbmRlcigpO1xuICAgIH07XG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSxcbiAgICAgICAgICBpc1ZhbGlkID0gIWlzTmFOKGRhdGUpO1xuXG4gICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgfSBlbHNlIGlmICghJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yKSB7XG4gICAgICAgICRsb2cuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMDEuMDEuMTk3MCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gUkZDMjgyMiBvciBJU08gODYwMSBkYXRlLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgdGhpcy5yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2hWaWV3KCk7XG5cbiAgICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIDogbnVsbDtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZGF0ZURpc2FibGVkJywgIWRhdGUgfHwgKHRoaXMuZWxlbWVudCAmJiAhdGhpcy5pc0Rpc2FibGVkKGRhdGUpKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY3JlYXRlRGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xuICAgIHZhciBtb2RlbCA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGU6IGRhdGUsXG4gICAgICBsYWJlbDogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQpLFxuICAgICAgc2VsZWN0ZWQ6IG1vZGVsICYmIHRoaXMuY29tcGFyZShkYXRlLCBtb2RlbCkgPT09IDAsXG4gICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkKGRhdGUpLFxuICAgICAgY3VycmVudDogdGhpcy5jb21wYXJlKGRhdGUsIG5ldyBEYXRlKCkpID09PSAwLFxuICAgICAgY3VzdG9tQ2xhc3M6IHRoaXMuY3VzdG9tQ2xhc3MoZGF0ZSlcbiAgICB9O1xuICB9O1xuXG4gIHRoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gKCh0aGlzLm1pbkRhdGUgJiYgdGhpcy5jb21wYXJlKGRhdGUsIHRoaXMubWluRGF0ZSkgPCAwKSB8fCAodGhpcy5tYXhEYXRlICYmIHRoaXMuY29tcGFyZShkYXRlLCB0aGlzLm1heERhdGUpID4gMCkgfHwgKCRhdHRycy5kYXRlRGlzYWJsZWQgJiYgJHNjb3BlLmRhdGVEaXNhYmxlZCh7ZGF0ZTogZGF0ZSwgbW9kZTogJHNjb3BlLmRhdGVwaWNrZXJNb2RlfSkpKTtcbiAgfTtcblxuICB0aGlzLmN1c3RvbUNsYXNzID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiAkc2NvcGUuY3VzdG9tQ2xhc3Moe2RhdGU6IGRhdGUsIG1vZGU6ICRzY29wZS5kYXRlcGlja2VyTW9kZX0pO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFycmF5IGludG8gc21hbGxlciBhcnJheXNcbiAgdGhpcy5zcGxpdCA9IGZ1bmN0aW9uKGFyciwgc2l6ZSkge1xuICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICAgIGFycmF5cy5wdXNoKGFyci5zcGxpY2UoMCwgc2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlzO1xuICB9O1xuXG4gIC8vIEZpeCBhIGhhcmQtcmVwcm9kdXNpYmxlIGJ1ZyB3aXRoIHRpbWV6b25lc1xuICAvLyBUaGUgYnVnIGRlcGVuZHMgb24gT1MsIGJyb3dzZXIsIGN1cnJlbnQgdGltZXpvbmUgYW5kIGN1cnJlbnQgZGF0ZVxuICAvLyBpLmUuXG4gIC8vIHZhciBkYXRlID0gbmV3IERhdGUoMjAxNCwgMCwgMSk7XG4gIC8vIGNvbnNvbGUubG9nKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRIb3VycygpKTtcbiAgLy8gY2FuIHJlc3VsdCBpbiBcIjIwMTMgMTEgMzEgMjNcIiBiZWNhdXNlIG9mIHRoZSBidWcuXG4gIHRoaXMuZml4VGltZVpvbmUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgIGRhdGUuc2V0SG91cnMoaG91cnMgPT09IDIzID8gaG91cnMgKyAyIDogMCk7XG4gIH07XG5cbiAgJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBpZiAoJHNjb3BlLmRhdGVwaWNrZXJNb2RlID09PSBzZWxmLm1pbk1vZGUpIHtcbiAgICAgIHZhciBkdCA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG5ldyBEYXRlKDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgZHQuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZHQpO1xuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gc2VsZi5tb2Rlc1tzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSAtIDFdO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUubW92ZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIHZhciB5ZWFyID0gc2VsZi5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkgKyBkaXJlY3Rpb24gKiAoc2VsZi5zdGVwLnllYXJzIHx8IDApLFxuICAgICAgICBtb250aCA9IHNlbGYuYWN0aXZlRGF0ZS5nZXRNb250aCgpICsgZGlyZWN0aW9uICogKHNlbGYuc3RlcC5tb250aHMgfHwgMCk7XG4gICAgc2VsZi5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoLCAxKTtcbiAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgJHNjb3BlLnRvZ2dsZU1vZGUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgMTtcblxuICAgIGlmICgoJHNjb3BlLmRhdGVwaWNrZXJNb2RlID09PSBzZWxmLm1heE1vZGUgJiYgZGlyZWN0aW9uID09PSAxKSB8fCAoJHNjb3BlLmRhdGVwaWNrZXJNb2RlID09PSBzZWxmLm1pbk1vZGUgJiYgZGlyZWN0aW9uID09PSAtMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPSBzZWxmLm1vZGVzW3NlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpICsgZGlyZWN0aW9uXTtcbiAgfTtcblxuICAvLyBLZXkgZXZlbnQgbWFwcGVyXG4gICRzY29wZS5rZXlzID0geyAxMzogJ2VudGVyJywgMzI6ICdzcGFjZScsIDMzOiAncGFnZXVwJywgMzQ6ICdwYWdlZG93bicsIDM1OiAnZW5kJywgMzY6ICdob21lJywgMzc6ICdsZWZ0JywgMzg6ICd1cCcsIDM5OiAncmlnaHQnLCA0MDogJ2Rvd24nIH07XG5cbiAgdmFyIGZvY3VzRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZWxlbWVudFswXS5mb2N1cygpO1xuICB9O1xuXG4gIC8vIExpc3RlbiBmb3IgZm9jdXMgcmVxdWVzdHMgZnJvbSBwb3B1cCBkaXJlY3RpdmVcbiAgJHNjb3BlLiRvbignZGF0ZXBpY2tlci5mb2N1cycsIGZvY3VzRWxlbWVudCk7XG5cbiAgJHNjb3BlLmtleWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIga2V5ID0gJHNjb3BlLmtleXNbZXZ0LndoaWNoXTtcblxuICAgIGlmICgha2V5IHx8IGV2dC5zaGlmdEtleSB8fCBldnQuYWx0S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFzZWxmLnNob3J0Y3V0UHJvcGFnYXRpb24pIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnZW50ZXInIHx8IGtleSA9PT0gJ3NwYWNlJykge1xuICAgICAgaWYgKHNlbGYuaXNEaXNhYmxlZChzZWxmLmFjdGl2ZURhdGUpKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZ1xuICAgICAgfVxuICAgICAgJHNjb3BlLnNlbGVjdChzZWxmLmFjdGl2ZURhdGUpO1xuICAgICAgZm9jdXNFbGVtZW50KCk7XG4gICAgfSBlbHNlIGlmIChldnQuY3RybEtleSAmJiAoa2V5ID09PSAndXAnIHx8IGtleSA9PT0gJ2Rvd24nKSkge1xuICAgICAgJHNjb3BlLnRvZ2dsZU1vZGUoa2V5ID09PSAndXAnID8gMSA6IC0xKTtcbiAgICAgIGZvY3VzRWxlbWVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmhhbmRsZUtleURvd24oa2V5LCBldnQpO1xuICAgICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdkYXRlcGlja2VyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWwnO1xuICAgIH0sXG4gICAgc2NvcGU6IHtcbiAgICAgIGRhdGVwaWNrZXJNb2RlOiAnPT8nLFxuICAgICAgZGF0ZURpc2FibGVkOiAnJicsXG4gICAgICBjdXN0b21DbGFzczogJyYnLFxuICAgICAgc2hvcnRjdXRQcm9wYWdhdGlvbjogJyY/J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydkYXRlcGlja2VyJywgJ15uZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ0RhdGVwaWNrZXJDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdkYXRlcGlja2VyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgZGF0ZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgZGF0ZXBpY2tlckN0cmwuaW5pdChuZ01vZGVsQ3RybCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgnZGF5cGlja2VyJywgWydkYXRlRmlsdGVyJywgZnVuY3Rpb24oZGF0ZUZpbHRlcikge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sJyxcbiAgICByZXF1aXJlOiAnXmRhdGVwaWNrZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCkge1xuICAgICAgc2NvcGUuc2hvd1dlZWtzID0gY3RybC5zaG93V2Vla3M7XG5cbiAgICAgIGN0cmwuc3RlcCA9IHsgbW9udGhzOiAxIH07XG4gICAgICBjdHJsLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICB2YXIgREFZU19JTl9NT05USCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbiAgICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiAoKG1vbnRoID09PSAxKSAmJiAoeWVhciAlIDQgPT09IDApICYmICgoeWVhciAlIDEwMCAhPT0gMCkgfHwgKHllYXIgJSA0MDAgPT09IDApKSkgPyAyOSA6IERBWVNfSU5fTU9OVEhbbW9udGhdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREYXRlcyhzdGFydERhdGUsIG4pIHtcbiAgICAgICAgdmFyIGRhdGVzID0gbmV3IEFycmF5KG4pLCBjdXJyZW50ID0gbmV3IERhdGUoc3RhcnREYXRlKSwgaSA9IDAsIGRhdGU7XG4gICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShjdXJyZW50KTtcbiAgICAgICAgICBjdHJsLmZpeFRpbWVab25lKGRhdGUpO1xuICAgICAgICAgIGRhdGVzW2krK10gPSBkYXRlO1xuICAgICAgICAgIGN1cnJlbnQuc2V0RGF0ZShjdXJyZW50LmdldERhdGUoKSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlcztcbiAgICAgIH1cblxuICAgICAgY3RybC5fcmVmcmVzaFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHllYXIgPSBjdHJsLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICBtb250aCA9IGN0cmwuYWN0aXZlRGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgIGZpcnN0RGF5T2ZNb250aCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKSxcbiAgICAgICAgICBkaWZmZXJlbmNlID0gY3RybC5zdGFydGluZ0RheSAtIGZpcnN0RGF5T2ZNb250aC5nZXREYXkoKSxcbiAgICAgICAgICBudW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aCA9IChkaWZmZXJlbmNlID4gMCkgPyA3IC0gZGlmZmVyZW5jZSA6IC0gZGlmZmVyZW5jZSxcbiAgICAgICAgICBmaXJzdERhdGUgPSBuZXcgRGF0ZShmaXJzdERheU9mTW9udGgpO1xuXG4gICAgICAgIGlmIChudW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aCA+IDApIHtcbiAgICAgICAgICBmaXJzdERhdGUuc2V0RGF0ZSgtbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQyIGlzIHRoZSBudW1iZXIgb2YgZGF5cyBvbiBhIHNpeC1tb250aCBjYWxlbmRhclxuICAgICAgICB2YXIgZGF5cyA9IGdldERhdGVzKGZpcnN0RGF0ZSwgNDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQyOyBpICsrKSB7XG4gICAgICAgICAgZGF5c1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKGN0cmwuY3JlYXRlRGF0ZU9iamVjdChkYXlzW2ldLCBjdHJsLmZvcm1hdERheSksIHtcbiAgICAgICAgICAgIHNlY29uZGFyeTogZGF5c1tpXS5nZXRNb250aCgpICE9PSBtb250aCxcbiAgICAgICAgICAgIHVpZDogc2NvcGUudW5pcXVlSWQgKyAnLScgKyBpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS5sYWJlbHMgPSBuZXcgQXJyYXkoNyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgICAgc2NvcGUubGFiZWxzW2pdID0ge1xuICAgICAgICAgICAgYWJicjogZGF0ZUZpbHRlcihkYXlzW2pdLmRhdGUsIGN0cmwuZm9ybWF0RGF5SGVhZGVyKSxcbiAgICAgICAgICAgIGZ1bGw6IGRhdGVGaWx0ZXIoZGF5c1tqXS5kYXRlLCAnRUVFRScpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLnRpdGxlID0gZGF0ZUZpbHRlcihjdHJsLmFjdGl2ZURhdGUsIGN0cmwuZm9ybWF0RGF5VGl0bGUpO1xuICAgICAgICBzY29wZS5yb3dzID0gY3RybC5zcGxpdChkYXlzLCA3KTtcblxuICAgICAgICBpZiAoc2NvcGUuc2hvd1dlZWtzKSB7XG4gICAgICAgICAgc2NvcGUud2Vla051bWJlcnMgPSBbXTtcbiAgICAgICAgICB2YXIgdGh1cnNkYXlJbmRleCA9ICg0ICsgNyAtIGN0cmwuc3RhcnRpbmdEYXkpICUgNyxcbiAgICAgICAgICAgICAgbnVtV2Vla3MgPSBzY29wZS5yb3dzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBjdXJXZWVrID0gMDsgY3VyV2VlayA8IG51bVdlZWtzOyBjdXJXZWVrKyspIHtcbiAgICAgICAgICAgIHNjb3BlLndlZWtOdW1iZXJzLnB1c2goXG4gICAgICAgICAgICAgIGdldElTTzg2MDFXZWVrTnVtYmVyKHNjb3BlLnJvd3NbY3VyV2Vla11bdGh1cnNkYXlJbmRleF0uZGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY3RybC5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiAobmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSwgZGF0ZTEuZ2V0RGF0ZSgpKSAtIG5ldyBEYXRlKGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCksIGRhdGUyLmdldERhdGUoKSkpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gZ2V0SVNPODYwMVdlZWtOdW1iZXIoZGF0ZSkge1xuICAgICAgICB2YXIgY2hlY2tEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgIGNoZWNrRGF0ZS5zZXREYXRlKGNoZWNrRGF0ZS5nZXREYXRlKCkgKyA0IC0gKGNoZWNrRGF0ZS5nZXREYXkoKSB8fCA3KSk7IC8vIFRodXJzZGF5XG4gICAgICAgIHZhciB0aW1lID0gY2hlY2tEYXRlLmdldFRpbWUoKTtcbiAgICAgICAgY2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcbiAgICAgICAgY2hlY2tEYXRlLnNldERhdGUoMSk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucm91bmQoKHRpbWUgLSBjaGVja0RhdGUpIC8gODY0MDAwMDApIC8gNykgKyAxO1xuICAgICAgfVxuXG4gICAgICBjdHJsLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihrZXksIGV2dCkge1xuICAgICAgICB2YXIgZGF0ZSA9IGN0cmwuYWN0aXZlRGF0ZS5nZXREYXRlKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgLSAxOyAgIC8vIHVwXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndXAnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgLSA3OyAgIC8vIGRvd25cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBkYXRlID0gZGF0ZSArIDE7ICAgLy8gZG93blxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgKyA3O1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3BhZ2V1cCcgfHwga2V5ID09PSAncGFnZWRvd24nKSB7XG4gICAgICAgICAgdmFyIG1vbnRoID0gY3RybC5hY3RpdmVEYXRlLmdldE1vbnRoKCkgKyAoa2V5ID09PSAncGFnZXVwJyA/IC0gMSA6IDEpO1xuICAgICAgICAgIGN0cmwuYWN0aXZlRGF0ZS5zZXRNb250aChtb250aCwgMSk7XG4gICAgICAgICAgZGF0ZSA9IE1hdGgubWluKGdldERheXNJbk1vbnRoKGN0cmwuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLCBjdHJsLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSksIGRhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2hvbWUnKSB7XG4gICAgICAgICAgZGF0ZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuICAgICAgICAgIGRhdGUgPSBnZXREYXlzSW5Nb250aChjdHJsLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSwgY3RybC5hY3RpdmVEYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGN0cmwuYWN0aXZlRGF0ZS5zZXREYXRlKGRhdGUpO1xuICAgICAgfTtcblxuICAgICAgY3RybC5yZWZyZXNoVmlldygpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdtb250aHBpY2tlcicsIFsnZGF0ZUZpbHRlcicsIGZ1bmN0aW9uKGRhdGVGaWx0ZXIpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sJyxcbiAgICByZXF1aXJlOiAnXmRhdGVwaWNrZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCkge1xuICAgICAgY3RybC5zdGVwID0geyB5ZWFyczogMSB9O1xuICAgICAgY3RybC5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgY3RybC5fcmVmcmVzaFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vbnRocyA9IG5ldyBBcnJheSgxMiksXG4gICAgICAgICAgICB5ZWFyID0gY3RybC5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBpLCAxKTtcbiAgICAgICAgICBjdHJsLmZpeFRpbWVab25lKGRhdGUpO1xuICAgICAgICAgIG1vbnRoc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKGN0cmwuY3JlYXRlRGF0ZU9iamVjdChkYXRlLCBjdHJsLmZvcm1hdE1vbnRoKSwge1xuICAgICAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLnRpdGxlID0gZGF0ZUZpbHRlcihjdHJsLmFjdGl2ZURhdGUsIGN0cmwuZm9ybWF0TW9udGhUaXRsZSk7XG4gICAgICAgIHNjb3BlLnJvd3MgPSBjdHJsLnNwbGl0KG1vbnRocywgMyk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUxLmdldEZ1bGxZZWFyKCksIGRhdGUxLmdldE1vbnRoKCkpIC0gbmV3IERhdGUoZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihrZXksIGV2dCkge1xuICAgICAgICB2YXIgZGF0ZSA9IGN0cmwuYWN0aXZlRGF0ZS5nZXRNb250aCgpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGRhdGUgPSBkYXRlIC0gMTsgICAvLyB1cFxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xuICAgICAgICAgIGRhdGUgPSBkYXRlIC0gMzsgICAvLyBkb3duXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgKyAxOyAgIC8vIGRvd25cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdkb3duJykge1xuICAgICAgICAgIGRhdGUgPSBkYXRlICsgMztcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xuICAgICAgICAgIHZhciB5ZWFyID0gY3RybC5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkgKyAoa2V5ID09PSAncGFnZXVwJyA/IC0gMSA6IDEpO1xuICAgICAgICAgIGN0cmwuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdob21lJykge1xuICAgICAgICAgIGRhdGUgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICBkYXRlID0gMTE7XG4gICAgICAgIH1cbiAgICAgICAgY3RybC5hY3RpdmVEYXRlLnNldE1vbnRoKGRhdGUpO1xuICAgICAgfTtcblxuICAgICAgY3RybC5yZWZyZXNoVmlldygpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd5ZWFycGlja2VyJywgWydkYXRlRmlsdGVyJywgZnVuY3Rpb24oZGF0ZUZpbHRlcikge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbCcsXG4gICAgcmVxdWlyZTogJ15kYXRlcGlja2VyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmwpIHtcbiAgICAgIHZhciByYW5nZSA9IGN0cmwueWVhclJhbmdlO1xuXG4gICAgICBjdHJsLnN0ZXAgPSB7IHllYXJzOiByYW5nZSB9O1xuICAgICAgY3RybC5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgZnVuY3Rpb24gZ2V0U3RhcnRpbmdZZWFyKCB5ZWFyICkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoKHllYXIgLSAxKSAvIHJhbmdlLCAxMCkgKiByYW5nZSArIDE7XG4gICAgICB9XG5cbiAgICAgIGN0cmwuX3JlZnJlc2hWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ZWFycyA9IG5ldyBBcnJheShyYW5nZSksIGRhdGU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHN0YXJ0ID0gZ2V0U3RhcnRpbmdZZWFyKGN0cmwuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpKTsgaSA8IHJhbmdlOyBpKyspIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUoc3RhcnQgKyBpLCAwLCAxKTtcbiAgICAgICAgICBjdHJsLmZpeFRpbWVab25lKGRhdGUpO1xuICAgICAgICAgIHllYXJzW2ldID0gYW5ndWxhci5leHRlbmQoY3RybC5jcmVhdGVEYXRlT2JqZWN0KGRhdGUsIGN0cmwuZm9ybWF0WWVhciksIHtcbiAgICAgICAgICAgIHVpZDogc2NvcGUudW5pcXVlSWQgKyAnLScgKyBpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS50aXRsZSA9IFt5ZWFyc1swXS5sYWJlbCwgeWVhcnNbcmFuZ2UgLSAxXS5sYWJlbF0uam9pbignIC0gJyk7XG4gICAgICAgIHNjb3BlLnJvd3MgPSBjdHJsLnNwbGl0KHllYXJzLCA1KTtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwuY29tcGFyZSA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gZGF0ZTEuZ2V0RnVsbFllYXIoKSAtIGRhdGUyLmdldEZ1bGxZZWFyKCk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihrZXksIGV2dCkge1xuICAgICAgICB2YXIgZGF0ZSA9IGN0cmwuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGRhdGUgPSBkYXRlIC0gMTsgICAvLyB1cFxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xuICAgICAgICAgIGRhdGUgPSBkYXRlIC0gNTsgICAvLyBkb3duXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgZGF0ZSA9IGRhdGUgKyAxOyAgIC8vIGRvd25cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdkb3duJykge1xuICAgICAgICAgIGRhdGUgPSBkYXRlICsgNTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xuICAgICAgICAgIGRhdGUgKz0gKGtleSA9PT0gJ3BhZ2V1cCcgPyAtIDEgOiAxKSAqIGN0cmwuc3RlcC55ZWFycztcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdob21lJykge1xuICAgICAgICAgIGRhdGUgPSBnZXRTdGFydGluZ1llYXIoY3RybC5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICBkYXRlID0gZ2V0U3RhcnRpbmdZZWFyKGN0cmwuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpKSArIHJhbmdlIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdHJsLmFjdGl2ZURhdGUuc2V0RnVsbFllYXIoZGF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb25zdGFudCgnZGF0ZXBpY2tlclBvcHVwQ29uZmlnJywge1xuICBkYXRlcGlja2VyUG9wdXA6ICd5eXl5LU1NLWRkJyxcbiAgZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWwnLFxuICBkYXRlcGlja2VyVGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbCcsXG4gIGh0bWw1VHlwZXM6IHtcbiAgICBkYXRlOiAneXl5eS1NTS1kZCcsXG4gICAgJ2RhdGV0aW1lLWxvY2FsJzogJ3l5eXktTU0tZGRUSEg6bW06c3Muc3NzJyxcbiAgICAnbW9udGgnOiAneXl5eS1NTSdcbiAgfSxcbiAgY3VycmVudFRleHQ6ICdUb2RheScsXG4gIGNsZWFyVGV4dDogJ0NsZWFyJyxcbiAgY2xvc2VUZXh0OiAnRG9uZScsXG4gIGNsb3NlT25EYXRlU2VsZWN0aW9uOiB0cnVlLFxuICBhcHBlbmRUb0JvZHk6IGZhbHNlLFxuICBzaG93QnV0dG9uQmFyOiB0cnVlLFxuICBvbk9wZW5Gb2N1czogdHJ1ZVxufSlcblxuLmRpcmVjdGl2ZSgnZGF0ZXBpY2tlclBvcHVwJywgWyckY29tcGlsZScsICckcGFyc2UnLCAnJGRvY3VtZW50JywgJyRyb290U2NvcGUnLCAnJHBvc2l0aW9uJywgJ2RhdGVGaWx0ZXInLCAnZGF0ZVBhcnNlcicsICdkYXRlcGlja2VyUG9wdXBDb25maWcnLCAnJHRpbWVvdXQnLFxuZnVuY3Rpb24oJGNvbXBpbGUsICRwYXJzZSwgJGRvY3VtZW50LCAkcm9vdFNjb3BlLCAkcG9zaXRpb24sIGRhdGVGaWx0ZXIsIGRhdGVQYXJzZXIsIGRhdGVwaWNrZXJQb3B1cENvbmZpZywgJHRpbWVvdXQpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgc2NvcGU6IHtcbiAgICAgIGlzT3BlbjogJz0/JyxcbiAgICAgIGN1cnJlbnRUZXh0OiAnQCcsXG4gICAgICBjbGVhclRleHQ6ICdAJyxcbiAgICAgIGNsb3NlVGV4dDogJ0AnLFxuICAgICAgZGF0ZURpc2FibGVkOiAnJicsXG4gICAgICBjdXN0b21DbGFzczogJyYnXG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcbiAgICAgIHZhciBkYXRlRm9ybWF0LFxuICAgICAgICAgIGNsb3NlT25EYXRlU2VsZWN0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5jbG9zZU9uRGF0ZVNlbGVjdGlvbikgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuY2xvc2VPbkRhdGVTZWxlY3Rpb24sXG4gICAgICAgICAgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZGF0ZXBpY2tlckFwcGVuZFRvQm9keSkgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmFwcGVuZFRvQm9keSxcbiAgICAgICAgICBvbk9wZW5Gb2N1cyA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLm9uT3BlbkZvY3VzKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMub25PcGVuRm9jdXMpIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLm9uT3BlbkZvY3VzLFxuICAgICAgICAgIGRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwpID8gYXR0cnMuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwsXG4gICAgICAgICAgZGF0ZXBpY2tlclRlbXBsYXRlVXJsID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZGF0ZXBpY2tlclRlbXBsYXRlVXJsKSA/IGF0dHJzLmRhdGVwaWNrZXJUZW1wbGF0ZVVybCA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlcGlja2VyVGVtcGxhdGVVcmwsXG4gICAgICAgICAgY2FjaGUgPSB7fTtcblxuICAgICAgc2NvcGUuc2hvd0J1dHRvbkJhciA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnNob3dCdXR0b25CYXIpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5zaG93QnV0dG9uQmFyKSA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5zaG93QnV0dG9uQmFyO1xuXG4gICAgICBzY29wZS5nZXRUZXh0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBzY29wZVtrZXkgKyAnVGV4dCddIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZ1trZXkgKyAnVGV4dCddO1xuICAgICAgfTtcblxuICAgICAgc2NvcGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUgPT09ICd0b2RheScpIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKHNjb3BlLndhdGNoRGF0YS5taW5EYXRlICYmIHNjb3BlLmNvbXBhcmUoZGF0ZSwgY2FjaGUubWluRGF0ZSkgPCAwKSB8fFxuICAgICAgICAgIChzY29wZS53YXRjaERhdGEubWF4RGF0ZSAmJiBzY29wZS5jb21wYXJlKGRhdGUsIGNhY2hlLm1heERhdGUpID4gMCkpO1xuICAgICAgfTtcblxuICAgICAgc2NvcGUuY29tcGFyZSA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKGRhdGUxLmdldEZ1bGxZZWFyKCksIGRhdGUxLmdldE1vbnRoKCksIGRhdGUxLmdldERhdGUoKSkgLSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCBkYXRlMi5nZXRNb250aCgpLCBkYXRlMi5nZXREYXRlKCkpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBpc0h0bWw1RGF0ZUlucHV0ID0gZmFsc2U7XG4gICAgICBpZiAoZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmh0bWw1VHlwZXNbYXR0cnMudHlwZV0pIHtcbiAgICAgICAgZGF0ZUZvcm1hdCA9IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5odG1sNVR5cGVzW2F0dHJzLnR5cGVdO1xuICAgICAgICBpc0h0bWw1RGF0ZUlucHV0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGVGb3JtYXQgPSBhdHRycy5kYXRlcGlja2VyUG9wdXAgfHwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJQb3B1cDtcbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2RhdGVwaWNrZXJQb3B1cCcsIGZ1bmN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5ld0RhdGVGb3JtYXQgPSB2YWx1ZSB8fCBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclBvcHVwO1xuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgJG1vZGVsVmFsdWUgdG8gZW5zdXJlIHRoYXQgZm9ybWF0dGVycyByZS1ydW5cbiAgICAgICAgICAgIC8vIEZJWE1FOiBSZWZhY3RvciB3aGVuIFBSIGlzIG1lcmdlZDogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9wdWxsLzEwNzY0XG4gICAgICAgICAgICBpZiAobmV3RGF0ZUZvcm1hdCAhPT0gZGF0ZUZvcm1hdCkge1xuICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gbmV3RGF0ZUZvcm1hdDtcbiAgICAgICAgICAgICAgbmdNb2RlbC4kbW9kZWxWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgaWYgKCFkYXRlRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRlcGlja2VyUG9wdXAgbXVzdCBoYXZlIGEgZGF0ZSBmb3JtYXQgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGVGb3JtYXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRlcGlja2VyUG9wdXAgbXVzdCBoYXZlIGEgZGF0ZSBmb3JtYXQgc3BlY2lmaWVkLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNIdG1sNURhdGVJbnB1dCAmJiBhdHRycy5kYXRlcGlja2VyUG9wdXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVE1MNSBkYXRlIGlucHV0IHR5cGVzIGRvIG5vdCBzdXBwb3J0IGN1c3RvbSBmb3JtYXRzLicpO1xuICAgICAgfVxuXG4gICAgICAvLyBwb3B1cCBlbGVtZW50IHVzZWQgdG8gZGlzcGxheSBjYWxlbmRhclxuICAgICAgdmFyIHBvcHVwRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgZGF0ZXBpY2tlci1wb3B1cC13cmFwPjxkaXYgZGF0ZXBpY2tlcj48L2Rpdj48L2Rpdj4nKTtcbiAgICAgIHBvcHVwRWwuYXR0cih7XG4gICAgICAgICduZy1tb2RlbCc6ICdkYXRlJyxcbiAgICAgICAgJ25nLWNoYW5nZSc6ICdkYXRlU2VsZWN0aW9uKGRhdGUpJyxcbiAgICAgICAgJ3RlbXBsYXRlLXVybCc6IGRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY2FtZWx0b0Rhc2goc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbigkMSkgeyByZXR1cm4gJy0nICsgJDEudG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRhdGVwaWNrZXIgZWxlbWVudFxuICAgICAgdmFyIGRhdGVwaWNrZXJFbCA9IGFuZ3VsYXIuZWxlbWVudChwb3B1cEVsLmNoaWxkcmVuKClbMF0pO1xuICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoJ3RlbXBsYXRlLXVybCcsIGRhdGVwaWNrZXJUZW1wbGF0ZVVybCk7XG5cbiAgICAgIGlmIChpc0h0bWw1RGF0ZUlucHV0KSB7XG4gICAgICAgIGlmIChhdHRycy50eXBlID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoJ2RhdGVwaWNrZXItbW9kZScsICdcIm1vbnRoXCInKTtcbiAgICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignbWluLW1vZGUnLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMuZGF0ZXBpY2tlck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmRhdGVwaWNrZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbml0RGF0ZSkge1xuICAgICAgICAgIHNjb3BlLmluaXREYXRlID0gb3B0aW9ucy5pbml0RGF0ZTtcbiAgICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignaW5pdC1kYXRlJywgJ2luaXREYXRlJyk7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW5pdERhdGU7XG4gICAgICAgIH1cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBvcHRpb24pIHtcbiAgICAgICAgICBkYXRlcGlja2VyRWwuYXR0ciggY2FtZWx0b0Rhc2gob3B0aW9uKSwgdmFsdWUgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLndhdGNoRGF0YSA9IHt9O1xuICAgICAgYW5ndWxhci5mb3JFYWNoKFsnbWluTW9kZScsICdtYXhNb2RlJywgJ21pbkRhdGUnLCAnbWF4RGF0ZScsICdkYXRlcGlja2VyTW9kZScsICdpbml0RGF0ZScsICdzaG9ydGN1dFByb3BhZ2F0aW9uJ10sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoYXR0cnNba2V5XSkge1xuICAgICAgICAgIHZhciBnZXRBdHRyaWJ1dGUgPSAkcGFyc2UoYXR0cnNba2V5XSk7XG4gICAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goZ2V0QXR0cmlidXRlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgc2NvcGUud2F0Y2hEYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdtaW5EYXRlJyB8fCBrZXkgPT09ICdtYXhEYXRlJykge1xuICAgICAgICAgICAgICBjYWNoZVtrZXldID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKGNhbWVsdG9EYXNoKGtleSksICd3YXRjaERhdGEuJyArIGtleSk7XG5cbiAgICAgICAgICAvLyBQcm9wYWdhdGUgY2hhbmdlcyBmcm9tIGRhdGVwaWNrZXIgdG8gb3V0c2lkZVxuICAgICAgICAgIGlmIChrZXkgPT09ICdkYXRlcGlja2VyTW9kZScpIHtcbiAgICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSBnZXRBdHRyaWJ1dGUuYXNzaWduO1xuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCd3YXRjaERhdGEuJyArIGtleSwgZnVuY3Rpb24odmFsdWUsIG9sZHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24oc2V0QXR0cmlidXRlKSAmJiB2YWx1ZSAhPT0gb2xkdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUoc2NvcGUuJHBhcmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGF0dHJzLmRhdGVEaXNhYmxlZCkge1xuICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignZGF0ZS1kaXNhYmxlZCcsICdkYXRlRGlzYWJsZWQoeyBkYXRlOiBkYXRlLCBtb2RlOiBtb2RlIH0pJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycy5zaG93V2Vla3MpIHtcbiAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoJ3Nob3ctd2Vla3MnLCBhdHRycy5zaG93V2Vla3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMuY3VzdG9tQ2xhc3MpIHtcbiAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoJ2N1c3RvbS1jbGFzcycsICdjdXN0b21DbGFzcyh7IGRhdGU6IGRhdGUsIG1vZGU6IG1vZGUgfSknKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGFyc2VEYXRlKHZpZXdWYWx1ZSkge1xuICAgICAgICBpZiAoYW5ndWxhci5pc051bWJlcih2aWV3VmFsdWUpKSB7XG4gICAgICAgICAgLy8gcHJlc3VtYWJseSB0aW1lc3RhbXAgdG8gZGF0ZSBvYmplY3RcbiAgICAgICAgICB2aWV3VmFsdWUgPSBuZXcgRGF0ZSh2aWV3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2aWV3VmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzRGF0ZSh2aWV3VmFsdWUpICYmICFpc05hTih2aWV3VmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpZXdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZpZXdWYWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVQYXJzZXIucGFyc2Uodmlld1ZhbHVlLCBkYXRlRm9ybWF0LCBzY29wZS5kYXRlKTtcbiAgICAgICAgICBpZiAoaXNOYU4oZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRvcihtb2RlbFZhbHVlLCB2aWV3VmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbW9kZWxWYWx1ZSB8fCB2aWV3VmFsdWU7XG5cbiAgICAgICAgaWYgKCFhdHRycy5uZ1JlcXVpcmVkICYmICF2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNEYXRlKHZhbHVlKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVQYXJzZXIucGFyc2UodmFsdWUsIGRhdGVGb3JtYXQpO1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNIdG1sNURhdGVJbnB1dCkge1xuICAgICAgICAvLyBJbnRlcm5hbCBBUEkgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgbmctaW52YWxpZC1ba2V5XSBjbGFzc1xuICAgICAgICBuZ01vZGVsLiQkcGFyc2VyTmFtZSA9ICdkYXRlJztcbiAgICAgICAgbmdNb2RlbC4kdmFsaWRhdG9ycy5kYXRlID0gdmFsaWRhdG9yO1xuICAgICAgICBuZ01vZGVsLiRwYXJzZXJzLnVuc2hpZnQocGFyc2VEYXRlKTtcbiAgICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgc2NvcGUuZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBuZ01vZGVsLiRpc0VtcHR5KHZhbHVlKSA/IHZhbHVlIDogZGF0ZUZpbHRlcih2YWx1ZSwgZGF0ZUZvcm1hdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgc2NvcGUuZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElubmVyIGNoYW5nZVxuICAgICAgc2NvcGUuZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGR0KSB7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChkdCkpIHtcbiAgICAgICAgICBzY29wZS5kYXRlID0gZHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGUgPSBzY29wZS5kYXRlID8gZGF0ZUZpbHRlcihzY29wZS5kYXRlLCBkYXRlRm9ybWF0KSA6IG51bGw7IC8vIFNldHRpbmcgdG8gTlVMTCBpcyBuZWNlc3NhcnkgZm9yIGZvcm0gdmFsaWRhdG9ycyB0byBmdW5jdGlvblxuICAgICAgICBlbGVtZW50LnZhbChkYXRlKTtcbiAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKGRhdGUpO1xuXG4gICAgICAgIGlmIChjbG9zZU9uRGF0ZVNlbGVjdGlvbikge1xuICAgICAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gRGV0ZWN0IGNoYW5nZXMgaW4gdGhlIHZpZXcgZnJvbSB0aGUgdGV4dCBib3hcbiAgICAgIG5nTW9kZWwuJHZpZXdDaGFuZ2VMaXN0ZW5lcnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgc2NvcGUuZGF0ZSA9IGRhdGVQYXJzZXIucGFyc2UobmdNb2RlbC4kdmlld1ZhbHVlLCBkYXRlRm9ybWF0LCBzY29wZS5kYXRlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZG9jdW1lbnRDbGlja0JpbmQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoc2NvcGUuaXNPcGVuICYmICEoZWxlbWVudFswXS5jb250YWlucyhldmVudC50YXJnZXQpIHx8IHBvcHVwRWxbMF0uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGlucHV0S2V5ZG93bkJpbmQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gMjcgJiYgc2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDQwICYmICFzY29wZS5pc09wZW4pIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2NvcGUuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnQuYmluZCgna2V5ZG93bicsIGlucHV0S2V5ZG93bkJpbmQpO1xuXG4gICAgICBzY29wZS5rZXlkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmIChldnQud2hpY2ggPT09IDI3KSB7XG4gICAgICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHNjb3BlLnBvc2l0aW9uID0gYXBwZW5kVG9Cb2R5ID8gJHBvc2l0aW9uLm9mZnNldChlbGVtZW50KSA6ICRwb3NpdGlvbi5wb3NpdGlvbihlbGVtZW50KTtcbiAgICAgICAgICBzY29wZS5wb3NpdGlvbi50b3AgPSBzY29wZS5wb3NpdGlvbi50b3AgKyBlbGVtZW50LnByb3AoJ29mZnNldEhlaWdodCcpO1xuXG4gICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAob25PcGVuRm9jdXMpIHtcbiAgICAgICAgICAgICAgc2NvcGUuJGJyb2FkY2FzdCgnZGF0ZXBpY2tlci5mb2N1cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xuICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZG9jdW1lbnQudW5iaW5kKCdjbGljaycsIGRvY3VtZW50Q2xpY2tCaW5kKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUgPT09ICd0b2RheScpIHtcbiAgICAgICAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZShzY29wZS5kYXRlKSkge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHNjb3BlLmRhdGUpO1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih0b2RheS5nZXRGdWxsWWVhcigpLCB0b2RheS5nZXRNb250aCgpLCB0b2RheS5nZXREYXRlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUodG9kYXkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY29wZS5kYXRlU2VsZWN0aW9uKGRhdGUpO1xuICAgICAgfTtcblxuICAgICAgc2NvcGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciAkcG9wdXAgPSAkY29tcGlsZShwb3B1cEVsKShzY29wZSk7XG4gICAgICAvLyBQcmV2ZW50IGpRdWVyeSBjYWNoZSBtZW1vcnkgbGVhayAodGVtcGxhdGUgaXMgbm93IHJlZHVuZGFudCBhZnRlciBsaW5raW5nKVxuICAgICAgcG9wdXBFbC5yZW1vdmUoKTtcblxuICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZCgkcG9wdXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5hZnRlcigkcG9wdXApO1xuICAgICAgfVxuXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzY29wZS5pc09wZW4gPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRwb3B1cC5yZW1vdmUoKTtcbiAgICAgICAgZWxlbWVudC51bmJpbmQoJ2tleWRvd24nLCBpbnB1dEtleWRvd25CaW5kKTtcbiAgICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgnZGF0ZXBpY2tlclBvcHVwV3JhcCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OidFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWwnO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRyb3Bkb3duJywgWyd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcblxuLmNvbnN0YW50KCdkcm9wZG93bkNvbmZpZycsIHtcbiAgb3BlbkNsYXNzOiAnb3Blbidcbn0pXG5cbi5zZXJ2aWNlKCdkcm9wZG93blNlcnZpY2UnLCBbJyRkb2N1bWVudCcsICckcm9vdFNjb3BlJywgZnVuY3Rpb24oJGRvY3VtZW50LCAkcm9vdFNjb3BlKSB7XG4gIHZhciBvcGVuU2NvcGUgPSBudWxsO1xuXG4gIHRoaXMub3BlbiA9IGZ1bmN0aW9uKGRyb3Bkb3duU2NvcGUpIHtcbiAgICBpZiAoIW9wZW5TY29wZSkge1xuICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgY2xvc2VEcm9wZG93bik7XG4gICAgICAkZG9jdW1lbnQuYmluZCgna2V5ZG93bicsIGtleWJpbmRGaWx0ZXIpO1xuICAgIH1cblxuICAgIGlmIChvcGVuU2NvcGUgJiYgb3BlblNjb3BlICE9PSBkcm9wZG93blNjb3BlKSB7XG4gICAgICBvcGVuU2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgb3BlblNjb3BlID0gZHJvcGRvd25TY29wZTtcbiAgfTtcblxuICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSkge1xuICAgIGlmIChvcGVuU2NvcGUgPT09IGRyb3Bkb3duU2NvcGUpIHtcbiAgICAgIG9wZW5TY29wZSA9IG51bGw7XG4gICAgICAkZG9jdW1lbnQudW5iaW5kKCdjbGljaycsIGNsb3NlRHJvcGRvd24pO1xuICAgICAgJGRvY3VtZW50LnVuYmluZCgna2V5ZG93bicsIGtleWJpbmRGaWx0ZXIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2xvc2VEcm9wZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG1heSBzdGlsbCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBzYW1lIG1vdXNlIGV2ZW50IHRoYXRcbiAgICAvLyB1bmJvdW5kIHRoaXMgZXZlbnQgaGFuZGxlci4gU28gY2hlY2sgb3BlblNjb3BlIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIGlmICghb3BlblNjb3BlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGV2dCAmJiBvcGVuU2NvcGUuZ2V0QXV0b0Nsb3NlKCkgPT09ICdkaXNhYmxlZCcpICB7IHJldHVybiA7IH1cblxuICAgIHZhciB0b2dnbGVFbGVtZW50ID0gb3BlblNjb3BlLmdldFRvZ2dsZUVsZW1lbnQoKTtcbiAgICBpZiAoZXZ0ICYmIHRvZ2dsZUVsZW1lbnQgJiYgdG9nZ2xlRWxlbWVudFswXS5jb250YWlucyhldnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkcm9wZG93bkVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0RHJvcGRvd25FbGVtZW50KCk7XG4gICAgaWYgKGV2dCAmJiBvcGVuU2NvcGUuZ2V0QXV0b0Nsb3NlKCkgPT09ICdvdXRzaWRlQ2xpY2snICYmXG4gICAgICBkcm9wZG93bkVsZW1lbnQgJiYgZHJvcGRvd25FbGVtZW50WzBdLmNvbnRhaW5zKGV2dC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3BlblNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgIG9wZW5TY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGtleWJpbmRGaWx0ZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LndoaWNoID09PSAyNykge1xuICAgICAgb3BlblNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCgpO1xuICAgICAgY2xvc2VEcm9wZG93bigpO1xuICAgIH0gZWxzZSBpZiAob3BlblNjb3BlLmlzS2V5bmF2RW5hYmxlZCgpICYmIC8oMzh8NDApLy50ZXN0KGV2dC53aGljaCkgJiYgb3BlblNjb3BlLmlzT3Blbikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBvcGVuU2NvcGUuZm9jdXNEcm9wZG93bkVudHJ5KGV2dC53aGljaCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb250cm9sbGVyKCdEcm9wZG93bkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJ2Ryb3Bkb3duQ29uZmlnJywgJ2Ryb3Bkb3duU2VydmljZScsICckYW5pbWF0ZScsICckcG9zaXRpb24nLCAnJGRvY3VtZW50JywgJyRjb21waWxlJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJHBhcnNlLCBkcm9wZG93bkNvbmZpZywgZHJvcGRvd25TZXJ2aWNlLCAkYW5pbWF0ZSwgJHBvc2l0aW9uLCAkZG9jdW1lbnQsICRjb21waWxlLCAkdGVtcGxhdGVSZXF1ZXN0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBzY29wZSA9ICRzY29wZS4kbmV3KCksIC8vIGNyZWF0ZSBhIGNoaWxkIHNjb3BlIHNvIHdlIGFyZSBub3QgcG9sbHV0aW5nIG9yaWdpbmFsIG9uZVxuICAgIHRlbXBsYXRlU2NvcGUsXG4gICAgb3BlbkNsYXNzID0gZHJvcGRvd25Db25maWcub3BlbkNsYXNzLFxuICAgIGdldElzT3BlbixcbiAgICBzZXRJc09wZW4gPSBhbmd1bGFyLm5vb3AsXG4gICAgdG9nZ2xlSW52b2tlciA9ICRhdHRycy5vblRvZ2dsZSA/ICRwYXJzZSgkYXR0cnMub25Ub2dnbGUpIDogYW5ndWxhci5ub29wLFxuICAgIGFwcGVuZFRvQm9keSA9IGZhbHNlLFxuICAgIGtleW5hdkVuYWJsZWQgPSBmYWxzZSxcbiAgICBzZWxlY3RlZE9wdGlvbiA9IG51bGwsXG4gICAgYm9keSA9ICRkb2N1bWVudC5maW5kKCdib2R5Jyk7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHNlbGYuJGVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgaWYgKCRhdHRycy5pc09wZW4pIHtcbiAgICAgIGdldElzT3BlbiA9ICRwYXJzZSgkYXR0cnMuaXNPcGVuKTtcbiAgICAgIHNldElzT3BlbiA9IGdldElzT3Blbi5hc3NpZ247XG5cbiAgICAgICRzY29wZS4kd2F0Y2goZ2V0SXNPcGVuLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzY29wZS5pc09wZW4gPSAhIXZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRyb3Bkb3duQXBwZW5kVG9Cb2R5KTtcbiAgICBrZXluYXZFbmFibGVkID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmtleWJvYXJkTmF2KTtcblxuICAgIGlmIChhcHBlbmRUb0JvZHkgJiYgc2VsZi5kcm9wZG93bk1lbnUpIHtcbiAgICAgIGJvZHkuYXBwZW5kKHNlbGYuZHJvcGRvd25NZW51KTtcbiAgICAgIGJvZHkuYWRkQ2xhc3MoJ2Ryb3Bkb3duJyk7XG4gICAgICBlbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uIGhhbmRsZURlc3Ryb3lFdmVudCgpIHtcbiAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbihvcGVuKSB7XG4gICAgcmV0dXJuIHNjb3BlLmlzT3BlbiA9IGFyZ3VtZW50cy5sZW5ndGggPyAhIW9wZW4gOiAhc2NvcGUuaXNPcGVuO1xuICB9O1xuXG4gIC8vIEFsbG93IG90aGVyIGRpcmVjdGl2ZXMgdG8gd2F0Y2ggc3RhdHVzXG4gIHRoaXMuaXNPcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNjb3BlLmlzT3BlbjtcbiAgfTtcblxuICBzY29wZS5nZXRUb2dnbGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYudG9nZ2xlRWxlbWVudDtcbiAgfTtcblxuICBzY29wZS5nZXRBdXRvQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGF0dHJzLmF1dG9DbG9zZSB8fCAnYWx3YXlzJzsgLy9vciAnb3V0c2lkZUNsaWNrJyBvciAnZGlzYWJsZWQnXG4gIH07XG5cbiAgc2NvcGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLiRlbGVtZW50O1xuICB9O1xuXG4gIHNjb3BlLmlzS2V5bmF2RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrZXluYXZFbmFibGVkO1xuICB9O1xuXG4gIHNjb3BlLmZvY3VzRHJvcGRvd25FbnRyeSA9IGZ1bmN0aW9uKGtleUNvZGUpIHtcbiAgICB2YXIgZWxlbXMgPSBzZWxmLmRyb3Bkb3duTWVudSA/IC8vSWYgYXBwZW5kIHRvIGJvZHkgaXMgdXNlZC5cbiAgICAgIChhbmd1bGFyLmVsZW1lbnQoc2VsZi5kcm9wZG93bk1lbnUpLmZpbmQoJ2EnKSkgOlxuICAgICAgKGFuZ3VsYXIuZWxlbWVudChzZWxmLiRlbGVtZW50KS5maW5kKCd1bCcpLmVxKDApLmZpbmQoJ2EnKSk7XG5cbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgIGNhc2UgKDQwKToge1xuICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoc2VsZi5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gKHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IGVsZW1zLmxlbmd0aCAtMSA/XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uIDpcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgKDM4KToge1xuICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoc2VsZi5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gZWxlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gc2VsZi5zZWxlY3RlZE9wdGlvbiA9PT0gMCA/XG4gICAgICAgICAgICAwIDogc2VsZi5zZWxlY3RlZE9wdGlvbiAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1zW3NlbGYuc2VsZWN0ZWRPcHRpb25dLmZvY3VzKCk7XG4gIH07XG5cbiAgc2NvcGUuZ2V0RHJvcGRvd25FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuZHJvcGRvd25NZW51O1xuICB9O1xuXG4gIHNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnRvZ2dsZUVsZW1lbnQpIHtcbiAgICAgIHNlbGYudG9nZ2xlRWxlbWVudFswXS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKGlzT3Blbiwgd2FzT3Blbikge1xuICAgIGlmIChhcHBlbmRUb0JvZHkgJiYgc2VsZi5kcm9wZG93bk1lbnUpIHtcbiAgICAgIHZhciBwb3MgPSAkcG9zaXRpb24ucG9zaXRpb25FbGVtZW50cyhzZWxmLiRlbGVtZW50LCBzZWxmLmRyb3Bkb3duTWVudSwgJ2JvdHRvbS1sZWZ0JywgdHJ1ZSk7XG4gICAgICB2YXIgY3NzID0ge1xuICAgICAgICB0b3A6IHBvcy50b3AgKyAncHgnLFxuICAgICAgICBkaXNwbGF5OiBpc09wZW4gPyAnYmxvY2snIDogJ25vbmUnXG4gICAgICB9O1xuXG4gICAgICB2YXIgcmlnaHRhbGlnbiA9IHNlbGYuZHJvcGRvd25NZW51Lmhhc0NsYXNzKCdkcm9wZG93bi1tZW51LXJpZ2h0Jyk7XG4gICAgICBpZiAoIXJpZ2h0YWxpZ24pIHtcbiAgICAgICAgY3NzLmxlZnQgPSBwb3MubGVmdCArICdweCc7XG4gICAgICAgIGNzcy5yaWdodCA9ICdhdXRvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNzcy5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICBjc3MucmlnaHQgPSAod2luZG93LmlubmVyV2lkdGggLSAocG9zLmxlZnQgKyBzZWxmLiRlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJykpKSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZHJvcGRvd25NZW51LmNzcyhjc3MpO1xuICAgIH1cblxuICAgIHZhciBvcGVuQ29udGFpbmVyID0gYXBwZW5kVG9Cb2R5ID8gYm9keSA6IHNlbGYuJGVsZW1lbnQ7XG5cbiAgICAkYW5pbWF0ZVtpc09wZW4gPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10ob3BlbkNvbnRhaW5lciwgb3BlbkNsYXNzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGlzT3BlbikgJiYgaXNPcGVuICE9PSB3YXNPcGVuKSB7XG4gICAgICAgIHRvZ2dsZUludm9rZXIoJHNjb3BlLCB7IG9wZW46ICEhaXNPcGVuIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGlzT3Blbikge1xuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcbiAgICAgICAgJHRlbXBsYXRlUmVxdWVzdChzZWxmLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsKS50aGVuKGZ1bmN0aW9uKHRwbENvbnRlbnQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICRjb21waWxlKHRwbENvbnRlbnQudHJpbSgpKSh0ZW1wbGF0ZVNjb3BlLCBmdW5jdGlvbihkcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbCA9IGRyb3Bkb3duRWxlbWVudDtcbiAgICAgICAgICAgIHNlbGYuZHJvcGRvd25NZW51LnJlcGxhY2VXaXRoKG5ld0VsKTtcbiAgICAgICAgICAgIHNlbGYuZHJvcGRvd25NZW51ID0gbmV3RWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQoKTtcbiAgICAgIGRyb3Bkb3duU2VydmljZS5vcGVuKHNjb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlU2NvcGUpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0VsID0gYW5ndWxhci5lbGVtZW50KCc8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCI+PC91bD4nKTtcbiAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVwbGFjZVdpdGgobmV3RWwpO1xuICAgICAgICBzZWxmLmRyb3Bkb3duTWVudSA9IG5ld0VsO1xuICAgICAgfVxuXG4gICAgICBkcm9wZG93blNlcnZpY2UuY2xvc2Uoc2NvcGUpO1xuICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRJc09wZW4pKSB7XG4gICAgICBzZXRJc09wZW4oJHNjb3BlLCBpc09wZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgJHNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzY29wZS5nZXRBdXRvQ2xvc2UoKSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb2ZmRGVzdHJveSA9ICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgfSk7XG4gIHNjb3BlLiRvbignJGRlc3Ryb3knLCBvZmZEZXN0cm95KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdkcm9wZG93bicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6ICdEcm9wZG93bkNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBkcm9wZG93bkN0cmwuaW5pdCggZWxlbWVudCApO1xuICAgICAgZWxlbWVudC5hZGRDbGFzcygnZHJvcGRvd24nKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdkcm9wZG93bk1lbnUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0FDJyxcbiAgICByZXF1aXJlOiAnP15kcm9wZG93bicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcbiAgICAgIGlmICghZHJvcGRvd25DdHJsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0cGxVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcbiAgICAgIGlmICh0cGxVcmwpIHtcbiAgICAgICAgZHJvcGRvd25DdHJsLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsID0gdHBsVXJsO1xuICAgICAgfVxuICAgICAgaWYgKCFkcm9wZG93bkN0cmwuZHJvcGRvd25NZW51KSB7XG4gICAgICAgIGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ2tleWJvYXJkTmF2JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiAnP15kcm9wZG93bicsXG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG5cbiAgICAgIGVsZW1lbnQuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKFszOCwgNDBdLmluZGV4T2YoZS53aGljaCkgIT09IC0xKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICB2YXIgZWxlbXMgPSBkcm9wZG93bkN0cmwuZHJvcGRvd25NZW51LmZpbmQoJ2EnKTtcblxuICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgY2FzZSAoNDApOiB7IC8vIERvd25cbiAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb24gPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9PT0gZWxlbXMubGVuZ3RoIC0xID9cbiAgICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA6IGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICgzOCk6IHsgLy8gVXBcbiAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb24gPSBlbGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAwIDogZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uIC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbXNbZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdkcm9wZG93blRvZ2dsZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICc/XmRyb3Bkb3duJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xuICAgICAgaWYgKCFkcm9wZG93bkN0cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bi10b2dnbGUnKTtcblxuICAgICAgZHJvcGRvd25DdHJsLnRvZ2dsZUVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICB2YXIgdG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghZWxlbWVudC5oYXNDbGFzcygnZGlzYWJsZWQnKSAmJiAhYXR0cnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkcm9wZG93bkN0cmwudG9nZ2xlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGVsZW1lbnQuYmluZCgnY2xpY2snLCB0b2dnbGVEcm9wZG93bik7XG5cbiAgICAgIC8vIFdBSS1BUklBXG4gICAgICBlbGVtZW50LmF0dHIoeyAnYXJpYS1oYXNwb3B1cCc6IHRydWUsICdhcmlhLWV4cGFuZGVkJzogZmFsc2UgfSk7XG4gICAgICBzY29wZS4kd2F0Y2goZHJvcGRvd25DdHJsLmlzT3BlbiwgZnVuY3Rpb24oIGlzT3BlbiApIHtcbiAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgISFpc09wZW4pO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudC51bmJpbmQoJ2NsaWNrJywgdG9nZ2xlRHJvcGRvd24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAubW9kYWwnLCBbXSlcblxuLyoqXG4gKiBBIGhlbHBlciwgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBhY3RzIGFzIGEgbWFwIGJ1dCBhbHNvIGFsbG93cyBnZXR0aW5nIC8gcmVtb3ZpbmdcbiAqIGVsZW1lbnRzIGluIHRoZSBMSUZPIG9yZGVyXG4gKi9cbiAgLmZhY3RvcnkoJyQkc3RhY2tlZE1hcCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAga2V5cy5wdXNoKHN0YWNrW2ldLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoa2V5ID09IHN0YWNrW2ldLmtleSkge1xuICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2UoaWR4LCAxKVswXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZVRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIDEsIDEpWzBdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0pXG5cbi8qKlxuICogQSBoZWxwZXIsIGludGVybmFsIGRhdGEgc3RydWN0dXJlIHRoYXQgc3RvcmVzIGFsbCByZWZlcmVuY2VzIGF0dGFjaGVkIHRvIGtleVxuICovXG4gIC5mYWN0b3J5KCckJG11bHRpTWFwJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZU5ldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXAgPSB7fTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXBba2V5XVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFtrZXldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzS2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAhIW1hcFtrZXldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHB1dDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtYXBba2V5XSkge1xuICAgICAgICAgICAgICBtYXBba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXBba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG1hcFtrZXldO1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB2YWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSlcblxuLyoqXG4gKiBBIGhlbHBlciBkaXJlY3RpdmUgZm9yIHRoZSAkbW9kYWwgc2VydmljZS4gSXQgY3JlYXRlcyBhIGJhY2tkcm9wIGVsZW1lbnQuXG4gKi9cbiAgLmRpcmVjdGl2ZSgnbW9kYWxCYWNrZHJvcCcsIFtcbiAgICAgICAgICAgJyRhbmltYXRlJywgJyRpbmplY3RvcicsICckbW9kYWxTdGFjaycsXG4gIGZ1bmN0aW9uKCRhbmltYXRlICwgICRpbmplY3RvciwgICAkbW9kYWxTdGFjaykge1xuICAgIHZhciAkYW5pbWF0ZUNzcyA9IG51bGw7XG5cbiAgICBpZiAoJGluamVjdG9yLmhhcygnJGFuaW1hdGVDc3MnKSkge1xuICAgICAgJGFuaW1hdGVDc3MgPSAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZUNzcycpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWwnLFxuICAgICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xuICAgICAgICB0RWxlbWVudC5hZGRDbGFzcyh0QXR0cnMuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgIHJldHVybiBsaW5rRm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxpbmtGbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIGlmIChhdHRycy5tb2RhbEluQ2xhc3MpIHtcbiAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgYWRkQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgIH0pLnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiRvbigkbW9kYWxTdGFjay5OT1dfQ0xPU0lOR19FVkVOVCwgZnVuY3Rpb24oZSwgc2V0SXNBc3luYykge1xuICAgICAgICAgIHZhciBkb25lID0gc2V0SXNBc3luYygpO1xuICAgICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXG4gICAgICAgICAgICB9KS5zdGFydCgpLnRoZW4oZG9uZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcykudGhlbihkb25lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgnbW9kYWxXaW5kb3cnLCBbXG4gICAgICAgICAgICckbW9kYWxTdGFjaycsICckcScsICckYW5pbWF0ZScsICckaW5qZWN0b3InLFxuICBmdW5jdGlvbigkbW9kYWxTdGFjayAsICAkcSAsICAkYW5pbWF0ZSwgICAkaW5qZWN0b3IpIHtcbiAgICB2YXIgJGFuaW1hdGVDc3MgPSBudWxsO1xuXG4gICAgaWYgKCRpbmplY3Rvci5oYXMoJyRhbmltYXRlQ3NzJykpIHtcbiAgICAgICRhbmltYXRlQ3NzID0gJGluamVjdG9yLmdldCgnJGFuaW1hdGVDc3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgICBzY29wZToge1xuICAgICAgICBpbmRleDogJ0AnXG4gICAgICB9LFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xuICAgICAgICByZXR1cm4gdEF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbCc7XG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoYXR0cnMud2luZG93Q2xhc3MgfHwgJycpO1xuICAgICAgICBzY29wZS5zaXplID0gYXR0cnMuc2l6ZTtcblxuICAgICAgICBzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHZhciBtb2RhbCA9ICRtb2RhbFN0YWNrLmdldFRvcCgpO1xuICAgICAgICAgIGlmIChtb2RhbCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAhPT0gJ3N0YXRpYycgJiYgKGV2dC50YXJnZXQgPT09IGV2dC5jdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2JhY2tkcm9wIGNsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoaXMgcHJvcGVydHkgaXMgb25seSBhZGRlZCB0byB0aGUgc2NvcGUgZm9yIHRoZSBwdXJwb3NlIG9mIGRldGVjdGluZyB3aGVuIHRoaXMgZGlyZWN0aXZlIGlzIHJlbmRlcmVkLlxuICAgICAgICAvLyBXZSBjYW4gZGV0ZWN0IHRoYXQgYnkgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZGlyZWN0aXZlIGFuZCB0aGVuIHVzZVxuICAgICAgICAvLyB7QGxpbmsgQXR0cmlidXRlIyRvYnNlcnZlfSBvbiBpdC4gRm9yIG1vcmUgZGV0YWlscyBwbGVhc2Ugc2VlIHtAbGluayBUYWJsZUNvbHVtblJlc2l6ZX0uXG4gICAgICAgIHNjb3BlLiRpc1JlbmRlcmVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBEZWZlcnJlZCBvYmplY3QgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhpcyBtb2RhbCBpcyByZW5kZXIuXG4gICAgICAgIHZhciBtb2RhbFJlbmRlckRlZmVyT2JqID0gJHEuZGVmZXIoKTtcbiAgICAgICAgLy8gT2JzZXJ2ZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBuZXh0IGRpZ2VzdCBjeWNsZSBhZnRlciBjb21waWxhdGlvbiwgZW5zdXJpbmcgdGhhdCB0aGUgRE9NIGlzIHJlYWR5LlxuICAgICAgICAvLyBJbiBvcmRlciB0byB1c2UgdGhpcyB3YXkgb2YgZmluZGluZyB3aGV0aGVyIERPTSBpcyByZWFkeSwgd2UgbmVlZCB0byBvYnNlcnZlIGEgc2NvcGUgcHJvcGVydHkgdXNlZCBpbiBtb2RhbCdzIHRlbXBsYXRlLlxuICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnbW9kYWxSZW5kZXInLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIG1vZGFsUmVuZGVyRGVmZXJPYmoucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kYWxSZW5kZXJEZWZlck9iai5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGF0dHJzLm1vZGFsSW5DbGFzcykge1xuICAgICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2UgPSAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgICB9KS5zdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZSA9ICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLiRvbigkbW9kYWxTdGFjay5OT1dfQ0xPU0lOR19FVkVOVCwgZnVuY3Rpb24oZSwgc2V0SXNBc3luYykge1xuICAgICAgICAgICAgICB2YXIgZG9uZSA9IHNldElzQXN5bmMoKTtcbiAgICAgICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgICAgIH0pLnN0YXJ0KCkudGhlbihkb25lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZS5yZW1vdmVDbGFzcyhlbGVtZW50LCBhdHRycy5tb2RhbEluQ2xhc3MpLnRoZW4oZG9uZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgJHEud2hlbihhbmltYXRpb25Qcm9taXNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0c1dpdGhBdXRvZm9jdXMgPSBlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJ1thdXRvZm9jdXNdJyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEF1dG8tZm9jdXNpbmcgb2YgYSBmcmVzaGx5LW9wZW5lZCBtb2RhbCBlbGVtZW50IGNhdXNlcyBhbnkgY2hpbGQgZWxlbWVudHNcbiAgICAgICAgICAgICAqIHdpdGggdGhlIGF1dG9mb2N1cyBhdHRyaWJ1dGUgdG8gbG9zZSBmb2N1cy4gVGhpcyBpcyBhbiBpc3N1ZSBvbiB0b3VjaFxuICAgICAgICAgICAgICogYmFzZWQgZGV2aWNlcyB3aGljaCB3aWxsIHNob3cgYW5kIHRoZW4gaGlkZSB0aGUgb25zY3JlZW4ga2V5Ym9hcmQuXG4gICAgICAgICAgICAgKiBBdHRlbXB0cyB0byByZWZvY3VzIHRoZSBhdXRvZm9jdXMgZWxlbWVudCB2aWEgSmF2YVNjcmlwdCB3aWxsIG5vdCByZW9wZW5cbiAgICAgICAgICAgICAqIHRoZSBvbnNjcmVlbiBrZXlib2FyZC4gRml4ZWQgYnkgdXBkYXRlZCB0aGUgZm9jdXNpbmcgbG9naWMgdG8gb25seSBhdXRvZm9jdXNcbiAgICAgICAgICAgICAqIHRoZSBtb2RhbCBlbGVtZW50IGlmIHRoZSBtb2RhbCBkb2VzIG5vdCBjb250YWluIGFuIGF1dG9mb2N1cyBlbGVtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaW5wdXRzV2l0aEF1dG9mb2N1cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaW5wdXRzV2l0aEF1dG9mb2N1c1swXS5mb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTm90aWZ5IHtAbGluayAkbW9kYWxTdGFja30gdGhhdCBtb2RhbCBpcyByZW5kZXJlZC5cbiAgICAgICAgICB2YXIgbW9kYWwgPSAkbW9kYWxTdGFjay5nZXRUb3AoKTtcbiAgICAgICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgICAgICRtb2RhbFN0YWNrLm1vZGFsUmVuZGVyZWQobW9kYWwua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ21vZGFsQW5pbWF0aW9uQ2xhc3MnLCBbXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xuICAgICAgICAgIGlmICh0QXR0cnMubW9kYWxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRFbGVtZW50LmFkZENsYXNzKHRBdHRycy5tb2RhbEFuaW1hdGlvbkNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgnbW9kYWxUcmFuc2NsdWRlJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgY29udHJvbGxlciwgJHRyYW5zY2x1ZGUpIHtcbiAgICAgICAgJHRyYW5zY2x1ZGUoJHNjb3BlLiRwYXJlbnQsIGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICAgICAgJGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAkZWxlbWVudC5hcHBlbmQoY2xvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KVxuXG4gIC5mYWN0b3J5KCckbW9kYWxTdGFjaycsIFtcbiAgICAgICAgICAgICAnJGFuaW1hdGUnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyRjb21waWxlJywgJyRyb290U2NvcGUnLFxuICAgICAgICAgICAgICckcScsXG4gICAgICAgICAgICAgJyRpbmplY3RvcicsXG4gICAgICAgICAgICAgJyQkbXVsdGlNYXAnLFxuICAgICAgICAgICAgICckJHN0YWNrZWRNYXAnLFxuICAgIGZ1bmN0aW9uKCRhbmltYXRlICwgICR0aW1lb3V0ICwgICRkb2N1bWVudCAsICAkY29tcGlsZSAsICAkcm9vdFNjb3BlICxcbiAgICAgICAgICAgICAgJHEsXG4gICAgICAgICAgICAgICRpbmplY3RvcixcbiAgICAgICAgICAgICAgJCRtdWx0aU1hcCxcbiAgICAgICAgICAgICAgJCRzdGFja2VkTWFwKSB7XG4gICAgICB2YXIgJGFuaW1hdGVDc3MgPSBudWxsO1xuXG4gICAgICBpZiAoJGluamVjdG9yLmhhcygnJGFuaW1hdGVDc3MnKSkge1xuICAgICAgICAkYW5pbWF0ZUNzcyA9ICRpbmplY3Rvci5nZXQoJyRhbmltYXRlQ3NzJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBPUEVORURfTU9EQUxfQ0xBU1MgPSAnbW9kYWwtb3Blbic7XG5cbiAgICAgIHZhciBiYWNrZHJvcERvbUVsLCBiYWNrZHJvcFNjb3BlO1xuICAgICAgdmFyIG9wZW5lZFdpbmRvd3MgPSAkJHN0YWNrZWRNYXAuY3JlYXRlTmV3KCk7XG4gICAgICB2YXIgb3BlbmVkQ2xhc3NlcyA9ICQkbXVsdGlNYXAuY3JlYXRlTmV3KCk7XG4gICAgICB2YXIgJG1vZGFsU3RhY2sgPSB7XG4gICAgICAgIE5PV19DTE9TSU5HX0VWRU5UOiAnbW9kYWwuc3RhY2subm93LWNsb3NpbmcnXG4gICAgICB9O1xuXG4gICAgICAvL01vZGFsIGZvY3VzIGJlaGF2aW9yXG4gICAgICB2YXIgZm9jdXNhYmxlRWxlbWVudExpc3Q7XG4gICAgICB2YXIgZm9jdXNJbmRleCA9IDA7XG4gICAgICB2YXIgdGFiYWJibGVTZWxlY3RvciA9ICdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksICcgK1xuICAgICAgICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKSxzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksICcgK1xuICAgICAgICAnaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGU9dHJ1ZV0nO1xuXG4gICAgICBmdW5jdGlvbiBiYWNrZHJvcEluZGV4KCkge1xuICAgICAgICB2YXIgdG9wQmFja2Ryb3BJbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3BlbmVkID0gb3BlbmVkV2luZG93cy5rZXlzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9wZW5lZFdpbmRvd3MuZ2V0KG9wZW5lZFtpXSkudmFsdWUuYmFja2Ryb3ApIHtcbiAgICAgICAgICAgIHRvcEJhY2tkcm9wSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wQmFja2Ryb3BJbmRleDtcbiAgICAgIH1cblxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2goYmFja2Ryb3BJbmRleCwgZnVuY3Rpb24obmV3QmFja2Ryb3BJbmRleCkge1xuICAgICAgICBpZiAoYmFja2Ryb3BTY29wZSkge1xuICAgICAgICAgIGJhY2tkcm9wU2NvcGUuaW5kZXggPSBuZXdCYWNrZHJvcEluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgZWxlbWVudFRvUmVjZWl2ZUZvY3VzKSB7XG4gICAgICAgIHZhciBib2R5ID0gJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5lcSgwKTtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSkudmFsdWU7XG5cbiAgICAgICAgLy9jbGVhbiB1cCB0aGUgc3RhY2tcbiAgICAgICAgb3BlbmVkV2luZG93cy5yZW1vdmUobW9kYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgcmVtb3ZlQWZ0ZXJBbmltYXRlKG1vZGFsV2luZG93Lm1vZGFsRG9tRWwsIG1vZGFsV2luZG93Lm1vZGFsU2NvcGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBtb2RhbEJvZHlDbGFzcyA9IG1vZGFsV2luZG93Lm9wZW5lZENsYXNzIHx8IE9QRU5FRF9NT0RBTF9DTEFTUztcbiAgICAgICAgICBvcGVuZWRDbGFzc2VzLnJlbW92ZShtb2RhbEJvZHlDbGFzcywgbW9kYWxJbnN0YW5jZSk7XG4gICAgICAgICAgYm9keS50b2dnbGVDbGFzcyhtb2RhbEJvZHlDbGFzcywgb3BlbmVkQ2xhc3Nlcy5oYXNLZXkobW9kYWxCb2R5Q2xhc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrUmVtb3ZlQmFja2Ryb3AoKTtcblxuICAgICAgICAvL21vdmUgZm9jdXMgdG8gc3BlY2lmaWVkIGVsZW1lbnQgaWYgYXZhaWxhYmxlLCBvciBlbHNlIHRvIGJvZHlcbiAgICAgICAgaWYgKGVsZW1lbnRUb1JlY2VpdmVGb2N1cyAmJiBlbGVtZW50VG9SZWNlaXZlRm9jdXMuZm9jdXMpIHtcbiAgICAgICAgICBlbGVtZW50VG9SZWNlaXZlRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib2R5LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSZW1vdmVCYWNrZHJvcCgpIHtcbiAgICAgICAgICAvL3JlbW92ZSBiYWNrZHJvcCBpZiBubyBsb25nZXIgbmVlZGVkXG4gICAgICAgICAgaWYgKGJhY2tkcm9wRG9tRWwgJiYgYmFja2Ryb3BJbmRleCgpID09IC0xKSB7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3BTY29wZVJlZiA9IGJhY2tkcm9wU2NvcGU7XG4gICAgICAgICAgICByZW1vdmVBZnRlckFuaW1hdGUoYmFja2Ryb3BEb21FbCwgYmFja2Ryb3BTY29wZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGJhY2tkcm9wU2NvcGVSZWYgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiYWNrZHJvcERvbUVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYmFja2Ryb3BTY29wZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUFmdGVyQW5pbWF0ZShkb21FbCwgc2NvcGUsIGRvbmUpIHtcbiAgICAgICAgdmFyIGFzeW5jRGVmZXJyZWQ7XG4gICAgICAgIHZhciBhc3luY1Byb21pc2UgPSBudWxsO1xuICAgICAgICB2YXIgc2V0SXNBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghYXN5bmNEZWZlcnJlZCkge1xuICAgICAgICAgICAgYXN5bmNEZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICBhc3luY1Byb21pc2UgPSBhc3luY0RlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jRG9uZSgpIHtcbiAgICAgICAgICAgIGFzeW5jRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiRicm9hZGNhc3QoJG1vZGFsU3RhY2suTk9XX0NMT1NJTkdfRVZFTlQsIHNldElzQXN5bmMpO1xuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpdCdzIGludGVudGlvbmFsIHRoYXQgYXN5bmNQcm9taXNlIG1pZ2h0IGJlIG51bGwuXG4gICAgICAgIC8vIFRoYXQncyB3aGVuIHNldElzQXN5bmMgaGFzIG5vdCBiZWVuIGNhbGxlZCBkdXJpbmcgdGhlXG4gICAgICAgIC8vIE5PV19DTE9TSU5HX0VWRU5UIGJyb2FkY2FzdC5cbiAgICAgICAgcmV0dXJuICRxLndoZW4oYXN5bmNQcm9taXNlKS50aGVuKGFmdGVyQW5pbWF0aW5nKTtcblxuICAgICAgICBmdW5jdGlvbiBhZnRlckFuaW1hdGluZygpIHtcbiAgICAgICAgICBpZiAoYWZ0ZXJBbmltYXRpbmcuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZnRlckFuaW1hdGluZy5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICAgJGFuaW1hdGVDc3MoZG9tRWwsIHtcbiAgICAgICAgICAgICAgZXZlbnQ6ICdsZWF2ZSdcbiAgICAgICAgICAgIH0pLnN0YXJ0KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZG9tRWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZG9tRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICRkb2N1bWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmIChldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vZGFsID0gb3BlbmVkV2luZG93cy50b3AoKTtcbiAgICAgICAgaWYgKG1vZGFsICYmIG1vZGFsLnZhbHVlLmtleWJvYXJkKSB7XG4gICAgICAgICAgc3dpdGNoIChldnQud2hpY2gpe1xuICAgICAgICAgICAgY2FzZSAyNzoge1xuICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJG1vZGFsU3RhY2suZGlzbWlzcyhtb2RhbC5rZXksICdlc2NhcGUga2V5IHByZXNzJyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgICAkbW9kYWxTdGFjay5sb2FkRm9jdXNFbGVtZW50TGlzdChtb2RhbCk7XG4gICAgICAgICAgICAgIHZhciBmb2N1c0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGV2dC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICgkbW9kYWxTdGFjay5pc0ZvY3VzSW5GaXJzdEl0ZW0oZXZ0KSkge1xuICAgICAgICAgICAgICAgICAgZm9jdXNDaGFuZ2VkID0gJG1vZGFsU3RhY2suZm9jdXNMYXN0Rm9jdXNhYmxlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJG1vZGFsU3RhY2suaXNGb2N1c0luTGFzdEl0ZW0oZXZ0KSkge1xuICAgICAgICAgICAgICAgICAgZm9jdXNDaGFuZ2VkID0gJG1vZGFsU3RhY2suZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZm9jdXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgICRtb2RhbFN0YWNrLm9wZW4gPSBmdW5jdGlvbihtb2RhbEluc3RhbmNlLCBtb2RhbCkge1xuICAgICAgICB2YXIgbW9kYWxPcGVuZXIgPSAkZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCxcbiAgICAgICAgICBtb2RhbEJvZHlDbGFzcyA9IG1vZGFsLm9wZW5lZENsYXNzIHx8IE9QRU5FRF9NT0RBTF9DTEFTUztcblxuICAgICAgICBvcGVuZWRXaW5kb3dzLmFkZChtb2RhbEluc3RhbmNlLCB7XG4gICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsLmRlZmVycmVkLFxuICAgICAgICAgIHJlbmRlckRlZmVycmVkOiBtb2RhbC5yZW5kZXJEZWZlcnJlZCxcbiAgICAgICAgICBtb2RhbFNjb3BlOiBtb2RhbC5zY29wZSxcbiAgICAgICAgICBiYWNrZHJvcDogbW9kYWwuYmFja2Ryb3AsXG4gICAgICAgICAga2V5Ym9hcmQ6IG1vZGFsLmtleWJvYXJkLFxuICAgICAgICAgIG9wZW5lZENsYXNzOiBtb2RhbC5vcGVuZWRDbGFzc1xuICAgICAgICB9KTtcblxuICAgICAgICBvcGVuZWRDbGFzc2VzLnB1dChtb2RhbEJvZHlDbGFzcywgbW9kYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgdmFyIGJvZHkgPSAkZG9jdW1lbnQuZmluZCgnYm9keScpLmVxKDApLFxuICAgICAgICAgICAgY3VyckJhY2tkcm9wSW5kZXggPSBiYWNrZHJvcEluZGV4KCk7XG5cbiAgICAgICAgaWYgKGN1cnJCYWNrZHJvcEluZGV4ID49IDAgJiYgIWJhY2tkcm9wRG9tRWwpIHtcbiAgICAgICAgICBiYWNrZHJvcFNjb3BlID0gJHJvb3RTY29wZS4kbmV3KHRydWUpO1xuICAgICAgICAgIGJhY2tkcm9wU2NvcGUuaW5kZXggPSBjdXJyQmFja2Ryb3BJbmRleDtcbiAgICAgICAgICB2YXIgYW5ndWxhckJhY2tncm91bmREb21FbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBtb2RhbC1iYWNrZHJvcD1cIm1vZGFsLWJhY2tkcm9wXCI+PC9kaXY+Jyk7XG4gICAgICAgICAgYW5ndWxhckJhY2tncm91bmREb21FbC5hdHRyKCdiYWNrZHJvcC1jbGFzcycsIG1vZGFsLmJhY2tkcm9wQ2xhc3MpO1xuICAgICAgICAgIGlmIChtb2RhbC5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIGFuZ3VsYXJCYWNrZ3JvdW5kRG9tRWwuYXR0cignbW9kYWwtYW5pbWF0aW9uJywgJ3RydWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmFja2Ryb3BEb21FbCA9ICRjb21waWxlKGFuZ3VsYXJCYWNrZ3JvdW5kRG9tRWwpKGJhY2tkcm9wU2NvcGUpO1xuICAgICAgICAgIGJvZHkuYXBwZW5kKGJhY2tkcm9wRG9tRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuZ3VsYXJEb21FbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBtb2RhbC13aW5kb3c9XCJtb2RhbC13aW5kb3dcIj48L2Rpdj4nKTtcbiAgICAgICAgYW5ndWxhckRvbUVsLmF0dHIoe1xuICAgICAgICAgICd0ZW1wbGF0ZS11cmwnOiBtb2RhbC53aW5kb3dUZW1wbGF0ZVVybCxcbiAgICAgICAgICAnd2luZG93LWNsYXNzJzogbW9kYWwud2luZG93Q2xhc3MsXG4gICAgICAgICAgJ3NpemUnOiBtb2RhbC5zaXplLFxuICAgICAgICAgICdpbmRleCc6IG9wZW5lZFdpbmRvd3MubGVuZ3RoKCkgLSAxLFxuICAgICAgICAgICdhbmltYXRlJzogJ2FuaW1hdGUnXG4gICAgICAgIH0pLmh0bWwobW9kYWwuY29udGVudCk7XG4gICAgICAgIGlmIChtb2RhbC5hbmltYXRpb24pIHtcbiAgICAgICAgICBhbmd1bGFyRG9tRWwuYXR0cignbW9kYWwtYW5pbWF0aW9uJywgJ3RydWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RhbERvbUVsID0gJGNvbXBpbGUoYW5ndWxhckRvbUVsKShtb2RhbC5zY29wZSk7XG4gICAgICAgIG9wZW5lZFdpbmRvd3MudG9wKCkudmFsdWUubW9kYWxEb21FbCA9IG1vZGFsRG9tRWw7XG4gICAgICAgIG9wZW5lZFdpbmRvd3MudG9wKCkudmFsdWUubW9kYWxPcGVuZXIgPSBtb2RhbE9wZW5lcjtcbiAgICAgICAgYm9keS5hcHBlbmQobW9kYWxEb21FbCk7XG4gICAgICAgIGJvZHkuYWRkQ2xhc3MobW9kYWxCb2R5Q2xhc3MpO1xuXG4gICAgICAgICRtb2RhbFN0YWNrLmNsZWFyRm9jdXNMaXN0Q2FjaGUoKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGJyb2FkY2FzdENsb3NpbmcobW9kYWxXaW5kb3csIHJlc3VsdE9yUmVhc29uLCBjbG9zaW5nKSB7XG4gICAgICAgICAgcmV0dXJuICFtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiRicm9hZGNhc3QoJ21vZGFsLmNsb3NpbmcnLCByZXN1bHRPclJlYXNvbiwgY2xvc2luZykuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH1cblxuICAgICAgJG1vZGFsU3RhY2suY2xvc2UgPSBmdW5jdGlvbihtb2RhbEluc3RhbmNlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdyAmJiBicm9hZGNhc3RDbG9zaW5nKG1vZGFsV2luZG93LCByZXN1bHQsIHRydWUpKSB7XG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxTY29wZS4kJHVpYkRlc3RydWN0aW9uU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxPcGVuZXIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbW9kYWxXaW5kb3c7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5kaXNtaXNzID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSwgcmVhc29uKSB7XG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpO1xuICAgICAgICBpZiAobW9kYWxXaW5kb3cgJiYgYnJvYWRjYXN0Q2xvc2luZyhtb2RhbFdpbmRvdywgcmVhc29uLCBmYWxzZSkpIHtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLmRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UsIG1vZGFsV2luZG93LnZhbHVlLm1vZGFsT3BlbmVyKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW1vZGFsV2luZG93O1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZGlzbWlzc0FsbCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICB2YXIgdG9wTW9kYWwgPSB0aGlzLmdldFRvcCgpO1xuICAgICAgICB3aGlsZSAodG9wTW9kYWwgJiYgdGhpcy5kaXNtaXNzKHRvcE1vZGFsLmtleSwgcmVhc29uKSkge1xuICAgICAgICAgIHRvcE1vZGFsID0gdGhpcy5nZXRUb3AoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZ2V0VG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvcGVuZWRXaW5kb3dzLnRvcCgpO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2subW9kYWxSZW5kZXJlZCA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdykge1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLnJlbmRlckRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb2N1c2FibGVFbGVtZW50TGlzdFswXS5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICAkbW9kYWxTdGFjay5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9jdXNhYmxlRWxlbWVudExpc3RbZm9jdXNhYmxlRWxlbWVudExpc3QubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5pc0ZvY3VzSW5GaXJzdEl0ZW0gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gKGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQpID09IGZvY3VzYWJsZUVsZW1lbnRMaXN0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmlzRm9jdXNJbkxhc3RJdGVtID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIChldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50KSA9PSBmb2N1c2FibGVFbGVtZW50TGlzdFtmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5jbGVhckZvY3VzTGlzdENhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRMaXN0ID0gW107XG4gICAgICAgIGZvY3VzSW5kZXggPSAwO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2subG9hZEZvY3VzRWxlbWVudExpc3QgPSBmdW5jdGlvbihtb2RhbFdpbmRvdykge1xuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudExpc3QgPT09IHVuZGVmaW5lZCB8fCAhZm9jdXNhYmxlRWxlbWVudExpc3QubGVuZ3RoMCkge1xuICAgICAgICAgIGlmIChtb2RhbFdpbmRvdykge1xuICAgICAgICAgICAgdmFyIG1vZGFsRG9tRTEgPSBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbERvbUVsO1xuICAgICAgICAgICAgaWYgKG1vZGFsRG9tRTEgJiYgbW9kYWxEb21FMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9jdXNhYmxlRWxlbWVudExpc3QgPSBtb2RhbERvbUUxWzBdLnF1ZXJ5U2VsZWN0b3JBbGwodGFiYWJibGVTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gJG1vZGFsU3RhY2s7XG4gICAgfV0pXG5cbiAgLnByb3ZpZGVyKCckbW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgJG1vZGFsUHJvdmlkZXIgPSB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgYmFja2Ryb3A6IHRydWUsIC8vY2FuIGFsc28gYmUgZmFsc2Ugb3IgJ3N0YXRpYydcbiAgICAgICAga2V5Ym9hcmQ6IHRydWVcbiAgICAgIH0sXG4gICAgICAkZ2V0OiBbJyRpbmplY3RvcicsICckcm9vdFNjb3BlJywgJyRxJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLCAnJGNvbnRyb2xsZXInLCAnJG1vZGFsU3RhY2snLFxuICAgICAgICBmdW5jdGlvbiAoJGluamVjdG9yLCAkcm9vdFNjb3BlLCAkcSwgJHRlbXBsYXRlUmVxdWVzdCwgJGNvbnRyb2xsZXIsICRtb2RhbFN0YWNrKSB7XG4gICAgICAgICAgdmFyICRtb2RhbCA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVQcm9taXNlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnRlbXBsYXRlID8gJHEud2hlbihvcHRpb25zLnRlbXBsYXRlKSA6XG4gICAgICAgICAgICAgICR0ZW1wbGF0ZVJlcXVlc3QoYW5ndWxhci5pc0Z1bmN0aW9uKG9wdGlvbnMudGVtcGxhdGVVcmwpID8gKG9wdGlvbnMudGVtcGxhdGVVcmwpKCkgOiBvcHRpb25zLnRlbXBsYXRlVXJsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRSZXNvbHZlUHJvbWlzZXMocmVzb2x2ZXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlc0FyciA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc29sdmVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHZhbHVlKSB8fCBhbmd1bGFyLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNBcnIucHVzaCgkcS53aGVuKCRpbmplY3Rvci5pbnZva2UodmFsdWUpKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc0Fyci5wdXNoKCRxLndoZW4oJGluamVjdG9yLmdldCh2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc0Fyci5wdXNoKCRxLndoZW4odmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXNBcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByb21pc2VDaGFpbiA9IG51bGw7XG4gICAgICAgICAgJG1vZGFsLmdldFByb21pc2VDaGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VDaGFpbjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgJG1vZGFsLm9wZW4gPSBmdW5jdGlvbiAobW9kYWxPcHRpb25zKSB7XG5cbiAgICAgICAgICAgIHZhciBtb2RhbFJlc3VsdERlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIHZhciBtb2RhbE9wZW5lZERlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIHZhciBtb2RhbFJlbmRlckRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAgICAgLy9wcmVwYXJlIGFuIGluc3RhbmNlIG9mIGEgbW9kYWwgdG8gYmUgaW5qZWN0ZWQgaW50byBjb250cm9sbGVycyBhbmQgcmV0dXJuZWQgdG8gYSBjYWxsZXJcbiAgICAgICAgICAgIHZhciBtb2RhbEluc3RhbmNlID0ge1xuICAgICAgICAgICAgICByZXN1bHQ6IG1vZGFsUmVzdWx0RGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgICAgICAgb3BlbmVkOiBtb2RhbE9wZW5lZERlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgICAgIHJlbmRlcmVkOiBtb2RhbFJlbmRlckRlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtb2RhbFN0YWNrLmNsb3NlKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRpc21pc3M6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1vZGFsU3RhY2suZGlzbWlzcyhtb2RhbEluc3RhbmNlLCByZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL21lcmdlIGFuZCBjbGVhbiB1cCBvcHRpb25zXG4gICAgICAgICAgICBtb2RhbE9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgJG1vZGFsUHJvdmlkZXIub3B0aW9ucywgbW9kYWxPcHRpb25zKTtcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucy5yZXNvbHZlID0gbW9kYWxPcHRpb25zLnJlc29sdmUgfHwge307XG5cbiAgICAgICAgICAgIC8vdmVyaWZ5IG9wdGlvbnNcbiAgICAgICAgICAgIGlmICghbW9kYWxPcHRpb25zLnRlbXBsYXRlICYmICFtb2RhbE9wdGlvbnMudGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb2YgdGVtcGxhdGUgb3IgdGVtcGxhdGVVcmwgb3B0aW9ucyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2UgPVxuICAgICAgICAgICAgICAkcS5hbGwoW2dldFRlbXBsYXRlUHJvbWlzZShtb2RhbE9wdGlvbnMpXS5jb25jYXQoZ2V0UmVzb2x2ZVByb21pc2VzKG1vZGFsT3B0aW9ucy5yZXNvbHZlKSkpO1xuXG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZXhpc3RpbmcgcHJvbWlzZSBjaGFpbi5cbiAgICAgICAgICAgIC8vIFRoZW4gc3dpdGNoIHRvIG91ciBvd24gY29tYmluZWQgcHJvbWlzZSBkZXBlbmRlbmN5IChyZWdhcmRsZXNzIG9mIGhvdyB0aGUgcHJldmlvdXMgbW9kYWwgZmFyZWQpLlxuICAgICAgICAgICAgLy8gVGhlbiBhZGQgdG8gJG1vZGFsU3RhY2sgYW5kIHJlc29sdmUgb3BlbmVkLlxuICAgICAgICAgICAgLy8gRmluYWxseSBjbGVhbiB1cCB0aGUgY2hhaW4gdmFyaWFibGUgaWYgbm8gc3Vic2VxdWVudCBtb2RhbCBoYXMgb3ZlcndyaXR0ZW4gaXQuXG4gICAgICAgICAgICB2YXIgc2FtZVByb21pc2U7XG4gICAgICAgICAgICBzYW1lUHJvbWlzZSA9IHByb21pc2VDaGFpbiA9ICRxLmFsbChbcHJvbWlzZUNoYWluXSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiB0ZW1wbGF0ZUFuZFJlc29sdmVQcm9taXNlOyB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2U7IH0pXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIHJlc29sdmVTdWNjZXNzKHRwbEFuZFZhcnMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBtb2RhbFNjb3BlID0gKG1vZGFsT3B0aW9ucy5zY29wZSB8fCAkcm9vdFNjb3BlKS4kbmV3KCk7XG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kY2xvc2UgPSBtb2RhbEluc3RhbmNlLmNsb3NlO1xuICAgICAgICAgICAgICAgIG1vZGFsU2NvcGUuJGRpc21pc3MgPSBtb2RhbEluc3RhbmNlLmRpc21pc3M7XG5cbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbW9kYWxTY29wZS4kJHVpYkRlc3RydWN0aW9uU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsU2NvcGUuJGRpc21pc3MoJyR1aWJVbnNjaGVkdWxlZERlc3RydWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3RybEluc3RhbmNlLCBjdHJsTG9jYWxzID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVJdGVyID0gMTtcblxuICAgICAgICAgICAgICAgIC8vY29udHJvbGxlcnNcbiAgICAgICAgICAgICAgICBpZiAobW9kYWxPcHRpb25zLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGN0cmxMb2NhbHMuJHNjb3BlID0gbW9kYWxTY29wZTtcbiAgICAgICAgICAgICAgICAgIGN0cmxMb2NhbHMuJG1vZGFsSW5zdGFuY2UgPSBtb2RhbEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZGFsT3B0aW9ucy5yZXNvbHZlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmxMb2NhbHNba2V5XSA9IHRwbEFuZFZhcnNbcmVzb2x2ZUl0ZXIrK107XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgY3RybEluc3RhbmNlID0gJGNvbnRyb2xsZXIobW9kYWxPcHRpb25zLmNvbnRyb2xsZXIsIGN0cmxMb2NhbHMpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1vZGFsT3B0aW9ucy5jb250cm9sbGVyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGFsT3B0aW9ucy5iaW5kVG9Db250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5leHRlbmQoY3RybEluc3RhbmNlLCBtb2RhbFNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1vZGFsU2NvcGVbbW9kYWxPcHRpb25zLmNvbnRyb2xsZXJBc10gPSBjdHJsSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJG1vZGFsU3RhY2sub3Blbihtb2RhbEluc3RhbmNlLCB7XG4gICAgICAgICAgICAgICAgICBzY29wZTogbW9kYWxTY29wZSxcbiAgICAgICAgICAgICAgICAgIGRlZmVycmVkOiBtb2RhbFJlc3VsdERlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyRGVmZXJyZWQ6IG1vZGFsUmVuZGVyRGVmZXJyZWQsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiB0cGxBbmRWYXJzWzBdLFxuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBtb2RhbE9wdGlvbnMuYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgYmFja2Ryb3A6IG1vZGFsT3B0aW9ucy5iYWNrZHJvcCxcbiAgICAgICAgICAgICAgICAgIGtleWJvYXJkOiBtb2RhbE9wdGlvbnMua2V5Ym9hcmQsXG4gICAgICAgICAgICAgICAgICBiYWNrZHJvcENsYXNzOiBtb2RhbE9wdGlvbnMuYmFja2Ryb3BDbGFzcyxcbiAgICAgICAgICAgICAgICAgIHdpbmRvd0NsYXNzOiBtb2RhbE9wdGlvbnMud2luZG93Q2xhc3MsXG4gICAgICAgICAgICAgICAgICB3aW5kb3dUZW1wbGF0ZVVybDogbW9kYWxPcHRpb25zLndpbmRvd1RlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogbW9kYWxPcHRpb25zLnNpemUsXG4gICAgICAgICAgICAgICAgICBvcGVuZWRDbGFzczogbW9kYWxPcHRpb25zLm9wZW5lZENsYXNzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xuXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiByZXNvbHZlRXJyb3IocmVhc29uKSB7XG4gICAgICAgICAgICAgIG1vZGFsT3BlbmVkRGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgIG1vZGFsUmVzdWx0RGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9taXNlQ2hhaW4gPT09IHNhbWVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZUNoYWluID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtb2RhbEluc3RhbmNlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gJG1vZGFsO1xuICAgICAgICB9XVxuICAgIH07XG5cbiAgICByZXR1cm4gJG1vZGFsUHJvdmlkZXI7XG4gIH0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBhZ2luYXRpb24nLCBbXSlcbi5jb250cm9sbGVyKCdQYWdpbmF0aW9uQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJHBhcnNlKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIG5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfSwgLy8gbnVsbE1vZGVsQ3RybFxuICAgICAgc2V0TnVtUGFnZXMgPSAkYXR0cnMubnVtUGFnZXMgPyAkcGFyc2UoJGF0dHJzLm51bVBhZ2VzKS5hc3NpZ24gOiBhbmd1bGFyLm5vb3A7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfLCBjb25maWcpIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIGlmICgkYXR0cnMuaXRlbXNQZXJQYWdlKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5pdGVtc1BlclBhZ2UpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmLml0ZW1zUGVyUGFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pdGVtc1BlclBhZ2UgPSBjb25maWcuaXRlbXNQZXJQYWdlO1xuICAgIH1cblxuICAgICRzY29wZS4kd2F0Y2goJ3RvdGFsSXRlbXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJHdhdGNoKCd0b3RhbFBhZ2VzJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNldE51bVBhZ2VzKCRzY29wZS4kcGFyZW50LCB2YWx1ZSk7IC8vIFJlYWRvbmx5IHZhcmlhYmxlXG5cbiAgICAgIGlmICggJHNjb3BlLnBhZ2UgPiB2YWx1ZSApIHtcbiAgICAgICAgJHNjb3BlLnNlbGVjdFBhZ2UodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuY2FsY3VsYXRlVG90YWxQYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbFBhZ2VzID0gdGhpcy5pdGVtc1BlclBhZ2UgPCAxID8gMSA6IE1hdGguY2VpbCgkc2NvcGUudG90YWxJdGVtcyAvIHRoaXMuaXRlbXNQZXJQYWdlKTtcbiAgICByZXR1cm4gTWF0aC5tYXgodG90YWxQYWdlcyB8fCAwLCAxKTtcbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5wYWdlID0gcGFyc2VJbnQobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSwgMTApIHx8IDE7XG4gIH07XG5cbiAgJHNjb3BlLnNlbGVjdFBhZ2UgPSBmdW5jdGlvbihwYWdlLCBldnQpIHtcbiAgICBpZiAoZXZ0KSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgY2xpY2tBbGxvd2VkID0gISRzY29wZS5uZ0Rpc2FibGVkIHx8ICFldnQ7XG4gICAgaWYgKGNsaWNrQWxsb3dlZCAmJiAkc2NvcGUucGFnZSAhPT0gcGFnZSAmJiBwYWdlID4gMCAmJiBwYWdlIDw9ICRzY29wZS50b3RhbFBhZ2VzKSB7XG4gICAgICBpZiAoZXZ0ICYmIGV2dC50YXJnZXQpIHtcbiAgICAgICAgZXZ0LnRhcmdldC5ibHVyKCk7XG4gICAgICB9XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHBhZ2UpO1xuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAkc2NvcGVba2V5ICsgJ1RleHQnXSB8fCBzZWxmLmNvbmZpZ1trZXkgKyAnVGV4dCddO1xuICB9O1xuXG4gICRzY29wZS5ub1ByZXZpb3VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRzY29wZS5wYWdlID09PSAxO1xuICB9O1xuXG4gICRzY29wZS5ub05leHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJHNjb3BlLnBhZ2UgPT09ICRzY29wZS50b3RhbFBhZ2VzO1xuICB9O1xufV0pXG5cbi5jb25zdGFudCgncGFnaW5hdGlvbkNvbmZpZycsIHtcbiAgaXRlbXNQZXJQYWdlOiAxMCxcbiAgYm91bmRhcnlMaW5rczogZmFsc2UsXG4gIGRpcmVjdGlvbkxpbmtzOiB0cnVlLFxuICBmaXJzdFRleHQ6ICdGaXJzdCcsXG4gIHByZXZpb3VzVGV4dDogJ1ByZXZpb3VzJyxcbiAgbmV4dFRleHQ6ICdOZXh0JyxcbiAgbGFzdFRleHQ6ICdMYXN0JyxcbiAgcm90YXRlOiB0cnVlXG59KVxuXG4uZGlyZWN0aXZlKCdwYWdpbmF0aW9uJywgWyckcGFyc2UnLCAncGFnaW5hdGlvbkNvbmZpZycsIGZ1bmN0aW9uKCRwYXJzZSwgcGFnaW5hdGlvbkNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHNjb3BlOiB7XG4gICAgICB0b3RhbEl0ZW1zOiAnPScsXG4gICAgICBmaXJzdFRleHQ6ICdAJyxcbiAgICAgIHByZXZpb3VzVGV4dDogJ0AnLFxuICAgICAgbmV4dFRleHQ6ICdAJyxcbiAgICAgIGxhc3RUZXh0OiAnQCcsXG4gICAgICBuZ0Rpc2FibGVkOic9J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydwYWdpbmF0aW9uJywgJz9uZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1BhZ2luYXRpb25Db250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdwYWdpbmF0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWwnO1xuICAgIH0sXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgcGFnaW5hdGlvbkN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgaWYgKCFuZ01vZGVsQ3RybCkge1xuICAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nIGlmIG5vIG5nLW1vZGVsXG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgdmFyIG1heFNpemUgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5tYXhTaXplKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMubWF4U2l6ZSkgOiBwYWdpbmF0aW9uQ29uZmlnLm1heFNpemUsXG4gICAgICAgICAgcm90YXRlID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMucm90YXRlKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMucm90YXRlKSA6IHBhZ2luYXRpb25Db25maWcucm90YXRlO1xuICAgICAgc2NvcGUuYm91bmRhcnlMaW5rcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmJvdW5kYXJ5TGlua3MpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5ib3VuZGFyeUxpbmtzKSA6IHBhZ2luYXRpb25Db25maWcuYm91bmRhcnlMaW5rcztcbiAgICAgIHNjb3BlLmRpcmVjdGlvbkxpbmtzID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZGlyZWN0aW9uTGlua3MpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5kaXJlY3Rpb25MaW5rcykgOiBwYWdpbmF0aW9uQ29uZmlnLmRpcmVjdGlvbkxpbmtzO1xuXG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCBwYWdpbmF0aW9uQ29uZmlnKTtcblxuICAgICAgaWYgKGF0dHJzLm1heFNpemUpIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1heFNpemUpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIG1heFNpemUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgIHBhZ2luYXRpb25DdHJsLnJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHBhZ2Ugb2JqZWN0IHVzZWQgaW4gdGVtcGxhdGVcbiAgICAgIGZ1bmN0aW9uIG1ha2VQYWdlKG51bWJlciwgdGV4dCwgaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGFjdGl2ZTogaXNBY3RpdmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGFnZXMoY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMpIHtcbiAgICAgICAgdmFyIHBhZ2VzID0gW107XG5cbiAgICAgICAgLy8gRGVmYXVsdCBwYWdlIGxpbWl0c1xuICAgICAgICB2YXIgc3RhcnRQYWdlID0gMSwgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICAgIHZhciBpc01heFNpemVkID0gYW5ndWxhci5pc0RlZmluZWQobWF4U2l6ZSkgJiYgbWF4U2l6ZSA8IHRvdGFsUGFnZXM7XG5cbiAgICAgICAgLy8gcmVjb21wdXRlIGlmIG1heFNpemVcbiAgICAgICAgaWYgKGlzTWF4U2l6ZWQpIHtcbiAgICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICAvLyBDdXJyZW50IHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xuICAgICAgICAgICAgc3RhcnRQYWdlID0gTWF0aC5tYXgoY3VycmVudFBhZ2UgLSBNYXRoLmZsb29yKG1heFNpemUvMiksIDEpO1xuICAgICAgICAgICAgZW5kUGFnZSAgID0gc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDE7XG5cbiAgICAgICAgICAgIC8vIEFkanVzdCBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgICAgIGVuZFBhZ2UgICA9IHRvdGFsUGFnZXM7XG4gICAgICAgICAgICAgIHN0YXJ0UGFnZSA9IGVuZFBhZ2UgLSBtYXhTaXplICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVmlzaWJsZSBwYWdlcyBhcmUgcGFnaW5hdGVkIHdpdGggbWF4U2l6ZVxuICAgICAgICAgICAgc3RhcnRQYWdlID0gKChNYXRoLmNlaWwoY3VycmVudFBhZ2UgLyBtYXhTaXplKSAtIDEpICogbWF4U2l6ZSkgKyAxO1xuXG4gICAgICAgICAgICAvLyBBZGp1c3QgbGFzdCBwYWdlIGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDEsIHRvdGFsUGFnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBwYWdlIG51bWJlciBsaW5rc1xuICAgICAgICBmb3IgKHZhciBudW1iZXIgPSBzdGFydFBhZ2U7IG51bWJlciA8PSBlbmRQYWdlOyBudW1iZXIrKykge1xuICAgICAgICAgIHZhciBwYWdlID0gbWFrZVBhZ2UobnVtYmVyLCBudW1iZXIsIG51bWJlciA9PT0gY3VycmVudFBhZ2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgbGlua3MgdG8gbW92ZSBiZXR3ZWVuIHBhZ2Ugc2V0c1xuICAgICAgICBpZiAoaXNNYXhTaXplZCAmJiAhIHJvdGF0ZSkge1xuICAgICAgICAgIGlmIChzdGFydFBhZ2UgPiAxKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQYWdlU2V0ID0gbWFrZVBhZ2Uoc3RhcnRQYWdlIC0gMSwgJy4uLicsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnVuc2hpZnQocHJldmlvdXNQYWdlU2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZW5kUGFnZSA8IHRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UGFnZVNldCA9IG1ha2VQYWdlKGVuZFBhZ2UgKyAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMucHVzaChuZXh0UGFnZVNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhZ2VzO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBwYWdpbmF0aW9uQ3RybC5yZW5kZXI7XG4gICAgICBwYWdpbmF0aW9uQ3RybC5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ2luYWxSZW5kZXIoKTtcbiAgICAgICAgaWYgKHNjb3BlLnBhZ2UgPiAwICYmIHNjb3BlLnBhZ2UgPD0gc2NvcGUudG90YWxQYWdlcykge1xuICAgICAgICAgIHNjb3BlLnBhZ2VzID0gZ2V0UGFnZXMoc2NvcGUucGFnZSwgc2NvcGUudG90YWxQYWdlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb25zdGFudCgncGFnZXJDb25maWcnLCB7XG4gIGl0ZW1zUGVyUGFnZTogMTAsXG4gIHByZXZpb3VzVGV4dDogJ8KrIFByZXZpb3VzJyxcbiAgbmV4dFRleHQ6ICdOZXh0IMK7JyxcbiAgYWxpZ246IHRydWVcbn0pXG5cbi5kaXJlY3RpdmUoJ3BhZ2VyJywgWydwYWdlckNvbmZpZycsIGZ1bmN0aW9uKHBhZ2VyQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgc2NvcGU6IHtcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcbiAgICAgIHByZXZpb3VzVGV4dDogJ0AnLFxuICAgICAgbmV4dFRleHQ6ICdAJyxcbiAgICAgIG5nRGlzYWJsZWQ6ICc9J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydwYWdlcicsICc/bmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6ICdQYWdpbmF0aW9uQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAncGFnaW5hdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnZXIuaHRtbCc7XG4gICAgfSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBwYWdpbmF0aW9uQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBpZiAoIW5nTW9kZWxDdHJsKSB7XG4gICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgaWYgbm8gbmctbW9kZWxcbiAgICAgIH1cblxuICAgICAgc2NvcGUuYWxpZ24gPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5hbGlnbikgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmFsaWduKSA6IHBhZ2VyQ29uZmlnLmFsaWduO1xuICAgICAgcGFnaW5hdGlvbkN0cmwuaW5pdChuZ01vZGVsQ3RybCwgcGFnZXJDb25maWcpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZlYXR1cmVzIGFyZSBzdGlsbCBvdXRzdGFuZGluZzogYW5pbWF0aW9uIGFzIGFcbiAqIGZ1bmN0aW9uLCBwbGFjZW1lbnQgYXMgYSBmdW5jdGlvbiwgaW5zaWRlLCBzdXBwb3J0IGZvciBtb3JlIHRyaWdnZXJzIHRoYW5cbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGh0bWwgdG9vbHRpcHMsIGFuZCBzZWxlY3RvciBkZWxlZ2F0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRvb2x0aXAnLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicsICd1aS5ib290c3RyYXAuYmluZEh0bWwnXSlcblxuLyoqXG4gKiBUaGUgJHRvb2x0aXAgc2VydmljZSBjcmVhdGVzIHRvb2x0aXAtIGFuZCBwb3BvdmVyLWxpa2UgZGlyZWN0aXZlcyBhcyB3ZWxsIGFzXG4gKiBob3VzZXMgZ2xvYmFsIG9wdGlvbnMgZm9yIHRoZW0uXG4gKi9cbi5wcm92aWRlcignJHRvb2x0aXAnLCBmdW5jdGlvbigpIHtcbiAgLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyB0b29sdGlwIGFuZCBwb3BvdmVyLlxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgcG9wdXBEZWxheTogMCxcbiAgICB1c2VDb250ZW50RXhwOiBmYWxzZVxuICB9O1xuXG4gIC8vIERlZmF1bHQgaGlkZSB0cmlnZ2VycyBmb3IgZWFjaCBzaG93IHRyaWdnZXJcbiAgdmFyIHRyaWdnZXJNYXAgPSB7XG4gICAgJ21vdXNlZW50ZXInOiAnbW91c2VsZWF2ZScsXG4gICAgJ2NsaWNrJzogJ2NsaWNrJyxcbiAgICAnZm9jdXMnOiAnYmx1cicsXG4gICAgJ25vbmUnOiAnJ1xuICB9O1xuXG4gIC8vIFRoZSBvcHRpb25zIHNwZWNpZmllZCB0byB0aGUgcHJvdmlkZXIgZ2xvYmFsbHkuXG4gIHZhciBnbG9iYWxPcHRpb25zID0ge307XG5cbiAgLyoqXG4gICAqIGBvcHRpb25zKHt9KWAgYWxsb3dzIGdsb2JhbCBjb25maWd1cmF0aW9uIG9mIGFsbCB0b29sdGlwcyBpbiB0aGVcbiAgICogYXBwbGljYXRpb24uXG4gICAqXG4gICAqICAgdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCAnQXBwJywgWyd1aS5ib290c3RyYXAudG9vbHRpcCddLCBmdW5jdGlvbiggJHRvb2x0aXBQcm92aWRlciApIHtcbiAgICogICAgIC8vIHBsYWNlIHRvb2x0aXBzIGxlZnQgaW5zdGVhZCBvZiB0b3AgYnkgZGVmYXVsdFxuICAgKiAgICAgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zKCB7IHBsYWNlbWVudDogJ2xlZnQnIH0gKTtcbiAgICogICB9KTtcbiAgICovXG5cdHRoaXMub3B0aW9ucyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0YW5ndWxhci5leHRlbmQoZ2xvYmFsT3B0aW9ucywgdmFsdWUpO1xuXHR9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gZXh0ZW5kIHRoZSBzZXQgb2YgdHJpZ2dlciBtYXBwaW5ncyBhdmFpbGFibGUuIEUuZy46XG4gICAqXG4gICAqICAgJHRvb2x0aXBQcm92aWRlci5zZXRUcmlnZ2VycyggJ29wZW5UcmlnZ2VyJzogJ2Nsb3NlVHJpZ2dlcicgKTtcbiAgICovXG4gIHRoaXMuc2V0VHJpZ2dlcnMgPSBmdW5jdGlvbiBzZXRUcmlnZ2Vycyh0cmlnZ2Vycykge1xuICAgIGFuZ3VsYXIuZXh0ZW5kKHRyaWdnZXJNYXAsIHRyaWdnZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgdHJhbnNsYXRpbmcgY2FtZWwtY2FzZSB0byBzbmFrZS1jYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gc25ha2VfY2FzZShuYW1lKSB7XG4gICAgdmFyIHJlZ2V4cCA9IC9bQS1aXS9nO1xuICAgIHZhciBzZXBhcmF0b3IgPSAnLSc7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZShyZWdleHAsIGZ1bmN0aW9uKGxldHRlciwgcG9zKSB7XG4gICAgICByZXR1cm4gKHBvcyA/IHNlcGFyYXRvciA6ICcnKSArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdHVhbCBpbnN0YW5jZSBvZiB0aGUgJHRvb2x0aXAgc2VydmljZS5cbiAgICogVE9ETyBzdXBwb3J0IG11bHRpcGxlIHRyaWdnZXJzXG4gICAqL1xuICB0aGlzLiRnZXQgPSBbJyR3aW5kb3cnLCAnJGNvbXBpbGUnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyRwb3NpdGlvbicsICckaW50ZXJwb2xhdGUnLCAnJHJvb3RTY29wZScsICckcGFyc2UnLCBmdW5jdGlvbigkd2luZG93LCAkY29tcGlsZSwgJHRpbWVvdXQsICRkb2N1bWVudCwgJHBvc2l0aW9uLCAkaW50ZXJwb2xhdGUsICRyb290U2NvcGUsICRwYXJzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAkdG9vbHRpcCh0eXBlLCBwcmVmaXgsIGRlZmF1bHRUcmlnZ2VyU2hvdywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgZ2xvYmFsT3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBvYmplY3Qgb2Ygc2hvdyBhbmQgaGlkZSB0cmlnZ2Vycy5cbiAgICAgICAqXG4gICAgICAgKiBJZiBhIHRyaWdnZXIgaXMgc3VwcGxpZWQsXG4gICAgICAgKiBpdCBpcyB1c2VkIHRvIHNob3cgdGhlIHRvb2x0aXA7IG90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0cmlnZ2VyYFxuICAgICAgICogb3B0aW9uIHBhc3NlZCB0byB0aGUgYCR0b29sdGlwUHJvdmlkZXIub3B0aW9uc2AgbWV0aG9kOyBlbHNlIGl0IHdpbGxcbiAgICAgICAqIGRlZmF1bHQgdG8gdGhlIHRyaWdnZXIgc3VwcGxpZWQgdG8gdGhpcyBkaXJlY3RpdmUgZmFjdG9yeS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgaGlkZSB0cmlnZ2VyIGlzIGJhc2VkIG9uIHRoZSBzaG93IHRyaWdnZXIuIElmIHRoZSBgdHJpZ2dlcmAgb3B0aW9uXG4gICAgICAgKiB3YXMgcGFzc2VkIHRvIHRoZSBgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zYCBtZXRob2QsIGl0IHdpbGwgdXNlIHRoZVxuICAgICAgICogbWFwcGVkIHRyaWdnZXIgZnJvbSBgdHJpZ2dlck1hcGAgb3IgdGhlIHBhc3NlZCB0cmlnZ2VyIGlmIHRoZSBtYXAgaXNcbiAgICAgICAqIHVuZGVmaW5lZDsgb3RoZXJ3aXNlLCBpdCB1c2VzIHRoZSBgdHJpZ2dlck1hcGAgdmFsdWUgb2YgdGhlIHNob3dcbiAgICAgICAqIHRyaWdnZXI7IGVsc2UgaXQgd2lsbCBqdXN0IHVzZSB0aGUgc2hvdyB0cmlnZ2VyLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBnZXRUcmlnZ2Vycyh0cmlnZ2VyKSB7XG4gICAgICAgIHZhciBzaG93ID0gKHRyaWdnZXIgfHwgb3B0aW9ucy50cmlnZ2VyIHx8IGRlZmF1bHRUcmlnZ2VyU2hvdykuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIGhpZGUgPSBzaG93Lm1hcChmdW5jdGlvbih0cmlnZ2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXJNYXBbdHJpZ2dlcl0gfHwgdHJpZ2dlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2hvdzogc2hvdyxcbiAgICAgICAgICBoaWRlOiBoaWRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3RpdmVOYW1lID0gc25ha2VfY2FzZSh0eXBlKTtcblxuICAgICAgdmFyIHN0YXJ0U3ltID0gJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sKCk7XG4gICAgICB2YXIgZW5kU3ltID0gJGludGVycG9sYXRlLmVuZFN5bWJvbCgpO1xuICAgICAgdmFyIHRlbXBsYXRlID1cbiAgICAgICAgJzxkaXYgJysgZGlyZWN0aXZlTmFtZSArJy1wb3B1cCAnK1xuICAgICAgICAgICd0aXRsZT1cIicrc3RhcnRTeW0rJ3RpdGxlJytlbmRTeW0rJ1wiICcrXG4gICAgICAgICAgKG9wdGlvbnMudXNlQ29udGVudEV4cCA/XG4gICAgICAgICAgICAnY29udGVudC1leHA9XCJjb250ZW50RXhwKClcIiAnIDpcbiAgICAgICAgICAgICdjb250ZW50PVwiJytzdGFydFN5bSsnY29udGVudCcrZW5kU3ltKydcIiAnKSArXG4gICAgICAgICAgJ3BsYWNlbWVudD1cIicrc3RhcnRTeW0rJ3BsYWNlbWVudCcrZW5kU3ltKydcIiAnK1xuICAgICAgICAgICdwb3B1cC1jbGFzcz1cIicrc3RhcnRTeW0rJ3BvcHVwQ2xhc3MnK2VuZFN5bSsnXCIgJytcbiAgICAgICAgICAnYW5pbWF0aW9uPVwiYW5pbWF0aW9uXCIgJytcbiAgICAgICAgICAnaXMtb3Blbj1cImlzT3BlblwiJytcbiAgICAgICAgICAnb3JpZ2luLXNjb3BlPVwib3JpZ1Njb3BlXCIgJytcbiAgICAgICAgICAnPicrXG4gICAgICAgICc8L2Rpdj4nO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW0sIHRBdHRycykge1xuICAgICAgICAgIHZhciB0b29sdGlwTGlua2VyID0gJGNvbXBpbGUoIHRlbXBsYXRlICk7XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbGluayhzY29wZSwgZWxlbWVudCwgYXR0cnMsIHRvb2x0aXBDdHJsKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcDtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTGlua2VkU2NvcGU7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgcG9wdXBUaW1lb3V0O1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHZhciBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZChvcHRpb25zLmFwcGVuZFRvQm9keSkgPyBvcHRpb25zLmFwcGVuZFRvQm9keSA6IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJzID0gZ2V0VHJpZ2dlcnModW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHZhciBoYXNFbmFibGVFeHAgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRyc1twcmVmaXggKyAnRW5hYmxlJ10pO1xuICAgICAgICAgICAgdmFyIHR0U2NvcGUgPSBzY29wZS4kbmV3KHRydWUpO1xuICAgICAgICAgICAgdmFyIHJlcG9zaXRpb25TY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc09wZW5FeHAgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRyc1twcmVmaXggKyAnSXNPcGVuJ10pID8gJHBhcnNlKGF0dHJzW3ByZWZpeCArICdJc09wZW4nXSkgOiBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uVG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIXRvb2x0aXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgaWYgKCFwb3NpdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbmluZyBhbmQgYm94IHNpemUgZm9yIGNvcnJlY3Qgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICB0b29sdGlwLmNzcyh7IHRvcDogMCwgbGVmdDogMCwgd2lkdGg6ICdhdXRvJywgaGVpZ2h0OiAnYXV0bycgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciB0dEJveCA9ICRwb3NpdGlvbi5wb3NpdGlvbih0b29sdGlwKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0dENzcyA9ICRwb3NpdGlvbi5wb3NpdGlvbkVsZW1lbnRzKGVsZW1lbnQsIHRvb2x0aXAsIHR0U2NvcGUucGxhY2VtZW50LCBhcHBlbmRUb0JvZHkpO1xuICAgICAgICAgICAgICAgICAgdHRDc3MudG9wICs9ICdweCc7XG4gICAgICAgICAgICAgICAgICB0dENzcy5sZWZ0ICs9ICdweCc7XG5cbiAgICAgICAgICAgICAgICAgIHR0Q3NzLndpZHRoID0gdHRCb3gud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgdHRDc3MuaGVpZ2h0ID0gdHRCb3guaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgLy8gTm93IHNldCB0aGUgY2FsY3VsYXRlZCBwb3NpdGlvbmluZyBhbmQgc2l6ZS5cbiAgICAgICAgICAgICAgICAgIHRvb2x0aXAuY3NzKHR0Q3NzKTtcblxuICAgICAgICAgICAgICAgICAgcG9zaXRpb25UaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBjb3JyZWN0IHNjb3BlIHRvIGFsbG93IHRyYW5zY2x1c2lvbiBsYXRlclxuICAgICAgICAgICAgdHRTY29wZS5vcmlnU2NvcGUgPSBzY29wZTtcblxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgaXMgbm90IG9wZW4uXG4gICAgICAgICAgICAvLyBUT0RPIGFkZCBhYmlsaXR5IHRvIHN0YXJ0IHRvb2x0aXAgb3BlbmVkXG4gICAgICAgICAgICB0dFNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b2dnbGVUb29sdGlwQmluZCgpIHtcbiAgICAgICAgICAgICAgaWYgKCF0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHNob3dUb29sdGlwQmluZCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwQmluZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXAgd2l0aCBkZWxheSBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBzaG93IGl0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBmdW5jdGlvbiBzaG93VG9vbHRpcEJpbmQoKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNFbmFibGVFeHAgJiYgIXNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCArICdFbmFibGUnXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcmVwYXJlVG9vbHRpcCgpO1xuXG4gICAgICAgICAgICAgIGlmICh0dFNjb3BlLnBvcHVwRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB0b29sdGlwIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCB0byBwb3AtdXAuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGlmIHNob3cgaXMgdHJpZ2dlcmVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBhbnkgaGlkZSBpcyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKCFwb3B1cFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgIHBvcHVwVGltZW91dCA9ICR0aW1lb3V0KHNob3csIHR0U2NvcGUucG9wdXBEZWxheSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaG93KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaGlkZVRvb2x0aXBCaW5kICgpIHtcbiAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXAgcG9wdXAgZWxlbWVudC5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgICAgICAgIHBvcHVwVGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHJlbW92ZSB0cmFuc2l0aW9uLCB3ZSBtdXN0IGNhbmNlbCBpdCwgbGVzdCB0aGVcbiAgICAgICAgICAgICAgLy8gdG9vbHRpcCBiZSBteXN0ZXJpb3VzbHkgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRyYW5zaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGVtcHR5IHRvb2x0aXBzLlxuICAgICAgICAgICAgICBpZiAoIShvcHRpb25zLnVzZUNvbnRlbnRFeHAgPyB0dFNjb3BlLmNvbnRlbnRFeHAoKSA6IHR0U2NvcGUuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhci5ub29wO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3JlYXRlVG9vbHRpcCgpO1xuXG4gICAgICAgICAgICAgIC8vIEFuZCBzaG93IHRoZSB0b29sdGlwLlxuICAgICAgICAgICAgICB0dFNjb3BlLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChpc09wZW5FeHApIHtcbiAgICAgICAgICAgICAgICBpc09wZW5FeHAuYXNzaWduKHR0U2NvcGUub3JpZ1Njb3BlLCB0dFNjb3BlLmlzT3Blbik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAgIHR0U2NvcGUuJGFwcGx5KCk7IC8vIGRpZ2VzdCByZXF1aXJlZCBhcyAkYXBwbHkgaXMgbm90IGNhbGxlZFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdG9vbHRpcC5jc3MoeyBkaXNwbGF5OiAnYmxvY2snIH0pO1xuXG4gICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwIHBvcHVwIGVsZW1lbnQuXG4gICAgICAgICAgICBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgICAgICAvLyBGaXJzdCB0aGluZ3MgZmlyc3Q6IHdlIGRvbid0IHNob3cgaXQgYW55bW9yZS5cbiAgICAgICAgICAgICAgdHRTY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGlzT3BlbkV4cCkge1xuICAgICAgICAgICAgICAgIGlzT3BlbkV4cC5hc3NpZ24odHRTY29wZS5vcmlnU2NvcGUsIHR0U2NvcGUuaXNPcGVuKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vaWYgdG9vbHRpcCBpcyBnb2luZyB0byBiZSBzaG93biBhZnRlciBkZWxheSwgd2UgbXVzdCBjYW5jZWwgdGhpc1xuICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwocG9wdXBUaW1lb3V0KTtcbiAgICAgICAgICAgICAgcG9wdXBUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwocG9zaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgcG9zaXRpb25UaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAvLyBBbmQgbm93IHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBET00uIEhvd2V2ZXIsIGlmIHdlIGhhdmUgYW5pbWF0aW9uLCB3ZVxuICAgICAgICAgICAgICAvLyBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvIGV4cGlyZSBiZWZvcmVoYW5kLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIHBvcnQgb2YgdGhlIHRyYW5zaXRpb25zIGxpYnJhcnkuXG4gICAgICAgICAgICAgIGlmICh0dFNjb3BlLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNpdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lb3V0ID0gJHRpbWVvdXQocmVtb3ZlVG9vbHRpcCwgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSB0b29sdGlwIGVsZW1lbnQgcGVyIGRpcmVjdGl2ZSBzaG93biBhdCBvbmNlLlxuICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUgPSB0dFNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAgICAgdG9vbHRpcCA9IHRvb2x0aXBMaW5rZXIodG9vbHRpcExpbmtlZFNjb3BlLCBmdW5jdGlvbih0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICAgICAgICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5hcHBlbmQodG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWZ0ZXIodG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy51c2VDb250ZW50RXhwKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlLiR3YXRjaCgnY29udGVudEV4cCgpJywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFyZXBvc2l0aW9uU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9zaXRpb25TY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUuJCRwb3N0RGlnZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlcG9zaXRpb25TY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVUb29sdGlwKCkge1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodG9vbHRpcExpbmtlZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlVG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgcHJlcFBvcHVwQ2xhc3MoKTtcbiAgICAgICAgICAgICAgcHJlcFBsYWNlbWVudCgpO1xuICAgICAgICAgICAgICBwcmVwUG9wdXBEZWxheSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0dFNjb3BlLmNvbnRlbnRFeHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLiRldmFsKGF0dHJzW3R5cGVdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT2JzZXJ2ZSB0aGUgcmVsZXZhbnQgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVzZUNvbnRlbnRFeHApIHtcbiAgICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUodHlwZSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF2YWwgJiYgdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2Rpc2FibGVkJywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIGlmIChwb3B1cFRpbWVvdXQgJiYgdmFsKSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHBvcHVwVGltZW91dCk7XG4gICAgICAgICAgICAgICAgcG9wdXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh2YWwgJiYgdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZShwcmVmaXggKyAnVGl0bGUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgdHRTY29wZS50aXRsZSA9IHZhbDtcbiAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUocHJlZml4ICsgJ1BsYWNlbWVudCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAodHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBwcmVwUGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNPcGVuRXhwKSB7XG4gICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChpc09wZW5FeHAsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICB0b2dnbGVUb29sdGlwQmluZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBQb3B1cENsYXNzKCkge1xuICAgICAgICAgICAgICB0dFNjb3BlLnBvcHVwQ2xhc3MgPSBhdHRyc1twcmVmaXggKyAnQ2xhc3MnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcFBsYWNlbWVudCgpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IGF0dHJzW3ByZWZpeCArICdQbGFjZW1lbnQnXTtcbiAgICAgICAgICAgICAgdHRTY29wZS5wbGFjZW1lbnQgPSBhbmd1bGFyLmlzRGVmaW5lZCh2YWwpID8gdmFsIDogb3B0aW9ucy5wbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBQb3B1cERlbGF5KCkge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gYXR0cnNbcHJlZml4ICsgJ1BvcHVwRGVsYXknXTtcbiAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgICAgICAgIHR0U2NvcGUucG9wdXBEZWxheSA9ICFpc05hTihkZWxheSkgPyBkZWxheSA6IG9wdGlvbnMucG9wdXBEZWxheTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVucmVnaXN0ZXJUcmlnZ2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0cmlnZ2Vycy5zaG93LmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudW5iaW5kKHRyaWdnZXIsIHNob3dUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0cmlnZ2Vycy5oaWRlLmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudW5iaW5kKHRyaWdnZXIsIGhpZGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcFRyaWdnZXJzKCkge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gYXR0cnNbcHJlZml4ICsgJ1RyaWdnZXInXTtcbiAgICAgICAgICAgICAgdW5yZWdpc3RlclRyaWdnZXJzKCk7XG5cbiAgICAgICAgICAgICAgdHJpZ2dlcnMgPSBnZXRUcmlnZ2Vycyh2YWwpO1xuXG4gICAgICAgICAgICAgIGlmICh0cmlnZ2Vycy5zaG93ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2Vycy5zaG93LmZvckVhY2goZnVuY3Rpb24odHJpZ2dlciwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAvLyBVc2luZyByYXcgYWRkRXZlbnRMaXN0ZW5lciBkdWUgdG8ganFMaXRlL2pRdWVyeSBidWcgLSAjNDA2MFxuICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXIgPT09IHRyaWdnZXJzLmhpZGVbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIodHJpZ2dlciwgdG9nZ2xlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2VyLCBzaG93VG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIodHJpZ2dlcnMuaGlkZVtpZHhdLCBoaWRlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwVHJpZ2dlcnMoKTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCArICdBbmltYXRpb24nXSk7XG4gICAgICAgICAgICB0dFNjb3BlLmFuaW1hdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGFuaW1hdGlvbikgPyAhIWFuaW1hdGlvbiA6IG9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5VmFsID0gc2NvcGUuJGV2YWwoYXR0cnNbcHJlZml4ICsgJ0FwcGVuZFRvQm9keSddKTtcbiAgICAgICAgICAgIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGFwcGVuZFRvQm9keVZhbCkgPyBhcHBlbmRUb0JvZHlWYWwgOiBhcHBlbmRUb0JvZHk7XG5cbiAgICAgICAgICAgIC8vIGlmIGEgdG9vbHRpcCBpcyBhdHRhY2hlZCB0byA8Ym9keT4gd2UgbmVlZCB0byByZW1vdmUgaXQgb25cbiAgICAgICAgICAgIC8vIGxvY2F0aW9uIGNoYW5nZSBhcyBpdHMgcGFyZW50IHNjb3BlIHdpbGwgcHJvYmFibHkgbm90IGJlIGRlc3Ryb3llZFxuICAgICAgICAgICAgLy8gYnkgdGhlIGNoYW5nZS5cbiAgICAgICAgICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICAgICAgc2NvcGUuJG9uKCckbG9jYXRpb25DaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24gY2xvc2VUb29sdGlwT25Mb2NhdGlvbkNoYW5nZVN1Y2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgZGVzdHJveWVkIGFuZCByZW1vdmVkLlxuICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uIG9uRGVzdHJveVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChwb3B1cFRpbWVvdXQpO1xuICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwocG9zaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgdW5yZWdpc3RlclRyaWdnZXJzKCk7XG4gICAgICAgICAgICAgIHJlbW92ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgdHRTY29wZSA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH1dO1xufSlcblxuLy8gVGhpcyBpcyBtb3N0bHkgbmdJbmNsdWRlIGNvZGUgYnV0IHdpdGggYSBjdXN0b20gc2NvcGVcbi5kaXJlY3RpdmUoJ3Rvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGUnLCBbXG4gICAgICAgICAnJGFuaW1hdGUnLCAnJHNjZScsICckY29tcGlsZScsICckdGVtcGxhdGVSZXF1ZXN0JyxcbmZ1bmN0aW9uICgkYW5pbWF0ZSAsICAkc2NlICwgICRjb21waWxlICwgICR0ZW1wbGF0ZVJlcXVlc3QpIHtcbiAgcmV0dXJuIHtcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbSwgYXR0cnMpIHtcbiAgICAgIHZhciBvcmlnU2NvcGUgPSBzY29wZS4kZXZhbChhdHRycy50b29sdGlwVGVtcGxhdGVUcmFuc2NsdWRlU2NvcGUpO1xuXG4gICAgICB2YXIgY2hhbmdlQ291bnRlciA9IDAsXG4gICAgICAgIGN1cnJlbnRTY29wZSxcbiAgICAgICAgcHJldmlvdXNFbGVtZW50LFxuICAgICAgICBjdXJyZW50RWxlbWVudDtcblxuICAgICAgdmFyIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzRWxlbWVudCkge1xuICAgICAgICAgIHByZXZpb3VzRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50U2NvcGUpIHtcbiAgICAgICAgICBjdXJyZW50U2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICBjdXJyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICRhbmltYXRlLmxlYXZlKGN1cnJlbnRFbGVtZW50KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiR3YXRjaCgkc2NlLnBhcnNlQXNSZXNvdXJjZVVybChhdHRycy50b29sdGlwVGVtcGxhdGVUcmFuc2NsdWRlKSwgZnVuY3Rpb24oc3JjKSB7XG4gICAgICAgIHZhciB0aGlzQ2hhbmdlSWQgPSArK2NoYW5nZUNvdW50ZXI7XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIC8vc2V0IHRoZSAybmQgcGFyYW0gdG8gdHJ1ZSB0byBpZ25vcmUgdGhlIHRlbXBsYXRlIHJlcXVlc3QgZXJyb3Igc28gdGhhdCB0aGUgaW5uZXJcbiAgICAgICAgICAvL2NvbnRlbnRzIGFuZCBzY29wZSBjYW4gYmUgY2xlYW5lZCB1cC5cbiAgICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KHNyYywgdHJ1ZSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHRoaXNDaGFuZ2VJZCAhPT0gY2hhbmdlQ291bnRlcikgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHZhciBuZXdTY29wZSA9IG9yaWdTY29wZS4kbmV3KCk7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSByZXNwb25zZTtcblxuICAgICAgICAgICAgdmFyIGNsb25lID0gJGNvbXBpbGUodGVtcGxhdGUpKG5ld1Njb3BlLCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XG4gICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCBlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBuZXdTY29wZTtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY2xvbmU7XG5cbiAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50TG9hZGVkJywgc3JjKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQ2hhbmdlSWQgPT09IGNoYW5nZUNvdW50ZXIpIHtcbiAgICAgICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xuICAgICAgICAgICAgICBzY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50RXJyb3InLCBzcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRSZXF1ZXN0ZWQnLCBzcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KTtcbiAgICB9XG4gIH07XG59XSlcblxuLyoqXG4gKiBOb3RlIHRoYXQgaXQncyBpbnRlbnRpb25hbCB0aGF0IHRoZXNlIGNsYXNzZXMgYXJlICpub3QqIGFwcGxpZWQgdGhyb3VnaCAkYW5pbWF0ZS5cbiAqIFRoZXkgbXVzdCBub3QgYmUgYW5pbWF0ZWQgYXMgdGhleSdyZSBleHBlY3RlZCB0byBiZSBwcmVzZW50IG9uIHRoZSB0b29sdGlwIG9uXG4gKiBpbml0aWFsaXphdGlvbi5cbiAqL1xuLmRpcmVjdGl2ZSgndG9vbHRpcENsYXNzZXMnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgaWYgKHNjb3BlLnBsYWNlbWVudCkge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHNjb3BlLnBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUucG9wdXBDbGFzcykge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHNjb3BlLnBvcHVwQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlLmFuaW1hdGlvbigpKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoYXR0cnMudG9vbHRpcEFuaW1hdGlvbkNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd0b29sdGlwUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXAnLCBbICckdG9vbHRpcCcsIGZ1bmN0aW9uKCR0b29sdGlwKSB7XG4gIHJldHVybiAkdG9vbHRpcCgndG9vbHRpcCcsICd0b29sdGlwJywgJ21vdXNlZW50ZXInKTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0b29sdGlwVGVtcGxhdGVQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHsgY29udGVudEV4cDogJyYnLCBwbGFjZW1lbnQ6ICdAJywgcG9wdXBDbGFzczogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicsXG4gICAgICBvcmlnaW5TY29wZTogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBUZW1wbGF0ZScsIFsnJHRvb2x0aXAnLCBmdW5jdGlvbigkdG9vbHRpcCkge1xuICByZXR1cm4gJHRvb2x0aXAoJ3Rvb2x0aXBUZW1wbGF0ZScsICd0b29sdGlwJywgJ21vdXNlZW50ZXInLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0b29sdGlwSHRtbFBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIHBsYWNlbWVudDogJ0AnLCBwb3B1cENsYXNzOiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBIdG1sJywgWyckdG9vbHRpcCcsIGZ1bmN0aW9uKCR0b29sdGlwKSB7XG4gIHJldHVybiAkdG9vbHRpcCgndG9vbHRpcEh0bWwnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJywge1xuICAgIHVzZUNvbnRlbnRFeHA6IHRydWVcbiAgfSk7XG59XSlcblxuLypcbkRlcHJlY2F0ZWRcbiovXG4uZGlyZWN0aXZlKCd0b29sdGlwSHRtbFVuc2FmZVBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZTogeyBjb250ZW50OiAnQCcsIHBsYWNlbWVudDogJ0AnLCBwb3B1cENsYXNzOiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtdW5zYWZlLXBvcHVwLmh0bWwnXG4gIH07XG59KVxuXG4udmFsdWUoJ3Rvb2x0aXBIdG1sVW5zYWZlU3VwcHJlc3NEZXByZWNhdGVkJywgZmFsc2UpXG4uZGlyZWN0aXZlKCd0b29sdGlwSHRtbFVuc2FmZScsIFtcbiAgICAgICAgICAnJHRvb2x0aXAnLCAndG9vbHRpcEh0bWxVbnNhZmVTdXBwcmVzc0RlcHJlY2F0ZWQnLCAnJGxvZycsXG5mdW5jdGlvbigkdG9vbHRpcCAsICB0b29sdGlwSHRtbFVuc2FmZVN1cHByZXNzRGVwcmVjYXRlZCAsICAkbG9nKSB7XG4gIGlmICghdG9vbHRpcEh0bWxVbnNhZmVTdXBwcmVzc0RlcHJlY2F0ZWQpIHtcbiAgICAkbG9nLndhcm4oJ3Rvb2x0aXAtaHRtbC11bnNhZmUgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB0b29sdGlwLWh0bWwgb3IgdG9vbHRpcC10ZW1wbGF0ZSBpbnN0ZWFkLicpO1xuICB9XG4gIHJldHVybiAkdG9vbHRpcCgndG9vbHRpcEh0bWxVbnNhZmUnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJyk7XG59XSk7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmZWF0dXJlcyBhcmUgc3RpbGwgb3V0c3RhbmRpbmc6IHBvcHVwIGRlbGF5LCBhbmltYXRpb24gYXMgYVxuICogZnVuY3Rpb24sIHBsYWNlbWVudCBhcyBhIGZ1bmN0aW9uLCBpbnNpZGUsIHN1cHBvcnQgZm9yIG1vcmUgdHJpZ2dlcnMgdGhhblxuICoganVzdCBtb3VzZSBlbnRlci9sZWF2ZSwgYW5kIHNlbGVjdG9yIGRlbGVnYXRhdGlvbi5cbiAqL1xuYW5ndWxhci5tb2R1bGUoICd1aS5ib290c3RyYXAucG9wb3ZlcicsIFsndWkuYm9vdHN0cmFwLnRvb2x0aXAnXSlcblxuLmRpcmVjdGl2ZSgncG9wb3ZlclRlbXBsYXRlUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IHRpdGxlOiAnQCcsIGNvbnRlbnRFeHA6ICcmJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnLFxuICAgICAgb3JpZ2luU2NvcGU6ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCdwb3BvdmVyVGVtcGxhdGUnLCBbJyR0b29sdGlwJywgZnVuY3Rpb24oJHRvb2x0aXApIHtcbiAgcmV0dXJuICR0b29sdGlwKCdwb3BvdmVyVGVtcGxhdGUnLCAncG9wb3ZlcicsICdjbGljaycsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3BvcG92ZXJIdG1sUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJywgdGl0bGU6ICdAJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgncG9wb3Zlckh0bWwnLCBbJyR0b29sdGlwJywgZnVuY3Rpb24oJHRvb2x0aXApIHtcbiAgcmV0dXJuICR0b29sdGlwKCAncG9wb3Zlckh0bWwnLCAncG9wb3ZlcicsICdjbGljaycsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3BvcG92ZXJQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHsgdGl0bGU6ICdAJywgY29udGVudDogJ0AnLCBwbGFjZW1lbnQ6ICdAJywgcG9wdXBDbGFzczogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgncG9wb3ZlcicsIFsnJHRvb2x0aXAnLCBmdW5jdGlvbigkdG9vbHRpcCkge1xuICByZXR1cm4gJHRvb2x0aXAoICdwb3BvdmVyJywgJ3BvcG92ZXInLCAnY2xpY2snICk7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXInLCBbXSlcblxuLmNvbnN0YW50KCdwcm9ncmVzc0NvbmZpZycsIHtcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgbWF4OiAxMDBcbn0pXG5cbi52YWx1ZSgnJHByb2dyZXNzU3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG5cbi5jb250cm9sbGVyKCdQcm9ncmVzc0NvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAncHJvZ3Jlc3NDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgcHJvZ3Jlc3NDb25maWcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYW5pbWF0ZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hbmltYXRlKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hbmltYXRlKSA6IHByb2dyZXNzQ29uZmlnLmFuaW1hdGU7XG5cbiAgdGhpcy5iYXJzID0gW107XG4gICRzY29wZS5tYXggPSBhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUubWF4KSA/ICRzY29wZS5tYXggOiBwcm9ncmVzc0NvbmZpZy5tYXg7XG5cbiAgdGhpcy5hZGRCYXIgPSBmdW5jdGlvbihiYXIsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWFuaW1hdGUpIHtcbiAgICAgIGVsZW1lbnQuY3NzKHsndHJhbnNpdGlvbic6ICdub25lJ30pO1xuICAgIH1cblxuICAgIHRoaXMuYmFycy5wdXNoKGJhcik7XG5cbiAgICBiYXIubWF4ID0gJHNjb3BlLm1heDtcblxuICAgIGJhci4kd2F0Y2goJ3ZhbHVlJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcbiAgICB9KTtcblxuICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGJhci5wZXJjZW50ID0gKygxMDAgKiBiYXIudmFsdWUgLyBiYXIubWF4KS50b0ZpeGVkKDIpO1xuXG4gICAgICB2YXIgdG90YWxQZXJjZW50YWdlID0gc2VsZi5iYXJzLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgYmFyKSB7XG4gICAgICAgIHJldHVybiB0b3RhbCArIGJhci5wZXJjZW50O1xuICAgICAgfSwgMCk7XG5cbiAgICAgIGlmICh0b3RhbFBlcmNlbnRhZ2UgPiAxMDApIHtcbiAgICAgICAgYmFyLnBlcmNlbnQgLT0gdG90YWxQZXJjZW50YWdlIC0gMTAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBiYXIuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICBzZWxmLnJlbW92ZUJhcihiYXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlQmFyID0gZnVuY3Rpb24oYmFyKSB7XG4gICAgICB0aGlzLmJhcnMuc3BsaWNlKHRoaXMuYmFycy5pbmRleE9mKGJhciksIDEpO1xuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ21heCcsIGZ1bmN0aW9uKG1heCkge1xuICAgIHNlbGYuYmFycy5mb3JFYWNoKGZ1bmN0aW9uKGJhcikge1xuICAgICAgYmFyLm1heCA9ICRzY29wZS5tYXg7XG4gICAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlKCk7XG4gICAgfSk7XG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlByb2dyZXNzJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIGNvbnRyb2xsZXI6ICdQcm9ncmVzc0NvbnRyb2xsZXInLFxuICAgIHJlcXVpcmU6ICd1aWJQcm9ncmVzcycsXG4gICAgc2NvcGU6IHtcbiAgICAgIG1heDogJz0/J1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgncHJvZ3Jlc3MnLCBbJyRsb2cnLCAnJHByb2dyZXNzU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJHByb2dyZXNzU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIGNvbnRyb2xsZXI6ICdQcm9ncmVzc0NvbnRyb2xsZXInLFxuICAgIHJlcXVpcmU6ICdwcm9ncmVzcycsXG4gICAgc2NvcGU6IHtcbiAgICAgIG1heDogJz0/J1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgkcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdwcm9ncmVzcyBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1wcm9ncmVzcyBpbnN0ZWFkJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYkJhcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnXnVpYlByb2dyZXNzJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcbiAgICAgIHByb2dyZXNzQ3RybC5hZGRCYXIoc2NvcGUsIGVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ2JhcicsIFsnJGxvZycsICckcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVxdWlyZTogJ15wcm9ncmVzcycsXG4gICAgc2NvcGU6IHtcbiAgICAgIHZhbHVlOiAnPScsXG4gICAgICB0eXBlOiAnQCdcbiAgICB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgcHJvZ3Jlc3NDdHJsKSB7XG4gICAgICBpZiAoJHByb2dyZXNzU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybignYmFyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLWJhciBpbnN0ZWFkJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmVzc0N0cmwuYWRkQmFyKHNjb3BlLCBlbGVtZW50KTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgncHJvZ3Jlc3NiYXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ1Byb2dyZXNzQ29udHJvbGxlcicsXG4gICAgc2NvcGU6IHtcbiAgICAgIHZhbHVlOiAnPScsXG4gICAgICBtYXg6ICc9PycsXG4gICAgICB0eXBlOiAnQCdcbiAgICB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcbiAgICAgIHByb2dyZXNzQ3RybC5hZGRCYXIoc2NvcGUsIGFuZ3VsYXIuZWxlbWVudChlbGVtZW50LmNoaWxkcmVuKClbMF0pKTtcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5yYXRpbmcnLCBbXSlcblxuLmNvbnN0YW50KCdyYXRpbmdDb25maWcnLCB7XG4gIG1heDogNSxcbiAgc3RhdGVPbjogbnVsbCxcbiAgc3RhdGVPZmY6IG51bGwsXG4gIHRpdGxlcyA6IFsnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnXVxufSlcblxuLmNvbnRyb2xsZXIoJ1JhdGluZ0NvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAncmF0aW5nQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIHJhdGluZ0NvbmZpZykge1xuICB2YXIgbmdNb2RlbEN0cmwgID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8pIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcbiAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gdGhpcy5yZW5kZXI7XG5cbiAgICBuZ01vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoYW5ndWxhci5pc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPDwgMCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMuc3RhdGVPbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9uKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zdGF0ZU9uKSA6IHJhdGluZ0NvbmZpZy5zdGF0ZU9uO1xuICAgIHRoaXMuc3RhdGVPZmYgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc3RhdGVPZmYpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnN0YXRlT2ZmKSA6IHJhdGluZ0NvbmZpZy5zdGF0ZU9mZjtcbiAgICB2YXIgdG1wVGl0bGVzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnRpdGxlcykgID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnRpdGxlcykgOiByYXRpbmdDb25maWcudGl0bGVzIDsgICAgXG4gICAgdGhpcy50aXRsZXMgPSBhbmd1bGFyLmlzQXJyYXkodG1wVGl0bGVzKSAmJiB0bXBUaXRsZXMubGVuZ3RoID4gMCA/XG4gICAgICB0bXBUaXRsZXMgOiByYXRpbmdDb25maWcudGl0bGVzO1xuICAgIFxuICAgIHZhciByYXRpbmdTdGF0ZXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucmF0aW5nU3RhdGVzKSA/XG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucmF0aW5nU3RhdGVzKSA6XG4gICAgICBuZXcgQXJyYXkoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1heCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubWF4KSA6IHJhdGluZ0NvbmZpZy5tYXgpO1xuICAgICRzY29wZS5yYW5nZSA9IHRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHMocmF0aW5nU3RhdGVzKTtcbiAgfTtcblxuICB0aGlzLmJ1aWxkVGVtcGxhdGVPYmplY3RzID0gZnVuY3Rpb24oc3RhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzdGF0ZXNbaV0gPSBhbmd1bGFyLmV4dGVuZCh7IGluZGV4OiBpIH0sIHsgc3RhdGVPbjogdGhpcy5zdGF0ZU9uLCBzdGF0ZU9mZjogdGhpcy5zdGF0ZU9mZiwgdGl0bGU6IHRoaXMuZ2V0VGl0bGUoaSkgfSwgc3RhdGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfTtcbiAgXG4gIHRoaXMuZ2V0VGl0bGUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnRpdGxlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRpdGxlc1tpbmRleF07XG4gICAgfVxuICB9O1xuICBcbiAgJHNjb3BlLnJhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghJHNjb3BlLnJlYWRvbmx5ICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gJHNjb3BlLnJhbmdlLmxlbmd0aCkge1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlID09PSB2YWx1ZSA/IDAgOiB2YWx1ZSk7XG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5lbnRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCEkc2NvcGUucmVhZG9ubHkpIHtcbiAgICAgICRzY29wZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAkc2NvcGUub25Ib3Zlcih7dmFsdWU6IHZhbHVlfSk7XG4gIH07XG5cbiAgJHNjb3BlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnZhbHVlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZTtcbiAgICAkc2NvcGUub25MZWF2ZSgpO1xuICB9O1xuXG4gICRzY29wZS5vbktleWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoLygzN3wzOHwzOXw0MCkvLnRlc3QoZXZ0LndoaWNoKSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAkc2NvcGUucmF0ZSgkc2NvcGUudmFsdWUgKyAoZXZ0LndoaWNoID09PSAzOCB8fCBldnQud2hpY2ggPT09IDM5ID8gMSA6IC0xKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnZhbHVlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZTtcbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdyYXRpbmcnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXF1aXJlOiBbJ3JhdGluZycsICduZ01vZGVsJ10sXG4gICAgc2NvcGU6IHtcbiAgICAgIHJlYWRvbmx5OiAnPT8nLFxuICAgICAgb25Ib3ZlcjogJyYnLFxuICAgICAgb25MZWF2ZTogJyYnXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiAnUmF0aW5nQ29udHJvbGxlcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWwnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIHJhdGluZ0N0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcbiAgICAgIHJhdGluZ0N0cmwuaW5pdCggbmdNb2RlbEN0cmwgKTtcbiAgICB9XG4gIH07XG59KTtcblxuXG4vKipcbiAqIEBuZ2RvYyBvdmVydmlld1xuICogQG5hbWUgdWkuYm9vdHN0cmFwLnRhYnNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuZ3VsYXJKUyB2ZXJzaW9uIG9mIHRoZSB0YWJzIGRpcmVjdGl2ZS5cbiAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRhYnMnLCBbXSlcblxuLmNvbnRyb2xsZXIoJ1RhYnNldENvbnRyb2xsZXInLCBbJyRzY29wZScsIGZ1bmN0aW9uIFRhYnNldEN0cmwoJHNjb3BlKSB7XG4gIHZhciBjdHJsID0gdGhpcyxcbiAgICAgIHRhYnMgPSBjdHJsLnRhYnMgPSAkc2NvcGUudGFicyA9IFtdO1xuXG4gIGN0cmwuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0ZWRUYWIpIHtcbiAgICBhbmd1bGFyLmZvckVhY2godGFicywgZnVuY3Rpb24odGFiKSB7XG4gICAgICBpZiAodGFiLmFjdGl2ZSAmJiB0YWIgIT09IHNlbGVjdGVkVGFiKSB7XG4gICAgICAgIHRhYi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGFiLm9uRGVzZWxlY3QoKTtcbiAgICAgICAgc2VsZWN0ZWRUYWIuc2VsZWN0Q2FsbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VsZWN0ZWRUYWIuYWN0aXZlID0gdHJ1ZTtcbiAgICAvLyBvbmx5IGNhbGwgc2VsZWN0IGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgIGlmICghc2VsZWN0ZWRUYWIuc2VsZWN0Q2FsbGVkKSB7XG4gICAgICBzZWxlY3RlZFRhYi5vblNlbGVjdCgpO1xuICAgICAgc2VsZWN0ZWRUYWIuc2VsZWN0Q2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgY3RybC5hZGRUYWIgPSBmdW5jdGlvbiBhZGRUYWIodGFiKSB7XG4gICAgdGFicy5wdXNoKHRhYik7XG4gICAgLy8gd2UgY2FuJ3QgcnVuIHRoZSBzZWxlY3QgZnVuY3Rpb24gb24gdGhlIGZpcnN0IHRhYlxuICAgIC8vIHNpbmNlIHRoYXQgd291bGQgc2VsZWN0IGl0IHR3aWNlXG4gICAgaWYgKHRhYnMubGVuZ3RoID09PSAxICYmIHRhYi5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICB0YWIuYWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRhYi5hY3RpdmUpIHtcbiAgICAgIGN0cmwuc2VsZWN0KHRhYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYi5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgY3RybC5yZW1vdmVUYWIgPSBmdW5jdGlvbiByZW1vdmVUYWIodGFiKSB7XG4gICAgdmFyIGluZGV4ID0gdGFicy5pbmRleE9mKHRhYik7XG4gICAgLy9TZWxlY3QgYSBuZXcgdGFiIGlmIHRoZSB0YWIgdG8gYmUgcmVtb3ZlZCBpcyBzZWxlY3RlZCBhbmQgbm90IGRlc3Ryb3llZFxuICAgIGlmICh0YWIuYWN0aXZlICYmIHRhYnMubGVuZ3RoID4gMSAmJiAhZGVzdHJveWVkKSB7XG4gICAgICAvL0lmIHRoaXMgaXMgdGhlIGxhc3QgdGFiLCBzZWxlY3QgdGhlIHByZXZpb3VzIHRhYi4gZWxzZSwgdGhlIG5leHQgdGFiLlxuICAgICAgdmFyIG5ld0FjdGl2ZUluZGV4ID0gaW5kZXggPT0gdGFicy5sZW5ndGggLSAxID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgICAgY3RybC5zZWxlY3QodGFic1tuZXdBY3RpdmVJbmRleF0pO1xuICAgIH1cbiAgICB0YWJzLnNwbGljZShpbmRleCwgMSk7XG4gIH07XG5cbiAgdmFyIGRlc3Ryb3llZDtcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9KTtcbn1dKVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJzZXRcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGFic2V0IGlzIHRoZSBvdXRlciBjb250YWluZXIgZm9yIHRoZSB0YWJzIGRpcmVjdGl2ZVxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHZlcnRpY2FsIFdoZXRoZXIgb3Igbm90IHRvIHVzZSB2ZXJ0aWNhbCBzdHlsaW5nIGZvciB0aGUgdGFicy5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGp1c3RpZmllZCBXaGV0aGVyIG9yIG5vdCB0byB1c2UganVzdGlmaWVkIHN0eWxpbmcgZm9yIHRoZSB0YWJzLlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICA8dGFic2V0PlxuICAgICAgPHRhYiBoZWFkaW5nPVwiVGFiIDFcIj48Yj5GaXJzdDwvYj4gQ29udGVudCE8L3RhYj5cbiAgICAgIDx0YWIgaGVhZGluZz1cIlRhYiAyXCI+PGk+U2Vjb25kPC9pPiBDb250ZW50ITwvdGFiPlxuICAgIDwvdGFic2V0PlxuICAgIDxociAvPlxuICAgIDx0YWJzZXQgdmVydGljYWw9XCJ0cnVlXCI+XG4gICAgICA8dGFiIGhlYWRpbmc9XCJWZXJ0aWNhbCBUYWIgMVwiPjxiPkZpcnN0PC9iPiBWZXJ0aWNhbCBDb250ZW50ITwvdGFiPlxuICAgICAgPHRhYiBoZWFkaW5nPVwiVmVydGljYWwgVGFiIDJcIj48aT5TZWNvbmQ8L2k+IFZlcnRpY2FsIENvbnRlbnQhPC90YWI+XG4gICAgPC90YWJzZXQ+XG4gICAgPHRhYnNldCBqdXN0aWZpZWQ9XCJ0cnVlXCI+XG4gICAgICA8dGFiIGhlYWRpbmc9XCJKdXN0aWZpZWQgVGFiIDFcIj48Yj5GaXJzdDwvYj4gSnVzdGlmaWVkIENvbnRlbnQhPC90YWI+XG4gICAgICA8dGFiIGhlYWRpbmc9XCJKdXN0aWZpZWQgVGFiIDJcIj48aT5TZWNvbmQ8L2k+IEp1c3RpZmllZCBDb250ZW50ITwvdGFiPlxuICAgIDwvdGFic2V0PlxuICA8L2ZpbGU+XG48L2V4YW1wbGU+XG4gKi9cbi5kaXJlY3RpdmUoJ3RhYnNldCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZToge1xuICAgICAgdHlwZTogJ0AnXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiAnVGFic2V0Q29udHJvbGxlcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHNjb3BlLnZlcnRpY2FsID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudmVydGljYWwpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy52ZXJ0aWNhbCkgOiBmYWxzZTtcbiAgICAgIHNjb3BlLmp1c3RpZmllZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmp1c3RpZmllZCkgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmp1c3RpZmllZCkgOiBmYWxzZTtcbiAgICB9XG4gIH07XG59KVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gaGVhZGluZyBUaGUgdmlzaWJsZSBoZWFkaW5nLCBvciB0aXRsZSwgb2YgdGhlIHRhYi4gU2V0IEhUTUwgaGVhZGluZ3Mgd2l0aCB7QGxpbmsgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYkhlYWRpbmcgdGFiSGVhZGluZ30uXG4gKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdCBBbiBleHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW4gdGhlIHRhYiBpcyBzZWxlY3RlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGFjdGl2ZSBBIGJpbmRpbmcsIHRlbGxpbmcgd2hldGhlciBvciBub3QgdGhpcyB0YWIgaXMgc2VsZWN0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBkaXNhYmxlZCBBIGJpbmRpbmcsIHRlbGxpbmcgd2hldGhlciBvciBub3QgdGhpcyB0YWIgaXMgZGlzYWJsZWQuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGEgdGFiIHdpdGggYSBoZWFkaW5nIGFuZCBjb250ZW50LiBNdXN0IGJlIHBsYWNlZCB3aXRoaW4gYSB7QGxpbmsgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYnNldCB0YWJzZXR9LlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJUYWJzRGVtb0N0cmxcIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtYWxsXCIgbmctY2xpY2s9XCJpdGVtc1swXS5hY3RpdmUgPSB0cnVlXCI+XG4gICAgICAgIFNlbGVjdCBpdGVtIDEsIHVzaW5nIGFjdGl2ZSBiaW5kaW5nXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtYWxsXCIgbmctY2xpY2s9XCJpdGVtc1sxXS5kaXNhYmxlZCA9ICFpdGVtc1sxXS5kaXNhYmxlZFwiPlxuICAgICAgICBFbmFibGUvZGlzYWJsZSBpdGVtIDIsIHVzaW5nIGRpc2FibGVkIGJpbmRpbmdcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJyIC8+XG4gICAgICA8dGFic2V0PlxuICAgICAgICA8dGFiIGhlYWRpbmc9XCJUYWIgMVwiPkZpcnN0IFRhYjwvdGFiPlxuICAgICAgICA8dGFiIHNlbGVjdD1cImFsZXJ0TWUoKVwiPlxuICAgICAgICAgIDx0YWItaGVhZGluZz48aSBjbGFzcz1cImljb24tYmVsbFwiPjwvaT4gQWxlcnQgbWUhPC90YWItaGVhZGluZz5cbiAgICAgICAgICBTZWNvbmQgVGFiLCB3aXRoIGFsZXJ0IGNhbGxiYWNrIGFuZCBodG1sIGhlYWRpbmchXG4gICAgICAgIDwvdGFiPlxuICAgICAgICA8dGFiIG5nLXJlcGVhdD1cIml0ZW0gaW4gaXRlbXNcIlxuICAgICAgICAgIGhlYWRpbmc9XCJ7e2l0ZW0udGl0bGV9fVwiXG4gICAgICAgICAgZGlzYWJsZWQ9XCJpdGVtLmRpc2FibGVkXCJcbiAgICAgICAgICBhY3RpdmU9XCJpdGVtLmFjdGl2ZVwiPlxuICAgICAgICAgIHt7aXRlbS5jb250ZW50fX1cbiAgICAgICAgPC90YWI+XG4gICAgICA8L3RhYnNldD5cbiAgICA8L2Rpdj5cbiAgPC9maWxlPlxuICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgZnVuY3Rpb24gVGFic0RlbW9DdHJsKCRzY29wZSkge1xuICAgICAgJHNjb3BlLml0ZW1zID0gW1xuICAgICAgICB7IHRpdGxlOlwiRHluYW1pYyBUaXRsZSAxXCIsIGNvbnRlbnQ6XCJEeW5hbWljIEl0ZW0gMFwiIH0sXG4gICAgICAgIHsgdGl0bGU6XCJEeW5hbWljIFRpdGxlIDJcIiwgY29udGVudDpcIkR5bmFtaWMgSXRlbSAxXCIsIGRpc2FibGVkOiB0cnVlIH1cbiAgICAgIF07XG5cbiAgICAgICRzY29wZS5hbGVydE1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYWxlcnQoXCJZb3UndmUgc2VsZWN0ZWQgdGhlIGFsZXJ0IHRhYiFcIik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuICA8L2ZpbGU+XG48L2V4YW1wbGU+XG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiSGVhZGluZ1xuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGFuIEhUTUwgaGVhZGluZyBmb3IgYSB7QGxpbmsgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYiB0YWJ9LiBNdXN0IGJlIHBsYWNlZCBhcyBhIGNoaWxkIG9mIGEgdGFiIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgIDx0YWJzZXQ+XG4gICAgICA8dGFiPlxuICAgICAgICA8dGFiLWhlYWRpbmc+PGI+SFRNTDwvYj4gaW4gbXkgdGl0bGVzPyE8L3RhYi1oZWFkaW5nPlxuICAgICAgICBBbmQgc29tZSBjb250ZW50LCB0b28hXG4gICAgICA8L3RhYj5cbiAgICAgIDx0YWI+XG4gICAgICAgIDx0YWItaGVhZGluZz48aSBjbGFzcz1cImljb24taGVhcnRcIj48L2k+IEljb24gaGVhZGluZz8hPzwvdGFiLWhlYWRpbmc+XG4gICAgICAgIFRoYXQncyByaWdodC5cbiAgICAgIDwvdGFiPlxuICAgIDwvdGFic2V0PlxuICA8L2ZpbGU+XG48L2V4YW1wbGU+XG4gKi9cbi5kaXJlY3RpdmUoJ3RhYicsIFsnJHBhcnNlJywgJyRsb2cnLCBmdW5jdGlvbigkcGFyc2UsICRsb2cpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXnRhYnNldCcsXG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3RhYnMvdGFiLmh0bWwnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgc2NvcGU6IHtcbiAgICAgIGFjdGl2ZTogJz0/JyxcbiAgICAgIGhlYWRpbmc6ICdAJyxcbiAgICAgIG9uU2VsZWN0OiAnJnNlbGVjdCcsIC8vVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgaW4gY29udGVudEhlYWRpbmdUcmFuc2NsdWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25jZSBpdCBpbnNlcnRzIHRoZSB0YWIncyBjb250ZW50IGludG8gdGhlIGRvbVxuICAgICAgb25EZXNlbGVjdDogJyZkZXNlbGVjdCdcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgLy9FbXB0eSBjb250cm9sbGVyIHNvIG90aGVyIGRpcmVjdGl2ZXMgY2FuIHJlcXVpcmUgYmVpbmcgJ3VuZGVyJyBhIHRhYlxuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYnNldEN0cmwsIHRyYW5zY2x1ZGUpIHtcbiAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICB0YWJzZXRDdHJsLnNlbGVjdChzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGF0dHJzLmRpc2FibGUpIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLmRpc2FibGUpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHNjb3BlLmRpc2FibGVkID0gISEgdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXByZWNhdGlvbiBzdXBwb3J0IG9mIFwiZGlzYWJsZWRcIiBwYXJhbWV0ZXJcbiAgICAgIC8vIGZpeCh0YWIpOiBJRTkgZGlzYWJsZWQgYXR0ciByZW5kZXJzIGdyZXkgdGV4dCBvbiBlbmFibGVkIHRhYiAjMjY3N1xuICAgICAgLy8gVGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgZnJvbSB0aGUgbGluZXMgYWJvdmUgdG8gbWFrZSBpdCBlYXN5IHRvIHJlbW92ZSBvbmNlXG4gICAgICAvLyB0aGUgZmVhdHVyZSBoYXMgYmVlbiBjb21wbGV0ZWx5IGRlcHJlY2F0ZWRcbiAgICAgIGlmIChhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAkbG9nLndhcm4oJ1VzZSBvZiBcImRpc2FibGVkXCIgYXR0cmlidXRlIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgXCJkaXNhYmxlXCInKTtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLmRpc2FibGVkKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5kaXNhYmxlZCA9ICEhIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2NvcGUuZGlzYWJsZWQpIHtcbiAgICAgICAgICBzY29wZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0YWJzZXRDdHJsLmFkZFRhYihzY29wZSk7XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRhYnNldEN0cmwucmVtb3ZlVGFiKHNjb3BlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvL1dlIG5lZWQgdG8gdHJhbnNjbHVkZSBsYXRlciwgb25jZSB0aGUgY29udGVudCBjb250YWluZXIgaXMgcmVhZHkuXG4gICAgICAvL3doZW4gdGhpcyBsaW5rIGhhcHBlbnMsIHdlJ3JlIGluc2lkZSBhIHRhYiBoZWFkaW5nLlxuICAgICAgc2NvcGUuJHRyYW5zY2x1ZGVGbiA9IHRyYW5zY2x1ZGU7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3RhYkhlYWRpbmdUcmFuc2NsdWRlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiAnXnRhYicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYkN0cmwpIHtcbiAgICAgIHNjb3BlLiR3YXRjaCgnaGVhZGluZ0VsZW1lbnQnLCBmdW5jdGlvbiB1cGRhdGVIZWFkaW5nRWxlbWVudChoZWFkaW5nKSB7XG4gICAgICAgIGlmIChoZWFkaW5nKSB7XG4gICAgICAgICAgZWxtLmh0bWwoJycpO1xuICAgICAgICAgIGVsbS5hcHBlbmQoaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3RhYkNvbnRlbnRUcmFuc2NsdWRlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiAnXnRhYnNldCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMpIHtcbiAgICAgIHZhciB0YWIgPSBzY29wZS4kZXZhbChhdHRycy50YWJDb250ZW50VHJhbnNjbHVkZSk7XG5cbiAgICAgIC8vTm93IG91ciB0YWIgaXMgcmVhZHkgdG8gYmUgdHJhbnNjbHVkZWQ6IGJvdGggdGhlIHRhYiBoZWFkaW5nIGFyZWFcbiAgICAgIC8vYW5kIHRoZSB0YWIgY29udGVudCBhcmVhIGFyZSBsb2FkZWQuICBUcmFuc2NsdWRlICdlbSBib3RoLlxuICAgICAgdGFiLiR0cmFuc2NsdWRlRm4odGFiLiRwYXJlbnQsIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChpc1RhYkhlYWRpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vTGV0IHRhYkhlYWRpbmdUcmFuc2NsdWRlIGtub3cuXG4gICAgICAgICAgICB0YWIuaGVhZGluZ0VsZW1lbnQgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbG0uYXBwZW5kKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNUYWJIZWFkaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lICYmIChcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCd0YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS10YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgneC10YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RhYi1oZWFkaW5nJyB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkYXRhLXRhYi1oZWFkaW5nJyB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd4LXRhYi1oZWFkaW5nJ1xuICAgICk7XG4gIH1cbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRpbWVwaWNrZXInLCBbXSlcblxuLmNvbnN0YW50KCd0aW1lcGlja2VyQ29uZmlnJywge1xuICBob3VyU3RlcDogMSxcbiAgbWludXRlU3RlcDogMSxcbiAgc2hvd01lcmlkaWFuOiB0cnVlLFxuICBtZXJpZGlhbnM6IG51bGwsXG4gIHJlYWRvbmx5SW5wdXQ6IGZhbHNlLFxuICBtb3VzZXdoZWVsOiB0cnVlLFxuICBhcnJvd2tleXM6IHRydWUsXG4gIHNob3dTcGlubmVyczogdHJ1ZVxufSlcblxuLmNvbnRyb2xsZXIoJ1RpbWVwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJyRwYXJzZScsICckbG9nJywgJyRsb2NhbGUnLCAndGltZXBpY2tlckNvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRsb2csICRsb2NhbGUsIHRpbWVwaWNrZXJDb25maWcpIHtcbiAgdmFyIHNlbGVjdGVkID0gbmV3IERhdGUoKSxcbiAgICAgIG5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfSwgLy8gbnVsbE1vZGVsQ3RybFxuICAgICAgbWVyaWRpYW5zID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1lcmlkaWFucykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubWVyaWRpYW5zKSA6IHRpbWVwaWNrZXJDb25maWcubWVyaWRpYW5zIHx8ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5BTVBNUztcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8sIGlucHV0cykge1xuICAgIG5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmxfO1xuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSB0aGlzLnJlbmRlcjtcblxuICAgIG5nTW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnVuc2hpZnQoZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIG1vZGVsVmFsdWUgPyBuZXcgRGF0ZShtb2RlbFZhbHVlKSA6IG51bGw7XG4gICAgfSk7XG5cbiAgICB2YXIgaG91cnNJbnB1dEVsID0gaW5wdXRzLmVxKDApLFxuICAgICAgICBtaW51dGVzSW5wdXRFbCA9IGlucHV0cy5lcSgxKTtcblxuICAgIHZhciBtb3VzZXdoZWVsID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1vdXNld2hlZWwpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm1vdXNld2hlZWwpIDogdGltZXBpY2tlckNvbmZpZy5tb3VzZXdoZWVsO1xuICAgIGlmIChtb3VzZXdoZWVsKSB7XG4gICAgICB0aGlzLnNldHVwTW91c2V3aGVlbEV2ZW50cyhob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsKTtcbiAgICB9XG5cbiAgICB2YXIgYXJyb3drZXlzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFycm93a2V5cykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYXJyb3drZXlzKSA6IHRpbWVwaWNrZXJDb25maWcuYXJyb3drZXlzO1xuICAgIGlmIChhcnJvd2tleXMpIHtcbiAgICAgIHRoaXMuc2V0dXBBcnJvd2tleUV2ZW50cyhob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsKTtcbiAgICB9XG5cbiAgICAkc2NvcGUucmVhZG9ubHlJbnB1dCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yZWFkb25seUlucHV0KSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5yZWFkb25seUlucHV0KSA6IHRpbWVwaWNrZXJDb25maWcucmVhZG9ubHlJbnB1dDtcbiAgICB0aGlzLnNldHVwSW5wdXRFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCk7XG4gIH07XG5cbiAgdmFyIGhvdXJTdGVwID0gdGltZXBpY2tlckNvbmZpZy5ob3VyU3RlcDtcbiAgaWYgKCRhdHRycy5ob3VyU3RlcCkge1xuICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLmhvdXJTdGVwKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGhvdXJTdGVwID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBtaW51dGVTdGVwID0gdGltZXBpY2tlckNvbmZpZy5taW51dGVTdGVwO1xuICBpZiAoJGF0dHJzLm1pbnV0ZVN0ZXApIHtcbiAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5taW51dGVTdGVwKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIG1pbnV0ZVN0ZXAgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1pbjtcbiAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubWluKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgbWluID0gaXNOYU4oZHQpID8gdW5kZWZpbmVkIDogZHQ7XG4gIH0pO1xuXG4gIHZhciBtYXg7XG4gICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1heCksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUodmFsdWUpO1xuICAgIG1heCA9IGlzTmFOKGR0KSA/IHVuZGVmaW5lZCA6IGR0O1xuICB9KTtcblxuICAkc2NvcGUubm9JbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmNyZW1lbnRlZFNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgaG91clN0ZXAgKiA2MCk7XG4gICAgcmV0dXJuIGluY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXggfHxcbiAgICAgIChpbmNyZW1lbnRlZFNlbGVjdGVkIDwgc2VsZWN0ZWQgJiYgaW5jcmVtZW50ZWRTZWxlY3RlZCA8IG1pbik7XG4gIH07XG5cbiAgJHNjb3BlLm5vRGVjcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC1ob3VyU3RlcCAqIDYwKTtcbiAgICByZXR1cm4gZGVjcmVtZW50ZWRTZWxlY3RlZCA8IG1pbiB8fFxuICAgICAgKGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4KTtcbiAgfTtcblxuICAkc2NvcGUubm9JbmNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCBtaW51dGVTdGVwKTtcbiAgICByZXR1cm4gaW5jcmVtZW50ZWRTZWxlY3RlZCA+IG1heCB8fFxuICAgICAgKGluY3JlbWVudGVkU2VsZWN0ZWQgPCBzZWxlY3RlZCAmJiBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgbWluKTtcbiAgfTtcblxuICAkc2NvcGUubm9EZWNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCAtbWludXRlU3RlcCk7XG4gICAgcmV0dXJuIGRlY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW4gfHxcbiAgICAgIChkZWNyZW1lbnRlZFNlbGVjdGVkID4gc2VsZWN0ZWQgJiYgZGVjcmVtZW50ZWRTZWxlY3RlZCA+IG1heCk7XG4gIH07XG5cbiAgJHNjb3BlLm5vVG9nZ2xlTWVyaWRpYW4gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEzKSB7XG4gICAgICByZXR1cm4gYWRkTWludXRlcyhzZWxlY3RlZCwgMTIgKiA2MCkgPiBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRNaW51dGVzKHNlbGVjdGVkLCAtMTIgKiA2MCkgPCBtaW47XG4gICAgfVxuICB9O1xuXG4gIC8vIDEySCAvIDI0SCBtb2RlXG4gICRzY29wZS5zaG93TWVyaWRpYW4gPSB0aW1lcGlja2VyQ29uZmlnLnNob3dNZXJpZGlhbjtcbiAgaWYgKCRhdHRycy5zaG93TWVyaWRpYW4pIHtcbiAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5zaG93TWVyaWRpYW4pLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgJHNjb3BlLnNob3dNZXJpZGlhbiA9ICEhdmFsdWU7XG5cbiAgICAgIGlmIChuZ01vZGVsQ3RybC4kZXJyb3IudGltZSkge1xuICAgICAgICAvLyBFdmFsdWF0ZSBmcm9tIHRlbXBsYXRlXG4gICAgICAgIHZhciBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCksIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCk7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChob3VycykgJiYgYW5ndWxhci5pc0RlZmluZWQobWludXRlcykpIHtcbiAgICAgICAgICBzZWxlY3RlZC5zZXRIb3Vycyhob3Vycyk7XG4gICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVUZW1wbGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gR2V0ICRzY29wZS5ob3VycyBpbiAyNEggbW9kZSBpZiB2YWxpZFxuICBmdW5jdGlvbiBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpIHtcbiAgICB2YXIgaG91cnMgPSBwYXJzZUludCgkc2NvcGUuaG91cnMsIDEwKTtcbiAgICB2YXIgdmFsaWQgPSAkc2NvcGUuc2hvd01lcmlkaWFuID8gKGhvdXJzID4gMCAmJiBob3VycyA8IDEzKSA6IChob3VycyA+PSAwICYmIGhvdXJzIDwgMjQpO1xuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCRzY29wZS5zaG93TWVyaWRpYW4pIHtcbiAgICAgIGlmIChob3VycyA9PT0gMTIpIHtcbiAgICAgICAgaG91cnMgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCRzY29wZS5tZXJpZGlhbiA9PT0gbWVyaWRpYW5zWzFdKSB7XG4gICAgICAgIGhvdXJzID0gaG91cnMgKyAxMjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhvdXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpIHtcbiAgICB2YXIgbWludXRlcyA9IHBhcnNlSW50KCRzY29wZS5taW51dGVzLCAxMCk7XG4gICAgcmV0dXJuIChtaW51dGVzID49IDAgJiYgbWludXRlcyA8IDYwKSA/IG1pbnV0ZXMgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYWQodmFsdWUpIHtcbiAgICByZXR1cm4gKGFuZ3VsYXIuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCA8IDIpID8gJzAnICsgdmFsdWUgOiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgLy8gUmVzcG9uZCBvbiBtb3VzZXdoZWVsIHNwaW5cbiAgdGhpcy5zZXR1cE1vdXNld2hlZWxFdmVudHMgPSBmdW5jdGlvbihob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsKSB7XG4gICAgdmFyIGlzU2Nyb2xsaW5nVXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICB9XG4gICAgICAvL3BpY2sgY29ycmVjdCBkZWx0YSB2YXJpYWJsZSBkZXBlbmRpbmcgb24gZXZlbnRcbiAgICAgIHZhciBkZWx0YSA9IChlLndoZWVsRGVsdGEpID8gZS53aGVlbERlbHRhIDogLWUuZGVsdGFZO1xuICAgICAgcmV0dXJuIChlLmRldGFpbCB8fCBkZWx0YSA+IDApO1xuICAgIH07XG5cbiAgICBob3Vyc0lucHV0RWwuYmluZCgnbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoaXNTY3JvbGxpbmdVcChlKSA/ICRzY29wZS5pbmNyZW1lbnRIb3VycygpIDogJHNjb3BlLmRlY3JlbWVudEhvdXJzKCkpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgbWludXRlc0lucHV0RWwuYmluZCgnbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoaXNTY3JvbGxpbmdVcChlKSA/ICRzY29wZS5pbmNyZW1lbnRNaW51dGVzKCkgOiAkc2NvcGUuZGVjcmVtZW50TWludXRlcygpKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICB9O1xuXG4gIC8vIFJlc3BvbmQgb24gdXAvZG93biBhcnJvd2tleXNcbiAgdGhpcy5zZXR1cEFycm93a2V5RXZlbnRzID0gZnVuY3Rpb24oaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCkge1xuICAgIGhvdXJzSW5wdXRFbC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUud2hpY2ggPT09IDM4KSB7IC8vIHVwXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJHNjb3BlLmluY3JlbWVudEhvdXJzKCk7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gNDApIHsgLy8gZG93blxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICRzY29wZS5kZWNyZW1lbnRIb3VycygpO1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBtaW51dGVzSW5wdXRFbC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUud2hpY2ggPT09IDM4KSB7IC8vIHVwXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJHNjb3BlLmluY3JlbWVudE1pbnV0ZXMoKTtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSA0MCkgeyAvLyBkb3duXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMoKTtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuc2V0dXBJbnB1dEV2ZW50cyA9IGZ1bmN0aW9uKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwpIHtcbiAgICBpZiAoJHNjb3BlLnJlYWRvbmx5SW5wdXQpIHtcbiAgICAgICRzY29wZS51cGRhdGVIb3VycyA9IGFuZ3VsYXIubm9vcDtcbiAgICAgICRzY29wZS51cGRhdGVNaW51dGVzID0gYW5ndWxhci5ub29wO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkYXRlID0gZnVuY3Rpb24oaW52YWxpZEhvdXJzLCBpbnZhbGlkTWludXRlcykge1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShudWxsKTtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIGZhbHNlKTtcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpbnZhbGlkSG91cnMpKSB7XG4gICAgICAgICRzY29wZS5pbnZhbGlkSG91cnMgPSBpbnZhbGlkSG91cnM7XG4gICAgICB9XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaW52YWxpZE1pbnV0ZXMpKSB7XG4gICAgICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IGludmFsaWRNaW51dGVzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkc2NvcGUudXBkYXRlSG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCksXG4gICAgICAgIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCk7XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChob3VycykgJiYgYW5ndWxhci5pc0RlZmluZWQobWludXRlcykpIHtcbiAgICAgICAgc2VsZWN0ZWQuc2V0SG91cnMoaG91cnMpO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPCBtaW4gfHwgc2VsZWN0ZWQgPiBtYXgpIHtcbiAgICAgICAgICBpbnZhbGlkYXRlKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goJ2gnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZGF0ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaG91cnNJbnB1dEVsLmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoISRzY29wZS5pbnZhbGlkSG91cnMgJiYgJHNjb3BlLmhvdXJzIDwgMTApIHtcbiAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAkc2NvcGUuaG91cnMgPSBwYWQoJHNjb3BlLmhvdXJzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkc2NvcGUudXBkYXRlTWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCksXG4gICAgICAgIGhvdXJzID0gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKTtcblxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKG1pbnV0ZXMpICYmIGFuZ3VsYXIuaXNEZWZpbmVkKGhvdXJzKSkge1xuICAgICAgICBzZWxlY3RlZC5zZXRNaW51dGVzKG1pbnV0ZXMpO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPCBtaW4gfHwgc2VsZWN0ZWQgPiBtYXgpIHtcbiAgICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaCgnbScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIG1pbnV0ZXNJbnB1dEVsLmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoISRzY29wZS5pbnZhbGlkTWludXRlcyAmJiAkc2NvcGUubWludXRlcyA8IDEwKSB7XG4gICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNjb3BlLm1pbnV0ZXMgPSBwYWQoJHNjb3BlLm1pbnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGUgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XG4gICAgICAkbG9nLmVycm9yKCdUaW1lcGlja2VyIGRpcmVjdGl2ZTogXCJuZy1tb2RlbFwiIHZhbHVlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDAxLjAxLjE5NzAgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIFJGQzI4MjIgb3IgSVNPIDg2MDEgZGF0ZS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBkYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWQgPCBtaW4gfHwgc2VsZWN0ZWQgPiBtYXgpIHtcbiAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xuICAgICAgICAkc2NvcGUuaW52YWxpZEhvdXJzID0gdHJ1ZTtcbiAgICAgICAgJHNjb3BlLmludmFsaWRNaW51dGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VWYWxpZCgpO1xuICAgICAgfVxuICAgICAgdXBkYXRlVGVtcGxhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbCBpbnRlcm5hbGx5IHdoZW4gd2Uga25vdyB0aGF0IG1vZGVsIGlzIHZhbGlkLlxuICBmdW5jdGlvbiByZWZyZXNoKGtleWJvYXJkQ2hhbmdlKSB7XG4gICAgbWFrZVZhbGlkKCk7XG4gICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShuZXcgRGF0ZShzZWxlY3RlZCkpO1xuICAgIHVwZGF0ZVRlbXBsYXRlKGtleWJvYXJkQ2hhbmdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VWYWxpZCgpIHtcbiAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCB0cnVlKTtcbiAgICAkc2NvcGUuaW52YWxpZEhvdXJzID0gZmFsc2U7XG4gICAgJHNjb3BlLmludmFsaWRNaW51dGVzID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZW1wbGF0ZShrZXlib2FyZENoYW5nZSkge1xuICAgIHZhciBob3VycyA9IHNlbGVjdGVkLmdldEhvdXJzKCksIG1pbnV0ZXMgPSBzZWxlY3RlZC5nZXRNaW51dGVzKCk7XG5cbiAgICBpZiAoJHNjb3BlLnNob3dNZXJpZGlhbikge1xuICAgICAgaG91cnMgPSAoaG91cnMgPT09IDAgfHwgaG91cnMgPT09IDEyKSA/IDEyIDogaG91cnMgJSAxMjsgLy8gQ29udmVydCAyNCB0byAxMiBob3VyIHN5c3RlbVxuICAgIH1cblxuICAgICRzY29wZS5ob3VycyA9IGtleWJvYXJkQ2hhbmdlID09PSAnaCcgPyBob3VycyA6IHBhZChob3Vycyk7XG4gICAgaWYgKGtleWJvYXJkQ2hhbmdlICE9PSAnbScpIHtcbiAgICAgICRzY29wZS5taW51dGVzID0gcGFkKG1pbnV0ZXMpO1xuICAgIH1cbiAgICAkc2NvcGUubWVyaWRpYW4gPSBzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyBtZXJpZGlhbnNbMF0gOiBtZXJpZGlhbnNbMV07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRNaW51dGVzKGRhdGUsIG1pbnV0ZXMpIHtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIG1pbnV0ZXMgKiA2MDAwMCk7XG4gICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBuZXdEYXRlLnNldEhvdXJzKGR0LmdldEhvdXJzKCksIGR0LmdldE1pbnV0ZXMoKSk7XG4gICAgcmV0dXJuIG5ld0RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRNaW51dGVzVG9TZWxlY3RlZChtaW51dGVzKSB7XG4gICAgc2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCBtaW51dGVzKTtcbiAgICByZWZyZXNoKCk7XG4gIH1cblxuICAkc2NvcGUuc2hvd1NwaW5uZXJzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnNob3dTcGlubmVycykgP1xuICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zaG93U3Bpbm5lcnMpIDogdGltZXBpY2tlckNvbmZpZy5zaG93U3Bpbm5lcnM7XG5cbiAgJHNjb3BlLmluY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9JbmNyZW1lbnRIb3VycygpKSB7XG4gICAgICBhZGRNaW51dGVzVG9TZWxlY3RlZChob3VyU3RlcCAqIDYwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmRlY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9EZWNyZW1lbnRIb3VycygpKSB7XG4gICAgICBhZGRNaW51dGVzVG9TZWxlY3RlZCgtaG91clN0ZXAgKiA2MCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5pbmNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9JbmNyZW1lbnRNaW51dGVzKCkpIHtcbiAgICAgIGFkZE1pbnV0ZXNUb1NlbGVjdGVkKG1pbnV0ZVN0ZXApO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZGVjcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vRGVjcmVtZW50TWludXRlcygpKSB7XG4gICAgICBhZGRNaW51dGVzVG9TZWxlY3RlZCgtbWludXRlU3RlcCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS50b2dnbGVNZXJpZGlhbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vVG9nZ2xlTWVyaWRpYW4oKSkge1xuICAgICAgYWRkTWludXRlc1RvU2VsZWN0ZWQoMTIgKiA2MCAqIChzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyAxIDogLTEpKTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndGltZXBpY2tlcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcXVpcmU6IFsndGltZXBpY2tlcicsICc/Xm5nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOidUaW1lcGlja2VyQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAndGltZXBpY2tlcicsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZToge30sXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sJztcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciB0aW1lcGlja2VyQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBpZiAobmdNb2RlbEN0cmwpIHtcbiAgICAgICAgdGltZXBpY2tlckN0cmwuaW5pdChuZ01vZGVsQ3RybCwgZWxlbWVudC5maW5kKCdpbnB1dCcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50cmFuc2l0aW9uJywgW10pXG5cbi52YWx1ZSgnJHRyYW5zaXRpb25TdXBwcmVzc0RlcHJlY2F0ZWQnLCBmYWxzZSlcbi8qKlxuICogJHRyYW5zaXRpb24gc2VydmljZSBwcm92aWRlcyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIHRvIHRyaWdnZXIgQ1NTIDMgdHJhbnNpdGlvbnMgYW5kIHRvIGJlIGluZm9ybWVkIHdoZW4gdGhleSBjb21wbGV0ZS5cbiAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGVsZW1lbnQgIFRoZSBET01FbGVtZW50IHRoYXQgd2lsbCBiZSBhbmltYXRlZC5cbiAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R8ZnVuY3Rpb259IHRyaWdnZXIgIFRoZSB0aGluZyB0aGF0IHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gc3RhcnQ6XG4gKiAgIC0gQXMgYSBzdHJpbmcsIGl0IHJlcHJlc2VudHMgdGhlIGNzcyBjbGFzcyB0byBiZSBhZGRlZCB0byB0aGUgZWxlbWVudC5cbiAqICAgLSBBcyBhbiBvYmplY3QsIGl0IHJlcHJlc2VudHMgYSBoYXNoIG9mIHN0eWxlIGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cbiAqICAgLSBBcyBhIGZ1bmN0aW9uLCBpdCByZXByZXNlbnRzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRoYXQgd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBvY2N1ci5cbiAqIEByZXR1cm4ge1Byb21pc2V9ICBBIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzLlxuICovXG4uZmFjdG9yeSgnJHRyYW5zaXRpb24nLCBbXG4gICAgICAgICckcScsICckdGltZW91dCcsICckcm9vdFNjb3BlJywgJyRsb2cnLCAnJHRyYW5zaXRpb25TdXBwcmVzc0RlcHJlY2F0ZWQnLFxuZnVuY3Rpb24oJHEgLCAgJHRpbWVvdXQgLCAgJHJvb3RTY29wZSAsICAkbG9nICwgICR0cmFuc2l0aW9uU3VwcHJlc3NEZXByZWNhdGVkKSB7XG5cbiAgaWYgKCEkdHJhbnNpdGlvblN1cHByZXNzRGVwcmVjYXRlZCkge1xuICAgICRsb2cud2FybignJHRyYW5zaXRpb24gaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSAkYW5pbWF0ZSBmcm9tIG5nQW5pbWF0ZSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgdmFyICR0cmFuc2l0aW9uID0gZnVuY3Rpb24oZWxlbWVudCwgdHJpZ2dlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgdmFyIGVuZEV2ZW50TmFtZSA9ICR0cmFuc2l0aW9uW29wdGlvbnMuYW5pbWF0aW9uID8gJ2FuaW1hdGlvbkVuZEV2ZW50TmFtZScgOiAndHJhbnNpdGlvbkVuZEV2ZW50TmFtZSddO1xuXG4gICAgdmFyIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICRyb290U2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LnVuYmluZChlbmRFdmVudE5hbWUsIHRyYW5zaXRpb25FbmRIYW5kbGVyKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoZW5kRXZlbnROYW1lKSB7XG4gICAgICBlbGVtZW50LmJpbmQoZW5kRXZlbnROYW1lLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XG4gICAgfVxuXG4gICAgLy8gV3JhcCBpbiBhIHRpbWVvdXQgdG8gYWxsb3cgdGhlIGJyb3dzZXIgdGltZSB0byB1cGRhdGUgdGhlIERPTSBiZWZvcmUgdGhlIHRyYW5zaXRpb24gaXMgdG8gb2NjdXJcbiAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmICggYW5ndWxhci5pc1N0cmluZyh0cmlnZ2VyKSApIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyh0cmlnZ2VyKTtcbiAgICAgIH0gZWxzZSBpZiAoIGFuZ3VsYXIuaXNGdW5jdGlvbih0cmlnZ2VyKSApIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIGFuZ3VsYXIuaXNPYmplY3QodHJpZ2dlcikgKSB7XG4gICAgICAgIGVsZW1lbnQuY3NzKHRyaWdnZXIpO1xuICAgICAgfVxuICAgICAgLy9JZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHJhbnNpdGlvbnMsIGluc3RhbnRseSByZXNvbHZlXG4gICAgICBpZiAoICFlbmRFdmVudE5hbWUgKSB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgb3VyIGN1c3RvbSBjYW5jZWwgZnVuY3Rpb24gdG8gdGhlIHByb21pc2UgdGhhdCBpcyByZXR1cm5lZFxuICAgIC8vIFdlIGNhbiBjYWxsIHRoaXMgaWYgd2UgYXJlIGFib3V0IHRvIHJ1biBhIG5ldyB0cmFuc2l0aW9uLCB3aGljaCB3ZSBrbm93IHdpbGwgcHJldmVudCB0aGlzIHRyYW5zaXRpb24gZnJvbSBlbmRpbmcsXG4gICAgLy8gaS5lLiBpdCB3aWxsIHRoZXJlZm9yZSBuZXZlciByYWlzZSBhIHRyYW5zaXRpb25FbmQgZXZlbnQgZm9yIHRoYXQgdHJhbnNpdGlvblxuICAgIGRlZmVycmVkLnByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIGVuZEV2ZW50TmFtZSApIHtcbiAgICAgICAgZWxlbWVudC51bmJpbmQoZW5kRXZlbnROYW1lLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XG4gICAgICB9XG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ1RyYW5zaXRpb24gY2FuY2VsbGVkJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9O1xuXG4gIC8vIFdvcmsgb3V0IHRoZSBuYW1lIG9mIHRoZSB0cmFuc2l0aW9uRW5kIGV2ZW50XG4gIHZhciB0cmFuc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFucycpO1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50TmFtZXMgPSB7XG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJ1xuICB9O1xuICB2YXIgYW5pbWF0aW9uRW5kRXZlbnROYW1lcyA9IHtcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICdNb3pUcmFuc2l0aW9uJzogJ2FuaW1hdGlvbmVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ29BbmltYXRpb25FbmQnLFxuICAgICd0cmFuc2l0aW9uJzogJ2FuaW1hdGlvbmVuZCdcbiAgfTtcbiAgZnVuY3Rpb24gZmluZEVuZEV2ZW50TmFtZShlbmRFdmVudE5hbWVzKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBlbmRFdmVudE5hbWVzKXtcbiAgICAgIGlmICh0cmFuc0VsZW1lbnQuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZW5kRXZlbnROYW1lc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgJHRyYW5zaXRpb24udHJhbnNpdGlvbkVuZEV2ZW50TmFtZSA9IGZpbmRFbmRFdmVudE5hbWUodHJhbnNpdGlvbkVuZEV2ZW50TmFtZXMpO1xuICAkdHJhbnNpdGlvbi5hbmltYXRpb25FbmRFdmVudE5hbWUgPSBmaW5kRW5kRXZlbnROYW1lKGFuaW1hdGlvbkVuZEV2ZW50TmFtZXMpO1xuICByZXR1cm4gJHRyYW5zaXRpb247XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudHlwZWFoZWFkJywgWyd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcblxuLyoqXG4gKiBBIGhlbHBlciBzZXJ2aWNlIHRoYXQgY2FuIHBhcnNlIHR5cGVhaGVhZCdzIHN5bnRheCAoc3RyaW5nIHByb3ZpZGVkIGJ5IHVzZXJzKVxuICogRXh0cmFjdGVkIHRvIGEgc2VwYXJhdGUgc2VydmljZSBmb3IgZWFzZSBvZiB1bml0IHRlc3RpbmdcbiAqL1xuICAuZmFjdG9yeSgndHlwZWFoZWFkUGFyc2VyJywgWyckcGFyc2UnLCBmdW5jdGlvbigkcGFyc2UpIHtcblxuICAvLyAgICAgICAgICAgICAgICAgICAgICAwMDAwMDExMTAwMDAwMDAwMDAwMDAyMjIwMDAwMDAwMDAwMDAwMDAwMzMzMzMzMzMzMzMzMzMzMDAwMDAwMDAwMDA0NDAwMFxuICB2YXIgVFlQRUFIRUFEX1JFR0VYUCA9IC9eXFxzKihbXFxzXFxTXSs/KSg/Olxccythc1xccysoW1xcc1xcU10rPykpP1xccytmb3JcXHMrKD86KFtcXCRcXHddW1xcJFxcd1xcZF0qKSlcXHMraW5cXHMrKFtcXHNcXFNdKz8pJC87XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKFRZUEVBSEVBRF9SRUdFWFApO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIHR5cGVhaGVhZCBzcGVjaWZpY2F0aW9uIGluIGZvcm0gb2YgXCJfbW9kZWxWYWx1ZV8gKGFzIF9sYWJlbF8pPyBmb3IgX2l0ZW1fIGluIF9jb2xsZWN0aW9uX1wiJyArXG4gICAgICAgICAgICAnIGJ1dCBnb3QgXCInICsgaW5wdXQgKyAnXCIuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1OYW1lOm1hdGNoWzNdLFxuICAgICAgICBzb3VyY2U6JHBhcnNlKG1hdGNoWzRdKSxcbiAgICAgICAgdmlld01hcHBlcjokcGFyc2UobWF0Y2hbMl0gfHwgbWF0Y2hbMV0pLFxuICAgICAgICBtb2RlbE1hcHBlcjokcGFyc2UobWF0Y2hbMV0pXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1dKVxuXG4gIC5kaXJlY3RpdmUoJ3R5cGVhaGVhZCcsIFsnJGNvbXBpbGUnLCAnJHBhcnNlJywgJyRxJywgJyR0aW1lb3V0JywgJyRkb2N1bWVudCcsICckd2luZG93JywgJyRyb290U2NvcGUnLCAnJHBvc2l0aW9uJywgJ3R5cGVhaGVhZFBhcnNlcicsXG4gICAgZnVuY3Rpb24oJGNvbXBpbGUsICRwYXJzZSwgJHEsICR0aW1lb3V0LCAkZG9jdW1lbnQsICR3aW5kb3csICRyb290U2NvcGUsICRwb3NpdGlvbiwgdHlwZWFoZWFkUGFyc2VyKSB7XG4gICAgdmFyIEhPVF9LRVlTID0gWzksIDEzLCAyNywgMzgsIDQwXTtcbiAgICB2YXIgZXZlbnREZWJvdW5jZVRpbWUgPSAyMDA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZTogWyduZ01vZGVsJywgJ14/bmdNb2RlbE9wdGlvbnMnXSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKG9yaWdpbmFsU2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgICB2YXIgbW9kZWxDdHJsID0gY3RybHNbMF07XG4gICAgICAgIHZhciBuZ01vZGVsT3B0aW9ucyA9IGN0cmxzWzFdO1xuICAgICAgICAvL1NVUFBPUlRFRCBBVFRSSUJVVEVTIChPUFRJT05TKVxuXG4gICAgICAgIC8vbWluaW1hbCBubyBvZiBjaGFyYWN0ZXJzIHRoYXQgbmVlZHMgdG8gYmUgZW50ZXJlZCBiZWZvcmUgdHlwZWFoZWFkIGtpY2tzLWluXG4gICAgICAgIHZhciBtaW5MZW5ndGggPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZE1pbkxlbmd0aCk7XG4gICAgICAgIGlmICghbWluTGVuZ3RoICYmIG1pbkxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIG1pbkxlbmd0aCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvL21pbmltYWwgd2FpdCB0aW1lIGFmdGVyIGxhc3QgY2hhcmFjdGVyIHR5cGVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW5cbiAgICAgICAgdmFyIHdhaXRUaW1lID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRXYWl0TXMpIHx8IDA7XG5cbiAgICAgICAgLy9zaG91bGQgaXQgcmVzdHJpY3QgbW9kZWwgdmFsdWVzIHRvIHRoZSBvbmVzIHNlbGVjdGVkIGZyb20gdGhlIHBvcHVwIG9ubHk/XG4gICAgICAgIHZhciBpc0VkaXRhYmxlID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRFZGl0YWJsZSkgIT09IGZhbHNlO1xuXG4gICAgICAgIC8vYmluZGluZyB0byBhIHZhcmlhYmxlIHRoYXQgaW5kaWNhdGVzIGlmIG1hdGNoZXMgYXJlIGJlaW5nIHJldHJpZXZlZCBhc3luY2hyb25vdXNseVxuICAgICAgICB2YXIgaXNMb2FkaW5nU2V0dGVyID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZExvYWRpbmcpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XG5cbiAgICAgICAgLy9hIGNhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gYSBtYXRjaCBpcyBzZWxlY3RlZFxuICAgICAgICB2YXIgb25TZWxlY3RDYWxsYmFjayA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRPblNlbGVjdCk7XG5cbiAgICAgICAgLy9zaG91bGQgaXQgc2VsZWN0IGhpZ2hsaWdodGVkIHBvcHVwIHZhbHVlIHdoZW4gbG9zaW5nIGZvY3VzP1xuICAgICAgICB2YXIgaXNTZWxlY3RPbkJsdXIgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpIDogZmFsc2U7XG5cbiAgICAgICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlcmUgd2VyZSBubyByZXN1bHRzIGFmdGVyIHRoZSBxdWVyeSBpcyBjb21wbGV0ZWRcbiAgICAgICAgdmFyIGlzTm9SZXN1bHRzU2V0dGVyID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE5vUmVzdWx0cykuYXNzaWduIHx8IGFuZ3VsYXIubm9vcDtcblxuICAgICAgICB2YXIgaW5wdXRGb3JtYXR0ZXIgPSBhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlciA/ICRwYXJzZShhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlcikgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGFwcGVuZFRvQm9keSA9ICBhdHRycy50eXBlYWhlYWRBcHBlbmRUb0JvZHkgPyBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvQm9keSkgOiBmYWxzZTtcblxuICAgICAgICB2YXIgZm9jdXNGaXJzdCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNGaXJzdCkgIT09IGZhbHNlO1xuXG4gICAgICAgIC8vSWYgaW5wdXQgbWF0Y2hlcyBhbiBpdGVtIG9mIHRoZSBsaXN0IGV4YWN0bHksIHNlbGVjdCBpdCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHZhciBzZWxlY3RPbkV4YWN0ID0gYXR0cnMudHlwZWFoZWFkU2VsZWN0T25FeGFjdCA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkU2VsZWN0T25FeGFjdCkgOiBmYWxzZTtcblxuICAgICAgICAvL0lOVEVSTkFMIFZBUklBQkxFU1xuXG4gICAgICAgIC8vbW9kZWwgc2V0dGVyIGV4ZWN1dGVkIHVwb24gbWF0Y2ggc2VsZWN0aW9uXG4gICAgICAgIHZhciBwYXJzZWRNb2RlbCA9ICRwYXJzZShhdHRycy5uZ01vZGVsKTtcbiAgICAgICAgdmFyIGludm9rZU1vZGVsU2V0dGVyID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwgKyAnKCQkJHApJyk7XG4gICAgICAgIHZhciAkc2V0TW9kZWxWYWx1ZSA9IGZ1bmN0aW9uKHNjb3BlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24ocGFyc2VkTW9kZWwob3JpZ2luYWxTY29wZSkpICYmXG4gICAgICAgICAgICBuZ01vZGVsT3B0aW9ucyAmJiBuZ01vZGVsT3B0aW9ucy4kb3B0aW9ucyAmJiBuZ01vZGVsT3B0aW9ucy4kb3B0aW9ucy5nZXR0ZXJTZXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VNb2RlbFNldHRlcihzY29wZSwgeyQkJHA6IG5ld1ZhbHVlfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRNb2RlbC5hc3NpZ24oc2NvcGUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9leHByZXNzaW9ucyB1c2VkIGJ5IHR5cGVhaGVhZFxuICAgICAgICB2YXIgcGFyc2VyUmVzdWx0ID0gdHlwZWFoZWFkUGFyc2VyLnBhcnNlKGF0dHJzLnR5cGVhaGVhZCk7XG5cbiAgICAgICAgdmFyIGhhc0ZvY3VzO1xuXG4gICAgICAgIC8vVXNlZCB0byBhdm9pZCBidWcgaW4gaU9TIHdlYnZpZXcgd2hlcmUgaU9TIGtleWJvYXJkIGRvZXMgbm90IGZpcmVcbiAgICAgICAgLy9tb3VzZWRvd24gJiBtb3VzZXVwIGV2ZW50c1xuICAgICAgICAvL0lzc3VlICMzNjk5XG4gICAgICAgIHZhciBzZWxlY3RlZDtcblxuICAgICAgICAvL2NyZWF0ZSBhIGNoaWxkIHNjb3BlIGZvciB0aGUgdHlwZWFoZWFkIGRpcmVjdGl2ZSBzbyB3ZSBhcmUgbm90IHBvbGx1dGluZyBvcmlnaW5hbCBzY29wZVxuICAgICAgICAvL3dpdGggdHlwZWFoZWFkLXNwZWNpZmljIGRhdGEgKG1hdGNoZXMsIHF1ZXJ5IGV0Yy4pXG4gICAgICAgIHZhciBzY29wZSA9IG9yaWdpbmFsU2NvcGUuJG5ldygpO1xuICAgICAgICB2YXIgb2ZmRGVzdHJveSA9IG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICAgIHNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95Jywgb2ZmRGVzdHJveSk7XG5cbiAgICAgICAgLy8gV0FJLUFSSUFcbiAgICAgICAgdmFyIHBvcHVwSWQgPSAndHlwZWFoZWFkLScgKyBzY29wZS4kaWQgKyAnLScgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gICAgICAgIGVsZW1lbnQuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnLFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICAgJ2FyaWEtb3ducyc6IHBvcHVwSWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9wb3AtdXAgZWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgbWF0Y2hlc1xuICAgICAgICB2YXIgcG9wVXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiB0eXBlYWhlYWQtcG9wdXA+PC9kaXY+Jyk7XG4gICAgICAgIHBvcFVwRWwuYXR0cih7XG4gICAgICAgICAgaWQ6IHBvcHVwSWQsXG4gICAgICAgICAgbWF0Y2hlczogJ21hdGNoZXMnLFxuICAgICAgICAgIGFjdGl2ZTogJ2FjdGl2ZUlkeCcsXG4gICAgICAgICAgc2VsZWN0OiAnc2VsZWN0KGFjdGl2ZUlkeCknLFxuICAgICAgICAgICdtb3ZlLWluLXByb2dyZXNzJzogJ21vdmVJblByb2dyZXNzJyxcbiAgICAgICAgICBxdWVyeTogJ3F1ZXJ5JyxcbiAgICAgICAgICBwb3NpdGlvbjogJ3Bvc2l0aW9uJ1xuICAgICAgICB9KTtcbiAgICAgICAgLy9jdXN0b20gaXRlbSB0ZW1wbGF0ZVxuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZWFoZWFkVGVtcGxhdGVVcmwpKSB7XG4gICAgICAgICAgcG9wVXBFbC5hdHRyKCd0ZW1wbGF0ZS11cmwnLCBhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCkpIHtcbiAgICAgICAgICBwb3BVcEVsLmF0dHIoJ3BvcHVwLXRlbXBsYXRlLXVybCcsIGF0dHJzLnR5cGVhaGVhZFBvcHVwVGVtcGxhdGVVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc2V0TWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNjb3BlLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAtMTtcbiAgICAgICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1hdGNoSWQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwb3B1cElkICsgJy1vcHRpb24tJyArIGluZGV4O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluZGljYXRlIHRoYXQgdGhlIHNwZWNpZmllZCBtYXRjaCBpcyB0aGUgYWN0aXZlIChwcmUtc2VsZWN0ZWQpIGl0ZW0gaW4gdGhlIGxpc3Qgb3duZWQgYnkgdGhpcyB0eXBlYWhlYWQuXG4gICAgICAgIC8vIFRoaXMgYXR0cmlidXRlIGlzIGFkZGVkIG9yIHJlbW92ZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBgYWN0aXZlSWR4YCBjaGFuZ2VzLlxuICAgICAgICBzY29wZS4kd2F0Y2goJ2FjdGl2ZUlkeCcsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBnZXRNYXRjaElkKGluZGV4KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaW5wdXRJc0V4YWN0TWF0Y2ggPSBmdW5jdGlvbihpbnB1dFZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCA+IGluZGV4ICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlLnRvVXBwZXJDYXNlKCkgPT09IHNjb3BlLm1hdGNoZXNbaW5kZXhdLmxhYmVsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRNYXRjaGVzQXN5bmMgPSBmdW5jdGlvbihpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgdmFyIGxvY2FscyA9IHskdmlld1ZhbHVlOiBpbnB1dFZhbHVlfTtcbiAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgdHJ1ZSk7XG4gICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICRxLndoZW4ocGFyc2VyUmVzdWx0LnNvdXJjZShvcmlnaW5hbFNjb3BlLCBsb2NhbHMpKS50aGVuKGZ1bmN0aW9uKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIC8vaXQgbWlnaHQgaGFwcGVuIHRoYXQgc2V2ZXJhbCBhc3luYyBxdWVyaWVzIHdlcmUgaW4gcHJvZ3Jlc3MgaWYgYSB1c2VyIHdlcmUgdHlwaW5nIGZhc3RcbiAgICAgICAgICAgIC8vYnV0IHdlIGFyZSBpbnRlcmVzdGVkIG9ubHkgaW4gcmVzcG9uc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY3VycmVudCB2aWV3IHZhbHVlXG4gICAgICAgICAgICB2YXIgb25DdXJyZW50UmVxdWVzdCA9IChpbnB1dFZhbHVlID09PSBtb2RlbEN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAob25DdXJyZW50UmVxdWVzdCAmJiBoYXNGb2N1cykge1xuICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IGZvY3VzRmlyc3QgPyAwIDogLTE7XG4gICAgICAgICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNjb3BlLm1hdGNoZXMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIC8vdHJhbnNmb3JtIGxhYmVsc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBtYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGdldE1hdGNoSWQoaSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBwYXJzZXJSZXN1bHQudmlld01hcHBlcihzY29wZSwgbG9jYWxzKSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1hdGNoZXNbaV1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlLnF1ZXJ5ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAvL3Bvc2l0aW9uIHBvcC11cCB3aXRoIG1hdGNoZXMgLSB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBpdHMgcG9zaXRpb24gZWFjaCB0aW1lIHdlIGFyZSBvcGVuaW5nIGEgd2luZG93XG4gICAgICAgICAgICAgICAgLy93aXRoIG1hdGNoZXMgYXMgYSBwb3AtdXAgbWlnaHQgYmUgYWJzb2x1dGUtcG9zaXRpb25lZCBhbmQgcG9zaXRpb24gb2YgYW4gaW5wdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIG9uIGEgcGFnZVxuICAgICAgICAgICAgICAgIC8vZHVlIHRvIG90aGVyIGVsZW1lbnRzIGJlaW5nIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgcmVjYWxjdWxhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvL1NlbGVjdCB0aGUgc2luZ2xlIHJlbWFpbmluZyBvcHRpb24gaWYgdXNlciBpbnB1dCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdE9uRXhhY3QgJiYgc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDEgJiYgaW5wdXRJc0V4YWN0TWF0Y2goaW5wdXRWYWx1ZSwgMCkpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlLnNlbGVjdCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkN1cnJlbnRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBiaW5kIGV2ZW50cyBvbmx5IGlmIGFwcGVuZFRvQm9keSBwYXJhbXMgZXhpc3QgLSBwZXJmb3JtYW5jZSBmZWF0dXJlXG4gICAgICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykuYmluZCgncmVzaXplJywgZmlyZVJlY2FsY3VsYXRpbmcpO1xuICAgICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYmluZCgnc2Nyb2xsJywgZmlyZVJlY2FsY3VsYXRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjbGFyZSB0aGUgdGltZW91dCBwcm9taXNlIHZhciBvdXRzaWRlIHRoZSBmdW5jdGlvbiBzY29wZSBzbyB0aGF0IHN0YWNrZWQgY2FsbHMgY2FuIGJlIGNhbmNlbGxlZCBsYXRlclxuICAgICAgICB2YXIgdGltZW91dEV2ZW50UHJvbWlzZTtcblxuICAgICAgICAvLyBEZWZhdWx0IHByb2dyZXNzIHR5cGVcbiAgICAgICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBmaXJlUmVjYWxjdWxhdGluZygpIHtcbiAgICAgICAgICBpZiAoIXNjb3BlLm1vdmVJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBzY29wZS5tb3ZlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2FuY2VsIHByZXZpb3VzIHRpbWVvdXRcbiAgICAgICAgICBpZiAodGltZW91dEV2ZW50UHJvbWlzZSkge1xuICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRFdmVudFByb21pc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlYm91bmNlZCBleGVjdXRpbmcgcmVjYWxjdWxhdGUgYWZ0ZXIgZXZlbnRzIGZpcmVkXG4gICAgICAgICAgdGltZW91dEV2ZW50UHJvbWlzZSA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gaWYgcG9wdXAgaXMgdmlzaWJsZVxuICAgICAgICAgICAgaWYgKHNjb3BlLm1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlY2FsY3VsYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICB9LCBldmVudERlYm91bmNlVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWNhbGN1bGF0ZSBhY3R1YWwgcG9zaXRpb24gYW5kIHNldCBuZXcgdmFsdWVzIHRvIHNjb3BlXG4gICAgICAgIC8vIGFmdGVyIGRpZ2VzdCBsb29wIGlzIHBvcHVwIGluIHJpZ2h0IHBvc2l0aW9uXG4gICAgICAgIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUG9zaXRpb24oKSB7XG4gICAgICAgICAgc2NvcGUucG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KGVsZW1lbnQpIDogJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgICAgIHNjb3BlLnBvc2l0aW9uLnRvcCArPSBlbGVtZW50LnByb3AoJ29mZnNldEhlaWdodCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG5cbiAgICAgICAgLy93ZSBuZWVkIHRvIHByb3BhZ2F0ZSB1c2VyJ3MgcXVlcnkgc28gd2UgY2FuIGhpZ2xpZ2h0IG1hdGNoZXNcbiAgICAgICAgc2NvcGUucXVlcnkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy9EZWNsYXJlIHRoZSB0aW1lb3V0IHByb21pc2UgdmFyIG91dHNpZGUgdGhlIGZ1bmN0aW9uIHNjb3BlIHNvIHRoYXQgc3RhY2tlZCBjYWxscyBjYW4gYmUgY2FuY2VsbGVkIGxhdGVyXG4gICAgICAgIHZhciB0aW1lb3V0UHJvbWlzZTtcblxuICAgICAgICB2YXIgc2NoZWR1bGVTZWFyY2hXaXRoVGltZW91dCA9IGZ1bmN0aW9uKGlucHV0VmFsdWUpIHtcbiAgICAgICAgICB0aW1lb3V0UHJvbWlzZSA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xuICAgICAgICAgIH0sIHdhaXRUaW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2FuY2VsUHJldmlvdXNUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRpbWVvdXRQcm9taXNlKSB7XG4gICAgICAgICAgICAkdGltZW91dC5jYW5jZWwodGltZW91dFByb21pc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL3BsdWcgaW50byAkcGFyc2VycyBwaXBlbGluZSB0byBvcGVuIGEgdHlwZWFoZWFkIG9uIHZpZXcgY2hhbmdlcyBpbml0aWF0ZWQgZnJvbSBET01cbiAgICAgICAgLy8kcGFyc2VycyBraWNrLWluIG9uIGFsbCB0aGUgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGUgdmlldyBhcyB3ZWxsIGFzIG1hbnVhbGx5IHRyaWdnZXJlZCBieSAkc2V0Vmlld1ZhbHVlXG4gICAgICAgIG1vZGVsQ3RybC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uKGlucHV0VmFsdWUpIHtcbiAgICAgICAgICBoYXNGb2N1cyA9IHRydWU7XG5cbiAgICAgICAgICBpZiAobWluTGVuZ3RoID09PSAwIHx8IGlucHV0VmFsdWUgJiYgaW5wdXRWYWx1ZS5sZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAod2FpdFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgIGNhbmNlbFByZXZpb3VzVGltZW91dCgpO1xuICAgICAgICAgICAgICBzY2hlZHVsZVNlYXJjaFdpdGhUaW1lb3V0KGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICAgY2FuY2VsUHJldmlvdXNUaW1lb3V0KCk7XG4gICAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAvLyBSZXNldCBpbiBjYXNlIHVzZXIgaGFkIHR5cGVkIHNvbWV0aGluZyBwcmV2aW91c2x5LlxuICAgICAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgZmFsc2UpO1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xuICAgICAgICAgIHZhciBjYW5kaWRhdGVWaWV3VmFsdWUsIGVtcHR5Vmlld1ZhbHVlO1xuICAgICAgICAgIHZhciBsb2NhbHMgPSB7fTtcblxuICAgICAgICAgIC8vIFRoZSB2YWxpZGl0eSBtYXkgYmUgc2V0IHRvIGZhbHNlIHZpYSAkcGFyc2VycyAoc2VlIGFib3ZlKSBpZlxuICAgICAgICAgIC8vIHRoZSBtb2RlbCBpcyByZXN0cmljdGVkIHRvIHNlbGVjdGVkIHZhbHVlcy4gSWYgdGhlIG1vZGVsXG4gICAgICAgICAgLy8gaXMgc2V0IG1hbnVhbGx5IGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgdmFsaWQuXG4gICAgICAgICAgaWYgKCFpc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnB1dEZvcm1hdHRlcikge1xuICAgICAgICAgICAgbG9jYWxzLiRtb2RlbCA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRGb3JtYXR0ZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9pdCBtaWdodCBoYXBwZW4gdGhhdCB3ZSBkb24ndCBoYXZlIGVub3VnaCBpbmZvIHRvIHByb3Blcmx5IHJlbmRlciBpbnB1dCB2YWx1ZVxuICAgICAgICAgICAgLy93ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGlzIHNpdHVhdGlvbiBhbmQgc2ltcGx5IHJldHVybiBtb2RlbCB2YWx1ZSBpZiB3ZSBjYW4ndCBhcHBseSBjdXN0b20gZm9ybWF0dGluZ1xuICAgICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBtb2RlbFZhbHVlO1xuICAgICAgICAgICAgY2FuZGlkYXRlVmlld1ZhbHVlID0gcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZW1wdHlWaWV3VmFsdWUgPSBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlVmlld1ZhbHVlIT09IGVtcHR5Vmlld1ZhbHVlID8gY2FuZGlkYXRlVmlld1ZhbHVlIDogbW9kZWxWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGFjdGl2ZUlkeCkge1xuICAgICAgICAgIC8vY2FsbGVkIGZyb20gd2l0aGluIHRoZSAkZGlnZXN0KCkgY3ljbGVcbiAgICAgICAgICB2YXIgbG9jYWxzID0ge307XG4gICAgICAgICAgdmFyIG1vZGVsLCBpdGVtO1xuXG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gaXRlbSA9IHNjb3BlLm1hdGNoZXNbYWN0aXZlSWR4XS5tb2RlbDtcbiAgICAgICAgICBtb2RlbCA9IHBhcnNlclJlc3VsdC5tb2RlbE1hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuICAgICAgICAgICRzZXRNb2RlbFZhbHVlKG9yaWdpbmFsU2NvcGUsIG1vZGVsKTtcbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3BhcnNlJywgdHJ1ZSk7XG5cbiAgICAgICAgICBvblNlbGVjdENhbGxiYWNrKG9yaWdpbmFsU2NvcGUsIHtcbiAgICAgICAgICAgICRpdGVtOiBpdGVtLFxuICAgICAgICAgICAgJG1vZGVsOiBtb2RlbCxcbiAgICAgICAgICAgICRsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG5cbiAgICAgICAgICAvL3JldHVybiBmb2N1cyB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBhIG1hdGNoIHdhcyBzZWxlY3RlZCB2aWEgYSBtb3VzZSBjbGljayBldmVudFxuICAgICAgICAgIC8vIHVzZSB0aW1lb3V0IHRvIGF2b2lkICRyb290U2NvcGU6aW5wcm9nIGVycm9yXG4gICAgICAgICAgaWYgKHNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEZvY3VzT25TZWxlY3QpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7IGVsZW1lbnRbMF0uZm9jdXMoKTsgfSwgMCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL2JpbmQga2V5Ym9hcmQgZXZlbnRzOiBhcnJvd3MgdXAoMzgpIC8gZG93big0MCksIGVudGVyKDEzKSBhbmQgdGFiKDkpLCBlc2MoMjcpXG4gICAgICAgIGVsZW1lbnQuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIC8vdHlwZWFoZWFkIGlzIG9wZW4gYW5kIGFuIFwiaW50ZXJlc3RpbmdcIiBrZXkgd2FzIHByZXNzZWRcbiAgICAgICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDAgfHwgSE9UX0tFWVMuaW5kZXhPZihldnQud2hpY2gpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBzZWxlY3RlZCAoaS5lLiBmb2N1c0ZpcnN0KSBhbmQgZW50ZXIgb3IgdGFiIGlzIGhpdCwgY2xlYXIgdGhlIHJlc3VsdHNcbiAgICAgICAgICBpZiAoc2NvcGUuYWN0aXZlSWR4ID09PSAtMSAmJiAoZXZ0LndoaWNoID09PSA5IHx8IGV2dC53aGljaCA9PT0gMTMpKSB7XG4gICAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChldnQud2hpY2ggPT09IDQwKSB7XG4gICAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAoc2NvcGUuYWN0aXZlSWR4ICsgMSkgJSBzY29wZS5tYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAzOCkge1xuICAgICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCA+IDAgPyBzY29wZS5hY3RpdmVJZHggOiBzY29wZS5tYXRjaGVzLmxlbmd0aCkgLSAxO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuXG4gICAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDEzIHx8IGV2dC53aGljaCA9PT0gOSkge1xuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHNjb3BlLmFjdGl2ZUlkeCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAyNykge1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsZW1lbnQuYmluZCgnYmx1cicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpc1NlbGVjdE9uQmx1ciAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCAmJiBzY29wZS5hY3RpdmVJZHggIT09IC0xICYmICFzZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEtlZXAgcmVmZXJlbmNlIHRvIGNsaWNrIGhhbmRsZXIgdG8gdW5iaW5kIGl0LlxuICAgICAgICB2YXIgZGlzbWlzc0NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIC8vIElzc3VlICMzOTczXG4gICAgICAgICAgLy8gRmlyZWZveCB0cmVhdHMgcmlnaHQgY2xpY2sgYXMgYSBjbGljayBvbiBkb2N1bWVudFxuICAgICAgICAgIGlmIChlbGVtZW50WzBdICE9PSBldnQudGFyZ2V0ICYmIGV2dC53aGljaCAhPT0gMyAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgICRkb2N1bWVudC5iaW5kKCdjbGljaycsIGRpc21pc3NDbGlja0hhbmRsZXIpO1xuXG4gICAgICAgIG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XG4gICAgICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICAgICAgJHBvcHVwLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcmV2ZW50IGpRdWVyeSBjYWNoZSBtZW1vcnkgbGVha1xuICAgICAgICAgIHBvcFVwRWwucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciAkcG9wdXAgPSAkY29tcGlsZShwb3BVcEVsKShzY29wZSk7XG5cbiAgICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKCRwb3B1cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5hZnRlcigkcG9wdXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICB9XSlcblxuICAuZGlyZWN0aXZlKCd0eXBlYWhlYWRQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIG1hdGNoZXM6ICc9JyxcbiAgICAgICAgcXVlcnk6ICc9JyxcbiAgICAgICAgYWN0aXZlOiAnPScsXG4gICAgICAgIHBvc2l0aW9uOiAnJicsXG4gICAgICAgIG1vdmVJblByb2dyZXNzOiAnPScsXG4gICAgICAgIHNlbGVjdDogJyYnXG4gICAgICB9LFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgICByZXR1cm4gYXR0cnMucG9wdXBUZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sJztcbiAgICAgIH0sXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgc2NvcGUudGVtcGxhdGVVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcblxuICAgICAgICBzY29wZS5pc09wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc2NvcGUubWF0Y2hlcy5sZW5ndGggPiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24obWF0Y2hJZHgpIHtcbiAgICAgICAgICByZXR1cm4gc2NvcGUuYWN0aXZlID09IG1hdGNoSWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLnNlbGVjdEFjdGl2ZSA9IGZ1bmN0aW9uKG1hdGNoSWR4KSB7XG4gICAgICAgICAgc2NvcGUuYWN0aXZlID0gbWF0Y2hJZHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuc2VsZWN0TWF0Y2ggPSBmdW5jdGlvbihhY3RpdmVJZHgpIHtcbiAgICAgICAgICBzY29wZS5zZWxlY3Qoe2FjdGl2ZUlkeDphY3RpdmVJZHh9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KVxuXG4gIC5kaXJlY3RpdmUoJ3R5cGVhaGVhZE1hdGNoJywgWyckdGVtcGxhdGVSZXF1ZXN0JywgJyRjb21waWxlJywgJyRwYXJzZScsIGZ1bmN0aW9uKCR0ZW1wbGF0ZVJlcXVlc3QsICRjb21waWxlLCAkcGFyc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgICBzY29wZToge1xuICAgICAgICBpbmRleDogJz0nLFxuICAgICAgICBtYXRjaDogJz0nLFxuICAgICAgICBxdWVyeTogJz0nXG4gICAgICB9LFxuICAgICAgbGluazpmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIHRwbFVybCA9ICRwYXJzZShhdHRycy50ZW1wbGF0ZVVybCkoc2NvcGUuJHBhcmVudCkgfHwgJ3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbCc7XG4gICAgICAgICR0ZW1wbGF0ZVJlcXVlc3QodHBsVXJsKS50aGVuKGZ1bmN0aW9uKHRwbENvbnRlbnQpIHtcbiAgICAgICAgICAkY29tcGlsZSh0cGxDb250ZW50LnRyaW0oKSkoc2NvcGUsIGZ1bmN0aW9uKGNsb25lZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVwbGFjZVdpdGgoY2xvbmVkRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5maWx0ZXIoJ3R5cGVhaGVhZEhpZ2hsaWdodCcsIFsnJHNjZScsICckaW5qZWN0b3InLCAnJGxvZycsIGZ1bmN0aW9uKCRzY2UsICRpbmplY3RvciwgJGxvZykge1xuICAgIHZhciBpc1Nhbml0aXplUHJlc2VudDtcbiAgICBpc1Nhbml0aXplUHJlc2VudCA9ICRpbmplY3Rvci5oYXMoJyRzYW5pdGl6ZScpO1xuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnZXhwKHF1ZXJ5VG9Fc2NhcGUpIHtcbiAgICAgIC8vIFJlZ2V4OiBjYXB0dXJlIHRoZSB3aG9sZSBxdWVyeSBzdHJpbmcgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgc3RyaW5nIHRoYXQgd2lsbCBiZSB1c2VkIHRvIG1hdGNoXG4gICAgICAvLyB0aGUgcmVzdWx0cywgZm9yIGV4YW1wbGUgaWYgdGhlIGNhcHR1cmUgaXMgXCJhXCIgdGhlIHJlc3VsdCB3aWxsIGJlIFxcYVxuICAgICAgcmV0dXJuIHF1ZXJ5VG9Fc2NhcGUucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csICdcXFxcJDEnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluc0h0bWwobWF0Y2hJdGVtKSB7XG4gICAgICByZXR1cm4gLzwuKj4vZy50ZXN0KG1hdGNoSXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1hdGNoSXRlbSwgcXVlcnkpIHtcbiAgICAgIGlmICghaXNTYW5pdGl6ZVByZXNlbnQgJiYgY29udGFpbnNIdG1sKG1hdGNoSXRlbSkpIHtcbiAgICAgICAgJGxvZy53YXJuKCdVbnNhZmUgdXNlIG9mIHR5cGVhaGVhZCBwbGVhc2UgdXNlIG5nU2FuaXRpemUnKTsgLy8gV2FybiB0aGUgdXNlciBhYm91dCB0aGUgZGFuZ2VyXG4gICAgICB9XG4gICAgICBtYXRjaEl0ZW0gPSBxdWVyeT8gKCcnICsgbWF0Y2hJdGVtKS5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnZXhwKHF1ZXJ5KSwgJ2dpJyksICc8c3Ryb25nPiQmPC9zdHJvbmc+JykgOiBtYXRjaEl0ZW07IC8vIFJlcGxhY2VzIHRoZSBjYXB0dXJlIHN0cmluZyB3aXRoIGEgdGhlIHNhbWUgc3RyaW5nIGluc2lkZSBvZiBhIFwic3Ryb25nXCIgdGFnXG4gICAgICBpZiAoIWlzU2FuaXRpemVQcmVzZW50KSB7XG4gICAgICAgIG1hdGNoSXRlbSA9ICRzY2UudHJ1c3RBc0h0bWwobWF0Y2hJdGVtKTsgLy8gSWYgJHNhbml0aXplIGlzIG5vdCBwcmVzZW50IHdlIHBhY2sgdGhlIHN0cmluZyBpbiBhICRzY2Ugb2JqZWN0IGZvciB0aGUgbmctYmluZC1odG1sIGRpcmVjdGl2ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoSXRlbTtcbiAgICB9O1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwYW5lbCB7e3BhbmVsQ2xhc3MgfHwgJ3BhbmVsLWRlZmF1bHQnfX1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCIgbmcta2V5cHJlc3M9XFxcInRvZ2dsZU9wZW4oJGV2ZW50KVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxoNCBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDxhIGhyZWYgdGFiaW5kZXg9XFxcIjBcXFwiIGNsYXNzPVxcXCJhY2NvcmRpb24tdG9nZ2xlXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlT3BlbigpXFxcIiBhY2NvcmRpb24tdHJhbnNjbHVkZT1cXFwiaGVhZGluZ1xcXCI+PHNwYW4gbmctY2xhc3M9XFxcInsndGV4dC1tdXRlZCc6IGlzRGlzYWJsZWR9XFxcIj57e2hlYWRpbmd9fTwvc3Bhbj48L2E+XFxuXCIgK1xuICAgIFwiICAgIDwvaDQ+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWNvbGxhcHNlIGNvbGxhcHNlXFxcIiBjb2xsYXBzZT1cXFwiIWlzT3BlblxcXCI+XFxuXCIgK1xuICAgIFwiXHQgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ncm91cFxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcImFsZXJ0XFxcIiBuZy1jbGFzcz1cXFwiWydhbGVydC0nICsgKHR5cGUgfHwgJ3dhcm5pbmcnKSwgY2xvc2VhYmxlID8gJ2FsZXJ0LWRpc21pc3NpYmxlJyA6IG51bGxdXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxidXR0b24gbmctc2hvdz1cXFwiY2xvc2VhYmxlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgbmctY2xpY2s9XFxcImNsb3NlKCRldmVudClcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L3NwYW4+XFxuXCIgK1xuICAgIFwiICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+Q2xvc2U8L3NwYW4+XFxuXCIgK1xuICAgIFwiICAgIDwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXG4gICAgXCI8ZGl2IG5nLW1vdXNlZW50ZXI9XFxcInBhdXNlKClcXFwiIG5nLW1vdXNlbGVhdmU9XFxcInBsYXkoKVxcXCIgY2xhc3M9XFxcImNhcm91c2VsXFxcIiBuZy1zd2lwZS1yaWdodD1cXFwicHJldigpXFxcIiBuZy1zd2lwZS1sZWZ0PVxcXCJuZXh0KClcXFwiPlxcblwiICtcbiAgICBcIiAgICA8b2wgY2xhc3M9XFxcImNhcm91c2VsLWluZGljYXRvcnNcXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxsaSBuZy1yZXBlYXQ9XFxcInNsaWRlIGluIHNsaWRlcyB8IG9yZGVyQnk6aW5kZXhPZlNsaWRlIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IGlzQWN0aXZlKHNsaWRlKX1cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Qoc2xpZGUpXFxcIj48L2xpPlxcblwiICtcbiAgICBcIiAgICA8L29sPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJjYXJvdXNlbC1pbm5lclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgPGEgY2xhc3M9XFxcImxlZnQgY2Fyb3VzZWwtY29udHJvbFxcXCIgbmctY2xpY2s9XFxcInByZXYoKVxcXCIgbmctc2hvdz1cXFwic2xpZGVzLmxlbmd0aCA+IDFcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9zcGFuPjwvYT5cXG5cIiArXG4gICAgXCIgICAgPGEgY2xhc3M9XFxcInJpZ2h0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJuZXh0KClcXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L3NwYW4+PC9hPlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLFxuICAgIFwiPGRpdiBuZy1jbGFzcz1cXFwie1xcblwiICtcbiAgICBcIiAgICAnYWN0aXZlJzogYWN0aXZlXFxuXCIgK1xuICAgIFwiICB9XFxcIiBjbGFzcz1cXFwiaXRlbSB0ZXh0LWNlbnRlclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFxuICAgIFwiPGRpdiBuZy1zd2l0Y2g9XFxcImRhdGVwaWNrZXJNb2RlXFxcIiByb2xlPVxcXCJhcHBsaWNhdGlvblxcXCIgbmcta2V5ZG93bj1cXFwia2V5ZG93bigkZXZlbnQpXFxcIj5cXG5cIiArXG4gICAgXCIgIDxkYXlwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcImRheVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiPjwvZGF5cGlja2VyPlxcblwiICtcbiAgICBcIiAgPG1vbnRocGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJtb250aFxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiPjwvbW9udGhwaWNrZXI+XFxuXCIgK1xuICAgIFwiICA8eWVhcnBpY2tlciBuZy1zd2l0Y2gtd2hlbj1cXFwieWVhclxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiPjwveWVhcnBpY2tlcj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcIixcbiAgICBcIjx0YWJsZSByb2xlPVxcXCJncmlkXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInt7YWN0aXZlRGF0ZUlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgPHRoZWFkPlxcblwiICtcbiAgICBcIiAgICA8dHI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7ezo6NSArIHNob3dXZWVrc319XFxcIj48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgc3R5bGU9XFxcIndpZHRoOjEwMCU7XFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBuZy1pZj1cXFwic2hvd1dlZWtzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoIG5nLXJlcGVhdD1cXFwibGFiZWwgaW4gOjpsYWJlbHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxzbWFsbCBhcmlhLWxhYmVsPVxcXCJ7ezo6bGFiZWwuZnVsbH19XFxcIj57ezo6bGFiZWwuYWJicn19PC9zbWFsbD48L3RoPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90aGVhZD5cXG5cIiArXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXG4gICAgXCIgICAgPHRyIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctaWY9XFxcInNob3dXZWVrc1xcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyIGg2XFxcIj48ZW0+e3sgd2Vla051bWJlcnNbJGluZGV4XSB9fTwvZW0+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3cgdHJhY2sgYnkgZHQuZGF0ZVxcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCIgaWQ9XFxcInt7OjpkdC51aWR9fVxcXCIgbmctY2xhc3M9XFxcIjo6ZHQuY3VzdG9tQ2xhc3NcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHN0eWxlPVxcXCJtaW4td2lkdGg6MTAwJTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtXFxcIiBuZy1jbGFzcz1cXFwieydidG4taW5mbyc6IGR0LnNlbGVjdGVkLCBhY3RpdmU6IGlzQWN0aXZlKGR0KX1cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoZHQuZGF0ZSlcXFwiIG5nLWRpc2FibGVkPVxcXCJkdC5kaXNhYmxlZFxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7J3RleHQtbXV0ZWQnOiBkdC5zZWNvbmRhcnksICd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsXG4gICAgXCI8dGFibGUgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXG5cIiArXG4gICAgXCIgIDx0aGVhZD5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiBpZD1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIHJvbGU9XFxcImhlYWRpbmdcXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRhdGVwaWNrZXJNb2RlID09PSBtYXhNb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHN0eWxlPVxcXCJ3aWR0aDoxMDAlO1xcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3RoZWFkPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvdyB0cmFjayBieSBkdC5kYXRlXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIiBpZD1cXFwie3s6OmR0LnVpZH19XFxcIiBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDoxMDAlO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xhc3M9XFxcInsnYnRuLWluZm8nOiBkdC5zZWxlY3RlZCwgYWN0aXZlOiBpc0FjdGl2ZShkdCl9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZHQuZGlzYWJsZWRcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnVcXFwiIG5nLWlmPVxcXCJpc09wZW5cXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBibG9ja1xcXCIgbmctc3R5bGU9XFxcInt0b3A6IHBvc2l0aW9uLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0KydweCd9XFxcIiBuZy1rZXlkb3duPVxcXCJrZXlkb3duKCRldmVudClcXFwiIG5nLWNsaWNrPVxcXCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcXFwiPlxcblwiICtcbiAgICBcIlx0PGxpIG5nLXRyYW5zY2x1ZGU+PC9saT5cXG5cIiArXG4gICAgXCJcdDxsaSBuZy1pZj1cXFwic2hvd0J1dHRvbkJhclxcXCIgc3R5bGU9XFxcInBhZGRpbmc6MTBweCA5cHggMnB4XFxcIj5cXG5cIiArXG4gICAgXCJcdFx0PHNwYW4gY2xhc3M9XFxcImJ0bi1ncm91cCBwdWxsLWxlZnRcXFwiPlxcblwiICtcbiAgICBcIlx0XHRcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4taW5mb1xcXCIgbmctY2xpY2s9XFxcInNlbGVjdCgndG9kYXknKVxcXCIgbmctZGlzYWJsZWQ9XFxcImlzRGlzYWJsZWQoJ3RvZGF5JylcXFwiPnt7IGdldFRleHQoJ2N1cnJlbnQnKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIlx0XHRcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGFuZ2VyXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KG51bGwpXFxcIj57eyBnZXRUZXh0KCdjbGVhcicpIH19PC9idXR0b24+XFxuXCIgK1xuICAgIFwiXHRcdDwvc3Bhbj5cXG5cIiArXG4gICAgXCJcdFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZSgpXFxcIj57eyBnZXRUZXh0KCdjbG9zZScpIH19PC9idXR0b24+XFxuXCIgK1xuICAgIFwiXHQ8L2xpPlxcblwiICtcbiAgICBcIjwvdWw+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvZGF0ZXBpY2tlci95ZWFyLmh0bWxcIixcbiAgICBcIjx0YWJsZSByb2xlPVxcXCJncmlkXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInt7YWN0aXZlRGF0ZUlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgPHRoZWFkPlxcblwiICtcbiAgICBcIiAgICA8dHI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBjb2xzcGFuPVxcXCIzXFxcIj48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgc3R5bGU9XFxcIndpZHRoOjEwMCU7XFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBuZy1yZXBlYXQ9XFxcInJvdyBpbiByb3dzIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiZHQgaW4gcm93IHRyYWNrIGJ5IGR0LmRhdGVcXFwiIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgcm9sZT1cXFwiZ3JpZGNlbGxcXFwiIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHN0eWxlPVxcXCJtaW4td2lkdGg6MTAwJTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsYXNzPVxcXCJ7J2J0bi1pbmZvJzogZHQuc2VsZWN0ZWQsIGFjdGl2ZTogaXNBY3RpdmUoZHQpfVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCIgbmctZGlzYWJsZWQ9XFxcImR0LmRpc2FibGVkXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIG5nLWNsYXNzPVxcXCI6OnsndGV4dC1pbmZvJzogZHQuY3VycmVudH1cXFwiPnt7OjpkdC5sYWJlbH19PC9zcGFuPjwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3Rib2R5PlxcblwiICtcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbC1iYWNrZHJvcFxcXCJcXG5cIiArXG4gICAgXCIgICAgIG1vZGFsLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgICAgIG1vZGFsLWluLWNsYXNzPVxcXCJpblxcXCJcXG5cIiArXG4gICAgXCIgICAgIG5nLXN0eWxlPVxcXCJ7J3otaW5kZXgnOiAxMDQwICsgKGluZGV4ICYmIDEgfHwgMCkgKyBpbmRleCoxMH1cXFwiXFxuXCIgK1xuICAgIFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsXG4gICAgXCI8ZGl2IG1vZGFsLXJlbmRlcj1cXFwie3skaXNSZW5kZXJlZH19XFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgY2xhc3M9XFxcIm1vZGFsXFxcIlxcblwiICtcbiAgICBcIiAgICBtb2RhbC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICAgIG1vZGFsLWluLWNsYXNzPVxcXCJpblxcXCJcXG5cIiArXG4gICAgXCJcdG5nLXN0eWxlPVxcXCJ7J3otaW5kZXgnOiAxMDUwICsgaW5kZXgqMTAsIGRpc3BsYXk6ICdibG9jayd9XFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCIgbmctY2xhc3M9XFxcInNpemUgPyAnbW9kYWwtJyArIHNpemUgOiAnJ1xcXCI+PGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCIgbW9kYWwtdHJhbnNjbHVkZT48L2Rpdj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcInBhZ2VyXFxcIj5cXG5cIiArXG4gICAgXCIgIDxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWQsIHByZXZpb3VzOiBhbGlnbn1cXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSAtIDEsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCdwcmV2aW91cycpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCIgIDxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZCwgbmV4dDogYWxpZ259XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgKyAxLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dCgnbmV4dCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcInBhZ2luYXRpb25cXFwiPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCI6OmJvdW5kYXJ5TGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZH1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLWZpcnN0XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKDEsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCdmaXJzdCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCIgIDxsaSBuZy1pZj1cXFwiOjpkaXJlY3Rpb25MaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcHJldlxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlIC0gMSwgJGV2ZW50KVxcXCI+e3s6OmdldFRleHQoJ3ByZXZpb3VzJyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBwYWdlLmFjdGl2ZSxkaXNhYmxlZDogbmdEaXNhYmxlZCYmIXBhZ2UuYWN0aXZlfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcGFnZVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlLm51bWJlciwgJGV2ZW50KVxcXCI+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCI6OmRpcmVjdGlvbkxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZH1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLW5leHRcXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSArIDEsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCduZXh0Jyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCI6OmJvdW5kYXJ5TGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tbGFzdFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZSh0b3RhbFBhZ2VzLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dCgnbGFzdCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcFxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1jbGFzc2VzXFxuXCIgK1xuICAgIFwiICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIG5nLWJpbmQtaHRtbD1cXFwiY29udGVudEV4cCgpXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtdW5zYWZlLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcFxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1jbGFzc2VzXFxuXCIgK1xuICAgIFwiICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIGJpbmQtaHRtbC11bnNhZmU9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWNsYXNzZXNcXG5cIiArXG4gICAgXCIgIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCIgbmctYmluZD1cXFwiY29udGVudFxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXBcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtY2xhc3Nlc1xcblwiICtcbiAgICBcIiAgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIlxcblwiICtcbiAgICBcIiAgICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGU9XFxcImNvbnRlbnRFeHAoKVxcXCJcXG5cIiArXG4gICAgXCIgICAgdG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlLXNjb3BlPVxcXCJvcmlnaW5TY29wZSgpXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBvcG92ZXJcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtY2xhc3Nlc1xcblwiICtcbiAgICBcIiAgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ0aXRsZVxcXCIgbmctaWY9XFxcInRpdGxlXFxcIj48L2gzPlxcblwiICtcbiAgICBcIiAgICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY29udGVudFxcXCIgbmctYmluZC1odG1sPVxcXCJjb250ZW50RXhwKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBvcG92ZXJcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHRvb2x0aXAtY2xhc3Nlc1xcblwiICtcbiAgICBcIiAgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ0aXRsZVxcXCIgbmctaWY9XFxcInRpdGxlXFxcIj48L2gzPlxcblwiICtcbiAgICBcIiAgICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY29udGVudFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgIHRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZT1cXFwiY29udGVudEV4cCgpXFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgdG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlLXNjb3BlPVxcXCJvcmlnaW5TY29wZSgpXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyXFxcIlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWNsYXNzZXNcXG5cIiArXG4gICAgXCIgIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItaW5uZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidGl0bGVcXFwiIG5nLWlmPVxcXCJ0aXRsZVxcXCI+PC9oMz5cXG5cIiArXG4gICAgXCIgICAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiIG5nLWJpbmQ9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgJ3Byb2dyZXNzLWJhci0nICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArICclJ31cXFwiIGFyaWEtdmFsdWV0ZXh0PVxcXCJ7e3BlcmNlbnQgfCBudW1iZXI6MH19JVxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDogMDtcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgJ3Byb2dyZXNzLWJhci0nICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArICclJ31cXFwiIGFyaWEtdmFsdWV0ZXh0PVxcXCJ7e3BlcmNlbnQgfCBudW1iZXI6MH19JVxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDogMDtcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFxuICAgIFwiPHNwYW4gbmctbW91c2VsZWF2ZT1cXFwicmVzZXQoKVxcXCIgbmcta2V5ZG93bj1cXFwib25LZXlkb3duKCRldmVudClcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcInt7cmFuZ2UubGVuZ3RofX1cXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxzcGFuIG5nLXJlcGVhdC1zdGFydD1cXFwiciBpbiByYW5nZSB0cmFjayBieSAkaW5kZXhcXFwiIGNsYXNzPVxcXCJzci1vbmx5XFxcIj4oe3sgJGluZGV4IDwgdmFsdWUgPyAnKicgOiAnICcgfX0pPC9zcGFuPlxcblwiICtcbiAgICBcIiAgICA8aSBuZy1yZXBlYXQtZW5kIG5nLW1vdXNlZW50ZXI9XFxcImVudGVyKCRpbmRleCArIDEpXFxcIiBuZy1jbGljaz1cXFwicmF0ZSgkaW5kZXggKyAxKVxcXCIgY2xhc3M9XFxcImdseXBoaWNvblxcXCIgbmctY2xhc3M9XFxcIiRpbmRleCA8IHZhbHVlICYmIChyLnN0YXRlT24gfHwgJ2dseXBoaWNvbi1zdGFyJykgfHwgKHIuc3RhdGVPZmYgfHwgJ2dseXBoaWNvbi1zdGFyLWVtcHR5JylcXFwiIG5nLWF0dHItdGl0bGU9XFxcInt7ci50aXRsZX19XFxcIiA+PC9pPlxcblwiICtcbiAgICBcIjwvc3Bhbj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RhYnMvdGFiLmh0bWxcIixcbiAgICBcIjxsaSBuZy1jbGFzcz1cXFwie2FjdGl2ZTogYWN0aXZlLCBkaXNhYmxlZDogZGlzYWJsZWR9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdCgpXFxcIiB0YWItaGVhZGluZy10cmFuc2NsdWRlPnt7aGVhZGluZ319PC9hPlxcblwiICtcbiAgICBcIjwvbGk+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXCIsXG4gICAgXCI8ZGl2PlxcblwiICtcbiAgICBcIiAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXt7dHlwZSB8fCAndGFicyd9fVxcXCIgbmctY2xhc3M9XFxcInsnbmF2LXN0YWNrZWQnOiB2ZXJ0aWNhbCwgJ25hdi1qdXN0aWZpZWQnOiBqdXN0aWZpZWR9XFxcIiBuZy10cmFuc2NsdWRlPjwvdWw+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBcXG5cIiArXG4gICAgXCIgICAgICAgICBuZy1yZXBlYXQ9XFxcInRhYiBpbiB0YWJzXFxcIiBcXG5cIiArXG4gICAgXCIgICAgICAgICBuZy1jbGFzcz1cXFwie2FjdGl2ZTogdGFiLmFjdGl2ZX1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgdGFiLWNvbnRlbnQtdHJhbnNjbHVkZT1cXFwidGFiXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPC9kaXY+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLFxuICAgIFwiPHRhYmxlPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCI6OnNob3dTcGlubmVyc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRIb3VycygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0luY3JlbWVudEhvdXJzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkPiZuYnNwOzwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRNaW51dGVzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vSW5jcmVtZW50TWludXRlcygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cFxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1lcnJvcic6IGludmFsaWRIb3Vyc31cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGlucHV0IHN0eWxlPVxcXCJ3aWR0aDo1MHB4O1xcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcImhvdXJzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZUhvdXJzKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGV4dC1jZW50ZXJcXFwiIG5nLXJlYWRvbmx5PVxcXCI6OnJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+OjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIiBuZy1jbGFzcz1cXFwieydoYXMtZXJyb3InOiBpbnZhbGlkTWludXRlc31cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGlucHV0IHN0eWxlPVxcXCJ3aWR0aDo1MHB4O1xcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcIm1pbnV0ZXNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlTWludXRlcygpXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRleHQtY2VudGVyXFxcIiBuZy1yZWFkb25seT1cXFwiOjpyZWFkb25seUlucHV0XFxcIiBtYXhsZW5ndGg9XFxcIjJcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vVG9nZ2xlTWVyaWRpYW4oKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgdGV4dC1jZW50ZXJcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNZXJpZGlhbigpXFxcIj57e21lcmlkaWFufX08L2J1dHRvbj48L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCI6OnNob3dTcGlubmVyc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkPjxhIG5nLWNsaWNrPVxcXCJkZWNyZW1lbnRIb3VycygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudEhvdXJzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+Jm5ic3A7PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudE1pbnV0ZXMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9EZWNyZW1lbnRNaW51dGVzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXG4gICAgXCI8L3RhYmxlPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIixcbiAgICBcIjxhIGhyZWYgdGFiaW5kZXg9XFxcIi0xXFxcIiBuZy1iaW5kLWh0bWw9XFxcIm1hdGNoLmxhYmVsIHwgdHlwZWFoZWFkSGlnaGxpZ2h0OnF1ZXJ5XFxcIj48L2E+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLFxuICAgIFwiPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiBuZy1zaG93PVxcXCJpc09wZW4oKSAmJiAhbW92ZUluUHJvZ3Jlc3NcXFwiIG5nLXN0eWxlPVxcXCJ7dG9wOiBwb3NpdGlvbigpLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbigpLmxlZnQrJ3B4J31cXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBibG9jaztcXFwiIHJvbGU9XFxcImxpc3Rib3hcXFwiIGFyaWEtaGlkZGVuPVxcXCJ7eyFpc09wZW4oKX19XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGxpIG5nLXJlcGVhdD1cXFwibWF0Y2ggaW4gbWF0Y2hlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBpc0FjdGl2ZSgkaW5kZXgpIH1cXFwiIG5nLW1vdXNlZW50ZXI9XFxcInNlbGVjdEFjdGl2ZSgkaW5kZXgpXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0TWF0Y2goJGluZGV4KVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBpZD1cXFwie3s6Om1hdGNoLmlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGRpdiB0eXBlYWhlYWQtbWF0Y2ggaW5kZXg9XFxcIiRpbmRleFxcXCIgbWF0Y2g9XFxcIm1hdGNoXFxcIiBxdWVyeT1cXFwicXVlcnlcXFwiIHRlbXBsYXRlLXVybD1cXFwidGVtcGxhdGVVcmxcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgICA8L2xpPlxcblwiICtcbiAgICBcIjwvdWw+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuIWFuZ3VsYXIuJCRjc3AoKSAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+Lm5nLWFuaW1hdGUuaXRlbTpub3QoLmxlZnQpOm5vdCgucmlnaHQpey13ZWJraXQtdHJhbnNpdGlvbjowcyBlYXNlLWluLW91dCBsZWZ0O3RyYW5zaXRpb246MHMgZWFzZS1pbi1vdXQgbGVmdH08L3N0eWxlPicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9hbmd1bGFyLXNhbml0aXplJyk7XG5tb2R1bGUuZXhwb3J0cyA9ICduZ1Nhbml0aXplJztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FuZ3VsYXItc2FuaXRpemUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS40LjdcbiAqIChjKSAyMDEwLTIwMTUgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgQW55IGNvbW1pdHMgdG8gdGhpcyBmaWxlIHNob3VsZCBiZSByZXZpZXdlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuICAqXG4gKiAgIENoYW5nZXMgdG8gdGhpcyBmaWxlIGNhbiBwb3RlbnRpYWxseSBjcmVhdGUgc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzLiAqXG4gKiAgICAgICAgICBBbiBhcHByb3ZhbCBmcm9tIDIgQ29yZSBtZW1iZXJzIHdpdGggaGlzdG9yeSBvZiBtb2RpZnlpbmcgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGZpbGUgaXMgcmVxdWlyZWQuICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgRG9lcyB0aGUgY2hhbmdlIHNvbWVob3cgYWxsb3cgZm9yIGFyYml0cmFyeSBqYXZhc2NyaXB0IHRvIGJlIGV4ZWN1dGVkPyAqXG4gKiAgICBPciBhbGxvd3MgZm9yIHNvbWVvbmUgdG8gY2hhbmdlIHRoZSBwcm90b3R5cGUgb2YgYnVpbHQtaW4gb2JqZWN0cz8gICAqXG4gKiAgICAgT3IgZ2l2ZXMgdW5kZXNpcmVkIGFjY2VzcyB0byB2YXJpYWJsZXMgbGlrZXMgZG9jdW1lbnQgb3Igd2luZG93PyAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG52YXIgJHNhbml0aXplTWluRXJyID0gYW5ndWxhci4kJG1pbkVycignJHNhbml0aXplJyk7XG5cbi8qKlxuICogQG5nZG9jIG1vZHVsZVxuICogQG5hbWUgbmdTYW5pdGl6ZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogIyBuZ1Nhbml0aXplXG4gKlxuICogVGhlIGBuZ1Nhbml0aXplYCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byBzYW5pdGl6ZSBIVE1MLlxuICpcbiAqXG4gKiA8ZGl2IGRvYy1tb2R1bGUtY29tcG9uZW50cz1cIm5nU2FuaXRpemVcIj48L2Rpdj5cbiAqXG4gKiBTZWUge0BsaW5rIG5nU2FuaXRpemUuJHNhbml0aXplIGAkc2FuaXRpemVgfSBmb3IgdXNhZ2UuXG4gKi9cblxuLypcbiAqIEhUTUwgUGFyc2VyIEJ5IE1pc2tvIEhldmVyeSAobWlza29AaGV2ZXJ5LmNvbSlcbiAqIGJhc2VkIG9uOiAgSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqXG4gKiAvLyBVc2UgbGlrZSBzbzpcbiAqIGh0bWxQYXJzZXIoaHRtbFN0cmluZywge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzLCB1bmFyeSkge30sXG4gKiAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHt9LFxuICogICAgIGNoYXJzOiBmdW5jdGlvbih0ZXh0KSB7fSxcbiAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICogfSk7XG4gKlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJHNhbml0aXplXG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogICBUaGUgaW5wdXQgaXMgc2FuaXRpemVkIGJ5IHBhcnNpbmcgdGhlIEhUTUwgaW50byB0b2tlbnMuIEFsbCBzYWZlIHRva2VucyAoZnJvbSBhIHdoaXRlbGlzdCkgYXJlXG4gKiAgIHRoZW4gc2VyaWFsaXplZCBiYWNrIHRvIHByb3Blcmx5IGVzY2FwZWQgaHRtbCBzdHJpbmcuIFRoaXMgbWVhbnMgdGhhdCBubyB1bnNhZmUgaW5wdXQgY2FuIG1ha2VcbiAqICAgaXQgaW50byB0aGUgcmV0dXJuZWQgc3RyaW5nLCBob3dldmVyLCBzaW5jZSBvdXIgcGFyc2VyIGlzIG1vcmUgc3RyaWN0IHRoYW4gYSB0eXBpY2FsIGJyb3dzZXJcbiAqICAgcGFyc2VyLCBpdCdzIHBvc3NpYmxlIHRoYXQgc29tZSBvYnNjdXJlIGlucHV0LCB3aGljaCB3b3VsZCBiZSByZWNvZ25pemVkIGFzIHZhbGlkIEhUTUwgYnkgYVxuICogICBicm93c2VyLCB3b24ndCBtYWtlIGl0IHRocm91Z2ggdGhlIHNhbml0aXplci4gVGhlIGlucHV0IG1heSBhbHNvIGNvbnRhaW4gU1ZHIG1hcmt1cC5cbiAqICAgVGhlIHdoaXRlbGlzdCBpcyBjb25maWd1cmVkIHVzaW5nIHRoZSBmdW5jdGlvbnMgYGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0YCBhbmRcbiAqICAgYGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdGAgb2Yge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXIgYCRjb21waWxlUHJvdmlkZXJgfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBIVE1MIGlucHV0LlxuICogQHJldHVybnMge3N0cmluZ30gU2FuaXRpemVkIEhUTUwuXG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cInNhbml0aXplRXhhbXBsZVwiIGRlcHM9XCJhbmd1bGFyLXNhbml0aXplLmpzXCI+XG4gICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICA8c2NyaXB0PlxuICAgICAgICAgYW5ndWxhci5tb2R1bGUoJ3Nhbml0aXplRXhhbXBsZScsIFsnbmdTYW5pdGl6ZSddKVxuICAgICAgICAgICAuY29udHJvbGxlcignRXhhbXBsZUNvbnRyb2xsZXInLCBbJyRzY29wZScsICckc2NlJywgZnVuY3Rpb24oJHNjb3BlLCAkc2NlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLnNuaXBwZXQgPVxuICAgICAgICAgICAgICAgJzxwIHN0eWxlPVwiY29sb3I6Ymx1ZVwiPmFuIGh0bWxcXG4nICtcbiAgICAgICAgICAgICAgICc8ZW0gb25tb3VzZW92ZXI9XCJ0aGlzLnRleHRDb250ZW50PVxcJ1BXTjNEIVxcJ1wiPmNsaWNrIGhlcmU8L2VtPlxcbicgK1xuICAgICAgICAgICAgICAgJ3NuaXBwZXQ8L3A+JztcbiAgICAgICAgICAgICAkc2NvcGUuZGVsaWJlcmF0ZWx5VHJ1c3REYW5nZXJvdXNTbmlwcGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzSHRtbCgkc2NvcGUuc25pcHBldCk7XG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgfV0pO1xuICAgICA8L3NjcmlwdD5cbiAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiRXhhbXBsZUNvbnRyb2xsZXJcIj5cbiAgICAgICAgU25pcHBldDogPHRleHRhcmVhIG5nLW1vZGVsPVwic25pcHBldFwiIGNvbHM9XCI2MFwiIHJvd3M9XCIzXCI+PC90ZXh0YXJlYT5cbiAgICAgICA8dGFibGU+XG4gICAgICAgICA8dHI+XG4gICAgICAgICAgIDx0ZD5EaXJlY3RpdmU8L3RkPlxuICAgICAgICAgICA8dGQ+SG93PC90ZD5cbiAgICAgICAgICAgPHRkPlNvdXJjZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5SZW5kZXJlZDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiYmluZC1odG1sLXdpdGgtc2FuaXRpemVcIj5cbiAgICAgICAgICAgPHRkPm5nLWJpbmQtaHRtbDwvdGQ+XG4gICAgICAgICAgIDx0ZD5BdXRvbWF0aWNhbGx5IHVzZXMgJHNhbml0aXplPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0XCImZ3Q7PGJyLz4mbHQ7L2RpdiZndDs8L3ByZT48L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWh0bWwtd2l0aC10cnVzdFwiPlxuICAgICAgICAgICA8dGQ+bmctYmluZC1odG1sPC90ZD5cbiAgICAgICAgICAgPHRkPkJ5cGFzcyAkc2FuaXRpemUgYnkgZXhwbGljaXRseSB0cnVzdGluZyB0aGUgZGFuZ2Vyb3VzIHZhbHVlPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwiZGVsaWJlcmF0ZWx5VHJ1c3REYW5nZXJvdXNTbmlwcGV0KClcIiZndDtcbiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kLWh0bWw9XCJkZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQoKVwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiYmluZC1kZWZhdWx0XCI+XG4gICAgICAgICAgIDx0ZD5uZy1iaW5kPC90ZD5cbiAgICAgICAgICAgPHRkPkF1dG9tYXRpY2FsbHkgZXNjYXBlczwvdGQ+XG4gICAgICAgICAgIDx0ZD48cHJlPiZsdDtkaXYgbmctYmluZD1cInNuaXBwZXRcIiZndDs8YnIvPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgPC90YWJsZT5cbiAgICAgICA8L2Rpdj5cbiAgIDwvZmlsZT5cbiAgIDxmaWxlIG5hbWU9XCJwcm90cmFjdG9yLmpzXCIgdHlwZT1cInByb3RyYWN0b3JcIj5cbiAgICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSB0aGUgaHRtbCBzbmlwcGV0IGJ5IGRlZmF1bHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZSBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZSgnPHA+YW4gaHRtbFxcbjxlbT5jbGljayBoZXJlPC9lbT5cXG5zbmlwcGV0PC9wPicpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIGlubGluZSByYXcgc25pcHBldCBpZiBib3VuZCB0byBhIHRydXN0ZWQgdmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC10cnVzdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZShcIjxwIHN0eWxlPVxcXCJjb2xvcjpibHVlXFxcIj5hbiBodG1sXFxuXCIgK1xuICAgICAgICAgICAgICBcIjxlbSBvbm1vdXNlb3Zlcj1cXFwidGhpcy50ZXh0Q29udGVudD0nUFdOM0QhJ1xcXCI+Y2xpY2sgaGVyZTwvZW0+XFxuXCIgK1xuICAgICAgICAgICAgICBcInNuaXBwZXQ8L3A+XCIpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIGVzY2FwZSBzbmlwcGV0IHdpdGhvdXQgYW55IGZpbHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtZGVmYXVsdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZShcIiZsdDtwIHN0eWxlPVxcXCJjb2xvcjpibHVlXFxcIiZndDthbiBodG1sXFxuXCIgK1xuICAgICAgICAgICAgICBcIiZsdDtlbSBvbm1vdXNlb3Zlcj1cXFwidGhpcy50ZXh0Q29udGVudD0nUFdOM0QhJ1xcXCImZ3Q7Y2xpY2sgaGVyZSZsdDsvZW0mZ3Q7XFxuXCIgK1xuICAgICAgICAgICAgICBcInNuaXBwZXQmbHQ7L3AmZ3Q7XCIpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuY2xlYXIoKTtcbiAgICAgICBlbGVtZW50KGJ5Lm1vZGVsKCdzbmlwcGV0JykpLnNlbmRLZXlzKCduZXcgPGIgb25jbGljaz1cImFsZXJ0KDEpXCI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZSBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZSgnbmV3IDxiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1odG1sLXdpdGgtdHJ1c3QgZGl2JykpLmdldElubmVySHRtbCgpKS50b0JlKFxuICAgICAgICAgJ25ldyA8YiBvbmNsaWNrPVwiYWxlcnQoMSlcIj50ZXh0PC9iPicpO1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtZGVmYXVsdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLnRvQmUoXG4gICAgICAgICBcIm5ldyAmbHQ7YiBvbmNsaWNrPVxcXCJhbGVydCgxKVxcXCImZ3Q7dGV4dCZsdDsvYiZndDtcIik7XG4gICAgIH0pO1xuICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG5mdW5jdGlvbiAkU2FuaXRpemVQcm92aWRlcigpIHtcbiAgdGhpcy4kZ2V0ID0gWyckJHNhbml0aXplVXJpJywgZnVuY3Rpb24oJCRzYW5pdGl6ZVVyaSkge1xuICAgIHJldHVybiBmdW5jdGlvbihodG1sKSB7XG4gICAgICB2YXIgYnVmID0gW107XG4gICAgICBodG1sUGFyc2VyKGh0bWwsIGh0bWxTYW5pdGl6ZVdyaXRlcihidWYsIGZ1bmN0aW9uKHVyaSwgaXNJbWFnZSkge1xuICAgICAgICByZXR1cm4gIS9edW5zYWZlLy50ZXN0KCQkc2FuaXRpemVVcmkodXJpLCBpc0ltYWdlKSk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICAgIH07XG4gIH1dO1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVRleHQoY2hhcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdO1xuICB2YXIgd3JpdGVyID0gaHRtbFNhbml0aXplV3JpdGVyKGJ1ZiwgYW5ndWxhci5ub29wKTtcbiAgd3JpdGVyLmNoYXJzKGNoYXJzKTtcbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn1cblxuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBTVEFSVF9UQUdfUkVHRVhQID1cbiAgICAgICAvXjwoKD86W2EtekEtWl0pW1xcdzotXSopKCg/OlxccytbXFx3Oi1dKyg/Olxccyo9XFxzKig/Oig/OlwiW15cIl0qXCIpfCg/OidbXiddKicpfFtePlxcc10rKSk/KSopXFxzKihcXC8/KVxccyooPj8pLyxcbiAgRU5EX1RBR19SRUdFWFAgPSAvXjxcXC9cXHMqKFtcXHc6LV0rKVtePl0qPi8sXG4gIEFUVFJfUkVHRVhQID0gLyhbXFx3Oi1dKykoPzpcXHMqPVxccyooPzooPzpcIigoPzpbXlwiXSkqKVwiKXwoPzonKCg/OlteJ10pKiknKXwoW14+XFxzXSspKSk/L2csXG4gIEJFR0lOX1RBR19SRUdFWFAgPSAvXjwvLFxuICBCRUdJTkdfRU5EX1RBR0VfUkVHRVhQID0gL148XFwvLyxcbiAgQ09NTUVOVF9SRUdFWFAgPSAvPCEtLSguKj8pLS0+L2csXG4gIERPQ1RZUEVfUkVHRVhQID0gLzwhRE9DVFlQRShbXj5dKj8pPi9pLFxuICBDREFUQV9SRUdFWFAgPSAvPCFcXFtDREFUQVxcWyguKj8pXV0+L2csXG4gIFNVUlJPR0FURV9QQUlSX1JFR0VYUCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csXG4gIC8vIE1hdGNoIGV2ZXJ5dGhpbmcgb3V0c2lkZSBvZiBub3JtYWwgY2hhcnMgYW5kIFwiIChxdW90ZSBjaGFyYWN0ZXIpXG4gIE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQID0gLyhbXlxcIy1+fCB8IV0pL2c7XG5cblxuLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI3NlbWFudGljc1xuLy8gaHR0cDovL3NpbW9uLmh0bWw1Lm9yZy9odG1sLWVsZW1lbnRzXG5cbi8vIFNhZmUgVm9pZCBFbGVtZW50cyAtIEhUTUw1XG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdm9pZC1lbGVtZW50c1xudmFyIHZvaWRFbGVtZW50cyA9IG1ha2VNYXAoXCJhcmVhLGJyLGNvbCxocixpbWcsd2JyXCIpO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW4gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI29wdGlvbmFsLXRhZ3NcbnZhciBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMgPSBtYWtlTWFwKFwiY29sZ3JvdXAsZGQsZHQsbGkscCx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCx0clwiKSxcbiAgICBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzID0gbWFrZU1hcChcInJwLHJ0XCIpLFxuICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMgPSBhbmd1bGFyLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdJbmxpbmVFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzKTtcblxuLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG52YXIgYmxvY2tFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMsIG1ha2VNYXAoXCJhZGRyZXNzLGFydGljbGUsXCIgK1xuICAgICAgICBcImFzaWRlLGJsb2NrcXVvdGUsY2FwdGlvbixjZW50ZXIsZGVsLGRpcixkaXYsZGwsZmlndXJlLGZpZ2NhcHRpb24sZm9vdGVyLGgxLGgyLGgzLGg0LGg1LFwiICtcbiAgICAgICAgXCJoNixoZWFkZXIsaGdyb3VwLGhyLGlucyxtYXAsbWVudSxuYXYsb2wscHJlLHNjcmlwdCxzZWN0aW9uLHRhYmxlLHVsXCIpKTtcblxuLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbnZhciBpbmxpbmVFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzLCBtYWtlTWFwKFwiYSxhYmJyLGFjcm9ueW0sYixcIiArXG4gICAgICAgIFwiYmRpLGJkbyxiaWcsYnIsY2l0ZSxjb2RlLGRlbCxkZm4sZW0sZm9udCxpLGltZyxpbnMsa2JkLGxhYmVsLG1hcCxtYXJrLHEscnVieSxycCxydCxzLFwiICtcbiAgICAgICAgXCJzYW1wLHNtYWxsLHNwYW4sc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHRpbWUsdHQsdSx2YXJcIikpO1xuXG4vLyBTVkcgRWxlbWVudHNcbi8vIGh0dHBzOi8vd2lraS53aGF0d2cub3JnL3dpa2kvU2FuaXRpemF0aW9uX3J1bGVzI3N2Z19FbGVtZW50c1xuLy8gTm90ZTogdGhlIGVsZW1lbnRzIGFuaW1hdGUsYW5pbWF0ZUNvbG9yLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxzZXQgYXJlIGludGVudGlvbmFsbHkgb21pdHRlZC5cbi8vIFRoZXkgY2FuIHBvdGVudGlhbGx5IGFsbG93IGZvciBhcmJpdHJhcnkgamF2YXNjcmlwdCB0byBiZSBleGVjdXRlZC4gU2VlICMxMTI5MFxudmFyIHN2Z0VsZW1lbnRzID0gbWFrZU1hcChcImNpcmNsZSxkZWZzLGRlc2MsZWxsaXBzZSxmb250LWZhY2UsZm9udC1mYWNlLW5hbWUsZm9udC1mYWNlLXNyYyxnLGdseXBoLFwiICtcbiAgICAgICAgXCJoa2VybixpbWFnZSxsaW5lYXJHcmFkaWVudCxsaW5lLG1hcmtlcixtZXRhZGF0YSxtaXNzaW5nLWdseXBoLG1wYXRoLHBhdGgscG9seWdvbixwb2x5bGluZSxcIiArXG4gICAgICAgIFwicmFkaWFsR3JhZGllbnQscmVjdCxzdG9wLHN2Zyxzd2l0Y2gsdGV4dCx0aXRsZSx0c3Bhbix1c2VcIik7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIHNwZWNpYWxFbGVtZW50cyA9IG1ha2VNYXAoXCJzY3JpcHQsc3R5bGVcIik7XG5cbnZhciB2YWxpZEVsZW1lbnRzID0gYW5ndWxhci5leHRlbmQoe30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWRFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnRzKTtcblxuLy9BdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxudmFyIHVyaUF0dHJzID0gbWFrZU1hcChcImJhY2tncm91bmQsY2l0ZSxocmVmLGxvbmdkZXNjLHNyYyx1c2VtYXAseGxpbms6aHJlZlwiKTtcblxudmFyIGh0bWxBdHRycyA9IG1ha2VNYXAoJ2FiYnIsYWxpZ24sYWx0LGF4aXMsYmdjb2xvcixib3JkZXIsY2VsbHBhZGRpbmcsY2VsbHNwYWNpbmcsY2xhc3MsY2xlYXIsJyArXG4gICAgJ2NvbG9yLGNvbHMsY29sc3Bhbixjb21wYWN0LGNvb3JkcyxkaXIsZmFjZSxoZWFkZXJzLGhlaWdodCxocmVmbGFuZyxoc3BhY2UsJyArXG4gICAgJ2lzbWFwLGxhbmcsbGFuZ3VhZ2Usbm9ocmVmLG5vd3JhcCxyZWwscmV2LHJvd3Mscm93c3BhbixydWxlcywnICtcbiAgICAnc2NvcGUsc2Nyb2xsaW5nLHNoYXBlLHNpemUsc3BhbixzdGFydCxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0eXBlLCcgK1xuICAgICd2YWxpZ24sdmFsdWUsdnNwYWNlLHdpZHRoJyk7XG5cbi8vIFNWRyBhdHRyaWJ1dGVzICh3aXRob3V0IFwiaWRcIiBhbmQgXCJuYW1lXCIgYXR0cmlidXRlcylcbi8vIGh0dHBzOi8vd2lraS53aGF0d2cub3JnL3dpa2kvU2FuaXRpemF0aW9uX3J1bGVzI3N2Z19BdHRyaWJ1dGVzXG52YXIgc3ZnQXR0cnMgPSBtYWtlTWFwKCdhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxwaGFiZXRpYyxhcmFiaWMtZm9ybSxhc2NlbnQsJyArXG4gICAgJ2Jhc2VQcm9maWxlLGJib3gsYmVnaW4sYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjb2xvcixjb2xvci1yZW5kZXJpbmcsY29udGVudCwnICtcbiAgICAnY3gsY3ksZCxkeCxkeSxkZXNjZW50LGRpc3BsYXksZHVyLGVuZCxmaWxsLGZpbGwtcnVsZSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zdHJldGNoLCcgK1xuICAgICdmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmcm9tLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ3JhZGllbnRVbml0cyxoYW5naW5nLCcgK1xuICAgICdoZWlnaHQsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWRlb2dyYXBoaWMsayxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLCcgK1xuICAgICdtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxtYXRoZW1hdGljYWwsJyArXG4gICAgJ21heCxtaW4sb2Zmc2V0LG9wYWNpdHksb3JpZW50LG9yaWdpbixvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEsJyArXG4gICAgJ3BhdGgscGF0aExlbmd0aCxwb2ludHMscHJlc2VydmVBc3BlY3RSYXRpbyxyLHJlZlgscmVmWSxyZXBlYXRDb3VudCxyZXBlYXREdXIsJyArXG4gICAgJ3JlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscm90YXRlLHJ4LHJ5LHNsb3BlLHN0ZW1oLHN0ZW12LHN0b3AtY29sb3IsJyArXG4gICAgJ3N0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LCcgK1xuICAgICdzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksJyArXG4gICAgJ3N0cm9rZS13aWR0aCxzeXN0ZW1MYW5ndWFnZSx0YXJnZXQsdGV4dC1hbmNob3IsdG8sdHJhbnNmb3JtLHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLCcgK1xuICAgICd1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdmFsdWVzLHZlcnNpb24sdmlld0JveCx2aXNpYmlsaXR5LCcgK1xuICAgICd3aWR0aCx3aWR0aHMseCx4LWhlaWdodCx4MSx4Mix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLCcgK1xuICAgICd4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLHhtbDpzcGFjZSx4bWxucyx4bWxuczp4bGluayx5LHkxLHkyLHpvb21BbmRQYW4nLCB0cnVlKTtcblxudmFyIHZhbGlkQXR0cnMgPSBhbmd1bGFyLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0F0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sQXR0cnMpO1xuXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgbG93ZXJjYXNlS2V5cykge1xuICB2YXIgb2JqID0ge30sIGl0ZW1zID0gc3RyLnNwbGl0KCcsJyksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIG9ialtsb3dlcmNhc2VLZXlzID8gYW5ndWxhci5sb3dlcmNhc2UoaXRlbXNbaV0pIDogaXRlbXNbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQGV4YW1wbGVcbiAqIGh0bWxQYXJzZXIoaHRtbFN0cmluZywge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzLCB1bmFyeSkge30sXG4gKiAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHt9LFxuICogICAgIGNoYXJzOiBmdW5jdGlvbih0ZXh0KSB7fSxcbiAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICogfSk7XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgc3RyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlclxuICovXG5mdW5jdGlvbiBodG1sUGFyc2VyKGh0bWwsIGhhbmRsZXIpIHtcbiAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgIGlmIChodG1sID09PSBudWxsIHx8IHR5cGVvZiBodG1sID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaHRtbCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBodG1sID0gJycgKyBodG1sO1xuICAgIH1cbiAgfVxuICB2YXIgaW5kZXgsIGNoYXJzLCBtYXRjaCwgc3RhY2sgPSBbXSwgbGFzdCA9IGh0bWwsIHRleHQ7XG4gIHN0YWNrLmxhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdOyB9O1xuXG4gIHdoaWxlIChodG1sKSB7XG4gICAgdGV4dCA9ICcnO1xuICAgIGNoYXJzID0gdHJ1ZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBzY3JpcHQgb3Igc3R5bGUgZWxlbWVudFxuICAgIGlmICghc3RhY2subGFzdCgpIHx8ICFzcGVjaWFsRWxlbWVudHNbc3RhY2subGFzdCgpXSkge1xuXG4gICAgICAvLyBDb21tZW50XG4gICAgICBpZiAoaHRtbC5pbmRleE9mKFwiPCEtLVwiKSA9PT0gMCkge1xuICAgICAgICAvLyBjb21tZW50cyBjb250YWluaW5nIC0tIGFyZSBub3QgYWxsb3dlZCB1bmxlc3MgdGhleSB0ZXJtaW5hdGUgdGhlIGNvbW1lbnRcbiAgICAgICAgaW5kZXggPSBodG1sLmluZGV4T2YoXCItLVwiLCA0KTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBodG1sLmxhc3RJbmRleE9mKFwiLS0+XCIsIGluZGV4KSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlci5jb21tZW50KSBoYW5kbGVyLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgaW5kZXgpKTtcbiAgICAgICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcoaW5kZXggKyAzKTtcbiAgICAgICAgICBjaGFycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAvLyBET0NUWVBFXG4gICAgICB9IGVsc2UgaWYgKERPQ1RZUEVfUkVHRVhQLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgbWF0Y2ggPSBodG1sLm1hdGNoKERPQ1RZUEVfUkVHRVhQKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKG1hdGNoWzBdLCAnJyk7XG4gICAgICAgICAgY2hhcnMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgLy8gZW5kIHRhZ1xuICAgICAgfSBlbHNlIGlmIChCRUdJTkdfRU5EX1RBR0VfUkVHRVhQLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgbWF0Y2ggPSBodG1sLm1hdGNoKEVORF9UQUdfUkVHRVhQKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKEVORF9UQUdfUkVHRVhQLCBwYXJzZUVuZFRhZyk7XG4gICAgICAgICAgY2hhcnMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBzdGFydCB0YWdcbiAgICAgIH0gZWxzZSBpZiAoQkVHSU5fVEFHX1JFR0VYUC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIG1hdGNoID0gaHRtbC5tYXRjaChTVEFSVF9UQUdfUkVHRVhQKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBXZSBvbmx5IGhhdmUgYSB2YWxpZCBzdGFydC10YWcgaWYgdGhlcmUgaXMgYSAnPicuXG4gICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2UoU1RBUlRfVEFHX1JFR0VYUCwgcGFyc2VTdGFydFRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gZW5kaW5nIHRhZyBmb3VuZCAtLS0gdGhpcyBwaWVjZSBzaG91bGQgYmUgZW5jb2RlZCBhcyBhbiBlbnRpdHkuXG4gICAgICAgICAgdGV4dCArPSAnPCc7XG4gICAgICAgICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFycykge1xuICAgICAgICBpbmRleCA9IGh0bWwuaW5kZXhPZihcIjxcIik7XG5cbiAgICAgICAgdGV4dCArPSBpbmRleCA8IDAgPyBodG1sIDogaHRtbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICBodG1sID0gaW5kZXggPCAwID8gXCJcIiA6IGh0bWwuc3Vic3RyaW5nKGluZGV4KTtcblxuICAgICAgICBpZiAoaGFuZGxlci5jaGFycykgaGFuZGxlci5jaGFycyhkZWNvZGVFbnRpdGllcyh0ZXh0KSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgdmVyc2lvbnMgOSBhbmQgMTAgZG8gbm90IHVuZGVyc3RhbmQgdGhlIHJlZ2V4ICdbXl0nLCBzbyB1c2luZyBhIHdvcmthcm91bmQgd2l0aCBbXFxXXFx3XS5cbiAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UobmV3IFJlZ0V4cChcIihbXFxcXFdcXFxcd10qKTxcXFxccypcXFxcL1xcXFxzKlwiICsgc3RhY2subGFzdCgpICsgXCJbXj5dKj5cIiwgJ2knKSxcbiAgICAgICAgZnVuY3Rpb24oYWxsLCB0ZXh0KSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShDT01NRU5UX1JFR0VYUCwgXCIkMVwiKS5yZXBsYWNlKENEQVRBX1JFR0VYUCwgXCIkMVwiKTtcblxuICAgICAgICAgIGlmIChoYW5kbGVyLmNoYXJzKSBoYW5kbGVyLmNoYXJzKGRlY29kZUVudGl0aWVzKHRleHQpKTtcblxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSk7XG5cbiAgICAgIHBhcnNlRW5kVGFnKFwiXCIsIHN0YWNrLmxhc3QoKSk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT0gbGFzdCkge1xuICAgICAgdGhyb3cgJHNhbml0aXplTWluRXJyKCdiYWRwYXJzZScsIFwiVGhlIHNhbml0aXplciB3YXMgdW5hYmxlIHRvIHBhcnNlIHRoZSBmb2xsb3dpbmcgYmxvY2sgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib2YgaHRtbDogezB9XCIsIGh0bWwpO1xuICAgIH1cbiAgICBsYXN0ID0gaHRtbDtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnLCB0YWdOYW1lLCByZXN0LCB1bmFyeSkge1xuICAgIHRhZ05hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWdOYW1lKTtcbiAgICBpZiAoYmxvY2tFbGVtZW50c1t0YWdOYW1lXSkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxhc3QoKSAmJiBpbmxpbmVFbGVtZW50c1tzdGFjay5sYXN0KCldKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKFwiXCIsIHN0YWNrLmxhc3QoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbmFsRW5kVGFnRWxlbWVudHNbdGFnTmFtZV0gJiYgc3RhY2subGFzdCgpID09IHRhZ05hbWUpIHtcbiAgICAgIHBhcnNlRW5kVGFnKFwiXCIsIHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHVuYXJ5ID0gdm9pZEVsZW1lbnRzW3RhZ05hbWVdIHx8ICEhdW5hcnk7XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHZhciBhdHRycyA9IHt9O1xuXG4gICAgcmVzdC5yZXBsYWNlKEFUVFJfUkVHRVhQLFxuICAgICAgZnVuY3Rpb24obWF0Y2gsIG5hbWUsIGRvdWJsZVF1b3RlZFZhbHVlLCBzaW5nbGVRdW90ZWRWYWx1ZSwgdW5xdW90ZWRWYWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkb3VibGVRdW90ZWRWYWx1ZVxuICAgICAgICAgIHx8IHNpbmdsZVF1b3RlZFZhbHVlXG4gICAgICAgICAgfHwgdW5xdW90ZWRWYWx1ZVxuICAgICAgICAgIHx8ICcnO1xuXG4gICAgICAgIGF0dHJzW25hbWVdID0gZGVjb2RlRW50aXRpZXModmFsdWUpO1xuICAgIH0pO1xuICAgIGlmIChoYW5kbGVyLnN0YXJ0KSBoYW5kbGVyLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWcsIHRhZ05hbWUpIHtcbiAgICB2YXIgcG9zID0gMCwgaTtcbiAgICB0YWdOYW1lID0gYW5ndWxhci5sb3dlcmNhc2UodGFnTmFtZSk7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXSA9PSB0YWdOYW1lKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKVxuICAgICAgICBpZiAoaGFuZGxlci5lbmQpIGhhbmRsZXIuZW5kKHN0YWNrW2ldKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgfVxuICB9XG59XG5cbnZhciBoaWRkZW5QcmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbi8qKlxuICogZGVjb2RlcyBhbGwgZW50aXRpZXMgaW50byByZWd1bGFyIHN0cmluZ1xuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyB3aXRoIGRlY29kZWQgZW50aXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUVudGl0aWVzKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHsgcmV0dXJuICcnOyB9XG5cbiAgaGlkZGVuUHJlLmlubmVySFRNTCA9IHZhbHVlLnJlcGxhY2UoLzwvZyxcIiZsdDtcIik7XG4gIC8vIGlubmVyVGV4dCBkZXBlbmRzIG9uIHN0eWxpbmcgYXMgaXQgZG9lc24ndCBkaXNwbGF5IGhpZGRlbiBlbGVtZW50cy5cbiAgLy8gVGhlcmVmb3JlLCBpdCdzIGJldHRlciB0byB1c2UgdGV4dENvbnRlbnQgbm90IHRvIGNhdXNlIHVubmVjZXNzYXJ5IHJlZmxvd3MuXG4gIHJldHVybiBoaWRkZW5QcmUudGV4dENvbnRlbnQ7XG59XG5cbi8qKlxuICogRXNjYXBlcyBhbGwgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGNoYXJhY3RlcnMsIHNvIHRoYXQgdGhlXG4gKiByZXN1bHRpbmcgc3RyaW5nIGNhbiBiZSBzYWZlbHkgaW5zZXJ0ZWQgaW50byBhdHRyaWJ1dGUgb3JcbiAqIGVsZW1lbnQgdGV4dC5cbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCB0ZXh0XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUVudGl0aWVzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5cbiAgICByZXBsYWNlKC8mL2csICcmYW1wOycpLlxuICAgIHJlcGxhY2UoU1VSUk9HQVRFX1BBSVJfUkVHRVhQLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGhpID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgIHZhciBsb3cgPSB2YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgcmV0dXJuICcmIycgKyAoKChoaSAtIDB4RDgwMCkgKiAweDQwMCkgKyAobG93IC0gMHhEQzAwKSArIDB4MTAwMDApICsgJzsnO1xuICAgIH0pLlxuICAgIHJlcGxhY2UoTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gJyYjJyArIHZhbHVlLmNoYXJDb2RlQXQoMCkgKyAnOyc7XG4gICAgfSkuXG4gICAgcmVwbGFjZSgvPC9nLCAnJmx0OycpLlxuICAgIHJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYW4gSFRNTC9YTUwgd3JpdGVyIHdoaWNoIHdyaXRlcyB0byBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZiB1c2UgYnVmLmphaW4oJycpIHRvIGdldCBvdXQgc2FuaXRpemVkIGh0bWwgc3RyaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBpbiB0aGUgZm9ybSBvZiB7XG4gKiAgICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMsIHVuYXJ5KSB7fSxcbiAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gKiAgICAgY2hhcnM6IGZ1bmN0aW9uKHRleHQpIHt9LFxuICogICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKHRleHQpIHt9XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGh0bWxTYW5pdGl6ZVdyaXRlcihidWYsIHVyaVZhbGlkYXRvcikge1xuICB2YXIgaWdub3JlID0gZmFsc2U7XG4gIHZhciBvdXQgPSBhbmd1bGFyLmJpbmQoYnVmLCBidWYucHVzaCk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICB0YWcgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWcpO1xuICAgICAgaWYgKCFpZ25vcmUgJiYgc3BlY2lhbEVsZW1lbnRzW3RhZ10pIHtcbiAgICAgICAgaWdub3JlID0gdGFnO1xuICAgICAgfVxuICAgICAgaWYgKCFpZ25vcmUgJiYgdmFsaWRFbGVtZW50c1t0YWddID09PSB0cnVlKSB7XG4gICAgICAgIG91dCgnPCcpO1xuICAgICAgICBvdXQodGFnKTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGF0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdmFyIGxrZXk9YW5ndWxhci5sb3dlcmNhc2Uoa2V5KTtcbiAgICAgICAgICB2YXIgaXNJbWFnZSA9ICh0YWcgPT09ICdpbWcnICYmIGxrZXkgPT09ICdzcmMnKSB8fCAobGtleSA9PT0gJ2JhY2tncm91bmQnKTtcbiAgICAgICAgICBpZiAodmFsaWRBdHRyc1tsa2V5XSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgKHVyaUF0dHJzW2xrZXldICE9PSB0cnVlIHx8IHVyaVZhbGlkYXRvcih2YWx1ZSwgaXNJbWFnZSkpKSB7XG4gICAgICAgICAgICBvdXQoJyAnKTtcbiAgICAgICAgICAgIG91dChrZXkpO1xuICAgICAgICAgICAgb3V0KCc9XCInKTtcbiAgICAgICAgICAgIG91dChlbmNvZGVFbnRpdGllcyh2YWx1ZSkpO1xuICAgICAgICAgICAgb3V0KCdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG91dCh1bmFyeSA/ICcvPicgOiAnPicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgdGFnID0gYW5ndWxhci5sb3dlcmNhc2UodGFnKTtcbiAgICAgICAgaWYgKCFpZ25vcmUgJiYgdmFsaWRFbGVtZW50c1t0YWddID09PSB0cnVlKSB7XG4gICAgICAgICAgb3V0KCc8LycpO1xuICAgICAgICAgIG91dCh0YWcpO1xuICAgICAgICAgIG91dCgnPicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gaWdub3JlKSB7XG4gICAgICAgICAgaWdub3JlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgY2hhcnM6IGZ1bmN0aW9uKGNoYXJzKSB7XG4gICAgICAgIGlmICghaWdub3JlKSB7XG4gICAgICAgICAgb3V0KGVuY29kZUVudGl0aWVzKGNoYXJzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfTtcbn1cblxuXG4vLyBkZWZpbmUgbmdTYW5pdGl6ZSBtb2R1bGUgYW5kIHJlZ2lzdGVyICRzYW5pdGl6ZSBzZXJ2aWNlXG5hbmd1bGFyLm1vZHVsZSgnbmdTYW5pdGl6ZScsIFtdKS5wcm92aWRlcignJHNhbml0aXplJywgJFNhbml0aXplUHJvdmlkZXIpO1xuXG4vKiBnbG9iYWwgc2FuaXRpemVUZXh0OiBmYWxzZSAqL1xuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIGxpbmt5XG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRmluZHMgbGlua3MgaW4gdGV4dCBpbnB1dCBhbmQgdHVybnMgdGhlbSBpbnRvIGh0bWwgbGlua3MuIFN1cHBvcnRzIGh0dHAvaHR0cHMvZnRwL21haWx0byBhbmRcbiAqIHBsYWluIGVtYWlsIGFkZHJlc3MgbGlua3MuXG4gKlxuICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ1Nhbml0aXplIGBuZ1Nhbml0aXplYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBJbnB1dCB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBXaW5kb3cgKF9ibGFua3xfc2VsZnxfcGFyZW50fF90b3ApIG9yIG5hbWVkIGZyYW1lIHRvIG9wZW4gbGlua3MgaW4uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIdG1sLWxpbmtpZmllZCB0ZXh0LlxuICpcbiAqIEB1c2FnZVxuICAgPHNwYW4gbmctYmluZC1odG1sPVwibGlua3lfZXhwcmVzc2lvbiB8IGxpbmt5XCI+PC9zcGFuPlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZXhhbXBsZSBtb2R1bGU9XCJsaW5reUV4YW1wbGVcIiBkZXBzPVwiYW5ndWxhci1zYW5pdGl6ZS5qc1wiPlxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICBhbmd1bGFyLm1vZHVsZSgnbGlua3lFeGFtcGxlJywgWyduZ1Nhbml0aXplJ10pXG4gICAgICAgICAgIC5jb250cm9sbGVyKCdFeGFtcGxlQ29udHJvbGxlcicsIFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLnNuaXBwZXQgPVxuICAgICAgICAgICAgICAgJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczpcXG4nK1xuICAgICAgICAgICAgICAgJ2h0dHA6Ly9hbmd1bGFyanMub3JnLyxcXG4nK1xuICAgICAgICAgICAgICAgJ21haWx0bzp1c0Bzb21ld2hlcmUub3JnLFxcbicrXG4gICAgICAgICAgICAgICAnYW5vdGhlckBzb21ld2hlcmUub3JnLFxcbicrXG4gICAgICAgICAgICAgICAnYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLic7XG4gICAgICAgICAgICAgJHNjb3BlLnNuaXBwZXRXaXRoVGFyZ2V0ID0gJ2h0dHA6Ly9hbmd1bGFyanMub3JnLyc7XG4gICAgICAgICAgIH1dKTtcbiAgICAgICA8L3NjcmlwdD5cbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJFeGFtcGxlQ29udHJvbGxlclwiPlxuICAgICAgIFNuaXBwZXQ6IDx0ZXh0YXJlYSBuZy1tb2RlbD1cInNuaXBwZXRcIiBjb2xzPVwiNjBcIiByb3dzPVwiM1wiPjwvdGV4dGFyZWE+XG4gICAgICAgPHRhYmxlPlxuICAgICAgICAgPHRyPlxuICAgICAgICAgICA8dGQ+RmlsdGVyPC90ZD5cbiAgICAgICAgICAgPHRkPlNvdXJjZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5SZW5kZXJlZDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwibGlua3ktZmlsdGVyXCI+XG4gICAgICAgICAgIDx0ZD5saW5reSBmaWx0ZXI8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXQgfCBsaW5reVwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgIDxkaXYgbmctYmluZC1odG1sPVwic25pcHBldCB8IGxpbmt5XCI+PC9kaXY+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwibGlua3ktdGFyZ2V0XCI+XG4gICAgICAgICAgPHRkPmxpbmt5IHRhcmdldDwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoVGFyZ2V0IHwgbGlua3k6J19ibGFuaydcIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoVGFyZ2V0IHwgbGlua3k6J19ibGFuaydcIj48L2Rpdj5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImVzY2FwZWQtaHRtbFwiPlxuICAgICAgICAgICA8dGQ+bm8gZmlsdGVyPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kPVwic25pcHBldFwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT48L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kPVwic25pcHBldFwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgIDwvdGFibGU+XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInByb3RyYWN0b3IuanNcIiB0eXBlPVwicHJvdHJhY3RvclwiPlxuICAgICAgIGl0KCdzaG91bGQgbGlua2lmeSB0aGUgc25pcHBldCB3aXRoIHVybHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS1maWx0ZXInKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0IHwgbGlua3knKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCdQcmV0dHkgdGV4dCB3aXRoIHNvbWUgbGlua3M6IGh0dHA6Ly9hbmd1bGFyanMub3JnLywgdXNAc29tZXdoZXJlLm9yZywgJyArXG4gICAgICAgICAgICAgICAgICAnYW5vdGhlckBzb21ld2hlcmUub3JnLCBhbmQgb25lIG1vcmU6IGZ0cDovLzEyNy4wLjAuMS8uJyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudC5hbGwoYnkuY3NzKCcjbGlua3ktZmlsdGVyIGEnKSkuY291bnQoKSkudG9FcXVhbCg0KTtcbiAgICAgICB9KTtcblxuICAgICAgIGl0KCdzaG91bGQgbm90IGxpbmtpZnkgc25pcHBldCB3aXRob3V0IHRoZSBsaW5reSBmaWx0ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdlc2NhcGVkLWh0bWwnKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0JykpLmdldFRleHQoKSkuXG4gICAgICAgICAgICAgdG9CZSgnUHJldHR5IHRleHQgd2l0aCBzb21lIGxpbmtzOiBodHRwOi8vYW5ndWxhcmpzLm9yZy8sIG1haWx0bzp1c0Bzb21ld2hlcmUub3JnLCAnICtcbiAgICAgICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsIGFuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNlc2NhcGVkLWh0bWwgYScpKS5jb3VudCgpKS50b0VxdWFsKDApO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuY2xlYXIoKTtcbiAgICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuc2VuZEtleXMoJ25ldyBodHRwOi8vbGluay4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS1maWx0ZXInKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0IHwgbGlua3knKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCduZXcgaHR0cDovL2xpbmsuJyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudC5hbGwoYnkuY3NzKCcjbGlua3ktZmlsdGVyIGEnKSkuY291bnQoKSkudG9FcXVhbCgxKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdlc2NhcGVkLWh0bWwnKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0JykpLmdldFRleHQoKSlcbiAgICAgICAgICAgICAudG9CZSgnbmV3IGh0dHA6Ly9saW5rLicpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCB3b3JrIHdpdGggdGhlIHRhcmdldCBwcm9wZXJ0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnbGlua3ktdGFyZ2V0JykpLlxuICAgICAgICAgICAgZWxlbWVudChieS5iaW5kaW5nKFwic25pcHBldFdpdGhUYXJnZXQgfCBsaW5reTonX2JsYW5rJ1wiKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgIHRvQmUoJ2h0dHA6Ly9hbmd1bGFyanMub3JnLycpO1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNsaW5reS10YXJnZXQgYScpKS5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpKS50b0VxdWFsKCdfYmxhbmsnKTtcbiAgICAgICB9KTtcbiAgICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG5hbmd1bGFyLm1vZHVsZSgnbmdTYW5pdGl6ZScpLmZpbHRlcignbGlua3knLCBbJyRzYW5pdGl6ZScsIGZ1bmN0aW9uKCRzYW5pdGl6ZSkge1xuICB2YXIgTElOS1lfVVJMX1JFR0VYUCA9XG4gICAgICAgIC8oKGZ0cHxodHRwcz8pOlxcL1xcL3wod3d3XFwuKXwobWFpbHRvOik/W0EtWmEtejAtOS5fJSstXStAKVxcUypbXlxccy47LCgpe308PlwiXFx1MjAxZFxcdTIwMTldL2ksXG4gICAgICBNQUlMVE9fUkVHRVhQID0gL15tYWlsdG86L2k7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHRleHQsIHRhcmdldCkge1xuICAgIGlmICghdGV4dCkgcmV0dXJuIHRleHQ7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciByYXcgPSB0ZXh0O1xuICAgIHZhciBodG1sID0gW107XG4gICAgdmFyIHVybDtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmF3Lm1hdGNoKExJTktZX1VSTF9SRUdFWFApKSkge1xuICAgICAgLy8gV2UgY2FuIG5vdCBlbmQgaW4gdGhlc2UgYXMgdGhleSBhcmUgc29tZXRpbWVzIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIHNlbnRlbmNlXG4gICAgICB1cmwgPSBtYXRjaFswXTtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgbWF0Y2ggZnRwL2h0dHAvd3d3L21haWx0byB0aGVuIGFzc3VtZSBtYWlsdG9cbiAgICAgIGlmICghbWF0Y2hbMl0gJiYgIW1hdGNoWzRdKSB7XG4gICAgICAgIHVybCA9IChtYXRjaFszXSA/ICdodHRwOi8vJyA6ICdtYWlsdG86JykgKyB1cmw7XG4gICAgICB9XG4gICAgICBpID0gbWF0Y2guaW5kZXg7XG4gICAgICBhZGRUZXh0KHJhdy5zdWJzdHIoMCwgaSkpO1xuICAgICAgYWRkTGluayh1cmwsIG1hdGNoWzBdLnJlcGxhY2UoTUFJTFRPX1JFR0VYUCwgJycpKTtcbiAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoaSArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgfVxuICAgIGFkZFRleHQocmF3KTtcbiAgICByZXR1cm4gJHNhbml0aXplKGh0bWwuam9pbignJykpO1xuXG4gICAgZnVuY3Rpb24gYWRkVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaHRtbC5wdXNoKHNhbml0aXplVGV4dCh0ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGluayh1cmwsIHRleHQpIHtcbiAgICAgIGh0bWwucHVzaCgnPGEgJyk7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodGFyZ2V0KSkge1xuICAgICAgICBodG1sLnB1c2goJ3RhcmdldD1cIicsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAnXCIgJyk7XG4gICAgICB9XG4gICAgICBodG1sLnB1c2goJ2hyZWY9XCInLFxuICAgICAgICAgICAgICAgIHVybC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JyksXG4gICAgICAgICAgICAgICAgJ1wiPicpO1xuICAgICAgYWRkVGV4dCh0ZXh0KTtcbiAgICAgIGh0bWwucHVzaCgnPC9hPicpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FuZ3VsYXItc2FuaXRpemUvYW5ndWxhci1zYW5pdGl6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzW1wicmxfdXRpbGl0aWVzXCJdOyB9KCkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJybF91dGlsaXRpZXNcIlxuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzJyk7XHJcbnZhciBTbGlkZXIgPSByZXF1aXJlKCcuL2Jvb3RzdHJhcC1zbGlkZXIubWluJyk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLXNsaWRlcicsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZSgnc2xpZGVyJywgWyckcGFyc2UnLCAnJHRpbWVvdXQnLCAnJHJvb3RTY29wZScsIGZ1bmN0aW9uICgkcGFyc2UsICR0aW1lb3V0LCAkcm9vdFNjb3BlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdj48aW5wdXQgY2xhc3M9XCJzbGlkZXItaW5wdXRcIiB0eXBlPVwidGV4dFwiIHN0eWxlPVwid2lkdGg6MTAwJVwiIC8+PC9kaXY+JyxcclxuICAgICAgICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICAgICAgbWF4OiBcIj1cIixcclxuICAgICAgICAgICAgICAgIG1pbjogXCI9XCIsXHJcbiAgICAgICAgICAgICAgICBzdGVwOiBcIj1cIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIj1cIixcclxuICAgICAgICAgICAgICAgIG5nTW9kZWw6ICc9JyxcclxuICAgICAgICAgICAgICAgIG5nRGlzYWJsZWQ6ICc9JyxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiAnPScsXHJcbiAgICAgICAgICAgICAgICBzbGlkZXJpZDogJz0nLFxyXG4gICAgICAgICAgICAgICAgdGlja3M6ICc9JyxcclxuICAgICAgICAgICAgICAgIHRpY2tzTGFiZWxzOiAnPScsXHJcbiAgICAgICAgICAgICAgICB0aWNrc1NuYXBCb3VuZHM6ICc9JyxcclxuICAgICAgICAgICAgICAgIHRpY2tzUG9zaXRpb25zOiAnPScsXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogJz0nLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiAnJicsXHJcbiAgICAgICAgICAgICAgICBvblN0YXJ0U2xpZGU6ICcmJyxcclxuICAgICAgICAgICAgICAgIG9uU3RvcFNsaWRlOiAnJicsXHJcbiAgICAgICAgICAgICAgICBvblNsaWRlOiAnJidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKCRzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDdHJsLCAkY29tcGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5nTW9kZWxEZXJlZ2lzdGVyRm4sIG5nRGlzYWJsZWREZXJlZ2lzdGVyRm47XHJcblxyXG4gICAgICAgICAgICAgICAgaW5pdFNsaWRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluaXRTbGlkZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0T3B0aW9uKGtleSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZSB8fCBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRGbG9hdE9wdGlvbihrZXksIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldEJvb2xlYW5PcHRpb24oa2V5LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlID8gdmFsdWUgKyAnJyA9PT0gJ3RydWUnIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QXJyYXlPclZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYW5ndWxhci5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuaW5kZXhPZihcIltcIikgPT09IDApID8gYW5ndWxhci5mcm9tSnNvbih2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignaWQnLCAkc2NvcGUuc2xpZGVyaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignb3JpZW50YXRpb24nLCBhdHRycy5vcmllbnRhdGlvbiwgJ2hvcml6b250YWwnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3NlbGVjdGlvbicsIGF0dHJzLnNlbGVjdGlvbiwgJ2JlZm9yZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignaGFuZGxlJywgYXR0cnMuaGFuZGxlLCAncm91bmQnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3Rvb2x0aXAnLCBhdHRycy5zbGlkZXJUb29sdGlwIHx8IGF0dHJzLnRvb2x0aXAsICdzaG93Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCd0b29sdGlwX3Bvc2l0aW9uJywgYXR0cnMuc2xpZGVyVG9vbHRpcFBvc2l0aW9uLCAndG9wJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCd0b29sdGlwc2VwYXJhdG9yJywgYXR0cnMudG9vbHRpcHNlcGFyYXRvciwgJzonKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3RpY2tzJywgJHNjb3BlLnRpY2tzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3RpY2tzX2xhYmVscycsICRzY29wZS50aWNrc0xhYmVscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCd0aWNrc19zbmFwX2JvdW5kcycsICRzY29wZS50aWNrc1NuYXBCb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbigndGlja3NfcG9zaXRpb25zJywgJHNjb3BlLnRpY2tzUG9zaXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3NjYWxlJywgJHNjb3BlLnNjYWxlLCAnbGluZWFyJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldEZsb2F0T3B0aW9uKCdtaW4nLCAkc2NvcGUubWluLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGbG9hdE9wdGlvbignbWF4JywgJHNjb3BlLm1heCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZsb2F0T3B0aW9uKCdzdGVwJywgJHNjb3BlLnN0ZXAsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJOYnIgPSBvcHRpb25zLnN0ZXAgKyAnJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbHMgPSBzdHJOYnIuc3Vic3RyaW5nKHN0ck5ici5sYXN0SW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RmxvYXRPcHRpb24oJ3ByZWNpc2lvbicsIGF0dHJzLnByZWNpc2lvbiwgZGVjaW1hbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRCb29sZWFuT3B0aW9uKCd0b29sdGlwX3NwbGl0JywgYXR0cnMudG9vbHRpcHNwbGl0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Qm9vbGVhbk9wdGlvbignZW5hYmxlZCcsIGF0dHJzLmVuYWJsZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEJvb2xlYW5PcHRpb24oJ25hdHVyYWxhcnJvd2tleXMnLCBhdHRycy5uYXR1cmFsYXJyb3drZXlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Qm9vbGVhbk9wdGlvbigncmV2ZXJzZWQnLCBhdHRycy5yZXZlcnNlZCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRCb29sZWFuT3B0aW9uKCdyYW5nZScsICRzY29wZS5yYW5nZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoJHNjb3BlLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9ICRzY29wZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKCRzY29wZS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBnZXRBcnJheU9yVmFsdWUoJHNjb3BlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5ndWxhci5pc0FycmF5KG9wdGlvbnMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdCgkc2NvcGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHZhbHVlID0gNTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgJHNjb3BlLm1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRzY29wZS5taW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBbdmFsdWUsIG9wdGlvbnMubWF4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPiAkc2NvcGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNjb3BlLm1heDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IFtvcHRpb25zLm1pbiwgdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IFtvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBbb3B0aW9ucy5taW4sIG9wdGlvbnMubWF4XTsgLy8gVGhpcyBpcyBuZWVkZWQsIGJlY2F1c2Ugb2YgdmFsdWUgZGVmaW5lZCBhdCAkLmZuLnNsaWRlci5kZWZhdWx0cyAtIGRlZmF1bHQgdmFsdWUgNSBwcmV2ZW50cyBjcmVhdGluZyByYW5nZSBzbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubmdNb2RlbCA9IG9wdGlvbnMudmFsdWU7IC8vIG5lZWRlZCwgb3RoZXJ3aXNlIHR1cm5zIHZhbHVlIGludG8gW251bGwsICMjXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RmxvYXRPcHRpb24oJ3ZhbHVlJywgJHNjb3BlLnZhbHVlLCA1KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybWF0dGVyKSBvcHRpb25zLmZvcm1hdHRlciA9ICRzY29wZS4kZXZhbCgkc2NvcGUuZm9ybWF0dGVyKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNsaWRlciBqUXVlcnkgcGx1Z2luIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgnJCcgaW4gd2luZG93ICYmICQuZm4uc2xpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyBtZXRob2RzIHRvIGpRdWVyeSBzbGlkZXIgcGx1Z2luIHByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmZuLnNsaWRlci5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGlja2VyLm9mZigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmZuLnNsaWRlci5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waWNrZXIub24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3kgcHJldmlvdXMgc2xpZGVyIHRvIHJlc2V0IGFsbCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRbMF0uX19zbGlkZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uX19zbGlkZXIuZGVzdHJveSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpZGVyID0gbmV3IFNsaWRlcihlbGVtZW50WzBdLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NsaWRlci1pbnB1dCcpWzBdLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdLl9fc2xpZGVyID0gc2xpZGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgc2xpZGVyIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlRXZlbnQgPSBnZXRBcnJheU9yVmFsdWUoYXR0cnMudXBkYXRlZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHVwZGF0ZUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvbmx5IHNpbmdsZSBldmVudCBuYW1lIGluIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVFdmVudCA9IFt1cGRhdGVFdmVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIHNsaWRlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUV2ZW50ID0gWydzbGlkZSddO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godXBkYXRlRXZlbnQsIGZ1bmN0aW9uIChzbGlkZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXIub24oc2xpZGVyRXZlbnQsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlci5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZXYubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpZGVyRXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZVN0YXJ0OiAnb25TdGFydFNsaWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGU6ICdvblNsaWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVTdG9wOiAnb25TdG9wU2xpZGUnXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2xpZGVyRXZlbnRzLCBmdW5jdGlvbiAoc2xpZGVyRXZlbnRBdHRyLCBzbGlkZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSAkcGFyc2UoYXR0cnNbc2xpZGVyRXZlbnRBdHRyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci5vbihzbGlkZXJFdmVudCwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlW3NsaWRlckV2ZW50QXR0cl0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbigkc2NvcGUuJHBhcmVudCwgeyAkZXZlbnQ6IGV2LCB2YWx1ZTogZXYgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kJHBoYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kZXZhbEFzeW5jKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXJlZ2lzdGVyIG5nRGlzYWJsZWQgd2F0Y2hlciB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24obmdEaXNhYmxlZERlcmVnaXN0ZXJGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmdEaXNhYmxlZERlcmVnaXN0ZXJGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZ0Rpc2FibGVkRGVyZWdpc3RlckZuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5nRGlzYWJsZWREZXJlZ2lzdGVyRm4gPSAkc2NvcGUuJHdhdGNoKCduZ0Rpc2FibGVkJywgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLmRpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci5lbmFibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXJlZ2lzdGVyIG5nTW9kZWwgd2F0Y2hlciB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24obmdNb2RlbERlcmVnaXN0ZXJGbikpIG5nTW9kZWxEZXJlZ2lzdGVyRm4oKTtcclxuICAgICAgICAgICAgICAgICAgICBuZ01vZGVsRGVyZWdpc3RlckZuID0gJHNjb3BlLiR3YXRjaCgnbmdNb2RlbCcsIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigkc2NvcGUucmFuZ2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLnNldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXIuc2V0VmFsdWUocGFyc2VGbG9hdCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB3YXRjaGVycyA9IFsnbWluJywgJ21heCcsICdzdGVwJywgJ3JhbmdlJywgJ3NjYWxlJ107XHJcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2god2F0Y2hlcnMsIGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChwcm9wLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTbGlkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1dKVxyXG47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvc2xpZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtc2xpZGVyLm1pbi5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2FuZ3VsYXItYm9vdHN0cmFwLXNsaWRlci9ib290c3RyYXAtc2xpZGVyLm1pbi5jc3NcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuICAgICAgICAgICAgICAgICAgICAgIFZFUlNJT04gIDUuMS4xXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxyXFxuLyohID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiAqIGJvb3RzdHJhcC1zbGlkZXIuanNcXHJcXG4gKlxcclxcbiAqIE1haW50YWluZXJzOlxcclxcbiAqXFx0XFx0S3lsZSBLZW1wXFxyXFxuICpcXHRcXHRcXHQtIFR3aXR0ZXI6IEBzZWl5cmlhXFxyXFxuICpcXHRcXHRcXHQtIEdpdGh1YjogIHNlaXlyaWFcXHJcXG4gKlxcdFxcdFJvaGl0IEthbGt1clxcclxcbiAqXFx0XFx0XFx0LSBUd2l0dGVyOiBAUm92b2x1dGlvbmFyeVxcclxcbiAqXFx0XFx0XFx0LSBHaXRodWI6ICByb3ZvbHV0aW9uXFxyXFxuICpcXHJcXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG4gKlxcclxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpO1xcclxcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXHJcXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXHJcXG4gKlxcclxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcclxcbiAqXFxyXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcclxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFxcXCJBUyBJU1xcXCIgQkFTSVMsXFxyXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxyXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcclxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcclxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqLy5zbGlkZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO3Bvc2l0aW9uOnJlbGF0aXZlfS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWx7d2lkdGg6MjEwcHg7aGVpZ2h0OjIwcHh9LnNsaWRlci5zbGlkZXItaG9yaXpvbnRhbCAuc2xpZGVyLXRyYWNre2hlaWdodDoxMHB4O3dpZHRoOjEwMCU7bWFyZ2luLXRvcDotNXB4O3RvcDo1MCU7bGVmdDowfS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci1zZWxlY3Rpb24sLnNsaWRlci5zbGlkZXItaG9yaXpvbnRhbCAuc2xpZGVyLXRyYWNrLWxvdywuc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdHJhY2staGlnaHtoZWlnaHQ6MTAwJTt0b3A6MDtib3R0b206MH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljaywuc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItaGFuZGxle21hcmdpbi1sZWZ0Oi0xMHB4O21hcmdpbi10b3A6LTVweH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljay50cmlhbmdsZSwuc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItaGFuZGxlLnRyaWFuZ2xle2JvcmRlci13aWR0aDowIDEwcHggMTBweCAxMHB4O3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLWJvdHRvbS1jb2xvcjojMDQ4MGJlO21hcmdpbi10b3A6MH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljay1sYWJlbC1jb250YWluZXJ7d2hpdGUtc3BhY2U6bm93cmFwO21hcmdpbi10b3A6MjBweH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljay1sYWJlbC1jb250YWluZXIgLnNsaWRlci10aWNrLWxhYmVse3BhZGRpbmctdG9wOjRweDtkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmNlbnRlcn0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbHtoZWlnaHQ6MjEwcHg7d2lkdGg6MjBweH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRyYWNre3dpZHRoOjEwcHg7aGVpZ2h0OjEwMCU7bWFyZ2luLWxlZnQ6LTVweDtsZWZ0OjUwJTt0b3A6MH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXNlbGVjdGlvbnt3aWR0aDoxMDAlO2xlZnQ6MDt0b3A6MDtib3R0b206MH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRyYWNrLWxvdywuc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRyYWNrLWhpZ2h7d2lkdGg6MTAwJTtsZWZ0OjA7cmlnaHQ6MH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRpY2ssLnNsaWRlci5zbGlkZXItdmVydGljYWwgLnNsaWRlci1oYW5kbGV7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tdG9wOi0xMHB4fS5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItdGljay50cmlhbmdsZSwuc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLWhhbmRsZS50cmlhbmdsZXtib3JkZXItd2lkdGg6MTBweCAwIDEwcHggMTBweDt3aWR0aDoxcHg7aGVpZ2h0OjFweDtib3JkZXItbGVmdC1jb2xvcjojMDQ4MGJlO21hcmdpbi1sZWZ0OjB9LnNsaWRlci5zbGlkZXItZGlzYWJsZWQgLnNsaWRlci1oYW5kbGV7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2RmZGZkZiAwLCNiZWJlYmUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNkZmRmZGYgMCwjYmViZWJlIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZGZkZmRmIDAsI2JlYmViZSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmRmZGZkZicsZW5kQ29sb3JzdHI9JyNmZmJlYmViZScsR3JhZGllbnRUeXBlPTApfS5zbGlkZXIuc2xpZGVyLWRpc2FibGVkIC5zbGlkZXItdHJhY2t7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2U1ZTVlNSAwLCNlOWU5ZTkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNlNWU1ZTUgMCwjZTllOWU5IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZTVlNWU1IDAsI2U5ZTllOSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmU1ZTVlNScsZW5kQ29sb3JzdHI9JyNmZmU5ZTllOScsR3JhZGllbnRUeXBlPTApO2N1cnNvcjpub3QtYWxsb3dlZH0uc2xpZGVyIGlucHV0e2Rpc3BsYXk6bm9uZX0uc2xpZGVyIC50b29sdGlwLnRvcHttYXJnaW4tdG9wOi0zNnB4fS5zbGlkZXIgLnRvb2x0aXAtaW5uZXJ7d2hpdGUtc3BhY2U6bm93cmFwfS5zbGlkZXIgLmhpZGV7ZGlzcGxheTpub25lfS5zbGlkZXItdHJhY2t7cG9zaXRpb246YWJzb2x1dGU7Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2Y1ZjVmNSAwLCNmOWY5ZjkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNmNWY1ZjUgMCwjZjlmOWY5IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZjVmNWY1IDAsI2Y5ZjlmOSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmY1ZjVmNScsZW5kQ29sb3JzdHI9JyNmZmY5ZjlmOScsR3JhZGllbnRUeXBlPTApOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjEpO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4xKTtib3JkZXItcmFkaXVzOjRweH0uc2xpZGVyLXNlbGVjdGlvbntwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZjlmOWY5IDAsI2Y1ZjVmNSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2Y5ZjlmOSAwLCNmNWY1ZjUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCNmOWY5ZjkgMCwjZjVmNWY1IDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmZjlmOWY5JyxlbmRDb2xvcnN0cj0nI2ZmZjVmNWY1JyxHcmFkaWVudFR5cGU9MCk7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgLTFweCAwIHJnYmEoMCwwLDAsMC4xNSk7Ym94LXNoYWRvdzppbnNldCAwIC0xcHggMCByZ2JhKDAsMCwwLDAuMTUpOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXItcmFkaXVzOjRweH0uc2xpZGVyLXNlbGVjdGlvbi50aWNrLXNsaWRlci1zZWxlY3Rpb257YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsIzg5Y2RlZiAwLCM4MWJmZGUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCM4OWNkZWYgMCwjODFiZmRlIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjODljZGVmIDAsIzgxYmZkZSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZjg5Y2RlZicsZW5kQ29sb3JzdHI9JyNmZjgxYmZkZScsR3JhZGllbnRUeXBlPTApfS5zbGlkZXItdHJhY2stbG93LC5zbGlkZXItdHJhY2staGlnaHtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXItcmFkaXVzOjRweH0uc2xpZGVyLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtY29sb3I6IzMzN2FiNztiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjMTQ5YmRmIDAsIzA0ODBiZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsIzE0OWJkZiAwLCMwNDgwYmUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCMxNDliZGYgMCwjMDQ4MGJlIDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmMTQ5YmRmJyxlbmRDb2xvcnN0cj0nI2ZmMDQ4MGJlJyxHcmFkaWVudFR5cGU9MCk7ZmlsdGVyOm5vbmU7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgcmdiYSgyNTUsMjU1LDI1NSwuMiksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA1KTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgcmdiYSgyNTUsMjU1LDI1NSwuMiksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA1KTtib3JkZXI6MCBzb2xpZCB0cmFuc3BhcmVudH0uc2xpZGVyLWhhbmRsZS5yb3VuZHtib3JkZXItcmFkaXVzOjUwJX0uc2xpZGVyLWhhbmRsZS50cmlhbmdsZXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IG5vbmV9LnNsaWRlci1oYW5kbGUuY3VzdG9te2JhY2tncm91bmQ6dHJhbnNwYXJlbnQgbm9uZX0uc2xpZGVyLWhhbmRsZS5jdXN0b206OmJlZm9yZXtsaW5lLWhlaWdodDoyMHB4O2ZvbnQtc2l6ZToyMHB4O2NvbnRlbnQ6J1xcXFwyNjA1Jztjb2xvcjojNzI2MjA0fS5zbGlkZXItdGlja3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmOWY5ZjkgMCwjZjVmNWY1IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjZjlmOWY5IDAsI2Y1ZjVmNSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sI2Y5ZjlmOSAwLCNmNWY1ZjUgMTAwJSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPScjZmZmOWY5ZjknLGVuZENvbG9yc3RyPScjZmZmNWY1ZjUnLEdyYWRpZW50VHlwZT0wKTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAtMXB4IDAgcmdiYSgwLDAsMCwwLjE1KTtib3gtc2hhZG93Omluc2V0IDAgLTFweCAwIHJnYmEoMCwwLDAsMC4xNSk7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2ZpbHRlcjpub25lO29wYWNpdHk6Ljg7Ym9yZGVyOjAgc29saWQgdHJhbnNwYXJlbnR9LnNsaWRlci10aWNrLnJvdW5ke2JvcmRlci1yYWRpdXM6NTAlfS5zbGlkZXItdGljay50cmlhbmdsZXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IG5vbmV9LnNsaWRlci10aWNrLmN1c3RvbXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IG5vbmV9LnNsaWRlci10aWNrLmN1c3RvbTo6YmVmb3Jle2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC1zaXplOjIwcHg7Y29udGVudDonXFxcXDI2MDUnO2NvbG9yOiM3MjYyMDR9LnNsaWRlci10aWNrLmluLXNlbGVjdGlvbntiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjODljZGVmIDAsIzgxYmZkZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsIzg5Y2RlZiAwLCM4MWJmZGUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCM4OWNkZWYgMCwjODFiZmRlIDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmODljZGVmJyxlbmRDb2xvcnN0cj0nI2ZmODFiZmRlJyxHcmFkaWVudFR5cGU9MCk7b3BhY2l0eToxfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL2Jvb3RzdHJhcC1zbGlkZXIubWluLmNzc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KCkge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRoZWFkLmFwcGVuZENoaWxkKGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KCk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qISA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICAgICAgICAgICAgICBWRVJTSU9OICA1LjEuMVxyXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuLyohID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBib290c3RyYXAtc2xpZGVyLmpzXHJcbiAqXHJcbiAqIE1haW50YWluZXJzOlxyXG4gKlx0XHRLeWxlIEtlbXBcclxuICpcdFx0XHQtIFR3aXR0ZXI6IEBzZWl5cmlhXHJcbiAqXHRcdFx0LSBHaXRodWI6ICBzZWl5cmlhXHJcbiAqXHRcdFJvaGl0IEthbGt1clxyXG4gKlx0XHRcdC0gVHdpdHRlcjogQFJvdm9sdXRpb25hcnlcclxuICpcdFx0XHQtIEdpdGh1YjogIHJvdm9sdXRpb25cclxuICpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG4hZnVuY3Rpb24oYSxiKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtcImpxdWVyeVwiXSxiKTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzKXt2YXIgYzt0cnl7Yz1yZXF1aXJlKFwianF1ZXJ5XCIpfWNhdGNoKGQpe2M9bnVsbH1tb2R1bGUuZXhwb3J0cz1iKGMpfWVsc2UgYS5TbGlkZXI9YihhLmpRdWVyeSl9KHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuIGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoKXt9ZnVuY3Rpb24gYyhhKXtmdW5jdGlvbiBjKGIpe2IucHJvdG90eXBlLm9wdGlvbnx8KGIucHJvdG90eXBlLm9wdGlvbj1mdW5jdGlvbihiKXthLmlzUGxhaW5PYmplY3QoYikmJih0aGlzLm9wdGlvbnM9YS5leHRlbmQoITAsdGhpcy5vcHRpb25zLGIpKX0pfWZ1bmN0aW9uIGUoYixjKXthLmZuW2JdPWZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtmb3IodmFyIGc9ZC5jYWxsKGFyZ3VtZW50cywxKSxoPTAsaT10aGlzLmxlbmd0aDtpPmg7aCsrKXt2YXIgaj10aGlzW2hdLGs9YS5kYXRhKGosYik7aWYoaylpZihhLmlzRnVuY3Rpb24oa1tlXSkmJlwiX1wiIT09ZS5jaGFyQXQoMCkpe3ZhciBsPWtbZV0uYXBwbHkoayxnKTtpZih2b2lkIDAhPT1sJiZsIT09aylyZXR1cm4gbH1lbHNlIGYoXCJubyBzdWNoIG1ldGhvZCAnXCIrZStcIicgZm9yIFwiK2IrXCIgaW5zdGFuY2VcIik7ZWxzZSBmKFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIitiK1wiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBhdHRlbXB0ZWQgdG8gY2FsbCAnXCIrZStcIidcIil9cmV0dXJuIHRoaXN9dmFyIG09dGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgZD1hLmRhdGEodGhpcyxiKTtyZXR1cm4gZD8oZC5vcHRpb24oZSksZC5faW5pdCgpKTooZD1uZXcgYyh0aGlzLGUpLGEuZGF0YSh0aGlzLGIsZCkpLGEodGhpcyl9KTtyZXR1cm4hbXx8bS5sZW5ndGg+MT9tOm1bMF19fWlmKGEpe3ZhciBmPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBjb25zb2xlP2I6ZnVuY3Rpb24oYSl7Y29uc29sZS5lcnJvcihhKX07cmV0dXJuIGEuYnJpZGdldD1mdW5jdGlvbihhLGIpe2MoYiksZShhLGIpfSxhLmJyaWRnZXR9fXZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZTtjKGEpfShhKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBjKGIsYyl7ZnVuY3Rpb24gZChhLGIpe3ZhciBjPVwiZGF0YS1zbGlkZXItXCIrYi5yZXBsYWNlKC9fL2csXCItXCIpLGQ9YS5nZXRBdHRyaWJ1dGUoYyk7dHJ5e3JldHVybiBKU09OLnBhcnNlKGQpfWNhdGNoKGUpe3JldHVybiBkfX10aGlzLl9zdGF0ZT17dmFsdWU6bnVsbCxlbmFibGVkOm51bGwsb2Zmc2V0Om51bGwsc2l6ZTpudWxsLHBlcmNlbnRhZ2U6bnVsbCxpbkRyYWc6ITEsb3ZlcjohMX0sXCJzdHJpbmdcIj09dHlwZW9mIGI/dGhpcy5lbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYik6YiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiYodGhpcy5lbGVtZW50PWIpLGM9Yz9jOnt9O2Zvcih2YXIgZj1PYmplY3Qua2V5cyh0aGlzLmRlZmF1bHRPcHRpb25zKSxnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBoPWZbZ10saT1jW2hdO2k9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGk/aTpkKHRoaXMuZWxlbWVudCxoKSxpPW51bGwhPT1pP2k6dGhpcy5kZWZhdWx0T3B0aW9uc1toXSx0aGlzLm9wdGlvbnN8fCh0aGlzLm9wdGlvbnM9e30pLHRoaXMub3B0aW9uc1toXT1pfVwidmVydGljYWxcIiE9PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbnx8XCJ0b3BcIiE9PXRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9uJiZcImJvdHRvbVwiIT09dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb24/XCJob3Jpem9udGFsXCIhPT10aGlzLm9wdGlvbnMub3JpZW50YXRpb258fFwibGVmdFwiIT09dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb24mJlwicmlnaHRcIiE9PXRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9ufHwodGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb249XCJ0b3BcIik6dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb249XCJyaWdodFwiO3ZhciBqLGssbCxtLG4sbz10aGlzLmVsZW1lbnQuc3R5bGUud2lkdGgscD0hMSxxPXRoaXMuZWxlbWVudC5wYXJlbnROb2RlO2lmKHRoaXMuc2xpZGVyRWxlbSlwPSEwO2Vsc2V7dGhpcy5zbGlkZXJFbGVtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5zbGlkZXJFbGVtLmNsYXNzTmFtZT1cInNsaWRlclwiO3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aWYoci5jbGFzc05hbWU9XCJzbGlkZXItdHJhY2tcIixrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksay5jbGFzc05hbWU9XCJzbGlkZXItdHJhY2stbG93XCIsaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGouY2xhc3NOYW1lPVwic2xpZGVyLXNlbGVjdGlvblwiLGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxsLmNsYXNzTmFtZT1cInNsaWRlci10cmFjay1oaWdoXCIsbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG0uY2xhc3NOYW1lPVwic2xpZGVyLWhhbmRsZSBtaW4tc2xpZGVyLWhhbmRsZVwiLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxuLmNsYXNzTmFtZT1cInNsaWRlci1oYW5kbGUgbWF4LXNsaWRlci1oYW5kbGVcIixyLmFwcGVuZENoaWxkKGspLHIuYXBwZW5kQ2hpbGQoaiksci5hcHBlbmRDaGlsZChsKSx0aGlzLnRpY2tzPVtdLEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnRpY2tzKSYmdGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aD4wKXtmb3IoZz0wO2c8dGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aDtnKyspe3ZhciBzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cy5jbGFzc05hbWU9XCJzbGlkZXItdGlja1wiLHRoaXMudGlja3MucHVzaChzKSxyLmFwcGVuZENoaWxkKHMpfWouY2xhc3NOYW1lKz1cIiB0aWNrLXNsaWRlci1zZWxlY3Rpb25cIn1pZihyLmFwcGVuZENoaWxkKG0pLHIuYXBwZW5kQ2hpbGQobiksdGhpcy50aWNrTGFiZWxzPVtdLEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnRpY2tzX2xhYmVscykmJnRoaXMub3B0aW9ucy50aWNrc19sYWJlbHMubGVuZ3RoPjApZm9yKHRoaXMudGlja0xhYmVsQ29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy50aWNrTGFiZWxDb250YWluZXIuY2xhc3NOYW1lPVwic2xpZGVyLXRpY2stbGFiZWwtY29udGFpbmVyXCIsZz0wO2c8dGhpcy5vcHRpb25zLnRpY2tzX2xhYmVscy5sZW5ndGg7ZysrKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3QuY2xhc3NOYW1lPVwic2xpZGVyLXRpY2stbGFiZWxcIix0LmlubmVySFRNTD10aGlzLm9wdGlvbnMudGlja3NfbGFiZWxzW2ddLHRoaXMudGlja0xhYmVscy5wdXNoKHQpLHRoaXMudGlja0xhYmVsQ29udGFpbmVyLmFwcGVuZENoaWxkKHQpfXZhciB1PWZ1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Yi5jbGFzc05hbWU9XCJ0b29sdGlwLWFycm93XCI7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtjLmNsYXNzTmFtZT1cInRvb2x0aXAtaW5uZXJcIixhLmFwcGVuZENoaWxkKGIpLGEuYXBwZW5kQ2hpbGQoYyl9LHY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt2LmNsYXNzTmFtZT1cInRvb2x0aXAgdG9vbHRpcC1tYWluXCIsdSh2KTt2YXIgdz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3cuY2xhc3NOYW1lPVwidG9vbHRpcCB0b29sdGlwLW1pblwiLHUodyk7dmFyIHg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt4LmNsYXNzTmFtZT1cInRvb2x0aXAgdG9vbHRpcC1tYXhcIix1KHgpLHRoaXMuc2xpZGVyRWxlbS5hcHBlbmRDaGlsZChyKSx0aGlzLnNsaWRlckVsZW0uYXBwZW5kQ2hpbGQodiksdGhpcy5zbGlkZXJFbGVtLmFwcGVuZENoaWxkKHcpLHRoaXMuc2xpZGVyRWxlbS5hcHBlbmRDaGlsZCh4KSx0aGlzLnRpY2tMYWJlbENvbnRhaW5lciYmdGhpcy5zbGlkZXJFbGVtLmFwcGVuZENoaWxkKHRoaXMudGlja0xhYmVsQ29udGFpbmVyKSxxLmluc2VydEJlZm9yZSh0aGlzLnNsaWRlckVsZW0sdGhpcy5lbGVtZW50KSx0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIn1pZihhJiYodGhpcy4kZWxlbWVudD1hKHRoaXMuZWxlbWVudCksdGhpcy4kc2xpZGVyRWxlbT1hKHRoaXMuc2xpZGVyRWxlbSkpLHRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwPXt9LHRoaXMuc2xpZGVyRWxlbS5pZD10aGlzLm9wdGlvbnMuaWQsdGhpcy50b3VjaENhcGFibGU9XCJvbnRvdWNoc3RhcnRcImluIHdpbmRvd3x8d2luZG93LkRvY3VtZW50VG91Y2gmJmRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gsdGhpcy50b29sdGlwPXRoaXMuc2xpZGVyRWxlbS5xdWVyeVNlbGVjdG9yKFwiLnRvb2x0aXAtbWFpblwiKSx0aGlzLnRvb2x0aXBJbm5lcj10aGlzLnRvb2x0aXAucXVlcnlTZWxlY3RvcihcIi50b29sdGlwLWlubmVyXCIpLHRoaXMudG9vbHRpcF9taW49dGhpcy5zbGlkZXJFbGVtLnF1ZXJ5U2VsZWN0b3IoXCIudG9vbHRpcC1taW5cIiksdGhpcy50b29sdGlwSW5uZXJfbWluPXRoaXMudG9vbHRpcF9taW4ucXVlcnlTZWxlY3RvcihcIi50b29sdGlwLWlubmVyXCIpLHRoaXMudG9vbHRpcF9tYXg9dGhpcy5zbGlkZXJFbGVtLnF1ZXJ5U2VsZWN0b3IoXCIudG9vbHRpcC1tYXhcIiksdGhpcy50b29sdGlwSW5uZXJfbWF4PXRoaXMudG9vbHRpcF9tYXgucXVlcnlTZWxlY3RvcihcIi50b29sdGlwLWlubmVyXCIpLGVbdGhpcy5vcHRpb25zLnNjYWxlXSYmKHRoaXMub3B0aW9ucy5zY2FsZT1lW3RoaXMub3B0aW9ucy5zY2FsZV0pLHA9PT0hMCYmKHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuc2xpZGVyRWxlbSxcInNsaWRlci1ob3Jpem9udGFsXCIpLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuc2xpZGVyRWxlbSxcInNsaWRlci12ZXJ0aWNhbFwiKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXAsXCJoaWRlXCIpLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9taW4sXCJoaWRlXCIpLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJoaWRlXCIpLFtcImxlZnRcIixcInRvcFwiLFwid2lkdGhcIixcImhlaWdodFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RoaXMuX3JlbW92ZVByb3BlcnR5KHRoaXMudHJhY2tMb3csYSksdGhpcy5fcmVtb3ZlUHJvcGVydHkodGhpcy50cmFja1NlbGVjdGlvbixhKSx0aGlzLl9yZW1vdmVQcm9wZXJ0eSh0aGlzLnRyYWNrSGlnaCxhKX0sdGhpcyksW3RoaXMuaGFuZGxlMSx0aGlzLmhhbmRsZTJdLmZvckVhY2goZnVuY3Rpb24oYSl7dGhpcy5fcmVtb3ZlUHJvcGVydHkoYSxcImxlZnRcIiksdGhpcy5fcmVtb3ZlUHJvcGVydHkoYSxcInRvcFwiKX0sdGhpcyksW3RoaXMudG9vbHRpcCx0aGlzLnRvb2x0aXBfbWluLHRoaXMudG9vbHRpcF9tYXhdLmZvckVhY2goZnVuY3Rpb24oYSl7dGhpcy5fcmVtb3ZlUHJvcGVydHkoYSxcImxlZnRcIiksdGhpcy5fcmVtb3ZlUHJvcGVydHkoYSxcInRvcFwiKSx0aGlzLl9yZW1vdmVQcm9wZXJ0eShhLFwibWFyZ2luLWxlZnRcIiksdGhpcy5fcmVtb3ZlUHJvcGVydHkoYSxcIm1hcmdpbi10b3BcIiksdGhpcy5fcmVtb3ZlQ2xhc3MoYSxcInJpZ2h0XCIpLHRoaXMuX3JlbW92ZUNsYXNzKGEsXCJ0b3BcIil9LHRoaXMpKSxcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/KHRoaXMuX2FkZENsYXNzKHRoaXMuc2xpZGVyRWxlbSxcInNsaWRlci12ZXJ0aWNhbFwiKSx0aGlzLnN0eWxlUG9zPVwidG9wXCIsdGhpcy5tb3VzZVBvcz1cInBhZ2VZXCIsdGhpcy5zaXplUG9zPVwib2Zmc2V0SGVpZ2h0XCIpOih0aGlzLl9hZGRDbGFzcyh0aGlzLnNsaWRlckVsZW0sXCJzbGlkZXItaG9yaXpvbnRhbFwiKSx0aGlzLnNsaWRlckVsZW0uc3R5bGUud2lkdGg9byx0aGlzLm9wdGlvbnMub3JpZW50YXRpb249XCJob3Jpem9udGFsXCIsdGhpcy5zdHlsZVBvcz1cImxlZnRcIix0aGlzLm1vdXNlUG9zPVwicGFnZVhcIix0aGlzLnNpemVQb3M9XCJvZmZzZXRXaWR0aFwiKSx0aGlzLl9zZXRUb29sdGlwUG9zaXRpb24oKSxBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy50aWNrcykmJnRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGg+MCYmKHRoaXMub3B0aW9ucy5tYXg9TWF0aC5tYXguYXBwbHkoTWF0aCx0aGlzLm9wdGlvbnMudGlja3MpLHRoaXMub3B0aW9ucy5taW49TWF0aC5taW4uYXBwbHkoTWF0aCx0aGlzLm9wdGlvbnMudGlja3MpKSxBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy52YWx1ZSk/KHRoaXMub3B0aW9ucy5yYW5nZT0hMCx0aGlzLl9zdGF0ZS52YWx1ZT10aGlzLm9wdGlvbnMudmFsdWUpOnRoaXMuX3N0YXRlLnZhbHVlPXRoaXMub3B0aW9ucy5yYW5nZT9bdGhpcy5vcHRpb25zLnZhbHVlLHRoaXMub3B0aW9ucy5tYXhdOnRoaXMub3B0aW9ucy52YWx1ZSx0aGlzLnRyYWNrTG93PWt8fHRoaXMudHJhY2tMb3csdGhpcy50cmFja1NlbGVjdGlvbj1qfHx0aGlzLnRyYWNrU2VsZWN0aW9uLHRoaXMudHJhY2tIaWdoPWx8fHRoaXMudHJhY2tIaWdoLFwibm9uZVwiPT09dGhpcy5vcHRpb25zLnNlbGVjdGlvbiYmKHRoaXMuX2FkZENsYXNzKHRoaXMudHJhY2tMb3csXCJoaWRlXCIpLHRoaXMuX2FkZENsYXNzKHRoaXMudHJhY2tTZWxlY3Rpb24sXCJoaWRlXCIpLHRoaXMuX2FkZENsYXNzKHRoaXMudHJhY2tIaWdoLFwiaGlkZVwiKSksdGhpcy5oYW5kbGUxPW18fHRoaXMuaGFuZGxlMSx0aGlzLmhhbmRsZTI9bnx8dGhpcy5oYW5kbGUyLHA9PT0hMClmb3IodGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5oYW5kbGUxLFwicm91bmQgdHJpYW5nbGVcIiksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5oYW5kbGUyLFwicm91bmQgdHJpYW5nbGUgaGlkZVwiKSxnPTA7Zzx0aGlzLnRpY2tzLmxlbmd0aDtnKyspdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50aWNrc1tnXSxcInJvdW5kIHRyaWFuZ2xlIGhpZGVcIik7dmFyIHk9W1wicm91bmRcIixcInRyaWFuZ2xlXCIsXCJjdXN0b21cIl0sej0tMSE9PXkuaW5kZXhPZih0aGlzLm9wdGlvbnMuaGFuZGxlKTtpZih6KWZvcih0aGlzLl9hZGRDbGFzcyh0aGlzLmhhbmRsZTEsdGhpcy5vcHRpb25zLmhhbmRsZSksdGhpcy5fYWRkQ2xhc3ModGhpcy5oYW5kbGUyLHRoaXMub3B0aW9ucy5oYW5kbGUpLGc9MDtnPHRoaXMudGlja3MubGVuZ3RoO2crKyl0aGlzLl9hZGRDbGFzcyh0aGlzLnRpY2tzW2ddLHRoaXMub3B0aW9ucy5oYW5kbGUpO3RoaXMuX3N0YXRlLm9mZnNldD10aGlzLl9vZmZzZXQodGhpcy5zbGlkZXJFbGVtKSx0aGlzLl9zdGF0ZS5zaXplPXRoaXMuc2xpZGVyRWxlbVt0aGlzLnNpemVQb3NdLHRoaXMuc2V0VmFsdWUodGhpcy5fc3RhdGUudmFsdWUpLHRoaXMuaGFuZGxlMUtleWRvd249dGhpcy5fa2V5ZG93bi5iaW5kKHRoaXMsMCksdGhpcy5oYW5kbGUxLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5oYW5kbGUxS2V5ZG93biwhMSksdGhpcy5oYW5kbGUyS2V5ZG93bj10aGlzLl9rZXlkb3duLmJpbmQodGhpcywxKSx0aGlzLmhhbmRsZTIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLmhhbmRsZTJLZXlkb3duLCExKSx0aGlzLm1vdXNlZG93bj10aGlzLl9tb3VzZWRvd24uYmluZCh0aGlzKSx0aGlzLnRvdWNoQ2FwYWJsZSYmdGhpcy5zbGlkZXJFbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5tb3VzZWRvd24sITEpLHRoaXMuc2xpZGVyRWxlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpcy5tb3VzZWRvd24sITEpLFwiaGlkZVwiPT09dGhpcy5vcHRpb25zLnRvb2x0aXA/KHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcCxcImhpZGVcIiksdGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21pbixcImhpZGVcIiksdGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21heCxcImhpZGVcIikpOlwiYWx3YXlzXCI9PT10aGlzLm9wdGlvbnMudG9vbHRpcD8odGhpcy5fc2hvd1Rvb2x0aXAoKSx0aGlzLl9hbHdheXNTaG93VG9vbHRpcD0hMCk6KHRoaXMuc2hvd1Rvb2x0aXA9dGhpcy5fc2hvd1Rvb2x0aXAuYmluZCh0aGlzKSx0aGlzLmhpZGVUb29sdGlwPXRoaXMuX2hpZGVUb29sdGlwLmJpbmQodGhpcyksdGhpcy5zbGlkZXJFbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsdGhpcy5zaG93VG9vbHRpcCwhMSksdGhpcy5zbGlkZXJFbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsdGhpcy5oaWRlVG9vbHRpcCwhMSksdGhpcy5oYW5kbGUxLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuc2hvd1Rvb2x0aXAsITEpLHRoaXMuaGFuZGxlMS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuaGlkZVRvb2x0aXAsITEpLHRoaXMuaGFuZGxlMi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNob3dUb29sdGlwLCExKSx0aGlzLmhhbmRsZTIuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLmhpZGVUb29sdGlwLCExKSksdGhpcy5vcHRpb25zLmVuYWJsZWQ/dGhpcy5lbmFibGUoKTp0aGlzLmRpc2FibGUoKX12YXIgZD17Zm9ybWF0SW52YWxpZElucHV0RXJyb3JNc2c6ZnVuY3Rpb24oYSl7cmV0dXJuXCJJbnZhbGlkIGlucHV0IHZhbHVlICdcIithK1wiJyBwYXNzZWQgaW5cIn0sY2FsbGluZ0NvbnRleHROb3RTbGlkZXJJbnN0YW5jZTpcIkNhbGxpbmcgY29udGV4dCBlbGVtZW50IGRvZXMgbm90IGhhdmUgaW5zdGFuY2Ugb2YgU2xpZGVyIGJvdW5kIHRvIGl0LiBDaGVjayB5b3VyIGNvZGUgdG8gbWFrZSBzdXJlIHRoZSBKUXVlcnkgb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIGNhbGwgdG8gdGhlIHNsaWRlcigpIGluaXRpYWxpemVyIGlzIGNhbGxpbmcgdGhlIG1ldGhvZFwifSxlPXtsaW5lYXI6e3RvVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9YS8xMDAqKHRoaXMub3B0aW9ucy5tYXgtdGhpcy5vcHRpb25zLm1pbik7aWYodGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9ucy5sZW5ndGg+MCl7Zm9yKHZhciBjLGQsZSxmPTAsZz0wO2c8dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9ucy5sZW5ndGg7ZysrKWlmKGE8PXRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbZ10pe2M9Zz4wP3RoaXMub3B0aW9ucy50aWNrc1tnLTFdOjAsZT1nPjA/dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1tnLTFdOjAsZD10aGlzLm9wdGlvbnMudGlja3NbZ10sZj10aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2ddO2JyZWFrfWlmKGc+MCl7dmFyIGg9KGEtZSkvKGYtZSk7Yj1jK2gqKGQtYyl9fXZhciBpPXRoaXMub3B0aW9ucy5taW4rTWF0aC5yb3VuZChiL3RoaXMub3B0aW9ucy5zdGVwKSp0aGlzLm9wdGlvbnMuc3RlcDtyZXR1cm4gaTx0aGlzLm9wdGlvbnMubWluP3RoaXMub3B0aW9ucy5taW46aT50aGlzLm9wdGlvbnMubWF4P3RoaXMub3B0aW9ucy5tYXg6aX0sdG9QZXJjZW50YWdlOmZ1bmN0aW9uKGEpe2lmKHRoaXMub3B0aW9ucy5tYXg9PT10aGlzLm9wdGlvbnMubWluKXJldHVybiAwO2lmKHRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnMubGVuZ3RoPjApe2Zvcih2YXIgYixjLGQsZT0wLGY9MDtmPHRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGg7ZisrKWlmKGE8PXRoaXMub3B0aW9ucy50aWNrc1tmXSl7Yj1mPjA/dGhpcy5vcHRpb25zLnRpY2tzW2YtMV06MCxkPWY+MD90aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2YtMV06MCxjPXRoaXMub3B0aW9ucy50aWNrc1tmXSxlPXRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbZl07YnJlYWt9aWYoZj4wKXt2YXIgZz0oYS1iKS8oYy1iKTtyZXR1cm4gZCtnKihlLWQpfX1yZXR1cm4gMTAwKihhLXRoaXMub3B0aW9ucy5taW4pLyh0aGlzLm9wdGlvbnMubWF4LXRoaXMub3B0aW9ucy5taW4pfX0sbG9nYXJpdGhtaWM6e3RvVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9MD09PXRoaXMub3B0aW9ucy5taW4/MDpNYXRoLmxvZyh0aGlzLm9wdGlvbnMubWluKSxjPU1hdGgubG9nKHRoaXMub3B0aW9ucy5tYXgpLGQ9TWF0aC5leHAoYisoYy1iKSphLzEwMCk7cmV0dXJuIGQ9dGhpcy5vcHRpb25zLm1pbitNYXRoLnJvdW5kKChkLXRoaXMub3B0aW9ucy5taW4pL3RoaXMub3B0aW9ucy5zdGVwKSp0aGlzLm9wdGlvbnMuc3RlcCxkPHRoaXMub3B0aW9ucy5taW4/dGhpcy5vcHRpb25zLm1pbjpkPnRoaXMub3B0aW9ucy5tYXg/dGhpcy5vcHRpb25zLm1heDpkfSx0b1BlcmNlbnRhZ2U6ZnVuY3Rpb24oYSl7aWYodGhpcy5vcHRpb25zLm1heD09PXRoaXMub3B0aW9ucy5taW4pcmV0dXJuIDA7dmFyIGI9TWF0aC5sb2codGhpcy5vcHRpb25zLm1heCksYz0wPT09dGhpcy5vcHRpb25zLm1pbj8wOk1hdGgubG9nKHRoaXMub3B0aW9ucy5taW4pLGQ9MD09PWE/MDpNYXRoLmxvZyhhKTtyZXR1cm4gMTAwKihkLWMpLyhiLWMpfX19O2lmKGI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYy5jYWxsKHRoaXMsYSxiKSx0aGlzfSxiLnByb3RvdHlwZT17X2luaXQ6ZnVuY3Rpb24oKXt9LGNvbnN0cnVjdG9yOmIsZGVmYXVsdE9wdGlvbnM6e2lkOlwiXCIsbWluOjAsbWF4OjEwLHN0ZXA6MSxwcmVjaXNpb246MCxvcmllbnRhdGlvbjpcImhvcml6b250YWxcIix2YWx1ZTo1LHJhbmdlOiExLHNlbGVjdGlvbjpcImJlZm9yZVwiLHRvb2x0aXA6XCJzaG93XCIsdG9vbHRpcF9zcGxpdDohMSxoYW5kbGU6XCJyb3VuZFwiLHJldmVyc2VkOiExLGVuYWJsZWQ6ITAsZm9ybWF0dGVyOmZ1bmN0aW9uKGEpe3JldHVybiBBcnJheS5pc0FycmF5KGEpP2FbMF0rXCIgOiBcIithWzFdOmF9LG5hdHVyYWxfYXJyb3dfa2V5czohMSx0aWNrczpbXSx0aWNrc19wb3NpdGlvbnM6W10sdGlja3NfbGFiZWxzOltdLHRpY2tzX3NuYXBfYm91bmRzOjAsc2NhbGU6XCJsaW5lYXJcIixmb2N1czohMSx0b29sdGlwX3Bvc2l0aW9uOm51bGx9LGdldEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zbGlkZXJFbGVtfSxnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMucmFuZ2U/dGhpcy5fc3RhdGUudmFsdWU6dGhpcy5fc3RhdGUudmFsdWVbMF19LHNldFZhbHVlOmZ1bmN0aW9uKGEsYixjKXthfHwoYT0wKTt2YXIgZD10aGlzLmdldFZhbHVlKCk7dGhpcy5fc3RhdGUudmFsdWU9dGhpcy5fdmFsaWRhdGVJbnB1dFZhbHVlKGEpO3ZhciBlPXRoaXMuX2FwcGx5UHJlY2lzaW9uLmJpbmQodGhpcyk7dGhpcy5vcHRpb25zLnJhbmdlPyh0aGlzLl9zdGF0ZS52YWx1ZVswXT1lKHRoaXMuX3N0YXRlLnZhbHVlWzBdKSx0aGlzLl9zdGF0ZS52YWx1ZVsxXT1lKHRoaXMuX3N0YXRlLnZhbHVlWzFdKSx0aGlzLl9zdGF0ZS52YWx1ZVswXT1NYXRoLm1heCh0aGlzLm9wdGlvbnMubWluLE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXgsdGhpcy5fc3RhdGUudmFsdWVbMF0pKSx0aGlzLl9zdGF0ZS52YWx1ZVsxXT1NYXRoLm1heCh0aGlzLm9wdGlvbnMubWluLE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXgsdGhpcy5fc3RhdGUudmFsdWVbMV0pKSk6KHRoaXMuX3N0YXRlLnZhbHVlPWUodGhpcy5fc3RhdGUudmFsdWUpLHRoaXMuX3N0YXRlLnZhbHVlPVtNYXRoLm1heCh0aGlzLm9wdGlvbnMubWluLE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXgsdGhpcy5fc3RhdGUudmFsdWUpKV0sdGhpcy5fYWRkQ2xhc3ModGhpcy5oYW5kbGUyLFwiaGlkZVwiKSx0aGlzLl9zdGF0ZS52YWx1ZVsxXT1cImFmdGVyXCI9PT10aGlzLm9wdGlvbnMuc2VsZWN0aW9uP3RoaXMub3B0aW9ucy5tYXg6dGhpcy5vcHRpb25zLm1pbiksdGhpcy5fc3RhdGUucGVyY2VudGFnZT10aGlzLm9wdGlvbnMubWF4PnRoaXMub3B0aW9ucy5taW4/W3RoaXMuX3RvUGVyY2VudGFnZSh0aGlzLl9zdGF0ZS52YWx1ZVswXSksdGhpcy5fdG9QZXJjZW50YWdlKHRoaXMuX3N0YXRlLnZhbHVlWzFdKSwxMDAqdGhpcy5vcHRpb25zLnN0ZXAvKHRoaXMub3B0aW9ucy5tYXgtdGhpcy5vcHRpb25zLm1pbildOlswLDAsMTAwXSx0aGlzLl9sYXlvdXQoKTt2YXIgZj10aGlzLm9wdGlvbnMucmFuZ2U/dGhpcy5fc3RhdGUudmFsdWU6dGhpcy5fc3RhdGUudmFsdWVbMF07cmV0dXJuIGI9PT0hMCYmdGhpcy5fdHJpZ2dlcihcInNsaWRlXCIsZiksZCE9PWYmJmM9PT0hMCYmdGhpcy5fdHJpZ2dlcihcImNoYW5nZVwiLHtvbGRWYWx1ZTpkLG5ld1ZhbHVlOmZ9KSx0aGlzLl9zZXREYXRhVmFsKGYpLHRoaXN9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLl9yZW1vdmVTbGlkZXJFdmVudEhhbmRsZXJzKCksdGhpcy5zbGlkZXJFbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zbGlkZXJFbGVtKSx0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheT1cIlwiLHRoaXMuX2NsZWFuVXBFdmVudENhbGxiYWNrc01hcCgpLHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhXCIpLGEmJih0aGlzLl91bmJpbmRKUXVlcnlFdmVudEhhbmRsZXJzKCksdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKFwic2xpZGVyXCIpKX0sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZS5lbmFibGVkPSExLHRoaXMuaGFuZGxlMS5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSx0aGlzLmhhbmRsZTIucmVtb3ZlQXR0cmlidXRlKFwidGFiaW5kZXhcIiksdGhpcy5fYWRkQ2xhc3ModGhpcy5zbGlkZXJFbGVtLFwic2xpZGVyLWRpc2FibGVkXCIpLHRoaXMuX3RyaWdnZXIoXCJzbGlkZURpc2FibGVkXCIpLHRoaXN9LGVuYWJsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZS5lbmFibGVkPSEwLHRoaXMuaGFuZGxlMS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLDApLHRoaXMuaGFuZGxlMi5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLDApLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuc2xpZGVyRWxlbSxcInNsaWRlci1kaXNhYmxlZFwiKSx0aGlzLl90cmlnZ2VyKFwic2xpZGVFbmFibGVkXCIpLHRoaXN9LHRvZ2dsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZS5lbmFibGVkP3RoaXMuZGlzYWJsZSgpOnRoaXMuZW5hYmxlKCksdGhpc30saXNFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXRlLmVuYWJsZWR9LG9uOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2JpbmROb25RdWVyeUV2ZW50SGFuZGxlcihhLGIpLHRoaXN9LG9mZjpmdW5jdGlvbihiLGMpe2E/KHRoaXMuJGVsZW1lbnQub2ZmKGIsYyksdGhpcy4kc2xpZGVyRWxlbS5vZmYoYixjKSk6dGhpcy5fdW5iaW5kTm9uUXVlcnlFdmVudEhhbmRsZXIoYixjKX0sZ2V0QXR0cmlidXRlOmZ1bmN0aW9uKGEpe3JldHVybiBhP3RoaXMub3B0aW9uc1thXTp0aGlzLm9wdGlvbnN9LHNldEF0dHJpYnV0ZTpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm9wdGlvbnNbYV09Yix0aGlzfSxyZWZyZXNoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbW92ZVNsaWRlckV2ZW50SGFuZGxlcnMoKSxjLmNhbGwodGhpcyx0aGlzLmVsZW1lbnQsdGhpcy5vcHRpb25zKSxhJiZhLmRhdGEodGhpcy5lbGVtZW50LFwic2xpZGVyXCIsdGhpcyksdGhpc30scmVsYXlvdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF5b3V0KCksdGhpc30sX3JlbW92ZVNsaWRlckV2ZW50SGFuZGxlcnM6ZnVuY3Rpb24oKXt0aGlzLmhhbmRsZTEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLmhhbmRsZTFLZXlkb3duLCExKSx0aGlzLmhhbmRsZTEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5zaG93VG9vbHRpcCwhMSksdGhpcy5oYW5kbGUxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5oaWRlVG9vbHRpcCwhMSksdGhpcy5oYW5kbGUyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5oYW5kbGUyS2V5ZG93biwhMSksdGhpcy5oYW5kbGUyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuaGFuZGxlMktleWRvd24sITEpLHRoaXMuaGFuZGxlMi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuaGFuZGxlMktleWRvd24sITEpLHRoaXMuc2xpZGVyRWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLHRoaXMuc2hvd1Rvb2x0aXAsITEpLHRoaXMuc2xpZGVyRWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLHRoaXMuaGlkZVRvb2x0aXAsITEpLHRoaXMuc2xpZGVyRWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMubW91c2Vkb3duLCExKSx0aGlzLnNsaWRlckVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMubW91c2Vkb3duLCExKX0sX2JpbmROb25RdWVyeUV2ZW50SGFuZGxlcjpmdW5jdGlvbihhLGIpe3ZvaWQgMD09PXRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwW2FdJiYodGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbYV09W10pLHRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwW2FdLnB1c2goYil9LF91bmJpbmROb25RdWVyeUV2ZW50SGFuZGxlcjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwW2FdO2lmKHZvaWQgMCE9PWMpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspaWYoY1tkXT09PWIpe2Muc3BsaWNlKGQsMSk7YnJlYWt9fSxfY2xlYW5VcEV2ZW50Q2FsbGJhY2tzTWFwOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPU9iamVjdC5rZXlzKHRoaXMuZXZlbnRUb0NhbGxiYWNrTWFwKSxiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPWFbYl07dGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbY109bnVsbH19LF9zaG93VG9vbHRpcDpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy50b29sdGlwX3NwbGl0PT09ITE/KHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcCxcImluXCIpLHRoaXMudG9vbHRpcF9taW4uc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLnRvb2x0aXBfbWF4LnN0eWxlLmRpc3BsYXk9XCJub25lXCIpOih0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXBfbWluLFwiaW5cIiksdGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21heCxcImluXCIpLHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKSx0aGlzLl9zdGF0ZS5vdmVyPSEwfSxfaGlkZVRvb2x0aXA6ZnVuY3Rpb24oKXt0aGlzLl9zdGF0ZS5pbkRyYWc9PT0hMSYmdGhpcy5hbHdheXNTaG93VG9vbHRpcCE9PSEwJiYodGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwLFwiaW5cIiksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21pbixcImluXCIpLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJpblwiKSksdGhpcy5fc3RhdGUub3Zlcj0hMX0sX2xheW91dDpmdW5jdGlvbigpe3ZhciBhO2lmKGE9dGhpcy5vcHRpb25zLnJldmVyc2VkP1sxMDAtdGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSx0aGlzLm9wdGlvbnMucmFuZ2U/MTAwLXRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV06dGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXV06W3RoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0sdGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXV0sdGhpcy5oYW5kbGUxLnN0eWxlW3RoaXMuc3R5bGVQb3NdPWFbMF0rXCIlXCIsdGhpcy5oYW5kbGUyLnN0eWxlW3RoaXMuc3R5bGVQb3NdPWFbMV0rXCIlXCIsQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMudGlja3MpJiZ0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoPjApe3ZhciBiPU1hdGgubWF4LmFwcGx5KE1hdGgsdGhpcy5vcHRpb25zLnRpY2tzKSxjPU1hdGgubWluLmFwcGx5KE1hdGgsdGhpcy5vcHRpb25zLnRpY2tzKSxkPVwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj9cImhlaWdodFwiOlwid2lkdGhcIixlPVwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj9cIm1hcmdpblRvcFwiOlwibWFyZ2luTGVmdFwiLGY9dGhpcy5fc3RhdGUuc2l6ZS8odGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aC0xKTtpZih0aGlzLnRpY2tMYWJlbENvbnRhaW5lcil7dmFyIGc9MDtpZigwPT09dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9ucy5sZW5ndGgpdGhpcy50aWNrTGFiZWxDb250YWluZXIuc3R5bGVbZV09LWYvMitcInB4XCIsZz10aGlzLnRpY2tMYWJlbENvbnRhaW5lci5vZmZzZXRIZWlnaHQ7ZWxzZSBmb3IoaD0wO2g8dGhpcy50aWNrTGFiZWxDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGg7aCsrKXRoaXMudGlja0xhYmVsQ29udGFpbmVyLmNoaWxkTm9kZXNbaF0ub2Zmc2V0SGVpZ2h0PmcmJihnPXRoaXMudGlja0xhYmVsQ29udGFpbmVyLmNoaWxkTm9kZXNbaF0ub2Zmc2V0SGVpZ2h0KTtcImhvcml6b250YWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiYmKHRoaXMuc2xpZGVyRWxlbS5zdHlsZS5tYXJnaW5Cb3R0b209ZytcInB4XCIpfWZvcih2YXIgaD0wO2g8dGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aDtoKyspe3ZhciBpPXRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbaF18fDEwMCoodGhpcy5vcHRpb25zLnRpY2tzW2hdLWMpLyhiLWMpO3RoaXMudGlja3NbaF0uc3R5bGVbdGhpcy5zdHlsZVBvc109aStcIiVcIix0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRpY2tzW2hdLFwiaW4tc2VsZWN0aW9uXCIpLHRoaXMub3B0aW9ucy5yYW5nZT9pPj1hWzBdJiZpPD1hWzFdJiZ0aGlzLl9hZGRDbGFzcyh0aGlzLnRpY2tzW2hdLFwiaW4tc2VsZWN0aW9uXCIpOlwiYWZ0ZXJcIj09PXRoaXMub3B0aW9ucy5zZWxlY3Rpb24mJmk+PWFbMF0/dGhpcy5fYWRkQ2xhc3ModGhpcy50aWNrc1toXSxcImluLXNlbGVjdGlvblwiKTpcImJlZm9yZVwiPT09dGhpcy5vcHRpb25zLnNlbGVjdGlvbiYmaTw9YVswXSYmdGhpcy5fYWRkQ2xhc3ModGhpcy50aWNrc1toXSxcImluLXNlbGVjdGlvblwiKSx0aGlzLnRpY2tMYWJlbHNbaF0mJih0aGlzLnRpY2tMYWJlbHNbaF0uc3R5bGVbZF09ZitcInB4XCIsdm9pZCAwIT09dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1toXSYmKHRoaXMudGlja0xhYmVsc1toXS5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy50aWNrTGFiZWxzW2hdLnN0eWxlW3RoaXMuc3R5bGVQb3NdPXRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbaF0rXCIlXCIsdGhpcy50aWNrTGFiZWxzW2hdLnN0eWxlW2VdPS1mLzIrXCJweFwiKSl9fXZhciBqO2lmKHRoaXMub3B0aW9ucy5yYW5nZSl7aj10aGlzLm9wdGlvbnMuZm9ybWF0dGVyKHRoaXMuX3N0YXRlLnZhbHVlKSx0aGlzLl9zZXRUZXh0KHRoaXMudG9vbHRpcElubmVyLGopLHRoaXMudG9vbHRpcC5zdHlsZVt0aGlzLnN0eWxlUG9zXT0oYVsxXSthWzBdKS8yK1wiJVwiLFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj90aGlzLl9jc3ModGhpcy50b29sdGlwLFwibWFyZ2luLXRvcFwiLC10aGlzLnRvb2x0aXAub2Zmc2V0SGVpZ2h0LzIrXCJweFwiKTp0aGlzLl9jc3ModGhpcy50b29sdGlwLFwibWFyZ2luLWxlZnRcIiwtdGhpcy50b29sdGlwLm9mZnNldFdpZHRoLzIrXCJweFwiKSxcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/dGhpcy5fY3NzKHRoaXMudG9vbHRpcCxcIm1hcmdpbi10b3BcIiwtdGhpcy50b29sdGlwLm9mZnNldEhlaWdodC8yK1wicHhcIik6dGhpcy5fY3NzKHRoaXMudG9vbHRpcCxcIm1hcmdpbi1sZWZ0XCIsLXRoaXMudG9vbHRpcC5vZmZzZXRXaWR0aC8yK1wicHhcIik7dmFyIGs9dGhpcy5vcHRpb25zLmZvcm1hdHRlcih0aGlzLl9zdGF0ZS52YWx1ZVswXSk7dGhpcy5fc2V0VGV4dCh0aGlzLnRvb2x0aXBJbm5lcl9taW4sayk7dmFyIGw9dGhpcy5vcHRpb25zLmZvcm1hdHRlcih0aGlzLl9zdGF0ZS52YWx1ZVsxXSk7dGhpcy5fc2V0VGV4dCh0aGlzLnRvb2x0aXBJbm5lcl9tYXgsbCksdGhpcy50b29sdGlwX21pbi5zdHlsZVt0aGlzLnN0eWxlUG9zXT1hWzBdK1wiJVwiLFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj90aGlzLl9jc3ModGhpcy50b29sdGlwX21pbixcIm1hcmdpbi10b3BcIiwtdGhpcy50b29sdGlwX21pbi5vZmZzZXRIZWlnaHQvMitcInB4XCIpOnRoaXMuX2Nzcyh0aGlzLnRvb2x0aXBfbWluLFwibWFyZ2luLWxlZnRcIiwtdGhpcy50b29sdGlwX21pbi5vZmZzZXRXaWR0aC8yK1wicHhcIiksdGhpcy50b29sdGlwX21heC5zdHlsZVt0aGlzLnN0eWxlUG9zXT1hWzFdK1wiJVwiLFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj90aGlzLl9jc3ModGhpcy50b29sdGlwX21heCxcIm1hcmdpbi10b3BcIiwtdGhpcy50b29sdGlwX21heC5vZmZzZXRIZWlnaHQvMitcInB4XCIpOnRoaXMuX2Nzcyh0aGlzLnRvb2x0aXBfbWF4LFwibWFyZ2luLWxlZnRcIiwtdGhpcy50b29sdGlwX21heC5vZmZzZXRXaWR0aC8yK1wicHhcIil9ZWxzZSBqPXRoaXMub3B0aW9ucy5mb3JtYXR0ZXIodGhpcy5fc3RhdGUudmFsdWVbMF0pLHRoaXMuX3NldFRleHQodGhpcy50b29sdGlwSW5uZXIsaiksdGhpcy50b29sdGlwLnN0eWxlW3RoaXMuc3R5bGVQb3NdPWFbMF0rXCIlXCIsXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uP3RoaXMuX2Nzcyh0aGlzLnRvb2x0aXAsXCJtYXJnaW4tdG9wXCIsLXRoaXMudG9vbHRpcC5vZmZzZXRIZWlnaHQvMitcInB4XCIpOnRoaXMuX2Nzcyh0aGlzLnRvb2x0aXAsXCJtYXJnaW4tbGVmdFwiLC10aGlzLnRvb2x0aXAub2Zmc2V0V2lkdGgvMitcInB4XCIpO2lmKFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbil0aGlzLnRyYWNrTG93LnN0eWxlLnRvcD1cIjBcIix0aGlzLnRyYWNrTG93LnN0eWxlLmhlaWdodD1NYXRoLm1pbihhWzBdLGFbMV0pK1wiJVwiLHRoaXMudHJhY2tTZWxlY3Rpb24uc3R5bGUudG9wPU1hdGgubWluKGFbMF0sYVsxXSkrXCIlXCIsdGhpcy50cmFja1NlbGVjdGlvbi5zdHlsZS5oZWlnaHQ9TWF0aC5hYnMoYVswXS1hWzFdKStcIiVcIix0aGlzLnRyYWNrSGlnaC5zdHlsZS5ib3R0b209XCIwXCIsdGhpcy50cmFja0hpZ2guc3R5bGUuaGVpZ2h0PTEwMC1NYXRoLm1pbihhWzBdLGFbMV0pLU1hdGguYWJzKGFbMF0tYVsxXSkrXCIlXCI7ZWxzZXt0aGlzLnRyYWNrTG93LnN0eWxlLmxlZnQ9XCIwXCIsdGhpcy50cmFja0xvdy5zdHlsZS53aWR0aD1NYXRoLm1pbihhWzBdLGFbMV0pK1wiJVwiLHRoaXMudHJhY2tTZWxlY3Rpb24uc3R5bGUubGVmdD1NYXRoLm1pbihhWzBdLGFbMV0pK1wiJVwiLHRoaXMudHJhY2tTZWxlY3Rpb24uc3R5bGUud2lkdGg9TWF0aC5hYnMoYVswXS1hWzFdKStcIiVcIix0aGlzLnRyYWNrSGlnaC5zdHlsZS5yaWdodD1cIjBcIix0aGlzLnRyYWNrSGlnaC5zdHlsZS53aWR0aD0xMDAtTWF0aC5taW4oYVswXSxhWzFdKS1NYXRoLmFicyhhWzBdLWFbMV0pK1wiJVwiO3ZhciBtPXRoaXMudG9vbHRpcF9taW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj10aGlzLnRvb2x0aXBfbWF4LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO20ucmlnaHQ+bi5sZWZ0Pyh0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwidG9wXCIpLHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJib3R0b21cIiksdGhpcy50b29sdGlwX21heC5zdHlsZS50b3A9XCIxOHB4XCIpOih0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwiYm90dG9tXCIpLHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJ0b3BcIiksdGhpcy50b29sdGlwX21heC5zdHlsZS50b3A9dGhpcy50b29sdGlwX21pbi5zdHlsZS50b3ApfX0sX3JlbW92ZVByb3BlcnR5OmZ1bmN0aW9uKGEsYil7YS5zdHlsZS5yZW1vdmVQcm9wZXJ0eT9hLnN0eWxlLnJlbW92ZVByb3BlcnR5KGIpOmEuc3R5bGUucmVtb3ZlQXR0cmlidXRlKGIpfSxfbW91c2Vkb3duOmZ1bmN0aW9uKGEpe2lmKCF0aGlzLl9zdGF0ZS5lbmFibGVkKXJldHVybiExO3RoaXMuX3N0YXRlLm9mZnNldD10aGlzLl9vZmZzZXQodGhpcy5zbGlkZXJFbGVtKSx0aGlzLl9zdGF0ZS5zaXplPXRoaXMuc2xpZGVyRWxlbVt0aGlzLnNpemVQb3NdO3ZhciBiPXRoaXMuX2dldFBlcmNlbnRhZ2UoYSk7aWYodGhpcy5vcHRpb25zLnJhbmdlKXt2YXIgYz1NYXRoLmFicyh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLWIpLGQ9TWF0aC5hYnModGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXS1iKTt0aGlzLl9zdGF0ZS5kcmFnZ2VkPWQ+Yz8wOjF9ZWxzZSB0aGlzLl9zdGF0ZS5kcmFnZ2VkPTA7dGhpcy5fc3RhdGUucGVyY2VudGFnZVt0aGlzLl9zdGF0ZS5kcmFnZ2VkXT1iLHRoaXMuX2xheW91dCgpLHRoaXMudG91Y2hDYXBhYmxlJiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMubW91c2Vtb3ZlLCExKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm1vdXNldXAsITEpKSx0aGlzLm1vdXNlbW92ZSYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMubW91c2Vtb3ZlLCExKSx0aGlzLm1vdXNldXAmJmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5tb3VzZXVwLCExKSx0aGlzLm1vdXNlbW92ZT10aGlzLl9tb3VzZW1vdmUuYmluZCh0aGlzKSx0aGlzLm1vdXNldXA9dGhpcy5fbW91c2V1cC5iaW5kKHRoaXMpLHRoaXMudG91Y2hDYXBhYmxlJiYoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMubW91c2Vtb3ZlLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm1vdXNldXAsITEpKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5tb3VzZW1vdmUsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5tb3VzZXVwLCExKSx0aGlzLl9zdGF0ZS5pbkRyYWc9ITA7dmFyIGU9dGhpcy5fY2FsY3VsYXRlVmFsdWUoKTtyZXR1cm4gdGhpcy5fdHJpZ2dlcihcInNsaWRlU3RhcnRcIixlKSx0aGlzLl9zZXREYXRhVmFsKGUpLHRoaXMuc2V0VmFsdWUoZSwhMSwhMCksdGhpcy5fcGF1c2VFdmVudChhKSx0aGlzLm9wdGlvbnMuZm9jdXMmJnRoaXMuX3RyaWdnZXJGb2N1c09uSGFuZGxlKHRoaXMuX3N0YXRlLmRyYWdnZWQpLCEwfSxfdHJpZ2dlckZvY3VzT25IYW5kbGU6ZnVuY3Rpb24oYSl7MD09PWEmJnRoaXMuaGFuZGxlMS5mb2N1cygpLDE9PT1hJiZ0aGlzLmhhbmRsZTIuZm9jdXMoKX0sX2tleWRvd246ZnVuY3Rpb24oYSxiKXtpZighdGhpcy5fc3RhdGUuZW5hYmxlZClyZXR1cm4hMTt2YXIgYztzd2l0Y2goYi5rZXlDb2RlKXtjYXNlIDM3OmNhc2UgNDA6Yz0tMTticmVhaztjYXNlIDM5OmNhc2UgMzg6Yz0xfWlmKGMpe2lmKHRoaXMub3B0aW9ucy5uYXR1cmFsX2Fycm93X2tleXMpe3ZhciBkPVwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiYmIXRoaXMub3B0aW9ucy5yZXZlcnNlZCxlPVwiaG9yaXpvbnRhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uJiZ0aGlzLm9wdGlvbnMucmV2ZXJzZWQ7KGR8fGUpJiYoYz0tYyl9dmFyIGY9dGhpcy5fc3RhdGUudmFsdWVbYV0rYyp0aGlzLm9wdGlvbnMuc3RlcDtyZXR1cm4gdGhpcy5vcHRpb25zLnJhbmdlJiYoZj1bYT90aGlzLl9zdGF0ZS52YWx1ZVswXTpmLGE/Zjp0aGlzLl9zdGF0ZS52YWx1ZVsxXV0pLHRoaXMuX3RyaWdnZXIoXCJzbGlkZVN0YXJ0XCIsZiksdGhpcy5fc2V0RGF0YVZhbChmKSx0aGlzLnNldFZhbHVlKGYsITAsITApLHRoaXMuX3NldERhdGFWYWwoZiksdGhpcy5fdHJpZ2dlcihcInNsaWRlU3RvcFwiLGYpLHRoaXMuX2xheW91dCgpLHRoaXMuX3BhdXNlRXZlbnQoYiksITF9fSxfcGF1c2VFdmVudDpmdW5jdGlvbihhKXthLnN0b3BQcm9wYWdhdGlvbiYmYS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0JiZhLnByZXZlbnREZWZhdWx0KCksYS5jYW5jZWxCdWJibGU9ITAsYS5yZXR1cm5WYWx1ZT0hMX0sX21vdXNlbW92ZTpmdW5jdGlvbihhKXtpZighdGhpcy5fc3RhdGUuZW5hYmxlZClyZXR1cm4hMTt2YXIgYj10aGlzLl9nZXRQZXJjZW50YWdlKGEpO3RoaXMuX2FkanVzdFBlcmNlbnRhZ2VGb3JSYW5nZVNsaWRlcnMoYiksdGhpcy5fc3RhdGUucGVyY2VudGFnZVt0aGlzLl9zdGF0ZS5kcmFnZ2VkXT1iLHRoaXMuX2xheW91dCgpO3ZhciBjPXRoaXMuX2NhbGN1bGF0ZVZhbHVlKCEwKTtyZXR1cm4gdGhpcy5zZXRWYWx1ZShjLCEwLCEwKSwhMX0sX2FkanVzdFBlcmNlbnRhZ2VGb3JSYW5nZVNsaWRlcnM6ZnVuY3Rpb24oYSl7aWYodGhpcy5vcHRpb25zLnJhbmdlKXt2YXIgYj10aGlzLl9nZXROdW1EaWdpdHNBZnRlckRlY2ltYWxQbGFjZShhKTtiPWI/Yi0xOjA7dmFyIGM9dGhpcy5fYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdChhLGIpOzA9PT10aGlzLl9zdGF0ZS5kcmFnZ2VkJiZ0aGlzLl9hcHBseVRvRml4ZWRBbmRQYXJzZUZsb2F0KHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV0sYik8Yz8odGhpcy5fc3RhdGUucGVyY2VudGFnZVswXT10aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdLHRoaXMuX3N0YXRlLmRyYWdnZWQ9MSk6MT09PXRoaXMuX3N0YXRlLmRyYWdnZWQmJnRoaXMuX2FwcGx5VG9GaXhlZEFuZFBhcnNlRmxvYXQodGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSxiKT5jJiYodGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXT10aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLHRoaXMuX3N0YXRlLmRyYWdnZWQ9MCl9fSxfbW91c2V1cDpmdW5jdGlvbigpe2lmKCF0aGlzLl9zdGF0ZS5lbmFibGVkKXJldHVybiExO3RoaXMudG91Y2hDYXBhYmxlJiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMubW91c2Vtb3ZlLCExKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm1vdXNldXAsITEpKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5tb3VzZW1vdmUsITEpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5tb3VzZXVwLCExKSx0aGlzLl9zdGF0ZS5pbkRyYWc9ITEsdGhpcy5fc3RhdGUub3Zlcj09PSExJiZ0aGlzLl9oaWRlVG9vbHRpcCgpO3ZhciBhPXRoaXMuX2NhbGN1bGF0ZVZhbHVlKCEwKTtyZXR1cm4gdGhpcy5fbGF5b3V0KCksdGhpcy5fc2V0RGF0YVZhbChhKSx0aGlzLl90cmlnZ2VyKFwic2xpZGVTdG9wXCIsYSksITF9LF9jYWxjdWxhdGVWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYjtpZih0aGlzLm9wdGlvbnMucmFuZ2U/KGI9W3RoaXMub3B0aW9ucy5taW4sdGhpcy5vcHRpb25zLm1heF0sMCE9PXRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0mJihiWzBdPXRoaXMuX3RvVmFsdWUodGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSksYlswXT10aGlzLl9hcHBseVByZWNpc2lvbihiWzBdKSksMTAwIT09dGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXSYmKGJbMV09dGhpcy5fdG9WYWx1ZSh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdKSxiWzFdPXRoaXMuX2FwcGx5UHJlY2lzaW9uKGJbMV0pKSk6KGI9dGhpcy5fdG9WYWx1ZSh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdKSxiPXBhcnNlRmxvYXQoYiksYj10aGlzLl9hcHBseVByZWNpc2lvbihiKSksYSl7Zm9yKHZhciBjPVtiLDEvMF0sZD0wO2Q8dGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aDtkKyspe3ZhciBlPU1hdGguYWJzKHRoaXMub3B0aW9ucy50aWNrc1tkXS1iKTtlPD1jWzFdJiYoYz1bdGhpcy5vcHRpb25zLnRpY2tzW2RdLGVdKX1pZihjWzFdPD10aGlzLm9wdGlvbnMudGlja3Nfc25hcF9ib3VuZHMpcmV0dXJuIGNbMF19cmV0dXJuIGJ9LF9hcHBseVByZWNpc2lvbjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMucHJlY2lzaW9ufHx0aGlzLl9nZXROdW1EaWdpdHNBZnRlckRlY2ltYWxQbGFjZSh0aGlzLm9wdGlvbnMuc3RlcCk7cmV0dXJuIHRoaXMuX2FwcGx5VG9GaXhlZEFuZFBhcnNlRmxvYXQoYSxiKX0sX2dldE51bURpZ2l0c0FmdGVyRGVjaW1hbFBsYWNlOmZ1bmN0aW9uKGEpe3ZhciBiPShcIlwiK2EpLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO3JldHVybiBiP01hdGgubWF4KDAsKGJbMV0/YlsxXS5sZW5ndGg6MCktKGJbMl0/K2JbMl06MCkpOjB9LF9hcHBseVRvRml4ZWRBbmRQYXJzZUZsb2F0OmZ1bmN0aW9uKGEsYil7dmFyIGM9YS50b0ZpeGVkKGIpO3JldHVybiBwYXJzZUZsb2F0KGMpfSxfZ2V0UGVyY2VudGFnZTpmdW5jdGlvbihhKXshdGhpcy50b3VjaENhcGFibGV8fFwidG91Y2hzdGFydFwiIT09YS50eXBlJiZcInRvdWNobW92ZVwiIT09YS50eXBlfHwoYT1hLnRvdWNoZXNbMF0pO3ZhciBiPWFbdGhpcy5tb3VzZVBvc10sYz10aGlzLl9zdGF0ZS5vZmZzZXRbdGhpcy5zdHlsZVBvc10sZD1iLWMsZT1kL3RoaXMuX3N0YXRlLnNpemUqMTAwO3JldHVybiBlPU1hdGgucm91bmQoZS90aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzJdKSp0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzJdLHRoaXMub3B0aW9ucy5yZXZlcnNlZCYmKGU9MTAwLWUpLE1hdGgubWF4KDAsTWF0aC5taW4oMTAwLGUpKX0sX3ZhbGlkYXRlSW5wdXRWYWx1ZTpmdW5jdGlvbihhKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSlyZXR1cm4gYTtpZihBcnJheS5pc0FycmF5KGEpKXJldHVybiB0aGlzLl92YWxpZGF0ZUFycmF5KGEpLGE7dGhyb3cgbmV3IEVycm9yKGQuZm9ybWF0SW52YWxpZElucHV0RXJyb3JNc2coYSkpfSxfdmFsaWRhdGVBcnJheTpmdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9YVtiXTtpZihcIm51bWJlclwiIT10eXBlb2YgYyl0aHJvdyBuZXcgRXJyb3IoZC5mb3JtYXRJbnZhbGlkSW5wdXRFcnJvck1zZyhjKSl9fSxfc2V0RGF0YVZhbDpmdW5jdGlvbihhKXt0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLGEpLHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGEpLHRoaXMuZWxlbWVudC52YWx1ZT1hfSxfdHJpZ2dlcjpmdW5jdGlvbihiLGMpe2M9Y3x8MD09PWM/Yzp2b2lkIDA7dmFyIGQ9dGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbYl07aWYoZCYmZC5sZW5ndGgpZm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV07ZihjKX1hJiZ0aGlzLl90cmlnZ2VySlF1ZXJ5RXZlbnQoYixjKX0sX3RyaWdnZXJKUXVlcnlFdmVudDpmdW5jdGlvbihhLGIpe3ZhciBjPXt0eXBlOmEsdmFsdWU6Yn07dGhpcy4kZWxlbWVudC50cmlnZ2VyKGMpLHRoaXMuJHNsaWRlckVsZW0udHJpZ2dlcihjKX0sX3VuYmluZEpRdWVyeUV2ZW50SGFuZGxlcnM6ZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50Lm9mZigpLHRoaXMuJHNsaWRlckVsZW0ub2ZmKCl9LF9zZXRUZXh0OmZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuaW5uZXJUZXh0P2EuaW5uZXJUZXh0PWI6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEudGV4dENvbnRlbnQmJihhLnRleHRDb250ZW50PWIpfSxfcmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5zcGxpdChcIiBcIiksZD1hLmNsYXNzTmFtZSxlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV0sZz1uZXcgUmVnRXhwKFwiKD86XFxcXHN8XilcIitmK1wiKD86XFxcXHN8JClcIik7ZD1kLnJlcGxhY2UoZyxcIiBcIil9YS5jbGFzc05hbWU9ZC50cmltKCl9LF9hZGRDbGFzczpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iLnNwbGl0KFwiIFwiKSxkPWEuY2xhc3NOYW1lLGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9Y1tlXSxnPW5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiK2YrXCIoPzpcXFxcc3wkKVwiKSxoPWcudGVzdChkKTtofHwoZCs9XCIgXCIrZil9YS5jbGFzc05hbWU9ZC50cmltKCl9LF9vZmZzZXRMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnR9LF9vZmZzZXRUb3A6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEub2Zmc2V0VG9wOyhhPWEub2Zmc2V0UGFyZW50KSYmIWlzTmFOKGEub2Zmc2V0VG9wKTspYis9YS5vZmZzZXRUb3A7cmV0dXJuIGJ9LF9vZmZzZXQ6ZnVuY3Rpb24oYSl7cmV0dXJue2xlZnQ6dGhpcy5fb2Zmc2V0TGVmdChhKSx0b3A6dGhpcy5fb2Zmc2V0VG9wKGEpfX0sX2NzczpmdW5jdGlvbihiLGMsZCl7aWYoYSlhLnN0eWxlKGIsYyxkKTtlbHNle3ZhciBlPWMucmVwbGFjZSgvXi1tcy0vLFwibXMtXCIpLnJlcGxhY2UoLy0oW1xcZGEtel0pL2dpLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKX0pO2Iuc3R5bGVbZV09ZH19LF90b1ZhbHVlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm9wdGlvbnMuc2NhbGUudG9WYWx1ZS5hcHBseSh0aGlzLFthXSl9LF90b1BlcmNlbnRhZ2U6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMub3B0aW9ucy5zY2FsZS50b1BlcmNlbnRhZ2UuYXBwbHkodGhpcyxbYV0pfSxfc2V0VG9vbHRpcFBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9W3RoaXMudG9vbHRpcCx0aGlzLnRvb2x0aXBfbWluLHRoaXMudG9vbHRpcF9tYXhdO2lmKFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbil7dmFyIGI9dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb258fFwicmlnaHRcIixjPVwibGVmdFwiPT09Yj9cInJpZ2h0XCI6XCJsZWZ0XCI7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RoaXMuX2FkZENsYXNzKGEsYiksYS5zdHlsZVtjXT1cIjEwMCVcIn0uYmluZCh0aGlzKSl9ZWxzZSBhLmZvckVhY2goXCJib3R0b21cIj09PXRoaXMub3B0aW9ucy50b29sdGlwX3Bvc2l0aW9uP2Z1bmN0aW9uKGEpe3RoaXMuX2FkZENsYXNzKGEsXCJib3R0b21cIiksYS5zdHlsZS50b3A9XCIyMnB4XCJ9LmJpbmQodGhpcyk6ZnVuY3Rpb24oYSl7dGhpcy5fYWRkQ2xhc3MoYSxcInRvcFwiKSxhLnN0eWxlLnRvcD0tdGhpcy50b29sdGlwLm91dGVySGVpZ2h0LTE0K1wicHhcIn0uYmluZCh0aGlzKSl9fSxhKXt2YXIgZj1hLmZuLnNsaWRlcj9cImJvb3RzdHJhcFNsaWRlclwiOlwic2xpZGVyXCI7YS5icmlkZ2V0KGYsYil9fShhKSxifSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHRoaXNbXCIkXCJdOyB9KCkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCIkXCJcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUgdW5sZXNzIGFtZE1vZHVsZUlkIGlzIHNldFxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChyb290WydTaWduYXR1cmVQYWQnXSA9IGZhY3RvcnkoKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ1NpZ25hdHVyZVBhZCddID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLyohXG4gKiBTaWduYXR1cmUgUGFkIHYxLjQuMFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9zaWduYXR1cmVfcGFkXG4gKlxuICogQ29weXJpZ2h0IDIwMTUgU3p5bW9uIE5vd2FrXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqXG4gKiBUaGUgbWFpbiBpZGVhIGFuZCBzb21lIHBhcnRzIG9mIHRoZSBjb2RlIChlLmcuIGRyYXdpbmcgdmFyaWFibGUgd2lkdGggQsOpemllciBjdXJ2ZSkgYXJlIHRha2VuIGZyb206XG4gKiBodHRwOi8vY29ybmVyLnNxdWFyZXVwLmNvbS8yMDEyLzA3L3Ntb290aGVyLXNpZ25hdHVyZXMuaHRtbFxuICpcbiAqIEltcGxlbWVudGF0aW9uIG9mIGludGVycG9sYXRpb24gdXNpbmcgY3ViaWMgQsOpemllciBjdXJ2ZXMgaXMgdGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly9iZW5rbm93c2NvZGUud29yZHByZXNzLmNvbS8yMDEyLzA5LzE0L3BhdGgtaW50ZXJwb2xhdGlvbi11c2luZy1jdWJpYy1iZXppZXItYW5kLWNvbnRyb2wtcG9pbnQtZXN0aW1hdGlvbi1pbi1qYXZhc2NyaXB0XG4gKlxuICogQWxnb3JpdGhtIGZvciBhcHByb3hpbWF0ZWQgbGVuZ3RoIG9mIGEgQsOpemllciBjdXJ2ZSBpcyB0YWtlbiBmcm9tOlxuICogaHR0cDovL3d3dy5sZW1vZGEubmV0L21hdGhzL2Jlemllci1sZW5ndGgvaW5kZXguaHRtbFxuICpcbiAqL1xudmFyIFNpZ25hdHVyZVBhZCA9IChmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBTaWduYXR1cmVQYWQgPSBmdW5jdGlvbiAoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgPSBvcHRzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0IHx8IDAuNztcbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IG9wdHMubWluV2lkdGggfHwgMC41O1xuICAgICAgICB0aGlzLm1heFdpZHRoID0gb3B0cy5tYXhXaWR0aCB8fCAyLjU7XG4gICAgICAgIHRoaXMuZG90U2l6ZSA9IG9wdHMuZG90U2l6ZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubWluV2lkdGggKyB0aGlzLm1heFdpZHRoKSAvIDI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGVuQ29sb3IgPSBvcHRzLnBlbkNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvciB8fCBcInJnYmEoMCwwLDAsMClcIjtcbiAgICAgICAgdGhpcy5vbkVuZCA9IG9wdHMub25FbmQ7XG4gICAgICAgIHRoaXMub25CZWdpbiA9IG9wdHMub25CZWdpbjtcblxuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAvLyB3ZSBuZWVkIGFkZCB0aGVzZSBpbmxpbmUgc28gdGhleSBhcmUgYXZhaWxhYmxlIHRvIHVuYmluZCB3aGlsZSBzdGlsbCBoYXZpbmdcbiAgICAgICAgLy8gIGFjY2VzcyB0byAnc2VsZicgd2UgY291bGQgdXNlIF8uYmluZCBidXQgaXQncyBub3Qgd29ydGggYWRkaW5nIGEgZGVwZW5kZW5jeVxuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX21vdXNlQnV0dG9uRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5fc3Ryb2tlQmVnaW4oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21vdXNlQnV0dG9uRG93bikge1xuICAgICAgICAgICAgICAgIHNlbGYuX3N0cm9rZVVwZGF0ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAxICYmIHNlbGYuX21vdXNlQnV0dG9uRG93bikge1xuICAgICAgICAgICAgICAgIHNlbGYuX21vdXNlQnV0dG9uRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICBzZWxmLl9zdHJva2VCZWdpbih0b3VjaCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZy5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgc2VsZi5fc3Ryb2tlVXBkYXRlKHRvdWNoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVUb3VjaEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHdhc0NhbnZhc1RvdWNoZWQgPSBldmVudC50YXJnZXQgPT09IHNlbGYuX2NhbnZhcztcbiAgICAgICAgICAgIGlmICh3YXNDYW52YXNUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fc3Ryb2tlRW5kKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50cygpO1xuICAgICAgICB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50cygpO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgICAgICAgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS50b0RhdGFVUkwgPSBmdW5jdGlvbiAoaW1hZ2VUeXBlLCBxdWFsaXR5KSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMLmFwcGx5KGNhbnZhcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5mcm9tRGF0YVVSTCA9IGZ1bmN0aW9uIChkYXRhVXJsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCksXG4gICAgICAgICAgICByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2NhbnZhcy53aWR0aCAvIHJhdGlvLFxuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fY2FudmFzLmhlaWdodCAvIHJhdGlvO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIGltYWdlLnNyYyA9IGRhdGFVcmw7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuX2N0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pc0VtcHR5ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZVVwZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLl9jcmVhdGVQb2ludChldmVudCk7XG4gICAgICAgIHRoaXMuX2FkZFBvaW50KHBvaW50KTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlQmVnaW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlVXBkYXRlKGV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uQmVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25CZWdpbihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlRHJhdyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgICAgICAgZG90U2l6ZSA9IHR5cGVvZih0aGlzLmRvdFNpemUpID09PSAnZnVuY3Rpb24nID8gdGhpcy5kb3RTaXplKCkgOiB0aGlzLmRvdFNpemU7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9kcmF3UG9pbnQocG9pbnQueCwgcG9pbnQueSwgZG90U2l6ZSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjYW5EcmF3Q3VydmUgPSB0aGlzLnBvaW50cy5sZW5ndGggPiAyLFxuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLnBvaW50c1swXTtcblxuICAgICAgICBpZiAoIWNhbkRyYXdDdXJ2ZSAmJiBwb2ludCkge1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRHJhdyhwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uRW5kKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9oYW5kbGVNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tb3VzZUJ1dHRvbkRvd24gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9oYW5kbGVNb3VzZVVwKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5faGFuZGxlVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBQYXNzIHRvdWNoIGV2ZW50cyB0byBjYW52YXMgZWxlbWVudCBvbiBtb2JpbGUgSUUuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2hhbmRsZVRvdWNoRW5kKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2hhbmRsZVRvdWNoRW5kKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNFbXB0eTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuX2xhc3RWZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RXaWR0aCA9ICh0aGlzLm1pbldpZHRoICsgdGhpcy5tYXhXaWR0aCkgLyAyO1xuICAgICAgICB0aGlzLl9pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMucGVuQ29sb3I7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2NyZWF0ZVBvaW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgICAgIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9hZGRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBjMiwgYzMsXG4gICAgICAgICAgICBjdXJ2ZSwgdG1wO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcblxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIC8vIFRvIHJlZHVjZSB0aGUgaW5pdGlhbCBsYWcgbWFrZSBpdCB3b3JrIHdpdGggMyBwb2ludHNcbiAgICAgICAgICAgIC8vIGJ5IGNvcHlpbmcgdGhlIGZpcnN0IHBvaW50IHRvIHRoZSBiZWdpbm5pbmcuXG4gICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMykgcG9pbnRzLnVuc2hpZnQocG9pbnRzWzBdKTtcblxuICAgICAgICAgICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0pO1xuICAgICAgICAgICAgYzIgPSB0bXAuYzI7XG4gICAgICAgICAgICB0bXAgPSB0aGlzLl9jYWxjdWxhdGVDdXJ2ZUNvbnRyb2xQb2ludHMocG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICBjMyA9IHRtcC5jMTtcbiAgICAgICAgICAgIGN1cnZlID0gbmV3IEJlemllcihwb2ludHNbMV0sIGMyLCBjMywgcG9pbnRzWzJdKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEN1cnZlKGN1cnZlKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGxpc3QsXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHdlIGFsd2F5cyBoYXZlIG5vIG1vcmUgdGhhbiA0IHBvaW50cyBpbiBwb2ludHMgYXJyYXkuXG4gICAgICAgICAgICBwb2ludHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJ2ZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoczEsIHMyLCBzMykge1xuICAgICAgICB2YXIgZHgxID0gczEueCAtIHMyLngsIGR5MSA9IHMxLnkgLSBzMi55LFxuICAgICAgICAgICAgZHgyID0gczIueCAtIHMzLngsIGR5MiA9IHMyLnkgLSBzMy55LFxuXG4gICAgICAgICAgICBtMSA9IHt4OiAoczEueCArIHMyLngpIC8gMi4wLCB5OiAoczEueSArIHMyLnkpIC8gMi4wfSxcbiAgICAgICAgICAgIG0yID0ge3g6IChzMi54ICsgczMueCkgLyAyLjAsIHk6IChzMi55ICsgczMueSkgLyAyLjB9LFxuXG4gICAgICAgICAgICBsMSA9IE1hdGguc3FydChkeDEqZHgxICsgZHkxKmR5MSksXG4gICAgICAgICAgICBsMiA9IE1hdGguc3FydChkeDIqZHgyICsgZHkyKmR5MiksXG5cbiAgICAgICAgICAgIGR4bSA9IChtMS54IC0gbTIueCksXG4gICAgICAgICAgICBkeW0gPSAobTEueSAtIG0yLnkpLFxuXG4gICAgICAgICAgICBrID0gbDIgLyAobDEgKyBsMiksXG4gICAgICAgICAgICBjbSA9IHt4OiBtMi54ICsgZHhtKmssIHk6IG0yLnkgKyBkeW0qa30sXG5cbiAgICAgICAgICAgIHR4ID0gczIueCAtIGNtLngsXG4gICAgICAgICAgICB0eSA9IHMyLnkgLSBjbS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMTogbmV3IFBvaW50KG0xLnggKyB0eCwgbTEueSArIHR5KSxcbiAgICAgICAgICAgIGMyOiBuZXcgUG9pbnQobTIueCArIHR4LCBtMi55ICsgdHkpXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2FkZEN1cnZlID0gZnVuY3Rpb24gKGN1cnZlKSB7XG4gICAgICAgIHZhciBzdGFydFBvaW50ID0gY3VydmUuc3RhcnRQb2ludCxcbiAgICAgICAgICAgIGVuZFBvaW50ID0gY3VydmUuZW5kUG9pbnQsXG4gICAgICAgICAgICB2ZWxvY2l0eSwgbmV3V2lkdGg7XG5cbiAgICAgICAgdmVsb2NpdHkgPSBlbmRQb2ludC52ZWxvY2l0eUZyb20oc3RhcnRQb2ludCk7XG4gICAgICAgIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCAqIHZlbG9jaXR5XG4gICAgICAgICAgICArICgxIC0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCkgKiB0aGlzLl9sYXN0VmVsb2NpdHk7XG5cbiAgICAgICAgbmV3V2lkdGggPSB0aGlzLl9zdHJva2VXaWR0aCh2ZWxvY2l0eSk7XG4gICAgICAgIHRoaXMuX2RyYXdDdXJ2ZShjdXJ2ZSwgdGhpcy5fbGFzdFdpZHRoLCBuZXdXaWR0aCk7XG5cbiAgICAgICAgdGhpcy5fbGFzdFZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICAgIHRoaXMuX2xhc3RXaWR0aCA9IG5ld1dpZHRoO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgc2l6ZSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgc2l6ZSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3Q3VydmUgPSBmdW5jdGlvbiAoY3VydmUsIHN0YXJ0V2lkdGgsIGVuZFdpZHRoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsXG4gICAgICAgICAgICB3aWR0aERlbHRhID0gZW5kV2lkdGggLSBzdGFydFdpZHRoLFxuICAgICAgICAgICAgZHJhd1N0ZXBzLCB3aWR0aCwgaSwgdCwgdHQsIHR0dCwgdSwgdXUsIHV1dSwgeCwgeTtcblxuICAgICAgICBkcmF3U3RlcHMgPSBNYXRoLmZsb29yKGN1cnZlLmxlbmd0aCgpKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZHJhd1N0ZXBzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgQmV6aWVyICh4LCB5KSBjb29yZGluYXRlIGZvciB0aGlzIHN0ZXAuXG4gICAgICAgICAgICB0ID0gaSAvIGRyYXdTdGVwcztcbiAgICAgICAgICAgIHR0ID0gdCAqIHQ7XG4gICAgICAgICAgICB0dHQgPSB0dCAqIHQ7XG4gICAgICAgICAgICB1ID0gMSAtIHQ7XG4gICAgICAgICAgICB1dSA9IHUgKiB1O1xuICAgICAgICAgICAgdXV1ID0gdXUgKiB1O1xuXG4gICAgICAgICAgICB4ID0gdXV1ICogY3VydmUuc3RhcnRQb2ludC54O1xuICAgICAgICAgICAgeCArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueDtcbiAgICAgICAgICAgIHggKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLng7XG4gICAgICAgICAgICB4ICs9IHR0dCAqIGN1cnZlLmVuZFBvaW50Lng7XG5cbiAgICAgICAgICAgIHkgPSB1dXUgKiBjdXJ2ZS5zdGFydFBvaW50Lnk7XG4gICAgICAgICAgICB5ICs9IDMgKiB1dSAqIHQgKiBjdXJ2ZS5jb250cm9sMS55O1xuICAgICAgICAgICAgeSArPSAzICogdSAqIHR0ICogY3VydmUuY29udHJvbDIueTtcbiAgICAgICAgICAgIHkgKz0gdHR0ICogY3VydmUuZW5kUG9pbnQueTtcblxuICAgICAgICAgICAgd2lkdGggPSBzdGFydFdpZHRoICsgdHR0ICogd2lkdGhEZWx0YTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQb2ludCh4LCB5LCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VXaWR0aCA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5tYXhXaWR0aCAvICh2ZWxvY2l0eSArIDEpLCB0aGlzLm1pbldpZHRoKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgdGltZSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICBQb2ludC5wcm90b3R5cGUudmVsb2NpdHlGcm9tID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAodGhpcy50aW1lICE9PSBzdGFydC50aW1lKSA/IHRoaXMuZGlzdGFuY2VUbyhzdGFydCkgLyAodGhpcy50aW1lIC0gc3RhcnQudGltZSkgOiAxO1xuICAgIH07XG5cbiAgICBQb2ludC5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHN0YXJ0LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gc3RhcnQueSwgMikpO1xuICAgIH07XG5cbiAgICB2YXIgQmV6aWVyID0gZnVuY3Rpb24gKHN0YXJ0UG9pbnQsIGNvbnRyb2wxLCBjb250cm9sMiwgZW5kUG9pbnQpIHtcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ID0gc3RhcnRQb2ludDtcbiAgICAgICAgdGhpcy5jb250cm9sMSA9IGNvbnRyb2wxO1xuICAgICAgICB0aGlzLmNvbnRyb2wyID0gY29udHJvbDI7XG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBlbmRQb2ludDtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhcHByb3hpbWF0ZWQgbGVuZ3RoLlxuICAgIEJlemllci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcHMgPSAxMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICBpLCB0LCBjeCwgY3ksIHB4LCBweSwgeGRpZmYsIHlkaWZmO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gc3RlcHM7IGkrKykge1xuICAgICAgICAgICAgdCA9IGkgLyBzdGVwcztcbiAgICAgICAgICAgIGN4ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LngsIHRoaXMuY29udHJvbDEueCwgdGhpcy5jb250cm9sMi54LCB0aGlzLmVuZFBvaW50LngpO1xuICAgICAgICAgICAgY3kgPSB0aGlzLl9wb2ludCh0LCB0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5jb250cm9sMS55LCB0aGlzLmNvbnRyb2wyLnksIHRoaXMuZW5kUG9pbnQueSk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB4ZGlmZiA9IGN4IC0gcHg7XG4gICAgICAgICAgICAgICAgeWRpZmYgPSBjeSAtIHB5O1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoeGRpZmYgKiB4ZGlmZiArIHlkaWZmICogeWRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHggPSBjeDtcbiAgICAgICAgICAgIHB5ID0gY3k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9O1xuXG4gICAgQmV6aWVyLnByb3RvdHlwZS5fcG9pbnQgPSBmdW5jdGlvbiAodCwgc3RhcnQsIGMxLCBjMiwgZW5kKSB7XG4gICAgICAgIHJldHVybiAgICAgICAgICBzdGFydCAqICgxLjAgLSB0KSAqICgxLjAgLSB0KSAgKiAoMS4wIC0gdClcbiAgICAgICAgICAgICAgICsgMy4wICogIGMxICAgICogKDEuMCAtIHQpICogKDEuMCAtIHQpICAqIHRcbiAgICAgICAgICAgICAgICsgMy4wICogIGMyICAgICogKDEuMCAtIHQpICogdCAgICAgICAgICAqIHRcbiAgICAgICAgICAgICAgICsgICAgICAgIGVuZCAgICogdCAgICAgICAgICogdCAgICAgICAgICAqIHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBTaWduYXR1cmVQYWQ7XG59KShkb2N1bWVudCk7XG5cbnJldHVybiBTaWduYXR1cmVQYWQ7XG5cbn0pKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpZ25hdHVyZV9wYWQvc2lnbmF0dXJlX3BhZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIGFsaWFzID0gcmVxdWlyZSgnLi9hbGlhcy9hbGlhcycpO1xyXG5leHBvcnRzLmFsaWFzID0gYWxpYXM7XHJcbnZhciBhdXRvc2F2ZSA9IHJlcXVpcmUoJy4vYXV0b3NhdmUvYXV0b3NhdmUnKTtcclxuZXhwb3J0cy5hdXRvc2F2ZSA9IGF1dG9zYXZlO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuYmVoYXZpb3JzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICBhbGlhcy5tb2R1bGVOYW1lLFxyXG4gICAgYXV0b3NhdmUubW9kdWxlTmFtZSxcclxuXSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlaGF2aW9ycy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9iZWhhdmlvcnMvYmVoYXZpb3JzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuYmVoYXZpb3JzLmFsaWFzJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQWxpYXMnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0FsaWFzQ29udHJvbGxlcic7XHJcbnZhciBBbGlhc0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWxpYXNDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgIHZhciBleHByZXNzaW9uO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gJGF0dHJzLnJsQWxpYXMuc3BsaXQoJyBhcyAnKTtcclxuICAgICAgICAgICAgcmV0dXJuICRwYXJzZShleHByZXNzaW9uWzBdKSgkc2NvcGUpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGlhcyA9ICRpbnRlcnBvbGF0ZShleHByZXNzaW9uWzFdKSgkc2NvcGUpO1xyXG4gICAgICAgICAgICBpZiAoYWxpYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlW2FsaWFzXSA9IGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEFsaWFzQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGF0dHJzJywgJyRwYXJzZScsICckaW50ZXJwb2xhdGUnXTtcclxuICAgIHJldHVybiBBbGlhc0NvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQWxpYXNDb250cm9sbGVyID0gQWxpYXNDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBhbGlhcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmFsaWFzID0gYWxpYXM7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYWxpYXMpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBBbGlhc0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGlhcy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2JlaGF2aW9ycy9hbGlhcy9hbGlhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgX19vYmplY3RVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIGF1dG9zYXZlX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2F1dG9zYXZlL2F1dG9zYXZlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmJlaGF2aW9ycy5hdXRvc2F2ZSc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEF1dG9zYXZlJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdBdXRvc2F2ZUNvbnRyb2xsZXInO1xyXG52YXIgQXV0b3NhdmVDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlQ29udHJvbGxlcigkc2NvcGUsICRhdHRycywgJHBhcnNlLCAkZWxlbWVudCwgJHRpbWVvdXQsIGF1dG9zYXZlRmFjdG9yeSwgcGFyZW50Q2hpbGRCZWhhdmlvciwgb2JqZWN0VXRpbGl0eSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuJHRpbWVvdXQgPSAkdGltZW91dDtcclxuICAgICAgICB2YXIgY29udGVudEZvcm0gPSAkZWxlbWVudC5jb250cm9sbGVyKCdmb3JtJyk7XHJcbiAgICAgICAgdmFyIGhhc1ZhbGlkYXRvciA9IG9iamVjdFV0aWxpdHkuaXNOdWxsT3JXaGl0ZXNwYWNlKCRhdHRycy52YWxpZGF0ZSkgPT09IGZhbHNlO1xyXG4gICAgICAgIHZhciB2YWxpZGF0ZUV4cHJlc3Npb24gPSAkcGFyc2UoJGF0dHJzLnZhbGlkYXRlKTtcclxuICAgICAgICB2YXIgdmFsaWRhdGU7XHJcbiAgICAgICAgaWYgKGhhc1ZhbGlkYXRvcikge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24oJHNjb3BlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNhdmVFeHByZXNzaW9uID0gJHBhcnNlKCRhdHRycy5zYXZlKTtcclxuICAgICAgICB2YXIgc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNhdmVFeHByZXNzaW9uKCRzY29wZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZGVib3VuY2UgPSAkcGFyc2UoJGF0dHJzLmRlYm91bmNlRHVyYXRpb24pKCRzY29wZSk7XHJcbiAgICAgICAgdmFyIHVuYmluZCA9ICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMua2V5dXBMaXN0ZW5lcjsgfSwgZnVuY3Rpb24gKGtleXVwTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgaWYgKGtleXVwTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmF1dG9zYXZlID0gYXV0b3NhdmVGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgICAgICAgICBzYXZlOiBzYXZlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Rm9ybTogY29udGVudEZvcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2VEdXJhdGlvbjogZGVib3VuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnM6ICRhdHRycy50cmlnZ2VycyxcclxuICAgICAgICAgICAgICAgICAgICBzZXRDaGFuZ2VMaXN0ZW5lcjoga2V5dXBMaXN0ZW5lcixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9zYXZlOiBfdGhpcy5hdXRvc2F2ZS5hdXRvc2F2ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBhdXRvc2F2ZSBiZWhhdmlvciBhbmQgYXNzaWduIHRoZSB2YWx1ZSBiYWNrIHRvIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZExpbmsgPSAkcGFyc2UoJGF0dHJzLnJsQXV0b3NhdmUpKCRzY29wZSk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDaGlsZEJlaGF2aW9yLnJlZ2lzdGVyQ2hpbGRCZWhhdmlvcihjaGlsZExpbmssIGJlaGF2aW9yKTtcclxuICAgICAgICAgICAgICAgIHVuYmluZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBBdXRvc2F2ZUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJyxcclxuICAgICAgICAnJGF0dHJzJyxcclxuICAgICAgICAnJHBhcnNlJyxcclxuICAgICAgICAnJGVsZW1lbnQnLFxyXG4gICAgICAgICckdGltZW91dCcsXHJcbiAgICAgICAgYXV0b3NhdmVfc2VydmljZV8xLmZhY3RvcnlOYW1lLFxyXG4gICAgICAgIF9fcGFyZW50Q2hpbGQuc2VydmljZU5hbWUsXHJcbiAgICAgICAgX19vYmplY3RVdGlsaXR5LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBBdXRvc2F2ZUNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXV0b3NhdmVDb250cm9sbGVyID0gQXV0b3NhdmVDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBhdXRvc2F2ZSgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgICAgICByZXF1aXJlOiBbJ3JsQXV0b3NhdmUnLCAnP25nRm9ybSddLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcnMpIHtcclxuICAgICAgICAgICAgdmFyIGF1dG9zYXZlQ29udHJvbGxlciA9IGNvbnRyb2xsZXJzWzBdO1xyXG4gICAgICAgICAgICBhdXRvc2F2ZUNvbnRyb2xsZXIua2V5dXBMaXN0ZW5lciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5vbigna2V5dXAnLCBmdW5jdGlvbiAoKSB7IHNjb3BlLiRhcHBseShjYWxsYmFjayk7IH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZigna2V5dXAnKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5hdXRvc2F2ZSA9IGF1dG9zYXZlO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIGF1dG9zYXZlX3NlcnZpY2VfMS5tb2R1bGVOYW1lLFxyXG4gICAgX19vYmplY3RVdGlsaXR5Lm1vZHVsZU5hbWUsXHJcbiAgICBfX3BhcmVudENoaWxkLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYXV0b3NhdmUpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBBdXRvc2F2ZUNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2JlaGF2aW9ycy9hdXRvc2F2ZS9hdXRvc2F2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgYXV0b3NhdmVBY3Rpb25fc2VydmljZV8xID0gcmVxdWlyZSgnLi4vYXV0b3NhdmVBY3Rpb24vYXV0b3NhdmVBY3Rpb24uc2VydmljZScpO1xyXG52YXIgdHJpZ2dlcnMgPSByZXF1aXJlKCcuL3RyaWdnZXJzL3RyaWdnZXJzLnNlcnZpY2UnKTtcclxuZXhwb3J0cy50cmlnZ2VycyA9IHRyaWdnZXJzO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudXRpbGl0aWVzLnNlcnZpY2VzLmF1dG9zYXZlJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdhdXRvc2F2ZUZhY3RvcnknO1xyXG52YXIgQXV0b3NhdmVTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlU2VydmljZShhdXRvc2F2ZVNlcnZpY2UsIG9wdGlvbnMsIHRyaWdnZXJTZXJ2aWNlRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZVNlcnZpY2UgPSBhdXRvc2F2ZVNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGRhdGFbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRlbnRGb3JtLiRwcmlzdGluZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmhhc1ZhbGlkYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdmFsaWQgPSBfdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IF90aGlzLnNhdmUuYXBwbHkoX3RoaXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXV0b3NhdmVTZXJ2aWNlLnRyaWdnZXIocHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRlbnRGb3JtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRlbnRGb3JtLiRzZXRQcmlzdGluZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFzVmFsaWRhdG9yID0gb3B0aW9ucy52YWxpZGF0ZSAhPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udGVudEZvcm0gPSBvcHRpb25zLmNvbnRlbnRGb3JtIHx8IHRoaXMubnVsbEZvcm0oKTtcclxuICAgICAgICB0aGlzLnNhdmUgPSBvcHRpb25zLnNhdmU7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IG9wdGlvbnMudmFsaWRhdGU7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VydmljZSA9IHRyaWdnZXJTZXJ2aWNlRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJlVHJpZ2dlcnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VydmljZS5zZXRUcmlnZ2VycyhvcHRpb25zLnRyaWdnZXJzLCB0aGlzLmF1dG9zYXZlKTtcclxuICAgIH1cclxuICAgIEF1dG9zYXZlU2VydmljZS5wcm90b3R5cGUuY29uZmlndXJlVHJpZ2dlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlclNlcnZpY2UudHJpZ2dlcnMub25DaGFuZ2UuY29uZmlndXJlKHtcclxuICAgICAgICAgICAgZm9ybTogb3B0aW9ucy5jb250ZW50Rm9ybSxcclxuICAgICAgICAgICAgc2V0Q2hhbmdlTGlzdGVuZXI6IG9wdGlvbnMuc2V0Q2hhbmdlTGlzdGVuZXIsXHJcbiAgICAgICAgICAgIGRlYm91bmNlRHVyYXRpb246IG9wdGlvbnMuZGVib3VuY2VEdXJhdGlvbixcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBdXRvc2F2ZVNlcnZpY2UucHJvdG90eXBlLm51bGxGb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICRwcmlzdGluZTogZmFsc2UsXHJcbiAgICAgICAgICAgICRkaXJ0eTogdHJ1ZSxcclxuICAgICAgICAgICAgJHNldFByaXN0aW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXV0b3NhdmVTZXJ2aWNlO1xyXG59KSgpO1xyXG5hdXRvc2F2ZVNlcnZpY2VGYWN0b3J5LiRpbmplY3QgPSBbYXV0b3NhdmVBY3Rpb25fc2VydmljZV8xLnNlcnZpY2VOYW1lLCB0cmlnZ2Vycy5mYWN0b3J5TmFtZV07XHJcbmZ1bmN0aW9uIGF1dG9zYXZlU2VydmljZUZhY3RvcnkoYXV0b3NhdmVTZXJ2aWNlLCB0cmlnZ2VyU2VydmljZUZhY3RvcnkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXV0b3NhdmVTZXJ2aWNlKGF1dG9zYXZlU2VydmljZSwgb3B0aW9ucywgdHJpZ2dlclNlcnZpY2VGYWN0b3J5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW2F1dG9zYXZlQWN0aW9uX3NlcnZpY2VfMS5tb2R1bGVOYW1lLCB0cmlnZ2Vycy5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIGF1dG9zYXZlU2VydmljZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZS5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmUvYXV0b3NhdmUuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIl9cIl07IH0oKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIl9cIlxuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBuZyA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnV0aWxpdGllcy5zZXJ2aWNlcy5hdXRvc2F2ZUFjdGlvbic7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnYXV0b3NhdmVBY3Rpb24nO1xyXG52YXIgQXV0b3NhdmVBY3Rpb25TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlQWN0aW9uU2VydmljZSgkdGltZW91dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVNZXNzYWdlRHVyYXRpb24gPSAxMDAwO1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVTdWNjZXNzZnVsID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVBdXRvc2F2ZShkYXRhLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVGYWlsZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZUF1dG9zYXZlKGRhdGEsIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZUF1dG9zYXZlID0gZnVuY3Rpb24gKGRhdGEsIHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3NhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc3VjY2Vzc2Z1bCA9IHN1Y2Nlc3M7XHJcbiAgICAgICAgICAgIF90aGlzLiR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCBfdGhpcy5jb21wbGV0ZU1lc3NhZ2VEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXV0b3NhdmVBY3Rpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJzYXZpbmdcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2aW5nO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1dG9zYXZlQWN0aW9uU2VydmljZS5wcm90b3R5cGUsIFwiY29tcGxldGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXV0b3NhdmVBY3Rpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJzdWNjZXNzZnVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1Y2Nlc3NmdWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBdXRvc2F2ZUFjdGlvblNlcnZpY2UucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gICAgICAgIHRoaXMuX3NhdmluZyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbih0aGlzLmF1dG9zYXZlU3VjY2Vzc2Z1bClcclxuICAgICAgICAgICAgLmNhdGNoKHRoaXMuYXV0b3NhdmVGYWlsZWQpO1xyXG4gICAgfTtcclxuICAgIEF1dG9zYXZlQWN0aW9uU2VydmljZS4kaW5qZWN0ID0gWyckdGltZW91dCddO1xyXG4gICAgcmV0dXJuIEF1dG9zYXZlQWN0aW9uU2VydmljZTtcclxufSkoKTtcclxubmcubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBBdXRvc2F2ZUFjdGlvblNlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZUFjdGlvbi5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmVBY3Rpb24vYXV0b3NhdmVBY3Rpb24uc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIG9uQ2hhbmdlVHJpZ2dlcl8xID0gcmVxdWlyZSgnLi9vbkNoYW5nZVRyaWdnZXInKTtcclxudmFyIHRyaWdnZXJfMSA9IHJlcXVpcmUoJy4vdHJpZ2dlcicpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL29uQ2hhbmdlVHJpZ2dlcicpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi90cmlnZ2VyJykpO1xyXG5leHBvcnRzLmRlZmF1bHRUcmlnZ2VycyA9ICdvbkNoYW5nZSc7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5hdXRvc2F2ZS50cmlnZ2Vycyc7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnYXV0b3NhdmVUcmlnZ2Vycyc7XHJcbnZhciBUcmlnZ2VyU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmlnZ2VyU2VydmljZSgkcm9vdFNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcnMgPSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBuZXcgb25DaGFuZ2VUcmlnZ2VyXzEuT25DaGFuZ2VUcmlnZ2VyKCRyb290U2NvcGUsICR0aW1lb3V0KSxcclxuICAgICAgICAgICAgbm9uZTogbmV3IHRyaWdnZXJfMS5UcmlnZ2VyKCdub25lJyksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFRyaWdnZXJTZXJ2aWNlLnByb3RvdHlwZS5zZXRUcmlnZ2VycyA9IGZ1bmN0aW9uICh0cmlnZ2VyU3RyaW5nLCBhdXRvc2F2ZSkge1xyXG4gICAgICAgIGlmICh0cmlnZ2VyU3RyaW5nID09IG51bGwpIHtcclxuICAgICAgICAgICAgdHJpZ2dlclN0cmluZyA9IGV4cG9ydHMuZGVmYXVsdFRyaWdnZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfLmVhY2godGhpcy50cmlnZ2VycywgZnVuY3Rpb24gKHRyaWdnZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRyaWdnZXIuaGFzTWF0Y2godHJpZ2dlclN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIuc2V0VHJpZ2dlcihhdXRvc2F2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJpZ2dlclNlcnZpY2U7XHJcbn0pKCk7XHJcbnRyaWdnZXJTZXJ2aWNlRmFjdG9yeS4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJywgJyR0aW1lb3V0J107XHJcbmZ1bmN0aW9uIHRyaWdnZXJTZXJ2aWNlRmFjdG9yeSgkcm9vdFNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyaWdnZXJTZXJ2aWNlKCRyb290U2NvcGUsICR0aW1lb3V0KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgdHJpZ2dlclNlcnZpY2VGYWN0b3J5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpZ2dlcnMuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL3RyaWdnZXJzL3RyaWdnZXJzLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHJpZ2dlcl8xID0gcmVxdWlyZSgnLi90cmlnZ2VyJyk7XHJcbnZhciBPbkNoYW5nZVRyaWdnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9uQ2hhbmdlVHJpZ2dlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9uQ2hhbmdlVHJpZ2dlcigkcm9vdFNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdvbkNoYW5nZScpO1xyXG4gICAgICAgIHRoaXMuJHJvb3RTY29wZSA9ICRyb290U2NvcGU7XHJcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xyXG4gICAgICAgIHRoaXMuZGVib3VuY2VEdXJhdGlvbiA9IDEwMDA7XHJcbiAgICB9XHJcbiAgICBPbkNoYW5nZVRyaWdnZXIucHJvdG90eXBlLnNldFRyaWdnZXIgPSBmdW5jdGlvbiAoYXV0b3NhdmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMuc2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0Q2hhbmdlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXR0aW5ncy5mb3JtICE9IG51bGxcclxuICAgICAgICAgICAgICAgID8gX3RoaXMuc2V0dGluZ3MuZm9ybS4kZGlydHlcclxuICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VGltZXIoYXV0b3NhdmUpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJDaGFuZ2VMaXN0ZW5lciA9IF90aGlzLnNldENoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kdGltZW91dC5jYW5jZWwoX3RoaXMudGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFRpbWVyKGF1dG9zYXZlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgT25DaGFuZ2VUcmlnZ2VyLnByb3RvdHlwZS5zZXRUaW1lciA9IGZ1bmN0aW9uIChhdXRvc2F2ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHRoaXMuJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jbGVhckNoYW5nZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIGF1dG9zYXZlKCk7XHJcbiAgICAgICAgfSwgdGhpcy5kZWJvdW5jZUR1cmF0aW9uKTtcclxuICAgIH07XHJcbiAgICBPbkNoYW5nZVRyaWdnZXIucHJvdG90eXBlLmluaXRDaGFuZ2VMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRDaGFuZ2VMaXN0ZW5lciA9IHRoaXMuc2V0dGluZ3Muc2V0Q2hhbmdlTGlzdGVuZXIgfHwgdGhpcy5udWxsU2V0TGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5jbGVhckNoYW5nZUxpc3RlbmVyID0gdGhpcy5udWxsQ2xlYXJMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICBPbkNoYW5nZVRyaWdnZXIucHJvdG90eXBlLm51bGxTZXRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gY2hhbmdlIGxpc3RlbmVyIGF2YWlsYWJsZScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bGxDbGVhckxpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIE9uQ2hhbmdlVHJpZ2dlci5wcm90b3R5cGUubnVsbENsZWFyTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ05vIGNoYW5nZSBsaXN0ZW5lciByZWdpc3RlcicpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBPbkNoYW5nZVRyaWdnZXI7XHJcbn0pKHRyaWdnZXJfMS5UcmlnZ2VyKTtcclxuZXhwb3J0cy5PbkNoYW5nZVRyaWdnZXIgPSBPbkNoYW5nZVRyaWdnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uQ2hhbmdlVHJpZ2dlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL3RyaWdnZXJzL29uQ2hhbmdlVHJpZ2dlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciBUcmlnZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyaWdnZXIoYWxpYXNlcywgdHJpZ2dlckFjdGlvbikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckFjdGlvbiA9IHRyaWdnZXJBY3Rpb247XHJcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gYWxpYXNlcy5zcGxpdCgnICcpO1xyXG4gICAgfVxyXG4gICAgVHJpZ2dlci5wcm90b3R5cGUuc2V0VHJpZ2dlciA9IGZ1bmN0aW9uIChhdXRvc2F2ZSkge1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy50cmlnZ2VyQWN0aW9uKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJBY3Rpb24odGhpcy5zZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRyaWdnZXIucHJvdG90eXBlLmhhc01hdGNoID0gZnVuY3Rpb24gKHRyaWdnZXJzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdHJpZ2dlckxpc3QgPSB0cmlnZ2Vycy5zcGxpdCgnICcpO1xyXG4gICAgICAgIHJldHVybiBfLmFueSh0cmlnZ2VyTGlzdCwgZnVuY3Rpb24gKHRyaWdnZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8uYW55KF90aGlzLmFsaWFzZXMsIGZ1bmN0aW9uIChhbGlhcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXIgPT09IGFsaWFzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUcmlnZ2VyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRyaWdnZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVHJpZ2dlciA9IFRyaWdnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaWdnZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZS90cmlnZ2Vycy90cmlnZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBhdXRvc2F2ZURpYWxvZ0Zvb3RlciA9IHJlcXVpcmUoJy4vYXV0b3NhdmVEaWFsb2dGb290ZXIvYXV0b3NhdmVEaWFsb2dGb290ZXInKTtcclxuZXhwb3J0cy5hdXRvc2F2ZURpYWxvZ0Zvb3RlciA9IGF1dG9zYXZlRGlhbG9nRm9vdGVyO1xyXG52YXIgYnVzeSA9IHJlcXVpcmUoJy4vYnVzeS9idXN5Jyk7XHJcbmV4cG9ydHMuYnVzeSA9IGJ1c3k7XHJcbnZhciBidXR0b24gPSByZXF1aXJlKCcuL2J1dHRvbi9idXR0b24nKTtcclxuZXhwb3J0cy5idXR0b24gPSBidXR0b247XHJcbnZhciBidXR0b25Bc3luYyA9IHJlcXVpcmUoJy4vYnV0dG9uQXN5bmMvYnV0dG9uQXN5bmMnKTtcclxuZXhwb3J0cy5idXR0b25Bc3luYyA9IGJ1dHRvbkFzeW5jO1xyXG52YXIgYnV0dG9uTGluayA9IHJlcXVpcmUoJy4vYnV0dG9uTGluay9idXR0b25MaW5rJyk7XHJcbmV4cG9ydHMuYnV0dG9uTGluayA9IGJ1dHRvbkxpbms7XHJcbnZhciBidXR0b25Ub2dnbGUgPSByZXF1aXJlKCcuL2J1dHRvblRvZ2dsZS9idXR0b25Ub2dnbGUnKTtcclxuZXhwb3J0cy5idXR0b25Ub2dnbGUgPSBidXR0b25Ub2dnbGU7XHJcbnZhciBjYXJkQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXIubW9kdWxlJyk7XHJcbmV4cG9ydHMuY2FyZENvbnRhaW5lciA9IGNhcmRDb250YWluZXI7XHJcbnZhciBjaGVja2JveCA9IHJlcXVpcmUoJy4vY2hlY2tib3gvY2hlY2tib3gnKTtcclxuZXhwb3J0cy5jaGVja2JveCA9IGNoZWNrYm94O1xyXG52YXIgY29tbWFMaXN0ID0gcmVxdWlyZSgnLi9jb21tYUxpc3QvY29tbWFMaXN0Jyk7XHJcbmV4cG9ydHMuY29tbWFMaXN0ID0gY29tbWFMaXN0O1xyXG52YXIgZGF0ZVRpbWUgPSByZXF1aXJlKCcuL2RhdGVUaW1lL2RhdGVUaW1lJyk7XHJcbmV4cG9ydHMuZGF0ZVRpbWUgPSBkYXRlVGltZTtcclxudmFyIGdlbmVyaWNDb250YWluZXIgPSByZXF1aXJlKCcuL2dlbmVyaWNDb250YWluZXIvZ2VuZXJpY0NvbnRhaW5lcicpO1xyXG5leHBvcnRzLmdlbmVyaWNDb250YWluZXIgPSBnZW5lcmljQ29udGFpbmVyO1xyXG52YXIgbGF6eUxvYWQgPSByZXF1aXJlKCcuL2xhenlMb2FkL2xhenlMb2FkJyk7XHJcbmV4cG9ydHMubGF6eUxvYWQgPSBsYXp5TG9hZDtcclxudmFyIGxvbmdDbGlja0J1dHRvbiA9IHJlcXVpcmUoJy4vbG9uZ0NsaWNrQnV0dG9uL2xvbmdDbGlja0J1dHRvbicpO1xyXG5leHBvcnRzLmxvbmdDbGlja0J1dHRvbiA9IGxvbmdDbGlja0J1dHRvbjtcclxudmFyIG1lc3NhZ2VMb2cgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5tb2R1bGUnKTtcclxuZXhwb3J0cy5tZXNzYWdlTG9nID0gbWVzc2FnZUxvZztcclxudmFyIG11bHRpU3RlcEluZGljYXRvciA9IHJlcXVpcmUoJy4vbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvcicpO1xyXG5leHBvcnRzLm11bHRpU3RlcEluZGljYXRvciA9IG11bHRpU3RlcEluZGljYXRvcjtcclxudmFyIHJhZGlvID0gcmVxdWlyZSgnLi9yYWRpby9yYWRpby5tb2R1bGUnKTtcclxuZXhwb3J0cy5yYWRpbyA9IHJhZGlvO1xyXG52YXIgcmF0aW5nQmFyID0gcmVxdWlyZSgnLi9yYXRpbmdCYXIvcmF0aW5nQmFyJyk7XHJcbmV4cG9ydHMucmF0aW5nQmFyID0gcmF0aW5nQmFyO1xyXG52YXIgcmljaFRleHRFZGl0b3IgPSByZXF1aXJlKCcuL3JpY2hUZXh0RWRpdG9yL3JpY2hUZXh0RWRpdG9yJyk7XHJcbmV4cG9ydHMucmljaFRleHRFZGl0b3IgPSByaWNoVGV4dEVkaXRvcjtcclxudmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4vc2VsZWN0L3NlbGVjdCcpO1xyXG5leHBvcnRzLnNlbGVjdCA9IHNlbGVjdDtcclxudmFyIHNpZ25hdHVyZVBhZCA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlUGFkL3NpZ25hdHVyZVBhZCcpO1xyXG5leHBvcnRzLnNpZ25hdHVyZVBhZCA9IHNpZ25hdHVyZVBhZDtcclxudmFyIHNpbXBsZUNhcmRMaXN0ID0gcmVxdWlyZSgnLi9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkTGlzdC5tb2R1bGUnKTtcclxuZXhwb3J0cy5zaW1wbGVDYXJkTGlzdCA9IHNpbXBsZUNhcmRMaXN0O1xyXG52YXIgc3Bpbm5lciA9IHJlcXVpcmUoJy4vc3Bpbm5lci9zcGlubmVyJyk7XHJcbmV4cG9ydHMuc3Bpbm5lciA9IHNwaW5uZXI7XHJcbnZhciBzdHJpbmdXaXRoV2F0ZXJtYXJrID0gcmVxdWlyZSgnLi9zdHJpbmdXaXRoV2F0ZXJtYXJrL3N0cmluZ1dpdGhXYXRlcm1hcmsnKTtcclxuZXhwb3J0cy5zdHJpbmdXaXRoV2F0ZXJtYXJrID0gc3RyaW5nV2l0aFdhdGVybWFyaztcclxudmFyIHRhYnMgPSByZXF1aXJlKCcuL3RhYnMvdGFicy5tb2R1bGUnKTtcclxuZXhwb3J0cy50YWJzID0gdGFicztcclxudmFyIHRleHRhcmVhID0gcmVxdWlyZSgnLi90ZXh0YXJlYS90ZXh0YXJlYScpO1xyXG5leHBvcnRzLnRleHRhcmVhID0gdGV4dGFyZWE7XHJcbnZhciB0ZXh0Ym94ID0gcmVxdWlyZSgnLi90ZXh0Ym94L3RleHRib3gnKTtcclxuZXhwb3J0cy50ZXh0Ym94ID0gdGV4dGJveDtcclxudmFyIHR5cGVhaGVhZCA9IHJlcXVpcmUoJy4vdHlwZWFoZWFkL3R5cGVhaGVhZCcpO1xyXG5leHBvcnRzLnR5cGVhaGVhZCA9IHR5cGVhaGVhZDtcclxudmFyIHVzZXJSYXRpbmcgPSByZXF1aXJlKCcuL3VzZXJSYXRpbmcvdXNlclJhdGluZycpO1xyXG5leHBvcnRzLnVzZXJSYXRpbmcgPSB1c2VyUmF0aW5nO1xyXG52YXIgdmFsaWRhdGlvbkdyb3VwID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uR3JvdXAvdmFsaWRhdGlvbkdyb3VwJyk7XHJcbmV4cG9ydHMudmFsaWRhdGlvbkdyb3VwID0gdmFsaWRhdGlvbkdyb3VwO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgYXV0b3NhdmVEaWFsb2dGb290ZXIubW9kdWxlTmFtZSxcclxuICAgIGJ1c3kubW9kdWxlTmFtZSxcclxuICAgIGJ1dHRvbi5tb2R1bGVOYW1lLFxyXG4gICAgYnV0dG9uQXN5bmMubW9kdWxlTmFtZSxcclxuICAgIGJ1dHRvbkxpbmsubW9kdWxlTmFtZSxcclxuICAgIGJ1dHRvblRvZ2dsZS5tb2R1bGVOYW1lLFxyXG4gICAgY2FyZENvbnRhaW5lci5tb2R1bGVOYW1lLFxyXG4gICAgY2hlY2tib3gubW9kdWxlTmFtZSxcclxuICAgIGNvbW1hTGlzdC5tb2R1bGVOYW1lLFxyXG4gICAgZGF0ZVRpbWUubW9kdWxlTmFtZSxcclxuICAgIGdlbmVyaWNDb250YWluZXIubW9kdWxlTmFtZSxcclxuICAgIGxhenlMb2FkLm1vZHVsZU5hbWUsXHJcbiAgICBsb25nQ2xpY2tCdXR0b24ubW9kdWxlTmFtZSxcclxuICAgIG1lc3NhZ2VMb2cubW9kdWxlTmFtZSxcclxuICAgIG11bHRpU3RlcEluZGljYXRvci5tb2R1bGVOYW1lLFxyXG4gICAgcmFkaW8ubW9kdWxlTmFtZSxcclxuICAgIHJhdGluZ0Jhci5tb2R1bGVOYW1lLFxyXG4gICAgcmljaFRleHRFZGl0b3IubW9kdWxlTmFtZSxcclxuICAgIHNlbGVjdC5tb2R1bGVOYW1lLFxyXG4gICAgc2lnbmF0dXJlUGFkLm1vZHVsZU5hbWUsXHJcbiAgICBzaW1wbGVDYXJkTGlzdC5tb2R1bGVOYW1lLFxyXG4gICAgc3Bpbm5lci5tb2R1bGVOYW1lLFxyXG4gICAgc3RyaW5nV2l0aFdhdGVybWFyay5tb2R1bGVOYW1lLFxyXG4gICAgdGFicy5tb2R1bGVOYW1lLFxyXG4gICAgdGV4dGFyZWEubW9kdWxlTmFtZSxcclxuICAgIHRleHRib3gubW9kdWxlTmFtZSxcclxuICAgIHR5cGVhaGVhZC5tb2R1bGVOYW1lLFxyXG4gICAgdXNlclJhdGluZy5tb2R1bGVOYW1lLFxyXG4gICAgdmFsaWRhdGlvbkdyb3VwLm1vZHVsZU5hbWUsXHJcbl0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnRzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY29tcG9uZW50cy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuYXV0b3NhdmVEaWFsb2dGb290ZXInO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxBdXRvc2F2ZURpYWxvZ0Zvb3Rlcic7XHJcbmZ1bmN0aW9uIGF1dG9zYXZlRGlhbG9nRm9vdGVyKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2F1dG9zYXZlRGlhbG9nRm9vdGVyLmh0bWwnKSxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBhdXRvc2F2ZURpYWxvZ0Zvb3Rlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9zYXZlRGlhbG9nRm9vdGVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9hdXRvc2F2ZURpYWxvZ0Zvb3Rlci9hdXRvc2F2ZURpYWxvZ0Zvb3Rlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyXFxcIj5cXHJcXG5cXHQ8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctY2xpY2s9XFxcIiRjbG9zZSgpXFxcIj5DYW5jZWw8L2J1dHRvbj5cXHJcXG5cXHQ8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctY2xpY2s9XFxcIiRkaXNtaXNzKClcXFwiPlNhdmU8L2J1dHRvbj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9hdXRvc2F2ZURpYWxvZ0Zvb3Rlci9hdXRvc2F2ZURpYWxvZ0Zvb3Rlci5odG1sXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxucmVxdWlyZSgnLi9idXN5LmNzcycpO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuYnVzeSc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEJ1c3knO1xyXG5mdW5jdGlvbiBidXN5KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnPGkgY2xhc3M9XCJidXN5IHJsLXt7c2l6ZX19XCIgbmctc2hvdz1cImxvYWRpbmdcIj48L2k+JyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBsb2FkaW5nOiAnPScsXHJcbiAgICAgICAgICAgIC8vIFZhbGlkIHZhbHVlcyBhcmU6XHJcbiAgICAgICAgICAgIC8vIGBsZ2AsIGAyeGAsIGAzeGAsIGA0eGAsIGFuZCBgNXhgXHJcbiAgICAgICAgICAgIHNpemU6ICdAJyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGJ1c3kpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXN5LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXN5L2J1c3kuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9idXN5LmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9idXN5LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2J1c3kuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnVzeS9idXN5LmNzc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5idXN5IHtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbjogZmEtc3BpbiAycyBpbmZpbml0ZSBsaW5lYXI7XFxyXFxuXFx0YW5pbWF0aW9uOiBmYS1zcGluIDJzIGluZmluaXRlIGxpbmVhcjtcXHJcXG5cXHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuXFx0Zm9udC1zaXplOiBpbmhlcml0O1xcclxcblxcdGZvbnQtc3R5bGU6IG5vcm1hbDtcXHJcXG5cXHRmb250LWZhbWlseTogRm9udEF3ZXNvbWU7XFxyXFxufVxcclxcblxcclxcbi5idXN5OmJlZm9yZSB7XFxyXFxuXFx0Y29udGVudDogXFxcIlxcXFxGMTEwXFxcIjsgLyogZmEtc3Bpbm5lciAqL1xcclxcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vc291cmNlL2NvbXBvbmVudHMvYnVzeS9idXN5LmNzc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmJ1dHRvbic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEJ1dHRvbic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQnV0dG9uQ29udHJvbGxlcic7XHJcbnZhciBCdXR0b25Db250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1dHRvbkNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy50eXBlICE9IG51bGwgPyB0aGlzLnR5cGUgOiAnZGVmYXVsdCc7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmVkU2l6ZSA9IHRoaXMuc2l6ZSAhPSBudWxsID8gJ2J0bi0nICsgdGhpcy5zaXplIDogbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBCdXR0b25Db250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkJ1dHRvbkNvbnRyb2xsZXIgPSBCdXR0b25Db250cm9sbGVyO1xyXG5mdW5jdGlvbiBidXR0b24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9idXR0b24uaHRtbCcpLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJyYnLFxyXG4gICAgICAgICAgICB0eXBlOiAnQCcsXHJcbiAgICAgICAgICAgIG5nRGlzYWJsZWQ6ICc9JyxcclxuICAgICAgICAgICAgc2l6ZTogJ0AnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdidXR0b24nLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBidXR0b24pXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBCdXR0b25Db250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b24vYnV0dG9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b24udHlwZX19IHt7YnV0dG9uLmNvbmZpZ3VyZWRTaXplfX1cXFwiIG5nLWNsaWNrPVxcXCJidXR0b24uYWN0aW9uKClcXFwiIG5nLWRpc2FibGVkPVxcXCJidXR0b24ubmdEaXNhYmxlZFxcXCI+XFxyXFxuXFx0PHNwYW4gbmctdHJhbnNjbHVkZT48L3NwYW4+XFxyXFxuPC9idXR0b24+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5odG1sXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3Byb21pc2VVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnByb21pc2U7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmJ1dHRvbkFzeW5jJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQnV0dG9uQXN5bmMnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0J1dHRvbkFzeW5jQ29udHJvbGxlcic7XHJcbnZhciBCdXR0b25Bc3luY0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnV0dG9uQXN5bmNDb250cm9sbGVyKHByb21pc2VVdGlsaXR5KSB7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlVXRpbGl0eSA9IHByb21pc2VVdGlsaXR5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSAhPSBudWxsID8gdGhpcy50eXBlIDogJ2RlZmF1bHQnO1xyXG4gICAgICAgIHRoaXMuc2l6ZUNsYXNzID0gdGhpcy5zaXplICE9IG51bGwgPyAnYnRuLScgKyB0aGlzLnNpemUgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgQnV0dG9uQXN5bmNDb250cm9sbGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ1c3kpIHtcclxuICAgICAgICAgICAgdGhpcy5idXN5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb21pc2VVdGlsaXR5LmlzUHJvbWlzZShyZXN1bHQpICYmIF8uaXNGdW5jdGlvbihyZXN1bHQuZmluYWxseSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5maW5hbGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5idXN5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdXR0b25Bc3luY0NvbnRyb2xsZXIuJGluamVjdCA9IFtfX3Byb21pc2VVdGlsaXR5LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBCdXR0b25Bc3luY0NvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQnV0dG9uQXN5bmNDb250cm9sbGVyID0gQnV0dG9uQXN5bmNDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBidXR0b25Bc3luYygpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2J1dHRvbkFzeW5jLmh0bWwnKSxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBidXN5OiAnPScsXHJcbiAgICAgICAgICAgIGFjdGlvbjogJyYnLFxyXG4gICAgICAgICAgICB0eXBlOiAnQCcsXHJcbiAgICAgICAgICAgIG5nRGlzYWJsZWQ6ICc9JyxcclxuICAgICAgICAgICAgcmlnaHRBbGlnbmVkOiAnPScsXHJcbiAgICAgICAgICAgIHNpemU6ICdAJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnYnV0dG9uJyxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19wcm9taXNlVXRpbGl0eS5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBidXR0b25Bc3luYylcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIEJ1dHRvbkFzeW5jQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbkFzeW5jLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Bc3luYy9idXR0b25Bc3luYy5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXt7YnV0dG9uLnR5cGV9fSB7e2J1dHRvbi5zaXplQ2xhc3N9fVxcXCIgbmctY2xpY2s9XFxcImJ1dHRvbi50cmlnZ2VyKClcXFwiIG5nLWRpc2FibGVkPVxcXCJidXR0b24uYnVzeSB8fCBidXR0b24ubmdEaXNhYmxlZFxcXCI+XFxyXFxuXFx0PHJsLWJ1c3kgbmctc2hvdz1cXFwiYnV0dG9uLnJpZ2h0QWxpZ25lZFxcXCIgbG9hZGluZz1cXFwiYnV0dG9uLmJ1c3lcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHQ8c3BhbiBuZy10cmFuc2NsdWRlPjwvc3Bhbj5cXHJcXG5cXHQ8cmwtYnVzeSBuZy1oaWRlPVxcXCJidXR0b24ucmlnaHRBbGlnbmVkXFxcIiBsb2FkaW5nPVxcXCJidXR0b24uYnVzeVxcXCI+PC9ybC1idXN5PlxcclxcbjwvYnV0dG9uPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvbkFzeW5jL2J1dHRvbkFzeW5jLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5idXR0b25MaW5rJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQnV0dG9uTGluayc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQnV0dG9uTGlua0NvbnRyb2xsZXInO1xyXG52YXIgQnV0dG9uTGlua0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnV0dG9uTGlua0NvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy50eXBlICE9IG51bGwgPyB0aGlzLnR5cGUgOiAnZGVmYXVsdCc7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmVkU2l6ZSA9IHRoaXMuc2l6ZSAhPSBudWxsID8gJ2J0bi0nICsgdGhpcy5zaXplIDogbnVsbDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMubmV3VGFiID8gJ19ibGFuaycgOiAnX3NlbGYnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJ1dHRvbkxpbmtDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkJ1dHRvbkxpbmtDb250cm9sbGVyID0gQnV0dG9uTGlua0NvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGJ1dHRvbkxpbmsoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9idXR0b25MaW5rLmh0bWwnKSxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBsaW5rOiAnQCcsXHJcbiAgICAgICAgICAgIHR5cGU6ICdAJyxcclxuICAgICAgICAgICAgbmdEaXNhYmxlZDogJz0nLFxyXG4gICAgICAgICAgICBzaXplOiAnQCcsXHJcbiAgICAgICAgICAgIG5ld1RhYjogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdidXR0b24nLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmJ1dHRvbkxpbmsgPSBidXR0b25MaW5rO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGJ1dHRvbkxpbmspXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBCdXR0b25MaW5rQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbkxpbmsuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvbkxpbmsvYnV0dG9uTGluay5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGEgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b24udHlwZX19IHt7YnV0dG9uLmNvbmZpZ3VyZWRTaXplfX1cXFwiIG5nLWhyZWY9XFxcInt7YnV0dG9uLmxpbmt9fVxcXCIgbmctZGlzYWJsZWQ9XFxcImJ1dHRvbi5uZ0Rpc2FibGVkXFxcIiB0YXJnZXQ9XFxcInt7YnV0dG9uLnRhcmdldH19XFxcIj5cXHJcXG5cXHQ8c3BhbiBuZy10cmFuc2NsdWRlPjwvc3Bhbj5cXHJcXG48L2E+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uTGluay9idXR0b25MaW5rLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fYm9vbGVhbiA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5ib29sZWFuO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5idXR0b25Ub2dnbGUnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxCdXR0b25Ub2dnbGUnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0J1dHRvblRvZ2dsZUNvbnRyb2xsZXInO1xyXG52YXIgQnV0dG9uVG9nZ2xlQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCdXR0b25Ub2dnbGVDb250cm9sbGVyKCRzY29wZSwgYm9vbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy5idXR0b25DbGFzcyA9ICRzY29wZS50eXBlICE9IG51bGwgPyAkc2NvcGUudHlwZSA6ICdkZWZhdWx0JztcclxuICAgICAgICB0aGlzLmJ1dHRvblNpemUgPSAkc2NvcGUuc2l6ZSAhPSBudWxsID8gJ2J0bi0nICsgJHNjb3BlLnNpemUgOiBudWxsO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ25nTW9kZWwuJG1vZGVsVmFsdWUnLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBib29sLnRvQm9vbCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIF8uaXNGdW5jdGlvbigkc2NvcGUub25Ub2dnbGUpKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUub25Ub2dnbGUoeyB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEJ1dHRvblRvZ2dsZUNvbnRyb2xsZXIucHJvdG90eXBlLmNsaWNrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKCF0aGlzLiRzY29wZS5uZ01vZGVsLiR2aWV3VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEJ1dHRvblRvZ2dsZUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgX19ib29sZWFuLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBCdXR0b25Ub2dnbGVDb250cm9sbGVyO1xyXG59KSgpO1xyXG5mdW5jdGlvbiBidXR0b25Ub2dnbGUoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgcmVxdWlyZTogJ15uZ01vZGVsJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2J1dHRvblRvZ2dsZS5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdidXR0b25Ub2dnbGUnLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdAJyxcclxuICAgICAgICAgICAgc2l6ZTogJ0AnLFxyXG4gICAgICAgICAgICBvblRvZ2dsZTogJyYnLFxyXG4gICAgICAgICAgICBkaXNhYmxlZDogJz1uZ0Rpc2FibGVkJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgICAgICAgc2NvcGUubmdNb2RlbCA9IG5nTW9kZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX2Jvb2xlYW4ubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYnV0dG9uVG9nZ2xlKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQnV0dG9uVG9nZ2xlQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvblRvZ2dsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uVG9nZ2xlL2J1dHRvblRvZ2dsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXt7YnV0dG9uVG9nZ2xlLmJ1dHRvbkNsYXNzfX0ge3tidXR0b25Ub2dnbGUuYnV0dG9uU2l6ZX19XFxcIiBcXHJcXG5cXHRcXHRuZy1jbGFzcz1cXFwieyBhY3RpdmUgOiBidXR0b25Ub2dnbGUuaXNBY3RpdmUgfVxcXCIgbmctY2xpY2s9XFxcImJ1dHRvblRvZ2dsZS5jbGlja2VkKClcXFwiIG5nLWRpc2FibGVkPVxcXCJkaXNhYmxlZFxcXCI+XFxyXFxuXFx0PGkgbmctc2hvdz1cXFwiYnV0dG9uVG9nZ2xlLmlzQWN0aXZlXFxcIiBjbGFzcz1cXFwiZmEgZmEtY2hlY2sgY29tcGxldGVkXFxcIj48L2k+IDxzcGFuIG5nLXRyYW5zY2x1ZGU+PC9zcGFuPlxcclxcbjwvYnV0dG9uPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvblRvZ2dsZS9idXR0b25Ub2dnbGUuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fYXJyYXkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYXJyYXk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBfX2dlbmVyaWNTZWFyY2hGaWx0ZXIgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZ2VuZXJpY1NlYXJjaEZpbHRlcjtcclxudmFyIGNhcmQgPSByZXF1aXJlKCcuL2NhcmQvY2FyZCcpO1xyXG5leHBvcnRzLmNhcmQgPSBjYXJkO1xyXG52YXIgY2FyZFNlYXJjaCA9IHJlcXVpcmUoJy4vY2FyZFNlYXJjaC9jYXJkU2VhcmNoJyk7XHJcbmV4cG9ydHMuY2FyZFNlYXJjaCA9IGNhcmRTZWFyY2g7XHJcbnZhciBjb2x1bW5IZWFkZXIgPSByZXF1aXJlKCcuL2NvbHVtbkhlYWRlci9jb2x1bW5IZWFkZXInKTtcclxuZXhwb3J0cy5jb2x1bW5IZWFkZXIgPSBjb2x1bW5IZWFkZXI7XHJcbnZhciBkYXRhU291cmNlcyA9IHJlcXVpcmUoJy4vZGF0YVNvdXJjZXMvZGF0YVNvdXJjZXMubW9kdWxlJyk7XHJcbmV4cG9ydHMuZGF0YVNvdXJjZXMgPSBkYXRhU291cmNlcztcclxudmFyIGZpbHRlcnMgPSByZXF1aXJlKCcuL2ZpbHRlcnMvZmlsdGVycy5tb2R1bGUnKTtcclxuZXhwb3J0cy5maWx0ZXJzID0gZmlsdGVycztcclxudmFyIGl0ZW1Db3VudCA9IHJlcXVpcmUoJy4vaXRlbUNvdW50L2l0ZW1Db3VudCcpO1xyXG5leHBvcnRzLml0ZW1Db3VudCA9IGl0ZW1Db3VudDtcclxudmFyIHBhZ2VyID0gcmVxdWlyZSgnLi9wYWdlci9wYWdlcicpO1xyXG5leHBvcnRzLnBhZ2VyID0gcGFnZXI7XHJcbnZhciBwYWdlU2l6ZSA9IHJlcXVpcmUoJy4vcGFnZVNpemUvcGFnZVNpemUnKTtcclxuZXhwb3J0cy5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xyXG52YXIgc2VsZWN0aW9uQ29udHJvbCA9IHJlcXVpcmUoJy4vc2VsZWN0aW9uQ29udHJvbC9zZWxlY3Rpb25Db250cm9sJyk7XHJcbmV4cG9ydHMuc2VsZWN0aW9uQ29udHJvbCA9IHNlbGVjdGlvbkNvbnRyb2w7XHJcbnZhciBzb3J0cyA9IHJlcXVpcmUoJy4vc29ydHMvc29ydHMubW9kdWxlJyk7XHJcbmV4cG9ydHMuc29ydHMgPSBzb3J0cztcclxudmFyIGNhcmRDb250YWluZXJfMSA9IHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lcicpO1xyXG52YXIgYnVpbGRlciA9IHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lckJ1aWxkZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmJ1aWxkZXIgPSBidWlsZGVyO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2NhcmRDb250YWluZXInKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lci5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2NvbHVtbicpKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lcic7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgLy8gZGVwZW5kZW5jaWVzXHJcbiAgICBkYXRhU291cmNlcy5kYXRhUGFnZXIubW9kdWxlTmFtZSxcclxuICAgIF9fb2JqZWN0Lm1vZHVsZU5hbWUsXHJcbiAgICBfX2FycmF5Lm1vZHVsZU5hbWUsXHJcbiAgICBfX3BhcmVudENoaWxkLm1vZHVsZU5hbWUsXHJcbiAgICBfX2dlbmVyaWNTZWFyY2hGaWx0ZXIubW9kdWxlTmFtZSxcclxuICAgIC8vIGNvbXBvbmVudHNcclxuICAgIGNhcmQubW9kdWxlTmFtZSxcclxuICAgIGNhcmRTZWFyY2gubW9kdWxlTmFtZSxcclxuICAgIGNvbHVtbkhlYWRlci5tb2R1bGVOYW1lLFxyXG4gICAgaXRlbUNvdW50Lm1vZHVsZU5hbWUsXHJcbiAgICBwYWdlci5tb2R1bGVOYW1lLFxyXG4gICAgcGFnZVNpemUubW9kdWxlTmFtZSxcclxuICAgIHNlbGVjdGlvbkNvbnRyb2wubW9kdWxlTmFtZSxcclxuICAgIC8vIHN1Ym1vZHVsZXNcclxuICAgIGRhdGFTb3VyY2VzLm1vZHVsZU5hbWUsXHJcbiAgICBmaWx0ZXJzLm1vZHVsZU5hbWUsXHJcbiAgICBzb3J0cy5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLmRpcmVjdGl2ZShjYXJkQ29udGFpbmVyXzEuZGlyZWN0aXZlTmFtZSwgY2FyZENvbnRhaW5lcl8xLmNhcmRDb250YWluZXIpXHJcbiAgICAuY29udHJvbGxlcihjYXJkQ29udGFpbmVyXzEuY29udHJvbGxlck5hbWUsIGNhcmRDb250YWluZXJfMS5DYXJkQ29udGFpbmVyQ29udHJvbGxlcilcclxuICAgIC5mYWN0b3J5KGJ1aWxkZXIuZmFjdG9yeU5hbWUsIGJ1aWxkZXIuY2FyZENvbnRhaW5lckJ1aWxkZXJGYWN0b3J5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZENvbnRhaW5lci5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZENvbnRhaW5lci5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vLi4vdHlwaW5ncy9qcXVlcnkvanF1ZXJ5LmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBoZWFkZXJDb2x1bW5fbW9kdWxlXzEgPSByZXF1aXJlKCcuL2hlYWRlckNvbHVtbi9oZWFkZXJDb2x1bW4ubW9kdWxlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuY2FyZCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRDb250cm9sbGVyJztcclxudmFyIENhcmRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhcmRDb250cm9sbGVyKCRzY29wZSwgJGNvbnRyb2xsZXIsICRxLCBwYXJlbnRDaGlsZCwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLiRxID0gJHE7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZCA9IHBhcmVudENoaWxkO1xyXG4gICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZUxpbmsgPSB7fTtcclxuICAgICAgICB0aGlzLmF1dG9zYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2hvd0NvbnRlbnQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucGFyZW50Q2hpbGQudHJpZ2dlckNoaWxkQmVoYXZpb3IoX3RoaXMuYXV0b3NhdmVMaW5rLCBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvci5hdXRvc2F2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5jYXJkQXMpIHtcclxuICAgICAgICAgICAgJHNjb3BlW3RoaXMuY2FyZEFzXSA9IHRoaXMuaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHNjb3BlLmNvbGxhcHNlID0gdGhpcy5hdXRvc2F2ZTtcclxuICAgICAgICAkc2NvcGUuc2V0U2VsZWN0ZWQgPSB0aGlzLnNldFNlbGVjdGVkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgJHNjb3BlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdjYXJkLnJlZnJlc2gnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgICRzY29wZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZS5yZW1vdmUoX3RoaXMuaXRlbSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkc2NvcGUuY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YTtcclxuICAgICAgICBpZiAob2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSh0aGlzLmNhcmRDb250cm9sbGVyKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSAkY29udHJvbGxlcih0aGlzLmNhcmRDb250cm9sbGVyLCB7ICRzY29wZTogJHNjb3BlIH0pO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSh0aGlzLmNhcmRDb250cm9sbGVyQXMpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlW3RoaXMuY2FyZENvbnRyb2xsZXJBc10gPSBjb250cm9sbGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudENoaWxkLnJlZ2lzdGVyQ2hpbGRCZWhhdmlvcih0aGlzLml0ZW0sIHtcclxuICAgICAgICAgICAgY2xvc2U6IHRoaXMuYXV0b3NhdmUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLl9faW5pdENvbnRlbnRzID0gZnVuY3Rpb24gKGhhc0JvZHksIGhhc0Zvb3Rlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5oYXNCb2R5ID0gaGFzQm9keTtcclxuICAgICAgICAgICAgX3RoaXMuaGFzRm9vdGVyID0gaGFzRm9vdGVyO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBDYXJkQ29udHJvbGxlci5wcm90b3R5cGUudG9nZ2xlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvd0NvbnRlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9zYXZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250cm9sbGVyLnByb3RvdHlwZS52YWxpZGF0ZUNhcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5wYXJlbnRDaGlsZC5nZXRDaGlsZEJlaGF2aW9yKHRoaXMuaXRlbSk7XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihiZWhhdmlvci52YWxpZGF0ZUNhcmQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZWhhdmlvci52YWxpZGF0ZUNhcmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkQ29udHJvbGxlci5wcm90b3R5cGUuc2F2ZUNhcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5wYXJlbnRDaGlsZC5nZXRDaGlsZEJlaGF2aW9yKHRoaXMuaXRlbSk7XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihiZWhhdmlvci5zYXZlQ2FyZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlaGF2aW9yLnNhdmVDYXJkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcS53aGVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250cm9sbGVyLnByb3RvdHlwZS5jbGlja0NhcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZC50cmlnZ2VyQ2hpbGRCZWhhdmlvcih0aGlzLml0ZW0sIGZ1bmN0aW9uIChiZWhhdmlvcikge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGJlaGF2aW9yLmNsaWNrQ2FyZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiZWhhdmlvci5jbGlja0NhcmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250cm9sbGVyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQudHJpZ2dlckNoaWxkQmVoYXZpb3IodGhpcy5pdGVtLCBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihiZWhhdmlvci5pbml0Q2FyZCkpIHtcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yLmluaXRDYXJkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy4kc2NvcGUuX19ybENhcmRDb250YWluZXIub3BlbkNhcmQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNlbGVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5pdGVtLnZpZXdEYXRhKSkge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW0udmlld0RhdGEgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pdGVtLnZpZXdEYXRhLnNlbGVjdGVkID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRjb250cm9sbGVyJywgJyRxJywgX19wYXJlbnRDaGlsZC5zZXJ2aWNlTmFtZSwgX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIENhcmRDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNhcmRDb250cm9sbGVyID0gQ2FyZENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGNhcmQoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vY2FyZC5odG1sJyksXHJcbiAgICAgICAgcmVxdWlyZTogJ15ecmxDYXJkQ29udGFpbmVyJyxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ19fY2FyZCcsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgY29sdW1uczogJz0nLFxyXG4gICAgICAgICAgICBpdGVtOiAnPScsXHJcbiAgICAgICAgICAgIGNsaWNrYWJsZTogJz0nLFxyXG4gICAgICAgICAgICBzb3VyY2U6ICc9JyxcclxuICAgICAgICAgICAgY29udGFpbmVyRGF0YTogJz0nLFxyXG4gICAgICAgICAgICBjYXJkQ29udHJvbGxlcjogJz0nLFxyXG4gICAgICAgICAgICBjYXJkQ29udHJvbGxlckFzOiAnPScsXHJcbiAgICAgICAgICAgIGNhcmRBczogJz0nLFxyXG4gICAgICAgICAgICBwZXJtYW5lbnRGb290ZXI6ICc9JyxcclxuICAgICAgICAgICAgc2VsZWN0YWJsZTogJz0nLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkOiAnJicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBybENhcmRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgc2NvcGUuX19ybENhcmRDb250YWluZXIgPSBybENhcmRDb250YWluZXI7XHJcbiAgICAgICAgICAgIHJsQ2FyZENvbnRhaW5lci5tYWtlQ2FyZChzY29wZSwgZnVuY3Rpb24gKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGNsb25lLmZpbHRlcigncmwtY2FyZC1jb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9vdGVyID0gY2xvbmUuZmlsdGVyKCdybC1jYXJkLWZvb3RlcicpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRBcmVhID0gZWxlbWVudC5maW5kKCcuY29udGVudC10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudEFyZWEuYXBwZW5kKGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0JvZHkgPSBjb250ZW50Lmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzRm9vdGVyID0gKGZvb3Rlci5sZW5ndGggPiAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNGb290ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9vdGVyQXJlYSA9IGVsZW1lbnQuZmluZCgnLmZvb3Rlci10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvb3RlckFyZWEuYXBwZW5kKGZvb3Rlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzY29wZS5fX2luaXRDb250ZW50cyhoYXNCb2R5LCBoYXNGb290ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNhcmQgPSBjYXJkO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIF9fcGFyZW50Q2hpbGQubW9kdWxlTmFtZSxcclxuICAgIF9fb2JqZWN0Lm1vZHVsZU5hbWUsXHJcbiAgICBoZWFkZXJDb2x1bW5fbW9kdWxlXzEubW9kdWxlTmFtZSxcclxuXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBjYXJkKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQ2FyZENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvY2FyZC5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgaGVhZGVyQ29sdW1uXzEgPSByZXF1aXJlKCcuL2hlYWRlckNvbHVtbicpO1xyXG52YXIgc2l6ZUZvckJyZWFrcG9pbnRzXzEgPSByZXF1aXJlKCcuL3NpemVGb3JCcmVha3BvaW50cycpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmNhcmQuaGVhZGVyQ29sdW1uJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3RyaW5nLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuZGlyZWN0aXZlKHNpemVGb3JCcmVha3BvaW50c18xLnNpemVGb3JCcmVha3BvaW50c05hbWUsIHNpemVGb3JCcmVha3BvaW50c18xLnNpemVGb3JCcmVha3BvaW50cylcclxuICAgIC5kaXJlY3RpdmUoaGVhZGVyQ29sdW1uXzEuZGlyZWN0aXZlTmFtZSwgaGVhZGVyQ29sdW1uXzEuaGVhZGVyQ29sdW1uKVxyXG4gICAgLmNvbnRyb2xsZXIoaGVhZGVyQ29sdW1uXzEuY29udHJvbGxlck5hbWUsIGhlYWRlckNvbHVtbl8xLkhlYWRlckNvbHVtbkNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXJDb2x1bW4ubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvaGVhZGVyQ29sdW1uL2hlYWRlckNvbHVtbi5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy9qcXVlcnkvanF1ZXJ5LmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQ2FyZEhlYWRlckNvbHVtbic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQ2FyZEhlYWRlckNvbHVtbkNvbnRyb2xsZXInO1xyXG52YXIgSGVhZGVyQ29sdW1uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIZWFkZXJDb2x1bW5Db250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gX3RoaXMuY29sdW1uLmdldFZhbHVlKF90aGlzLml0ZW0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAkc2NvcGUuJG9uKCdjYXJkLnJlZnJlc2gnLCB0aGlzLnVwZGF0ZSk7IC8vKmV2ZW50P1xyXG4gICAgfVxyXG4gICAgSGVhZGVyQ29sdW1uQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBIZWFkZXJDb2x1bW5Db250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkhlYWRlckNvbHVtbkNvbnRyb2xsZXIgPSBIZWFkZXJDb2x1bW5Db250cm9sbGVyO1xyXG5oZWFkZXJDb2x1bW4uJGluamVjdCA9IFsnJGNvbXBpbGUnXTtcclxuZnVuY3Rpb24gaGVhZGVyQ29sdW1uKCRjb21waWxlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGRpdiBybC1zaXplLWZvci1icmVha3BvaW50cz1cXFwiaGVhZGVyLmNvbHVtbi5zaXplXFxcIiB0aXRsZT1cXFwie3s6OmhlYWRlci5jb2x1bW4uZGVzY3JpcHRpb259fVxcXCI+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwidGVtcGxhdGUtY29udGFpbmVyXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogaW5saW5lLWJsb2NrXFxcIj48L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2hlYWRlcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgY29sdW1uOiAnPScsXHJcbiAgICAgICAgICAgIGl0ZW06ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGhlYWRlci5jb2x1bW47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi50ZW1wbGF0ZVVybCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5yZW5kZXJlZFRlbXBsYXRlID0gJGNvbXBpbGUoJzxkaXYgbmctaW5jbHVkZT1cIlxcJycgKyBjb2x1bW4udGVtcGxhdGVVcmwgKyAnXFwnXCI+PC9kaXY+Jykoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2x1bW4udGVtcGxhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIucmVuZGVyZWRUZW1wbGF0ZSA9ICRjb21waWxlKGNvbHVtbi50ZW1wbGF0ZSkoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLnJlbmRlcmVkVGVtcGxhdGUgPSAkY29tcGlsZSgnPHNwYW4+e3toZWFkZXIudmFsdWV9fTwvc3Bhbj4nKShzY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBlbGVtZW50LmZpbmQoJy50ZW1wbGF0ZS1jb250YWluZXInKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKGhlYWRlci5yZW5kZXJlZFRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5oZWFkZXJDb2x1bW4gPSBoZWFkZXJDb2x1bW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWRlckNvbHVtbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9oZWFkZXJDb2x1bW4uanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19zdHJpbmcgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3RyaW5nO1xyXG52YXIgYnJlYWtwb2ludF8xID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludCcpO1xyXG5leHBvcnRzLnNpemVGb3JCcmVha3BvaW50c05hbWUgPSAncmxTaXplRm9yQnJlYWtwb2ludHMnO1xyXG5zaXplRm9yQnJlYWtwb2ludHMuJGluamVjdCA9IFsnJHBhcnNlJywgX19zdHJpbmcuc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBzaXplRm9yQnJlYWtwb2ludHMoJHBhcnNlLCBzdHJpbmdVdGlsaXR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICAgICAgbGluazogbGlua0RpcmVjdGl2ZSxcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBsaW5rRGlyZWN0aXZlKHNjb3BlLCBlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgdmFyIHNpemVzID0gJHBhcnNlKGF0dHJpYnV0ZXMucmxTaXplRm9yQnJlYWtwb2ludHMpKHNjb3BlKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgIGNsYXNzZXMucHVzaChnZXRDb2x1bW5DbGFzcyhzaXplcywgYnJlYWtwb2ludF8xLnhzKSk7XHJcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGdldENvbHVtbkNsYXNzKHNpemVzLCBicmVha3BvaW50XzEuc20pKTtcclxuICAgICAgICBjbGFzc2VzLnB1c2goZ2V0Q29sdW1uQ2xhc3Moc2l6ZXMsIGJyZWFrcG9pbnRfMS5tZCkpO1xyXG4gICAgICAgIGNsYXNzZXMucHVzaChnZXRDb2x1bW5DbGFzcyhzaXplcywgYnJlYWtwb2ludF8xLmxnKSk7XHJcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhjbGFzc2VzLmpvaW4oJyAnKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5DbGFzcyhjb2x1bW5TaXplcywgYnJlYWtwb2ludCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbHVtblNpemVzW2JyZWFrcG9pbnRdO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+IDAgJiYgdmFsdWUgIT09ICdoaWRkZW4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdVdGlsaXR5LnN1YnN0aXR1dGUoJ2NvbC17MH0tezF9JywgYnJlYWtwb2ludCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdoaWRkZW4tJyArIGJyZWFrcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc2l6ZUZvckJyZWFrcG9pbnRzID0gc2l6ZUZvckJyZWFrcG9pbnRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaXplRm9yQnJlYWtwb2ludHMuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZC9oZWFkZXJDb2x1bW4vc2l6ZUZvckJyZWFrcG9pbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5sZyA9ICdsZyc7XHJcbmV4cG9ydHMubWQgPSAnbWQnO1xyXG5leHBvcnRzLnNtID0gJ3NtJztcclxuZXhwb3J0cy54cyA9ICd4cyc7XHJcbmV4cG9ydHMuYWxsID0gW2V4cG9ydHMueHMsIGV4cG9ydHMuc20sIGV4cG9ydHMubWQsIGV4cG9ydHMubGddO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVha3BvaW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludC5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHJsLWdlbmVyaWMtY29udGFpbmVyIHNlbGVjdG9yPVxcXCJfX2NhcmQuc2VsZWN0YWJsZVxcXCI+XFxyXFxuXFx0PHRlbXBsYXRlIHdoZW4tc2VsZWN0b3I9XFxcImZhbHNlXFxcIiBkZWZhdWx0PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmRcXFwiIG5nLWNsYXNzPVxcXCJ7ICdzZWxlY3RlZCc6IF9fY2FyZC5pdGVtLnZpZXdEYXRhLnNlbGVjdGVkIH1cXFwiPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImhlYWRlclxcXCIgbmctY2xpY2s9XFxcIl9fY2FyZC50b2dnbGVDb250ZW50KClcXFwiIG5nLWNsYXNzPVxcXCJ7ICdhY3RpdmUnOiBfX2NhcmQuaGFzQm9keSB8fCAhX19jYXJkLnBlcm1hbmVudEZvb3RlciB9XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctcmVwZWF0PVxcXCJjb2x1bW4gaW4gX19jYXJkLmNvbHVtbnNcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDxybC1jYXJkLWhlYWRlci1jb2x1bW4gY29sdW1uPVxcXCJjb2x1bW5cXFwiIGl0ZW09XFxcIl9fY2FyZC5pdGVtXFxcIj48L3JsLWNhcmQtaGVhZGVyLWNvbHVtbj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcIl9fY2FyZC5zaG93Q29udGVudFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PG5nLWZvcm0gcmwtYXV0b3NhdmU9XFxcIl9fY2FyZC5hdXRvc2F2ZUxpbmtcXFwiIHNhdmU9XFxcIl9fY2FyZC5zYXZlQ2FyZCgpXFxcIiB2YWxpZGF0ZT1cXFwiX19jYXJkLnZhbGlkYXRlQ2FyZCgpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJib2R5XFxcIiBuZy1jbGFzcz1cXFwieyAnYWN0aXZlJzogX19jYXJkLmNsaWNrYWJsZSB9XFxcIiBuZy1jbGljaz1cXFwiX19jYXJkLmNsaWNrQ2FyZCgpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb250ZW50LXRlbXBsYXRlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PC9uZy1mb3JtPlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwiX19jYXJkLmhhc0Zvb3RlciAmJiAoX19jYXJkLnNob3dDb250ZW50IHx8IF9fY2FyZC5wZXJtYW5lbnRGb290ZXIpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb290ZXJcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImZvb3Rlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvdGVtcGxhdGU+XFxyXFxuXFx0PHRlbXBsYXRlIHdoZW4tc2VsZWN0b3I9XFxcInRydWVcXFwiPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInNlbGVjdC1ncm91cFxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic2VsZWN0LWNvbHVtblxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBjbGFzcz1cXFwic3RhbmQtYWxvbmUtY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJfX2NhcmQuaXRlbS52aWV3RGF0YS5zZWxlY3RlZFxcXCIgbmctY2hhbmdlPVxcXCJfX2NhcmQuc2VsZWN0aW9uQ2hhbmdlZCgpXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCAgIG5nLWRpc2FibGVkPVxcXCJfX2NhcmQuaXRlbS52aWV3RGF0YS5kaXNhYmxlZFNlbGVjdGlvblxcXCIgdGl0bGU9XFxcInt7X19jYXJkLml0ZW0udmlld0RhdGEuc2VsZWN0aW9uVGl0bGV9fVxcXCIgLz5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtY29udGVudFxcXCI+XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZCBzZWxlY3RhYmxlXFxcIiBuZy1jbGFzcz1cXFwieyAnc2VsZWN0ZWQnOiBfX2NhcmQuaXRlbS52aWV3RGF0YS5zZWxlY3RlZCB9XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJoZWFkZXIgYWN0aXZlXFxcIiBuZy1jbGljaz1cXFwiX19jYXJkLnRvZ2dsZUNvbnRlbnQoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXJlcGVhdD1cXFwiY29sdW1uIGluIF9fY2FyZC5jb2x1bW5zXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8cmwtY2FyZC1oZWFkZXItY29sdW1uIGNvbHVtbj1cXFwiY29sdW1uXFxcIiBpdGVtPVxcXCJfX2NhcmQuaXRlbVxcXCI+PC9ybC1jYXJkLWhlYWRlci1jb2x1bW4+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1zaG93PVxcXCJfX2NhcmQuc2hvd0NvbnRlbnRcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDxuZy1mb3JtIHJsLWF1dG9zYXZlPVxcXCJfX2NhcmQuYXV0b3NhdmVMaW5rXFxcIiBzYXZlPVxcXCJfX2NhcmQuc2F2ZUNhcmQoKVxcXCIgdmFsaWRhdGU9XFxcIl9fY2FyZC52YWxpZGF0ZUNhcmQoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiYm9keVxcXCIgbmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IF9fY2FyZC5jbGlja2FibGUgfVxcXCIgbmctY2xpY2s9XFxcIl9fY2FyZC5jbGlja0NhcmQoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvbmctZm9ybT5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcIl9fY2FyZC5oYXNGb290ZXIgJiYgKF9fY2FyZC5zaG93Q29udGVudCB8fCBfX2NhcmQucGVybWFuZW50Rm9vdGVyKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9vdGVyXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb290ZXItdGVtcGxhdGVcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3RlbXBsYXRlPlxcclxcbjwvcmwtZ2VuZXJpYy1jb250YWluZXI+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2NhcmQuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19nZW5lcmljU2VhcmNoRmlsdGVyID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmdlbmVyaWNTZWFyY2hGaWx0ZXI7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuY2FyZFNlYXJjaCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmRTZWFyY2gnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRTZWFyY2hDb250cm9sbGVyJztcclxuZXhwb3J0cy5kZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXIgPSAnU2VhcmNoJztcclxuZXhwb3J0cy5kZWZhdWx0U2VhcmNoRGVsYXkgPSAxMDAwO1xyXG52YXIgQ2FyZFNlYXJjaENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZFNlYXJjaENvbnRyb2xsZXIoJHNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hMZW5ndGhFcnJvciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGFzU2VhcmNoRmlsdGVyID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5jb250YWluZXJTZXJ2aWNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zZWFyY2hGaWx0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5jb250YWluZXJTZXJ2aWNlLmxvb2t1cEZpbHRlcihfX2dlbmVyaWNTZWFyY2hGaWx0ZXIuZmlsdGVyTmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzU2VhcmNoRmlsdGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzU2VhcmNoRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoUGxhY2Vob2xkZXIgPSBleHBvcnRzLmRlZmF1bHRTZWFyY2hQbGFjZWhvbGRlcjtcclxuICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLmNvbnRhaW5lclNlcnZpY2UuZGF0YVNvdXJjZTtcclxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5kZWxheSAhPSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZGVsYXlcclxuICAgICAgICAgICAgICAgIDogZXhwb3J0cy5kZWZhdWx0U2VhcmNoRGVsYXk7XHJcbiAgICAgICAgICAgIHZhciB0aW1lcjtcclxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWFyY2hUZXh0OyB9LCBmdW5jdGlvbiAoc2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dCA9IHNlYXJjaDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm1pblNlYXJjaExlbmd0aCA9IF90aGlzLnNlYXJjaEZpbHRlci5taW5TZWFyY2hMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZGF0ZVNlYXJjaExlbmd0aChzZWFyY2gsIF90aGlzLm1pblNlYXJjaExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aW1lciA9ICR0aW1lb3V0KGRhdGFTb3VyY2UucmVmcmVzaC5iaW5kKGRhdGFTb3VyY2UpLCBkZWxheSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIENhcmRTZWFyY2hDb250cm9sbGVyLnByb3RvdHlwZS52YWxpZGF0ZVNlYXJjaExlbmd0aCA9IGZ1bmN0aW9uIChzZWFyY2gsIG1pbkxlbmd0aCkge1xyXG4gICAgICAgIC8vIHNob3cgZXJyb3IgaWYgc2VhcmNoIHN0cmluZyBleGlzdHMgYnV0IGlzIGJlbG93IG1pbmltdW0gc2l6ZVxyXG4gICAgICAgIHRoaXMuc2VhcmNoTGVuZ3RoRXJyb3IgPSBzZWFyY2ggIT0gbnVsbFxyXG4gICAgICAgICAgICAmJiBzZWFyY2gubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAmJiBzZWFyY2gubGVuZ3RoIDwgbWluTGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIENhcmRTZWFyY2hDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckdGltZW91dCddO1xyXG4gICAgcmV0dXJuIENhcmRTZWFyY2hDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNhcmRTZWFyY2hDb250cm9sbGVyID0gQ2FyZFNlYXJjaENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGNhcmRTZWFyY2goKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vY2FyZFNlYXJjaC5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjYXJkU2VhcmNoJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBkZWxheTogJz1zZWFyY2hEZWxheScsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclNlcnZpY2U6ICc9JyxcclxuICAgICAgICAgICAgc2VhcmNoRmlsdGVyOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jYXJkU2VhcmNoID0gY2FyZFNlYXJjaDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBjYXJkU2VhcmNoKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQ2FyZFNlYXJjaENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJkU2VhcmNoLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiIG5nLXNob3c9XFxcImNhcmRTZWFyY2guaGFzU2VhcmNoRmlsdGVyXFxcIiBuZy1jbGFzcz1cXFwieyAnaGFzLWVycm9yJzogY2FyZFNlYXJjaC5zZWFyY2hMZW5ndGhFcnJvciB9XFxcIj5cXHJcXG5cXHQ8aW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7Y2FyZFNlYXJjaC5zZWFyY2hQbGFjZWhvbGRlcn19XFxcIiBuZy1tb2RlbD1cXFwiY2FyZFNlYXJjaC5zZWFyY2hUZXh0XFxcIlxcclxcblxcdFxcdFxcdHBvcG92ZXI9XFxcIllvdSBtdXN0IGVudGVyIGF0IGxlYXN0IHt7Y2FyZFNlYXJjaC5taW5TZWFyY2hMZW5ndGh9fSBjaGFyYWN0ZXJzIHRvIHBlcmZvcm0gYSBzZWFyY2hcXFwiIHBvcG92ZXItdHJpZ2dlcj1cXFwibW91c2VlbnRlclxcXCIgcG9wb3Zlci1lbmFibGU9XFxcImNhcmRTZWFyY2guc2VhcmNoTGVuZ3RoRXJyb3JcXFwiIC8+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIj5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctZGlzYWJsZWQ9XFxcImNhcmRTZWFyY2guc2VhcmNoVGV4dCB8IGlzRW1wdHlcXFwiIG5nLWNsaWNrPVxcXCJjYXJkU2VhcmNoLnNlYXJjaFRleHQgPSBudWxsXFxcIj5cXHJcXG5cXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtdGltZXNcXFwiPjwvaT5cXHJcXG5cXHRcXHQ8L2J1dHRvbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5odG1sXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgc29ydERpcmVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc29ydHMvc29ydERpcmVjdGlvbicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmNvbHVtbkhlYWRlcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENvbHVtbkhlYWRlcic7XHJcbmNhcmRDb2x1bW5IZWFkZXIuJGluamVjdCA9IFsnJGNvbXBpbGUnXTtcclxuZnVuY3Rpb24gY2FyZENvbHVtbkhlYWRlcigkY29tcGlsZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICdeXnJsQ2FyZENvbnRhaW5lcicsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGRpdiBybC1zaXplLWZvci1icmVha3BvaW50cz1cXFwiY29sdW1uLnNpemVcXFwiIG5nLWNsaWNrPVxcXCJzb3J0KClcXFwiIHRpdGxlPVxcXCJ7ezo6Y29sdW1uLmRlc2NyaXB0aW9ufX1cXFwiXFxuXFx0XFx0XFx0XFx0XFx0Y2xhc3M9XFxcImNvbHVtbi1oZWFkZXJcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInRlbXBsYXRlLWNvbnRhaW5lclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGlubGluZS1ibG9ja1xcXCI+PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGkgbmctc2hvdz1cXFwic29ydGluZyA9PT0gc29ydERpcmVjdGlvbi5hc2NlbmRpbmdcXFwiIGNsYXNzPVxcXCJmYSBmYS1zb3J0LWFzY1xcXCI+PC9pPlxcblxcdFxcdFxcdFxcdDxpIG5nLXNob3c9XFxcInNvcnRpbmcgPT09IHNvcnREaXJlY3Rpb24uZGVzY2VuZGluZ1xcXCIgY2xhc3M9XFxcImZhIGZhLXNvcnQtZGVzY1xcXCI+PC9pPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFwiLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIGNvbHVtbjogJz0nLFxyXG4gICAgICAgICAgICBzb3J0aW5nOiAnPScsXHJcbiAgICAgICAgICAgIHNvcnQ6ICcmJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHNjb3BlLmNvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmhlYWRlclRlbXBsYXRlVXJsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyZWRUZW1wbGF0ZSA9ICRjb21waWxlKCc8ZGl2IG5nLWluY2x1ZGU9XCJcXCcnICsgY29sdW1uLmhlYWRlclRlbXBsYXRlVXJsICsgJ1xcJ1wiPjwvZGl2PicpKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sdW1uLmhlYWRlclRlbXBsYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyZWRUZW1wbGF0ZSA9ICRjb21waWxlKGNvbHVtbi5oZWFkZXJUZW1wbGF0ZSkoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyZWRUZW1wbGF0ZSA9ICgnPGg1PicgKyBjb2x1bW4ubGFiZWwgKyAnPC9oNScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwb3N0OiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUuY29sdW1uLmRpc3BsYXlDb2x1bW5IZWFkZXIgIT0gbnVsbCAmJiBzY29wZS5jb2x1bW4uZGlzcGxheUNvbHVtbkhlYWRlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZWxlbWVudC5maW5kKCcudGVtcGxhdGUtY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZChzY29wZS5yZW5kZXJlZFRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5zb3J0RGlyZWN0aW9uID0gc29ydERpcmVjdGlvbl8xLlNvcnREaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jYXJkQ29sdW1uSGVhZGVyID0gY2FyZENvbHVtbkhlYWRlcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBjYXJkQ29sdW1uSGVhZGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sdW1uSGVhZGVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NvbHVtbkhlYWRlci9jb2x1bW5IZWFkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgU29ydERpcmVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTb3J0RGlyZWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgU29ydERpcmVjdGlvbi50b2dnbGUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gU29ydERpcmVjdGlvbi5hc2NlbmRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnREaXJlY3Rpb24uZGVzY2VuZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBTb3J0RGlyZWN0aW9uLmRlc2NlbmRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnREaXJlY3Rpb24ubm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTb3J0RGlyZWN0aW9uLmFzY2VuZGluZztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU29ydERpcmVjdGlvbi5nZXRGdWxsTmFtZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gU29ydERpcmVjdGlvbi5hc2NlbmRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNvcnREaXJlY3Rpb24uZGVzY2VuZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Rlc2NlbmRpbmcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU29ydERpcmVjdGlvbi5ub25lID0gbmV3IFNvcnREaXJlY3Rpb24oMCk7XHJcbiAgICBTb3J0RGlyZWN0aW9uLmFzY2VuZGluZyA9IG5ldyBTb3J0RGlyZWN0aW9uKDEpO1xyXG4gICAgU29ydERpcmVjdGlvbi5kZXNjZW5kaW5nID0gbmV3IFNvcnREaXJlY3Rpb24oMik7XHJcbiAgICByZXR1cm4gU29ydERpcmVjdGlvbjtcclxufSkoKTtcclxuZXhwb3J0cy5Tb3J0RGlyZWN0aW9uID0gU29ydERpcmVjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydERpcmVjdGlvbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0RGlyZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgc29ydHNfbW9kdWxlXzEgPSByZXF1aXJlKCcuLi9zb3J0cy9zb3J0cy5tb2R1bGUnKTtcclxudmFyIGRhdGFQYWdlciA9IHJlcXVpcmUoJy4vZGF0YVBhZ2VyL2RhdGFQYWdlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZGF0YVBhZ2VyID0gZGF0YVBhZ2VyO1xyXG52YXIgZGF0YVNlcnZpY2VEYXRhU291cmNlID0gcmVxdWlyZSgnLi9kYXRhU2VydmljZURhdGFTb3VyY2UvZGF0YVNlcnZpY2VEYXRhU291cmNlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kYXRhU2VydmljZURhdGFTb3VyY2UgPSBkYXRhU2VydmljZURhdGFTb3VyY2U7XHJcbnZhciBzaW1wbGVEYXRhU291cmNlID0gcmVxdWlyZSgnLi9zaW1wbGVEYXRhU291cmNlL3NpbXBsZURhdGFTb3VyY2Uuc2VydmljZScpO1xyXG5leHBvcnRzLnNpbXBsZURhdGFTb3VyY2UgPSBzaW1wbGVEYXRhU291cmNlO1xyXG52YXIgc2VydmVyU2VhcmNoRGF0YVNvdXJjZSA9IHJlcXVpcmUoJy4vc2VydmVyU2VhcmNoRGF0YVNvdXJjZS9zZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5zZXJ2ZXJTZWFyY2hEYXRhU291cmNlID0gc2VydmVyU2VhcmNoRGF0YVNvdXJjZTtcclxudmFyIGRhdGFTb3VyY2VQcm9jZXNzb3IgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZScpO1xyXG5leHBvcnRzLmRhdGFTb3VyY2VQcm9jZXNzb3IgPSBkYXRhU291cmNlUHJvY2Vzc29yO1xyXG52YXIgZGF0YVNvdXJjZUJhc2UgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kYXRhU291cmNlQmFzZSA9IGRhdGFTb3VyY2VCYXNlO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2RhdGFTb3VyY2UnKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3QubW9kdWxlTmFtZSxcclxuICAgIHNvcnRzX21vZHVsZV8xLm1vZHVsZU5hbWUsXHJcbiAgICBkYXRhUGFnZXIubW9kdWxlTmFtZSxcclxuICAgIGRhdGFTZXJ2aWNlRGF0YVNvdXJjZS5tb2R1bGVOYW1lLFxyXG4gICAgc2ltcGxlRGF0YVNvdXJjZS5tb2R1bGVOYW1lLFxyXG4gICAgc2VydmVyU2VhcmNoRGF0YVNvdXJjZS5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLnNlcnZpY2UoZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzb3JTZXJ2aWNlTmFtZSwgZGF0YVNvdXJjZVByb2Nlc3Nvci5EYXRhU291cmNlUHJvY2Vzc29yKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVNvdXJjZXMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIG1lcmdlU29ydCA9IHJlcXVpcmUoJy4vbWVyZ2VTb3J0L21lcmdlU29ydC5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubWVyZ2VTb3J0ID0gbWVyZ2VTb3J0O1xyXG52YXIgc29ydGVyID0gcmVxdWlyZSgnLi9zb3J0ZXIvc29ydGVyLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5zb3J0ZXIgPSBzb3J0ZXI7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc29ydCcpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zb3J0RGlyZWN0aW9uJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnNvcnRzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICBtZXJnZVNvcnQubW9kdWxlTmFtZSxcclxuICAgIHNvcnRlci5tb2R1bGVOYW1lLFxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydHMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnRzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnNvcnRzLm1lcmdlU29ydCc7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnbWVyZ2VTb3J0JztcclxudmFyIE1lcmdlU29ydCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXJnZVNvcnQoKSB7XHJcbiAgICB9XHJcbiAgICBNZXJnZVNvcnQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZGF0YSwgY29tcGFyZSkge1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wYXJlID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29tcGFyZSA9IHRoaXMuZGVmYXVsdENvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaWQ7XHJcbiAgICAgICAgdmFyIGxlZnQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0O1xyXG4gICAgICAgIG1pZCA9IGRhdGEubGVuZ3RoIC8gMjtcclxuICAgICAgICBsZWZ0ID0gdGhpcy5zb3J0KGRhdGEuc2xpY2UoMCwgbWlkKSwgY29tcGFyZSk7XHJcbiAgICAgICAgcmlnaHQgPSB0aGlzLnNvcnQoZGF0YS5zbGljZShtaWQsIGRhdGEubGVuZ3RoKSwgY29tcGFyZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xyXG4gICAgfTtcclxuICAgIE1lcmdlU29ydC5wcm90b3R5cGUuZGVmYXVsdENvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhIDwgYlxyXG4gICAgICAgICAgICA/IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0Lmxlc3NcclxuICAgICAgICAgICAgOiAoYSA+IGIgPyB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5ncmVhdGVyIDogdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZXF1YWwpO1xyXG4gICAgfTtcclxuICAgIE1lcmdlU29ydC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgd2hpbGUgKGxlZnQubGVuZ3RoICYmIHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyZShsZWZ0WzBdLCByaWdodFswXSkgPT09IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0LmdyZWF0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgZXF1YWwgaXQgc2hvdWxkIHByZXNlcnZlIHNhbWUgb3JkZXIgKHN0YWJsZSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbGVmdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyaWdodC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCByaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1lcmdlU29ydDtcclxufSkoKTtcclxuZXhwb3J0cy5NZXJnZVNvcnQgPSBNZXJnZVNvcnQ7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBNZXJnZVNvcnQpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZVNvcnQuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9tZXJnZVNvcnQvbWVyZ2VTb3J0LnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIHNvcnREaXJlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NvcnREaXJlY3Rpb24nKTtcclxudmFyIG1lcmdlU29ydF9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9tZXJnZVNvcnQvbWVyZ2VTb3J0LnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5zb3J0cy5zb3J0ZXInO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ3NvcnRlcic7XHJcbnZhciBTb3J0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU29ydGVyKG1lcmdlU29ydCkge1xyXG4gICAgICAgIHRoaXMubWVyZ2VTb3J0ID0gbWVyZ2VTb3J0O1xyXG4gICAgfVxyXG4gICAgU29ydGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGRhdGEsIHNvcnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChzb3J0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXy5pc0FycmF5KHNvcnQpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXZlcnNlU29ydHMgPSBfLmNsb25lKHNvcnQpO1xyXG4gICAgICAgICAgICByZXZlcnNlU29ydHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5yZWR1Y2UocmV2ZXJzZVNvcnRzLCBmdW5jdGlvbiAoc29ydGVkRGF0YSwgbmV4dFNvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaW5nbGVTb3J0KHNvcnRlZERhdGEsIG5leHRTb3J0KTtcclxuICAgICAgICAgICAgfSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNpbmdsZVNvcnQoZGF0YSwgc29ydCk7XHJcbiAgICB9O1xyXG4gICAgU29ydGVyLnByb3RvdHlwZS5zaW5nbGVTb3J0ID0gZnVuY3Rpb24gKGRhdGEsIHNvcnQpIHtcclxuICAgICAgICB2YXIgY29tcGFyZUZ1bmN0aW9uID0gdGhpcy5idWlsZFNvcnRGdW5jdGlvbihzb3J0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVNvcnQuc29ydChkYXRhLCBjb21wYXJlRnVuY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIFNvcnRlci5wcm90b3R5cGUuYnVpbGRTb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiAoc29ydCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZiAoc29ydC5kaXJlY3Rpb24gPT09IHNvcnREaXJlY3Rpb25fMS5Tb3J0RGlyZWN0aW9uLm5vbmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5lcXVhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWVPZkEgPSBzb3J0LmNvbHVtbi5nZXRWYWx1ZShhKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlT2ZCID0gc29ydC5jb2x1bW4uZ2V0VmFsdWUoYik7XHJcbiAgICAgICAgICAgIHZhciBncmVhdGVyUmVzdWx0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZ3JlYXRlcjtcclxuICAgICAgICAgICAgdmFyIGxlc3NSZXN1bHQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5sZXNzO1xyXG4gICAgICAgICAgICB2YXIgZGVzY2VuZGluZ1NvcnQgPSAoc29ydC5kaXJlY3Rpb24gPT09IHNvcnREaXJlY3Rpb25fMS5Tb3J0RGlyZWN0aW9uLmRlc2NlbmRpbmcpO1xyXG4gICAgICAgICAgICB2YXIgZmxpcCA9IHNvcnQuY29sdW1uLmZsaXBTb3J0O1xyXG4gICAgICAgICAgICAvLyBFeGNsdXNpdmUgT1IuLi4gaWYgZmxpcHBpbmcgYSBkZXNjZW5kaW5nIHNvcnQsIHlvdSBnZXQgYW4gYXNjZW5kaW5nIHNvcnRcclxuICAgICAgICAgICAgaWYgKChkZXNjZW5kaW5nU29ydCB8fCBmbGlwKSAmJiAhKGRlc2NlbmRpbmdTb3J0ICYmIGZsaXApKSB7XHJcbiAgICAgICAgICAgICAgICBncmVhdGVyUmVzdWx0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQubGVzcztcclxuICAgICAgICAgICAgICAgIGxlc3NSZXN1bHQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5ncmVhdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZU9mQSA+IHZhbHVlT2ZCXHJcbiAgICAgICAgICAgICAgICA/IGdyZWF0ZXJSZXN1bHRcclxuICAgICAgICAgICAgICAgIDogKHZhbHVlT2ZBIDwgdmFsdWVPZkIgPyBsZXNzUmVzdWx0IDogdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZXF1YWwpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU29ydGVyLiRpbmplY3QgPSBbbWVyZ2VTb3J0X3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gU29ydGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlNvcnRlciA9IFNvcnRlcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5zZXJ2aWNlKGV4cG9ydHMuc2VydmljZU5hbWUsIFNvcnRlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnRlci9zb3J0ZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc29ydHMvc29ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi8uLi90eXBpbmdzL2xvZGFzaFR5cGVFeHRlbnNpb25zLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMuZGF0YVBhZ2VyJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdkYXRhUGFnZXInO1xyXG5leHBvcnRzLmRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG52YXIgRGF0YVBhZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGFQYWdlcigpIHtcclxuICAgICAgICB0aGlzLnBhZ2VOdW1iZXIgPSAxO1xyXG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBleHBvcnRzLmRlZmF1bHRQYWdlU2l6ZTtcclxuICAgIH1cclxuICAgIERhdGFQYWdlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGRhdGFTZXQpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMucGFnZVNpemU7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gKHRoaXMucGFnZU51bWJlciAtIDEpICogc2l6ZTtcclxuICAgICAgICByZXR1cm4gXyhkYXRhU2V0KVxyXG4gICAgICAgICAgICAuZHJvcChzdGFydClcclxuICAgICAgICAgICAgLnRha2Uoc2l6ZSlcclxuICAgICAgICAgICAgLnZhbHVlKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGFQYWdlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRhUGFnZXIgPSBEYXRhUGFnZXI7XHJcbmZ1bmN0aW9uIGRhdGFQYWdlckZhY3RvcnkoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YVBhZ2VyKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5kYXRhUGFnZXJGYWN0b3J5ID0gZGF0YVBhZ2VyRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIGRhdGFQYWdlckZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhUGFnZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhUGFnZXIvZGF0YVBhZ2VyLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgX19hcnJheSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIGRhdGFTb3VyY2VCYXNlX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UnKTtcclxudmFyIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMuZGF0YVNlcnZpY2VEYXRhU291cmNlJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdkYXRhU2VydmljZURhdGFTb3VyY2UnO1xyXG52YXIgRGF0YVNlcnZpY2VEYXRhU291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEYXRhU2VydmljZURhdGFTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXRhU2VydmljZURhdGFTb3VyY2UoZ2V0RGF0YVNldCwgJHEsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSk7XHJcbiAgICAgICAgdGhpcy5nZXREYXRhU2V0ID0gZ2V0RGF0YVNldDtcclxuICAgICAgICB0aGlzLiRxID0gJHE7XHJcbiAgICAgICAgdGhpcy5jb3VudEZpbHRlckdyb3VwcyA9IHRydWU7XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmdldERhdGFTZXQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRGF0YVNlcnZpY2VEYXRhU291cmNlLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRhdGFTZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nRGF0YVNldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy4kcS53aGVuKHRoaXMuZ2V0RGF0YVNldCgpKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmdEYXRhU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLnJhd0RhdGFTZXQgPSBkYXRhO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIF90aGlzLm9ic2VydmFibGUuZmlyZSgncmVsb2FkZWQnKTtcclxuICAgICAgICAgICAgX3RoaXMub2JzZXJ2YWJsZS5maXJlKCdjaGFuZ2VkJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGFTZXJ2aWNlRGF0YVNvdXJjZTtcclxufSkoZGF0YVNvdXJjZUJhc2Vfc2VydmljZV8xLkRhdGFTb3VyY2VCYXNlKTtcclxuZXhwb3J0cy5EYXRhU2VydmljZURhdGFTb3VyY2UgPSBEYXRhU2VydmljZURhdGFTb3VyY2U7XHJcbmRhdGFTZXJ2aWNlRGF0YVNvdXJjZUZhY3RvcnkuJGluamVjdCA9IFtfX29ic2VydmFibGUuZmFjdG9yeU5hbWUsIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xLnByb2Nlc3NvclNlcnZpY2VOYW1lLCBfX2FycmF5LnNlcnZpY2VOYW1lLCAnJHEnXTtcclxuZnVuY3Rpb24gZGF0YVNlcnZpY2VEYXRhU291cmNlRmFjdG9yeShvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksICRxKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoZ2V0RGF0YVNldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFTZXJ2aWNlRGF0YVNvdXJjZShnZXREYXRhU2V0LCAkcSwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRhdGFTZXJ2aWNlRGF0YVNvdXJjZUZhY3RvcnkgPSBkYXRhU2VydmljZURhdGFTb3VyY2VGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZSwgX19hcnJheS5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIGRhdGFTZXJ2aWNlRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU2VydmljZURhdGFTb3VyY2Uuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU2VydmljZURhdGFTb3VyY2UvZGF0YVNlcnZpY2VEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgRGF0YVNvdXJjZUJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0YVNvdXJjZUJhc2Uob2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlUHJvY2Vzc29yID0gZGF0YVNvdXJjZVByb2Nlc3NvcjtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICAgICAgdGhpcy5zb3J0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuY291bnRGaWx0ZXJHcm91cHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvYWRpbmdEYXRhU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZUZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuICAgIERhdGFTb3VyY2VCYXNlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24sIGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2YWJsZS5yZWdpc3RlcihhY3Rpb24sIGV2ZW50KTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZERhdGE7XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnRGaWx0ZXJHcm91cHMpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzQW5kQ291bnQodGhpcy5zb3J0cywgdGhpcy5maWx0ZXJzLCB0aGlzLnBhZ2VyLCB0aGlzLnJhd0RhdGFTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzKHRoaXMuc29ydHMsIHRoaXMuZmlsdGVycywgdGhpcy5wYWdlciwgdGhpcy5yYXdEYXRhU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IHByb2Nlc3NlZERhdGEuY291bnQ7XHJcbiAgICAgICAgdGhpcy5kYXRhU2V0ID0gcHJvY2Vzc2VkRGF0YS5kYXRhU2V0O1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWREYXRhU2V0ID0gcHJvY2Vzc2VkRGF0YS5maWx0ZXJlZERhdGFTZXQ7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRpbmdEYXRhU2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ3JlZHJhd2luZycpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYXJyYXkucmVtb3ZlKHRoaXMucmF3RGF0YVNldCwgZGF0YSk7XHJcbiAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgncmVtb3ZlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgnY2hhbmdlZCcpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYWdlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldC5wdXNoKGRhdGEpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKCdhZGRlZCcpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKCdjaGFuZ2VkJyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAob2xkRGF0YSwgbmV3RGF0YSkge1xyXG4gICAgICAgIHZhciBsb2NhdGlvbk9mT2xkRGF0YSA9IHRoaXMucmF3RGF0YVNldC5pbmRleE9mKG9sZERhdGEpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbk9mT2xkRGF0YSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXkucmVwbGFjZSh0aGlzLnJhd0RhdGFTZXQsIG9sZERhdGEsIG5ld0RhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZSgncmVwbGFjZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2NoYW5nZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRhU291cmNlQmFzZTtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRhU291cmNlQmFzZSA9IERhdGFTb3VyY2VCYXNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU291cmNlQmFzZS5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgc29ydGVyX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL3NvcnRzL3NvcnRlci9zb3J0ZXIuc2VydmljZScpO1xyXG5leHBvcnRzLnByb2Nlc3NvclNlcnZpY2VOYW1lID0gJ2RhdGFTb3VyY2VQcm9jZXNzb3InO1xyXG52YXIgRGF0YVNvdXJjZVByb2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhU291cmNlUHJvY2Vzc29yKG9iamVjdCwgc29ydGVyKSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgdGhpcy5zb3J0ZXIgPSBzb3J0ZXI7XHJcbiAgICB9XHJcbiAgICBEYXRhU291cmNlUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNvcnRzLCBmaWx0ZXJzLCBwYWdlciwgZGF0YSkge1xyXG4gICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gZGF0YTtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eShzb3J0cykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLnNvcnRlci5zb3J0KHByb2Nlc3NlZERhdGEsIHNvcnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0LmlzTnVsbE9yRW1wdHkoZmlsdGVycykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSBfLnJlZHVjZShmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyZWREYXRhLCBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciB0aGUgZGF0YSBzZXQgdXNpbmcgdGhlIGZpbHRlciBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5maWx0ZXIoZmlsdGVyZWREYXRhLCBmaWx0ZXIuZmlsdGVyLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9LCBwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgY291bnQ6IChwcm9jZXNzZWREYXRhICE9IG51bGwgPyBwcm9jZXNzZWREYXRhLmxlbmd0aCA6IDApLFxyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgICAgIGRhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocGFnZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVNldCA9IHBhZ2VyLmZpbHRlcihwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzQW5kQ291bnQgPSBmdW5jdGlvbiAoc29ydHMsIGZpbHRlcnMsIHBhZ2VyLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZmlsdGVycyB0aGF0IG5lZWQgdG8gdXBkYXRlZCBvcHRpb24gY291bnRzLCB1c2UgdGhlIG5vcm1hbCBwcm9jZXNzb3JcclxuICAgICAgICBpZiAodGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eShmaWx0ZXJzKVxyXG4gICAgICAgICAgICB8fCBfLmFueShmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7IHJldHVybiBfLmlzRnVuY3Rpb24oZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cyk7IH0pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHNvcnRzLCBmaWx0ZXJzLCBwYWdlciwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gZGF0YTtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eShzb3J0cykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLnNvcnRlci5zb3J0KHByb2Nlc3NlZERhdGEsIHNvcnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdyYXBwZWREYXRhID0gdGhpcy53cmFwRGF0YShwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICAvLyBSdW4gZmlsdHJhdGlvbiBsb2dpYyBhbmQgY29tcHV0ZSB2aXNpYmxlIGl0ZW1zXHJcbiAgICAgICAgXy5lYWNoKGZpbHRlcnMsIGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgXy5lYWNoKHdyYXBwZWREYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5maWx0ZXJEYXRhW2ZpbHRlci50eXBlXSA9IGZpbHRlci5maWx0ZXIoaXRlbS5kYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gR2l2ZSBlYWNoIGZpbHRlciBhIGNoYW5jZSB0byB1cGRhdGUgb3B0aW9uIGNvdW50c1xyXG4gICAgICAgIF8uZWFjaChmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlckZpbHRlcnNBcHBsaWVkID0gXy5maWx0ZXIod3JhcHBlZERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT21pdCB0aGUgdHJ1ZSBvciBmYWxzZSBvZiB0aGUgY3VycmVudCBmaWx0ZXIgYW5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgb25seSBmaWx0ZXIgb3V0IGl0ZW1zIHJlbW92ZWQgYnkgb3RoZXIgZmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJEYXRhID0gXy5vbWl0KGl0ZW0uZmlsdGVyRGF0YSwgZmlsdGVyLnR5cGUpOyAvLypmaWx0ZXJEYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uYWxsKF8udmFsdWVzKGZpbHRlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cyhfdGhpcy51bndyYXBEYXRhKG90aGVyRmlsdGVyc0FwcGxpZWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEZpbHRlciBkb3duIHRvIGZpbmFsIGRhdGEgc2V0IGJ5IHJlbW92aW5nIGl0ZW1zIHRoYXQgZG9uJ3QgbWF0Y2ggYWxsIGZpbHRlcnNcclxuICAgICAgICB3cmFwcGVkRGF0YSA9IF8uZmlsdGVyKHdyYXBwZWREYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5hbGwoXy52YWx1ZXMoaXRlbS5maWx0ZXJEYXRhKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMudW53cmFwRGF0YSh3cmFwcGVkRGF0YSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgY291bnQ6IHByb2Nlc3NlZERhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgICAgIGRhdGFTZXQ6IHByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocGFnZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVNldCA9IHBhZ2VyLmZpbHRlcihwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlUHJvY2Vzc29yLnByb3RvdHlwZS53cmFwRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIF8ubWFwKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyRGF0YToge30sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZVByb2Nlc3Nvci5wcm90b3R5cGUudW53cmFwRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIF8ubWFwKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZVByb2Nlc3Nvci4kaW5qZWN0ID0gW19fb2JqZWN0LnNlcnZpY2VOYW1lLCBzb3J0ZXJfc2VydmljZV8xLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBEYXRhU291cmNlUHJvY2Vzc29yO1xyXG59KSgpO1xyXG5leHBvcnRzLkRhdGFTb3VyY2VQcm9jZXNzb3IgPSBEYXRhU291cmNlUHJvY2Vzc29yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU291cmNlUHJvY2Vzc29yLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxudmFyIF9fYXJyYXkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYXJyYXk7XHJcbnZhciBkYXRhU291cmNlQmFzZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9kYXRhU291cmNlQmFzZS5zZXJ2aWNlJyk7XHJcbnZhciBkYXRhU291cmNlUHJvY2Vzc29yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2VzLnNpbXBsZURhdGFTb3VyY2UnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3NpbXBsZURhdGFTb3VyY2UnO1xyXG52YXIgU2ltcGxlRGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2ltcGxlRGF0YVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZURhdGFTb3VyY2UoZGF0YSwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB0aGlzLmNvdW50RmlsdGVyR3JvdXBzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yYXdEYXRhU2V0ID0gZGF0YTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NEYXRhKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2ltcGxlRGF0YVNvdXJjZTtcclxufSkoZGF0YVNvdXJjZUJhc2Vfc2VydmljZV8xLkRhdGFTb3VyY2VCYXNlKTtcclxuZXhwb3J0cy5TaW1wbGVEYXRhU291cmNlID0gU2ltcGxlRGF0YVNvdXJjZTtcclxuc2ltcGxlRGF0YVNvdXJjZUZhY3RvcnkuJGluamVjdCA9IFtfX29ic2VydmFibGUuZmFjdG9yeU5hbWUsIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xLnByb2Nlc3NvclNlcnZpY2VOYW1lLCBfX2FycmF5LnNlcnZpY2VOYW1lXTtcclxuZnVuY3Rpb24gc2ltcGxlRGF0YVNvdXJjZUZhY3Rvcnkob2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURhdGFTb3VyY2UoZGF0YSwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNpbXBsZURhdGFTb3VyY2VGYWN0b3J5ID0gc2ltcGxlRGF0YVNvdXJjZUZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JzZXJ2YWJsZS5tb2R1bGVOYW1lLCBfX2FycmF5Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgc2ltcGxlRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVEYXRhU291cmNlLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvc2ltcGxlRGF0YVNvdXJjZS9zaW1wbGVEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgX19hcnJheSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fc3luY2hyb25pemVkUmVxdWVzdHMgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3luY2hyb25pemVkUmVxdWVzdHM7XHJcbnZhciBkYXRhU291cmNlQmFzZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9kYXRhU291cmNlQmFzZS5zZXJ2aWNlJyk7XHJcbnZhciBkYXRhU291cmNlUHJvY2Vzc29yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2VzLnNlcnZlclNlYXJjaERhdGFTb3VyY2UnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3NlcnZlclNlYXJjaERhdGFTb3VyY2UnO1xyXG52YXIgU2VydmVyU2VhcmNoRGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2VydmVyU2VhcmNoRGF0YVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNlcnZlclNlYXJjaERhdGFTb3VyY2UoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB0aGlzLnNlYXJjaEZpbHRlciA9IHNlYXJjaEZpbHRlcjtcclxuICAgICAgICB0aGlzLmdldEZpbHRlck1vZGVsID0gZ2V0RmlsdGVyTW9kZWw7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGVsID0gdmFsaWRhdGVNb2RlbDtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLm1pblNlYXJjaExlbmd0aCA9IDQ7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlUmVsb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgX3RoaXMubG9hZGluZ0RhdGFTZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMucmF3RGF0YVNldCA9IGRhdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgX3RoaXMub2JzZXJ2YWJsZS5maXJlKCdyZWxvYWRlZCcpO1xyXG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2NoYW5nZWQnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2V0RmlsdGVyTW9kZWwgPSB0aGlzLmdldEZpbHRlck1vZGVsIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGVsID0gdGhpcy52YWxpZGF0ZU1vZGVsIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICAgICAgdGhpcy5jb3VudEZpbHRlckdyb3VwcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dDtcclxuICAgICAgICB0aGlzLmZpbHRlck1vZGVsID0gXy5jbG9uZSh0aGlzLmdldEZpbHRlck1vZGVsKCkpO1xyXG4gICAgICAgIHNlYXJjaEZpbHRlci5taW5TZWFyY2hMZW5ndGggPSB0aGlzLm1pblNlYXJjaExlbmd0aDtcclxuICAgICAgICB0aGlzLnN5bmNocm9uaXplZFJlcXVlc3RzID0gc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5LmdldEluc3RhbmNlKGdldERhdGFTZXQsIHRoaXMucmVzb2x2ZVJlbG9hZC5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnByb3RvdHlwZSwgXCJnZXREYXRhU2V0XCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN5bmNocm9uaXplZFJlcXVlc3RzLmRhdGFQcm92aWRlciA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2VydmVyU2VhcmNoRGF0YVNvdXJjZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dCAhPT0gdGhpcy5zZWFyY2hcclxuICAgICAgICAgICAgfHwgdGhpcy5maWx0ZXJNb2RlbENoYW5nZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWZyZXNoLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcnZlclNlYXJjaERhdGFTb3VyY2UucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlYXJjaCA9IHRoaXMuc2VhcmNoRmlsdGVyLnNlYXJjaFRleHQ7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJNb2RlbCA9IF8uY2xvbmUodGhpcy5nZXRGaWx0ZXJNb2RlbCgpKTtcclxuICAgICAgICB2YXIgaGFzVmFsaWRTZWFyY2ggPSAhdGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eSh0aGlzLnNlYXJjaCkgJiYgdGhpcy5zZWFyY2gubGVuZ3RoID49IHRoaXMubWluU2VhcmNoTGVuZ3RoO1xyXG4gICAgICAgIHZhciBoYXNWYWxpZEZpbHRlck1vZGVsID0gdGhpcy5maWx0ZXJNb2RlbCAhPSBudWxsICYmIHRoaXMudmFsaWRhdGVNb2RlbCh0aGlzLmZpbHRlck1vZGVsKTtcclxuICAgICAgICBpZiAoIWhhc1ZhbGlkU2VhcmNoICYmICFoYXNWYWxpZEZpbHRlck1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZVJlbG9hZChudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRhdGFTZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nRGF0YVNldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZWRSZXF1ZXN0cy5nZXREYXRhKHRoaXMuYnVpbGRTZWFyY2hQYXJhbXMoKSk7XHJcbiAgICB9O1xyXG4gICAgU2VydmVyU2VhcmNoRGF0YVNvdXJjZS5wcm90b3R5cGUuZmlsdGVyTW9kZWxDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5vYmplY3QuYXJlRXF1YWwodGhpcy5nZXRGaWx0ZXJNb2RlbCgpLCB0aGlzLmZpbHRlck1vZGVsKTtcclxuICAgIH07XHJcbiAgICBTZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnByb3RvdHlwZS5idWlsZFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VhcmNoTW9kZWwgPSB0aGlzLmdldEZpbHRlck1vZGVsKCk7XHJcbiAgICAgICAgaWYgKHNlYXJjaE1vZGVsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2VhcmNoTW9kZWwuc2VhcmNoID0gdGhpcy5zZWFyY2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZWFyY2hNb2RlbCA9IHRoaXMuc2VhcmNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VhcmNoTW9kZWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNlcnZlclNlYXJjaERhdGFTb3VyY2U7XHJcbn0pKGRhdGFTb3VyY2VCYXNlX3NlcnZpY2VfMS5EYXRhU291cmNlQmFzZSk7XHJcbmV4cG9ydHMuU2VydmVyU2VhcmNoRGF0YVNvdXJjZSA9IFNlcnZlclNlYXJjaERhdGFTb3VyY2U7XHJcbnNlcnZlclNlYXJjaERhdGFTb3VyY2VGYWN0b3J5LiRpbmplY3QgPSBbX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lLCBkYXRhU291cmNlUHJvY2Vzc29yX3NlcnZpY2VfMS5wcm9jZXNzb3JTZXJ2aWNlTmFtZSwgX19hcnJheS5zZXJ2aWNlTmFtZSwgX19vYmplY3Quc2VydmljZU5hbWUsIF9fc3luY2hyb25pemVkUmVxdWVzdHMuZmFjdG9yeU5hbWVdO1xyXG5mdW5jdGlvbiBzZXJ2ZXJTZWFyY2hEYXRhU291cmNlRmFjdG9yeShvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksIG9iamVjdCwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlcnZlclNlYXJjaERhdGFTb3VyY2UoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zZXJ2ZXJTZWFyY2hEYXRhU291cmNlRmFjdG9yeSA9IHNlcnZlclNlYXJjaERhdGFTb3VyY2VGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZSwgX19hcnJheS5tb2R1bGVOYW1lLCBfX29iamVjdC5tb2R1bGVOYW1lLCBfX3N5bmNocm9uaXplZFJlcXVlc3RzLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgc2VydmVyU2VhcmNoRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvc2VydmVyU2VhcmNoRGF0YVNvdXJjZS9zZXJ2ZXJTZWFyY2hEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU291cmNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIGNvbHVtblNlYXJjaEZpbHRlciA9IHJlcXVpcmUoJy4vY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuY29sdW1uU2VhcmNoRmlsdGVyID0gY29sdW1uU2VhcmNoRmlsdGVyO1xyXG52YXIgZmlsdGVyR3JvdXAgPSByZXF1aXJlKCcuL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLm1vZHVsZScpO1xyXG5leHBvcnRzLmZpbHRlckdyb3VwID0gZmlsdGVyR3JvdXA7XHJcbnZhciBzZWxlY3RGaWx0ZXIgPSByZXF1aXJlKCcuL3NlbGVjdEZpbHRlci9zZWxlY3RGaWx0ZXIubW9kdWxlJyk7XHJcbmV4cG9ydHMuc2VsZWN0RmlsdGVyID0gc2VsZWN0RmlsdGVyO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIGNvbHVtblNlYXJjaEZpbHRlci5tb2R1bGVOYW1lLFxyXG4gICAgZmlsdGVyR3JvdXAubW9kdWxlTmFtZSxcclxuICAgIHNlbGVjdEZpbHRlci5tb2R1bGVOYW1lXHJcbl0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXJzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlcnMubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBfX3N0cmluZyA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5zdHJpbmc7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZmlsdGVycy5jb2x1bW5TZWFyY2hGaWx0ZXInO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ2NvbHVtblNlYXJjaEZpbHRlcic7XHJcbmV4cG9ydHMuZmlsdGVyTmFtZSA9ICdjb2x1bW4tc2VhcmNoJztcclxudmFyIENvbHVtblNlYXJjaEZpbHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb2x1bW5TZWFyY2hGaWx0ZXIob2JqZWN0LCBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcclxuICAgICAgICB0aGlzLnR5cGUgPSBleHBvcnRzLmZpbHRlck5hbWU7XHJcbiAgICB9XHJcbiAgICBDb2x1bW5TZWFyY2hGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMub2JqZWN0LnRvU3RyaW5nKHRoaXMuY29sdW1uLmdldFZhbHVlKGl0ZW0pKTtcclxuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2hUZXh0O1xyXG4gICAgICAgIGlmICghdGhpcy5jYXNlU2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaCA9IHNlYXJjaC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5jb250YWlucyh2YWx1ZSwgc2VhcmNoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29sdW1uU2VhcmNoRmlsdGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNvbHVtblNlYXJjaEZpbHRlciA9IENvbHVtblNlYXJjaEZpbHRlcjtcclxuY29sdW1uU2VhcmNoRmlsdGVyRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JqZWN0LnNlcnZpY2VOYW1lLCBfX3N0cmluZy5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIGNvbHVtblNlYXJjaEZpbHRlckZhY3Rvcnkob2JqZWN0LCBzdHJpbmcpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2x1bW5TZWFyY2hGaWx0ZXIob2JqZWN0LCBzdHJpbmcpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY29sdW1uU2VhcmNoRmlsdGVyRmFjdG9yeSA9IGNvbHVtblNlYXJjaEZpbHRlckZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWUsIF9fc3RyaW5nLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgY29sdW1uU2VhcmNoRmlsdGVyRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgZmlsdGVyT3B0aW9uID0gcmVxdWlyZSgnLi9maWx0ZXJPcHRpb24vZmlsdGVyT3B0aW9uJyk7XHJcbmV4cG9ydHMuZmlsdGVyT3B0aW9uID0gZmlsdGVyT3B0aW9uO1xyXG52YXIgbW9kZUZpbHRlckdyb3VwID0gcmVxdWlyZSgnLi9tb2RlRmlsdGVyR3JvdXAvbW9kZUZpbHRlckdyb3VwLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2RlRmlsdGVyR3JvdXAgPSBtb2RlRmlsdGVyR3JvdXA7XHJcbnZhciByYW5nZUZpbHRlckdyb3VwID0gcmVxdWlyZSgnLi9yYW5nZUZpbHRlckdyb3VwL3JhbmdlRmlsdGVyR3JvdXAuc2VydmljZScpO1xyXG5leHBvcnRzLnJhbmdlRmlsdGVyR3JvdXAgPSByYW5nZUZpbHRlckdyb3VwO1xyXG52YXIgZmlsdGVyR3JvdXBfc2VydmljZV8xID0gcmVxdWlyZSgnLi9maWx0ZXJHcm91cC5zZXJ2aWNlJyk7XHJcbnZhciBmaWx0ZXJHcm91cF9kaXJlY3RpdmVfMSA9IHJlcXVpcmUoJy4vZmlsdGVyR3JvdXAuZGlyZWN0aXZlJyk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZmlsdGVyR3JvdXAuZGlyZWN0aXZlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2ZpbHRlckdyb3VwLnNlcnZpY2UnKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZmlsdGVycy5maWx0ZXJHcm91cCc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdC5tb2R1bGVOYW1lLFxyXG4gICAgZmlsdGVyT3B0aW9uLm1vZHVsZU5hbWUsXHJcbiAgICBtb2RlRmlsdGVyR3JvdXAubW9kdWxlTmFtZSxcclxuICAgIHJhbmdlRmlsdGVyR3JvdXAubW9kdWxlTmFtZSxcclxuXSlcclxuICAgIC5mYWN0b3J5KGZpbHRlckdyb3VwX3NlcnZpY2VfMS5mYWN0b3J5TmFtZSwgZmlsdGVyR3JvdXBfc2VydmljZV8xLmZpbHRlckdyb3VwRmFjdG9yeSlcclxuICAgIC5kaXJlY3RpdmUoZmlsdGVyR3JvdXBfZGlyZWN0aXZlXzEuZGlyZWN0aXZlTmFtZSwgZmlsdGVyR3JvdXBfZGlyZWN0aXZlXzEuZmlsdGVyR3JvdXApXHJcbiAgICAuY29udHJvbGxlcihmaWx0ZXJHcm91cF9kaXJlY3RpdmVfMS5jb250cm9sbGVyTmFtZSwgZmlsdGVyR3JvdXBfZGlyZWN0aXZlXzEuRmlsdGVyR3JvdXBDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyR3JvdXAubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5maWx0ZXJzLmZpbHRlckdyb3VwLmZpbHRlck9wdGlvbic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEZpbHRlck9wdGlvbic7XHJcbmZ1bmN0aW9uIGZpbHRlck9wdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9maWx0ZXJPcHRpb24uaHRtbCcpLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIGFjdGl2YXRlOiAnJicsXHJcbiAgICAgICAgICAgIGlzQWN0aXZlOiAnPWFjdGl2ZScsXHJcbiAgICAgICAgICAgIG9wdGlvbjogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZmlsdGVyT3B0aW9uID0gZmlsdGVyT3B0aW9uO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGZpbHRlck9wdGlvbik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlck9wdGlvbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlck9wdGlvbi9maWx0ZXJPcHRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJvdyBmaWx0ZXItb3B0aW9uXFxcIiBuZy1jbGFzcz1cXFwieyAnYWN0aXZlJzogaXNBY3RpdmUgfVxcXCIgbmctY2xpY2s9XFxcImFjdGl2YXRlKClcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC14cy0xXFxcIj5cXHJcXG5cXHRcXHQ8aSBjbGFzcz0nZmEgZmEtYXJyb3ctcmlnaHQnIG5nLXNob3c9XFxcImlzQWN0aXZlID09IHRydWVcXFwiPjwvaT5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMVxcXCIgbmctaWY9XFxcImhhc0ljb25cXFwiIG5nLWJpbmQtaHRtbD1cXFwib3B0aW9uLmljb25cXFwiPjwvZGl2PlxcclxcblxcdDxkaXYgbmctY2xhc3M9XFxcInsgJ2NvbC14cy02JzogaGFzSWNvbiwgJ2NvbC14cy03JzogIWhhc0ljb24gfVxcXCI+XFxyXFxuXFx0XFx0e3tvcHRpb24ubGFiZWx9fVxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC14cy0zIHRleHQtcmlnaHRcXFwiIG5nLXNob3c9XFxcIm9wdGlvbi5jb3VudCAhPSBudWxsXFxcIj5cXHJcXG5cXHRcXHQoe3tvcHRpb24uY291bnR9fSlcXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyT3B0aW9uL2ZpbHRlck9wdGlvbi5odG1sXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBmaWx0ZXJHcm91cF9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9maWx0ZXJHcm91cC5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZmlsdGVycy5maWx0ZXJHcm91cC5tb2RlRmlsdGVyR3JvdXAnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ21vZGVGaWx0ZXJHcm91cCc7XHJcbnZhciBNb2RlRmlsdGVyR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1vZGVGaWx0ZXJHcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1vZGVGaWx0ZXJHcm91cChzZXR0aW5ncywgb2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IHNldHRpbmdzLmdldFZhbHVlO1xyXG4gICAgICAgIHNldHRpbmdzLm9wdGlvbnMgPSBfLm1hcChzZXR0aW5ncy5vcHRpb25zLCB0aGlzLmJ1aWxkTW9kZU9wdGlvbiwgdGhpcyk7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MsIG9iamVjdCk7XHJcbiAgICB9XHJcbiAgICBNb2RlRmlsdGVyR3JvdXAucHJvdG90eXBlLmJ1aWxkTW9kZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBtb2RlT3B0aW9uID0gb3B0aW9uO1xyXG4gICAgICAgIG1vZGVPcHRpb24uZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKG1vZGVPcHRpb24uZGlzcGxheUFsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFZhbHVlKGl0ZW0pID09PSBtb2RlT3B0aW9uLnZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG1vZGVPcHRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZGVGaWx0ZXJHcm91cDtcclxufSkoZmlsdGVyR3JvdXBfc2VydmljZV8xLkZpbHRlckdyb3VwKTtcclxuZXhwb3J0cy5Nb2RlRmlsdGVyR3JvdXAgPSBNb2RlRmlsdGVyR3JvdXA7XHJcbm1vZGVGaWx0ZXJHcm91cEZhY3RvcnkuJGluamVjdCA9IFtfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIG1vZGVGaWx0ZXJHcm91cEZhY3Rvcnkob2JqZWN0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlRmlsdGVyR3JvdXAoc2V0dGluZ3MsIG9iamVjdCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5tb2RlRmlsdGVyR3JvdXBGYWN0b3J5ID0gbW9kZUZpbHRlckdyb3VwRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShleHBvcnRzLmZhY3RvcnlOYW1lLCBtb2RlRmlsdGVyR3JvdXBGYWN0b3J5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZUZpbHRlckdyb3VwLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9tb2RlRmlsdGVyR3JvdXAvbW9kZUZpbHRlckdyb3VwLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ2ZpbHRlckdyb3VwJztcclxudmFyIEZpbHRlckdyb3VwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZpbHRlckdyb3VwKHNldHRpbmdzLCBvYmplY3QpIHtcclxuICAgICAgICB0aGlzLmxhYmVsID0gc2V0dGluZ3MubGFiZWw7XHJcbiAgICAgICAgdGhpcy50eXBlID0gc2V0dGluZ3MudHlwZSAhPSBudWxsID8gc2V0dGluZ3MudHlwZSA6IHNldHRpbmdzLmxhYmVsO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHNldHRpbmdzLm9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVPcHRpb24gPSB0aGlzLm9wdGlvbnNbMF07XHJcbiAgICAgICAgXy5lYWNoKHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb24udHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi50eXBlID0gb3B0aW9uLmxhYmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbi50eXBlID0gb2JqZWN0LnRvU3RyaW5nKG9wdGlvbi50eXBlKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRmlsdGVyR3JvdXAucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT3B0aW9uLmZpbHRlcihpdGVtKTtcclxuICAgIH07XHJcbiAgICBGaWx0ZXJHcm91cC5wcm90b3R5cGUuc2V0QWN0aXZlT3B0aW9uID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlT3B0aW9uID0gdGhpcy5vcHRpb25zW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyR3JvdXAucHJvdG90eXBlLnNldE9wdGlvbkNvdW50cyA9IGZ1bmN0aW9uIChjb3VudHMpIHtcclxuICAgICAgICBfLmVhY2godGhpcy5vcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmhhcyhjb3VudHMsIG9wdGlvbi50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLmNvdW50ID0gY291bnRzW29wdGlvbi50eXBlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckdyb3VwLnByb3RvdHlwZS51cGRhdGVPcHRpb25Db3VudHMgPSBmdW5jdGlvbiAoZmlsdGVyZWREYXRhU2V0KSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICBvcHRpb24uY291bnQgPSBfLmZpbHRlcihmaWx0ZXJlZERhdGFTZXQsIG9wdGlvbi5maWx0ZXIsIG9wdGlvbikubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGaWx0ZXJHcm91cDtcclxufSkoKTtcclxuZXhwb3J0cy5GaWx0ZXJHcm91cCA9IEZpbHRlckdyb3VwO1xyXG5maWx0ZXJHcm91cEZhY3RvcnkuJGluamVjdCA9IFtfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIGZpbHRlckdyb3VwRmFjdG9yeShvYmplY3QpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlckdyb3VwKHNldHRpbmdzLCBvYmplY3QpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZmlsdGVyR3JvdXBGYWN0b3J5ID0gZmlsdGVyR3JvdXBGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXJHcm91cC5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgZmlsdGVyR3JvdXBfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vZmlsdGVyR3JvdXAuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuZmlsdGVyR3JvdXAucmFuZ2VGaWx0ZXJHcm91cCc7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAncmFuZ2VGaWx0ZXJHcm91cCc7XHJcbnZhciBSYW5nZUZpbHRlckdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSYW5nZUZpbHRlckdyb3VwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmFuZ2VGaWx0ZXJHcm91cChzZXR0aW5ncywgb2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IHNldHRpbmdzLmdldFZhbHVlO1xyXG4gICAgICAgIHNldHRpbmdzLm9wdGlvbnMgPSBfLm1hcChzZXR0aW5ncy5vcHRpb25zLCB0aGlzLmJ1aWxkUmFuZ2VPcHRpb24sIHRoaXMpO1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzLCBvYmplY3QpO1xyXG4gICAgfVxyXG4gICAgUmFuZ2VGaWx0ZXJHcm91cC5wcm90b3R5cGUuYnVpbGRSYW5nZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBtb2RlT3B0aW9uID0gb3B0aW9uO1xyXG4gICAgICAgIG1vZGVPcHRpb24uZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0VmFsdWUoaXRlbSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb24uaGlnaEV4Y2x1c2l2ZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZSA8IG9wdGlvbi5oaWdoRXhjbHVzaXZlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLmhpZ2hJbmNsdXNpdmUpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgPD0gb3B0aW9uLmhpZ2hJbmNsdXNpdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLmxvd0V4Y2x1c2l2ZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdmFsdWUgPiBvcHRpb24ubG93RXhjbHVzaXZlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLmxvd0luY2x1c2l2ZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdmFsdWUgPj0gb3B0aW9uLmxvd0luY2x1c2l2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG1vZGVPcHRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJhbmdlRmlsdGVyR3JvdXA7XHJcbn0pKGZpbHRlckdyb3VwX3NlcnZpY2VfMS5GaWx0ZXJHcm91cCk7XHJcbnJhbmdlRmlsdGVyR3JvdXBGYWN0b3J5LiRpbmplY3QgPSBbX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiByYW5nZUZpbHRlckdyb3VwRmFjdG9yeShvYmplY3QpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlRmlsdGVyR3JvdXAoc2V0dGluZ3MsIG9iamVjdCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yYW5nZUZpbHRlckdyb3VwRmFjdG9yeSA9IHJhbmdlRmlsdGVyR3JvdXBGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIHJhbmdlRmlsdGVyR3JvdXBGYWN0b3J5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2VGaWx0ZXJHcm91cC5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvcmFuZ2VGaWx0ZXJHcm91cC9yYW5nZUZpbHRlckdyb3VwLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEZpbHRlckdyb3VwJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdGaWx0ZXJHcm91cENvbnRyb2xsZXInO1xyXG52YXIgRmlsdGVyR3JvdXBDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZpbHRlckdyb3VwQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLmhhc0ljb24gPSB0aGlzLmljb24gIT0gbnVsbCAmJiB0aGlzLmljb24gIT09ICcnO1xyXG4gICAgICAgIHRoaXMuc2hvd0NoaWxkcmVuID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIEZpbHRlckdyb3VwQ29udHJvbGxlci5wcm90b3R5cGUudG9nZ2xlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zaG93Q2hpbGRyZW4gPSAhdGhpcy5zaG93Q2hpbGRyZW47XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyR3JvdXBDb250cm9sbGVyLnByb3RvdHlwZS5zZWxlY3RPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJHcm91cC5hY3RpdmVPcHRpb24gPSBvcHRpb247XHJcbiAgICAgICAgdGhpcy5zaG93Q2hpbGRyZW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zb3VyY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLiRzY29wZS4kZW1pdCgnZGF0YVNvdXJjZS5yZXF1ZXN0UmVmcmVzaCcpOyAvLypldmVudD9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyR3JvdXBDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIEZpbHRlckdyb3VwQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5GaWx0ZXJHcm91cENvbnRyb2xsZXIgPSBGaWx0ZXJHcm91cENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGZpbHRlckdyb3VwKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZS5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjb250cm9sbGVyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBpY29uOiAnPScsXHJcbiAgICAgICAgICAgIGZpbHRlckdyb3VwOiAnPScsXHJcbiAgICAgICAgICAgIHNvdXJjZTogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZmlsdGVyR3JvdXAgPSBmaWx0ZXJHcm91cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyR3JvdXAuZGlyZWN0aXZlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAuZGlyZWN0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJmaWx0ZXItZ3JvdXBcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcInJvdyBmaWx0ZXItaGVhZGVyXFxcIiBuZy1jbGljaz1cXFwiY29udHJvbGxlci50b2dnbGVDaGlsZHJlbigpXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTJcXFwiPlxcclxcblxcdFxcdFxcdDxpIGNsYXNzPVxcXCJjb2xsYXBzZS1pY29uIGZhIGZhLWNhcmV0LWRvd24gZmEtMnhcXFwiIG5nLXNob3c9XFxcImNvbnRyb2xsZXIuc2hvd0NoaWxkcmVuXFxcIiB0aXRsZT1cXFwiSGlkZSBmaWx0ZXIgbGlzdFxcXCI+PC9pPlxcclxcblxcdFxcdFxcdDxpIGNsYXNzPVxcXCJjb2xsYXBzZS1pY29uIGZhIGZhLWNhcmV0LXJpZ2h0IGZhLTJ4XFxcIiBuZy1oaWRlPVxcXCJjb250cm9sbGVyLnNob3dDaGlsZHJlblxcXCIgdGl0bGU9XFxcIlNob3cgZmlsdGVyIGxpc3RcXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmaWx0ZXItb3B0aW9uXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OmlubGluZS1ibG9ja1xcXCIgbmctc2hvdz1cXFwiY29udHJvbGxlci5oYXNJY29uXFxcIiBuZy1iaW5kLWh0bWw9XFxcImNvbnRyb2xsZXIuaWNvblxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PGg0IHN0eWxlPVxcXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2tcXFwiPnt7Y29udHJvbGxlci5maWx0ZXJHcm91cC5sYWJlbH19OiB7e2NvbnRyb2xsZXIuZmlsdGVyR3JvdXAuYWN0aXZlT3B0aW9uLmxhYmVsfX08L2g0PlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgbmctc2hvdz1cXFwiY29udHJvbGxlci5zaG93Q2hpbGRyZW5cXFwiIG5nLXJlcGVhdD1cXFwiZmlsdGVyT3B0aW9uIGluIGNvbnRyb2xsZXIuZmlsdGVyR3JvdXAub3B0aW9uc1xcXCI+XFxyXFxuXFx0XFx0PHJsLWZpbHRlci1vcHRpb24gb3B0aW9uPVxcXCJmaWx0ZXJPcHRpb25cXFwiIGFjdGl2ZT1cXFwiZmlsdGVyR3JvdXAuYWN0aXZlT3B0aW9uID09PSBmaWx0ZXJPcHRpb25cXFwiIGFjdGl2YXRlPVxcXCJjb250cm9sbGVyLnNlbGVjdE9wdGlvbihmaWx0ZXJPcHRpb24pXFxcIj48L3JsLWZpbHRlci1vcHRpb24+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZS5odG1sXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgc2VsZWN0RmlsdGVyX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vc2VsZWN0RmlsdGVyLnNlcnZpY2UnKTtcclxudmFyIHNlbGVjdEZpbHRlcl9jb21wb25lbnRfMSA9IHJlcXVpcmUoJy4vc2VsZWN0RmlsdGVyLmNvbXBvbmVudCcpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuc2VsZWN0RmlsdGVyJztcclxuX19leHBvcnQocmVxdWlyZSgnLi9zZWxlY3RGaWx0ZXIuc2VydmljZScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9zZWxlY3RGaWx0ZXIuY29tcG9uZW50JykpO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmZhY3Rvcnkoc2VsZWN0RmlsdGVyX3NlcnZpY2VfMS5mYWN0b3J5TmFtZSwgc2VsZWN0RmlsdGVyX3NlcnZpY2VfMS5zZWxlY3RGaWx0ZXJGYWN0b3J5KVxyXG4gICAgLmRpcmVjdGl2ZShzZWxlY3RGaWx0ZXJfY29tcG9uZW50XzEuZGlyZWN0aXZlTmFtZSwgc2VsZWN0RmlsdGVyX2NvbXBvbmVudF8xLnNlbGVjdEZpbHRlcilcclxuICAgIC5jb250cm9sbGVyKHNlbGVjdEZpbHRlcl9jb21wb25lbnRfMS5jb250cm9sbGVyTmFtZSwgc2VsZWN0RmlsdGVyX2NvbXBvbmVudF8xLlNlbGVjdEZpbHRlckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3RGaWx0ZXIubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3NlbGVjdEZpbHRlcic7XHJcbnZhciBTZWxlY3RGaWx0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VsZWN0RmlsdGVyKHZhbHVlU2VsZWN0b3IpIHtcclxuICAgICAgICB0aGlzLnZhbHVlU2VsZWN0b3IgPSB2YWx1ZVNlbGVjdG9yO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzZWxlY3RGaWx0ZXInO1xyXG4gICAgfVxyXG4gICAgU2VsZWN0RmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoaXRlbSkgPT09IHRoaXMuc2VsZWN0ZWRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBTZWxlY3RGaWx0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMudmFsdWVTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSB0aGlzLnZhbHVlU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiAoZnVuYyhpdGVtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnZhbHVlU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtW3Byb3BlcnR5XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNlbGVjdEZpbHRlcjtcclxufSkoKTtcclxuZnVuY3Rpb24gc2VsZWN0RmlsdGVyRmFjdG9yeSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICh2YWx1ZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0RmlsdGVyKHZhbHVlU2VsZWN0b3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2VsZWN0RmlsdGVyRmFjdG9yeSA9IHNlbGVjdEZpbHRlckZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdEZpbHRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTZWxlY3RGaWx0ZXInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NlbGVjdEZpbHRlckNvbnRyb2xsZXInO1xyXG52YXIgU2VsZWN0RmlsdGVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3RGaWx0ZXJDb250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlbGVjdEZpbHRlckNvbnRyb2xsZXIucHJvdG90eXBlLCBcInNlbGVjdGVkVmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuc2VsZWN0ZWRWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXIuc2VsZWN0ZWRWYWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRzY29wZS4kZW1pdCgnZGF0YVNvdXJjZS5yZXF1ZXN0UmVmcmVzaCcpOyAvLypldmVudD9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2VsZWN0RmlsdGVyQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBTZWxlY3RGaWx0ZXJDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlNlbGVjdEZpbHRlckNvbnRyb2xsZXIgPSBTZWxlY3RGaWx0ZXJDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBzZWxlY3RGaWx0ZXIoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vc2VsZWN0RmlsdGVyLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2ZpbHRlcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgZmlsdGVyOiAnPScsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6ICc9JyxcclxuICAgICAgICAgICAgZ2V0T3B0aW9uczogJyYnLFxyXG4gICAgICAgICAgICBzb3VyY2U6ICc9JyxcclxuICAgICAgICAgICAgbGFiZWw6ICdAJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICc9JyxcclxuICAgICAgICAgICAgbnVsbE9wdGlvbjogJ0AnXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zZWxlY3RGaWx0ZXIgPSBzZWxlY3RGaWx0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdEZpbHRlci5jb21wb25lbnQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9zZWxlY3RGaWx0ZXIvc2VsZWN0RmlsdGVyLmNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiZmlsdGVyLWdyb3VwXFxcIj5cXHJcXG5cXHQ8cmwtc2VsZWN0IG5nLW1vZGVsPVxcXCJmaWx0ZXIuc2VsZWN0ZWRWYWx1ZVxcXCIgb3B0aW9ucz1cXFwiZmlsdGVyLm9wdGlvbnNcXFwiIGxhYmVsPVxcXCJ7e2ZpbHRlci5sYWJlbH19XFxcIlxcclxcblxcdFxcdFxcdCAgIHNlbGVjdG9yPVxcXCJmaWx0ZXIuc2VsZWN0b3JcXFwiIGdldC1vcHRpb25zPVxcXCJmaWx0ZXIuZ2V0T3B0aW9ucygpXFxcIiBudWxsLW9wdGlvbj1cXFwie3tmaWx0ZXIubnVsbE9wdGlvbn19XFxcIj48L3JsLXNlbGVjdD5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5odG1sXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuaXRlbUNvdW50JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsSXRlbUNvdW50JztcclxuZnVuY3Rpb24gaXRlbUNvdW50KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICdeXnJsQ2FyZENvbnRhaW5lcicsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vaXRlbUNvdW50Lmh0bWwnKSxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBjb250YWluZXJTZXJ2aWNlOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5pdGVtQ291bnQgPSBpdGVtQ291bnQ7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgaXRlbUNvdW50KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbUNvdW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2l0ZW1Db3VudC9pdGVtQ291bnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxwIG5nLXNob3c9XFxcIiFjb250YWluZXJTZXJ2aWNlLmRhdGFTb3VyY2UubG9hZGluZ0RhdGFTZXRcXFwiPlxcclxcblxcdFNob3dpbmcgPHN0cm9uZz57e2NvbnRhaW5lclNlcnZpY2UuZGF0YVNvdXJjZS5kYXRhU2V0Lmxlbmd0aH19IG9mIHt7Y29udGFpbmVyU2VydmljZS5kYXRhU291cmNlLmNvdW50fX08L3N0cm9uZz4gdG90YWwgaXRlbXNcXHJcXG48L3A+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9pdGVtQ291bnQvaXRlbUNvdW50Lmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnBhZ2VyJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsUGFnZXInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1BhZ2VyQ29udHJvbGxlcic7XHJcbmV4cG9ydHMuZGVmYXVsdFZpc2libGVQYWdlQ291bnQgPSA1O1xyXG52YXIgUGFnZXJDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhZ2VyQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2FuR29CYWNrID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW5Hb0ZvcndhcmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhhc1BhZ2VGaWx0ZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUGFnZUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdG90YWxJdGVtcyA9IF90aGlzLmRhdGFTb3VyY2UuY291bnQ7XHJcbiAgICAgICAgICAgIHZhciBuZXdMYXN0UGFnZSA9IE1hdGguY2VpbCh0b3RhbEl0ZW1zIC8gX3RoaXMucGFnZXIucGFnZVNpemUpO1xyXG4gICAgICAgICAgICBpZiAobmV3TGFzdFBhZ2UgIT09IF90aGlzLmxhc3RQYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0UGFnZSA9IG5ld0xhc3RQYWdlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFBhZ2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVBhZ2luZygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyU2VydmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYWdlciA9IHRoaXMuY29udGFpbmVyU2VydmljZS5wYWdlcjtcclxuICAgICAgICBpZiAodGhpcy5wYWdlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUGFnZUZpbHRlciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlUGFnZUNvdW50ID0gdGhpcy5wYWdlQ291bnQgIT0gbnVsbCA/IHRoaXMucGFnZUNvdW50IDogZXhwb3J0cy5kZWZhdWx0VmlzaWJsZVBhZ2VDb3VudDtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UGFnZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuY29udGFpbmVyU2VydmljZS5kYXRhU291cmNlO1xyXG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRhdGFTb3VyY2UuY291bnQ7IH0sIHRoaXMudXBkYXRlUGFnZUNvdW50KTtcclxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wYWdlci5wYWdlU2l6ZTsgfSwgdGhpcy51cGRhdGVQYWdlQ291bnQpO1xyXG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmN1cnJlbnRQYWdlOyB9LCBmdW5jdGlvbiAocGFnZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFnaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wYWdlci5wYWdlTnVtYmVyID0gcGFnZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRhdGFTb3VyY2UucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBQYWdlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVBhZ2luZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XHJcbiAgICAgICAgdGhpcy5jYW5Hb0JhY2sgPSBwYWdlID4gMTtcclxuICAgICAgICB0aGlzLmNhbkdvRm9yd2FyZCA9IHBhZ2UgPCB0aGlzLmxhc3RQYWdlO1xyXG4gICAgICAgIHZhciBub25DdXJyZW50VmlzaWJsZVBhZ2VzID0gdGhpcy52aXNpYmxlUGFnZUNvdW50IC0gMTtcclxuICAgICAgICB2YXIgYmVmb3JlID0gTWF0aC5mbG9vcihub25DdXJyZW50VmlzaWJsZVBhZ2VzIC8gMik7XHJcbiAgICAgICAgdmFyIGFmdGVyID0gTWF0aC5jZWlsKG5vbkN1cnJlbnRWaXNpYmxlUGFnZXMgLyAyKTtcclxuICAgICAgICB2YXIgc3RhcnRQYWdlID0gcGFnZSAtIGJlZm9yZTtcclxuICAgICAgICB2YXIgZW5kUGFnZSA9IHBhZ2UgKyBhZnRlcjtcclxuICAgICAgICBpZiAoc3RhcnRQYWdlIDwgMSkge1xyXG4gICAgICAgICAgICBzdGFydFBhZ2UgPSAxO1xyXG4gICAgICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4odGhpcy52aXNpYmxlUGFnZUNvdW50LCB0aGlzLmxhc3RQYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZW5kUGFnZSA+IHRoaXMubGFzdFBhZ2UpIHtcclxuICAgICAgICAgICAgZW5kUGFnZSA9IHRoaXMubGFzdFBhZ2U7XHJcbiAgICAgICAgICAgIHN0YXJ0UGFnZSA9IE1hdGgubWF4KHRoaXMubGFzdFBhZ2UgLSBub25DdXJyZW50VmlzaWJsZVBhZ2VzLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYWdlcyA9IF8ucmFuZ2Uoc3RhcnRQYWdlLCBlbmRQYWdlICsgMSk7XHJcbiAgICB9O1xyXG4gICAgUGFnZXJDb250cm9sbGVyLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gMTtcclxuICAgIH07XHJcbiAgICBQYWdlckNvbnRyb2xsZXIucHJvdG90eXBlLnByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlID4gMSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlLS07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhZ2VyQ29udHJvbGxlci5wcm90b3R5cGUuZ290byA9IGZ1bmN0aW9uIChwYWdlKSB7XHJcbiAgICAgICAgaWYgKHBhZ2UgPj0gMSAmJiBwYWdlIDw9IHRoaXMubGFzdFBhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhZ2VyQ29udHJvbGxlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGFnZSA8IHRoaXMubGFzdFBhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZSsrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWdlckNvbnRyb2xsZXIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHRoaXMubGFzdFBhZ2U7XHJcbiAgICB9O1xyXG4gICAgUGFnZXJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIFBhZ2VyQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5QYWdlckNvbnRyb2xsZXIgPSBQYWdlckNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHBhZ2VyKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3BhZ2VyLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3BhZ2VyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBwYWdlQ291bnQ6ICc9dmlzaWJsZVBhZ2VzJyxcclxuICAgICAgICAgICAgY29udGFpbmVyU2VydmljZTogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucGFnZXIgPSBwYWdlcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBwYWdlcilcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFBhZ2VyQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3BhZ2VyL3BhZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8bmF2IG5nLWlmPVxcXCJwYWdlci5oYXNQYWdlRmlsdGVyXFxcIj5cXHJcXG5cXHQ8dWwgY2xhc3M9XFxcInBhZ2luYXRpb25cXFwiPlxcclxcblxcdFxcdDxsaSB0aXRsZT1cXFwiR28gdG8gZmlyc3QgcGFnZVxcXCIgbmctY2xpY2s9XFxcInBhZ2VyLmZpcnN0KClcXFwiXFxyXFxuXFx0XFx0XFx0bmctY2xhc3M9XFxcInsgJ2Rpc2FibGVkJzogIXBhZ2VyLmNhbkdvQmFjayB9XFxcIj5cXHJcXG5cXHRcXHRcXHQ8YT48aSBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtZG91YmxlLWxlZnRcXFwiPjwvaT48L2E+XFxyXFxuXFx0XFx0PC9saT5cXHJcXG5cXHRcXHQ8bGkgdGl0bGU9XFxcIkdvIHRvIHByZXZpb3VzIHBhZ2VcXFwiIG5nLWNsaWNrPVxcXCJwYWdlci5wcmV2aW91cygpXFxcIlxcclxcblxcdFxcdFxcdG5nLWNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6ICFwYWdlci5jYW5Hb0JhY2sgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+PGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWxlZnRcXFwiPjwvaT48L2E+XFxyXFxuXFx0XFx0PC9saT5cXHJcXG5cXHRcXHQ8bGkgdGl0bGU9XFxcIkdvIHRvIHBhZ2Uge3twYWdlci5wYWdlfX1cXFwiIG5nLWNsaWNrPVxcXCJwYWdlci5nb3RvKHBhZ2UpXFxcIlxcclxcblxcdFxcdFxcdG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlci5wYWdlc1xcXCJcXHJcXG5cXHRcXHRcXHRuZy1jbGFzcz1cXFwieyAnYWN0aXZlJzogcGFnZXIuY3VycmVudFBhZ2UgPT0gcGFnZSB9XFxcIj5cXHJcXG5cXHRcXHRcXHQ8YT57e3BhZ2V9fTwvYT5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdFxcdDxsaSB0aXRsZT1cXFwiR28gdG8gbmV4dCBwYWdlXFxcIiBuZy1jbGljaz1cXFwicGFnZXIubmV4dCgpXFxcIlxcclxcblxcdFxcdFxcdG5nLWNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6ICFwYWdlci5jYW5Hb0ZvcndhcmQgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+PGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLXJpZ2h0XFxcIj48L2k+PC9hPlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0XFx0PGxpIHRpdGxlPVxcXCJHbyB0byBsYXN0IHBhZ2VcXFwiIG5nLWNsaWNrPVxcXCJwYWdlci5sYXN0KClcXFwiXFxyXFxuXFx0XFx0XFx0bmctY2xhc3M9XFxcInsgJ2Rpc2FibGVkJzogIXBhZ2VyLmNhbkdvRm9yd2FyZCB9XFxcIj5cXHJcXG5cXHRcXHRcXHQ8YT48aSBjbGFzcz1cXFwiZmEgZmEtYW5nbGUtZG91YmxlLXJpZ2h0XFxcIj48L2k+PC9hPlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0PC91bD5cXHJcXG48L25hdj5cXHJcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3BhZ2VyL3BhZ2VyLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnBhZ2VTaXplJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsUGFnZVNpemUnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1BhZ2VTaXplQ29udHJvbGxlcic7XHJcbmV4cG9ydHMuYXZhaWxhYmxlUGFnZVNpemVzID0gWzEwLCAyNSwgNTAsIDEwMF07XHJcbmV4cG9ydHMuZGVmYXVsdFBhZ2VTaXplID0gMTA7XHJcbnZhciBQYWdlU2l6ZUNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGFnZVNpemVDb250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyU2VydmljZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFBhZ2VTaXplID0gZXhwb3J0cy5kZWZhdWx0UGFnZVNpemU7XHJcbiAgICAgICAgdGhpcy5wYWdlU2l6ZXMgPSBleHBvcnRzLmF2YWlsYWJsZVBhZ2VTaXplcztcclxuICAgICAgICB0aGlzLmhhc1BhZ2VGaWx0ZXIgPSB0cnVlO1xyXG4gICAgICAgIHZhciBwYWdlciA9IHRoaXMuY29udGFpbmVyU2VydmljZS5wYWdlcjtcclxuICAgICAgICBpZiAocGFnZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BhZ2VGaWx0ZXIgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0ZWRQYWdlU2l6ZTsgfSwgZnVuY3Rpb24gKG5ld1BhZ2VTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VyLnBhZ2VTaXplID0gbmV3UGFnZVNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyU2VydmljZS5kYXRhU291cmNlLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUGFnZVNpemVDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIFBhZ2VTaXplQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5QYWdlU2l6ZUNvbnRyb2xsZXIgPSBQYWdlU2l6ZUNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHBhZ2VTaXplKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3BhZ2VTaXplLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2NvbnRyb2xsZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclNlcnZpY2U6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnBhZ2VTaXplID0gcGFnZVNpemU7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgcGFnZVNpemUpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBQYWdlU2l6ZUNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlU2l6ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlU2l6ZS9wYWdlU2l6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBuZy1zaG93PVxcXCJjb250cm9sbGVyLmhhc1BhZ2VGaWx0ZXJcXFwiPlxcclxcblxcdDxzZWxlY3QgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdGl0bGU9XFxcIkNhcmRzIHBlciBwYWdlXFxcIiBuZy1tb2RlbD1cXFwiY29udHJvbGxlci5zZWxlY3RlZFBhZ2VTaXplXFxcIlxcclxcblxcdFxcdFxcdG5nLW9wdGlvbnM9XFxcInBhZ2VTaXplIGZvciBwYWdlU2l6ZSBpbiBjb250cm9sbGVyLnBhZ2VTaXplc1xcXCI+PC9zZWxlY3Q+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlU2l6ZS9wYWdlU2l6ZS5odG1sXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fYm9vbGVhbiA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5ib29sZWFuO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnNlbGVjdGlvbkNvbnRyb2wnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTZWxlY3Rpb25Db250cm9sJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlcic7XHJcbnZhciBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlcigkc2NvcGUsIGJvb2wpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNlcnZpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtcyA9IHRoaXMuY29udGFpbmVyU2VydmljZS5udW1iZXJTZWxlY3RlZDtcclxuICAgICAgICB0aGlzLnBhZ2luZ0VuYWJsZWQgPSBib29sLnRvQm9vbCh0aGlzLmNvbnRhaW5lclNlcnZpY2UucGFnZXIpO1xyXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuY29udGFpbmVyU2VydmljZS5kYXRhU291cmNlO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29udGFpbmVyU2VydmljZS5udW1iZXJTZWxlY3RlZDsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNlbGVjdGVkSXRlbXMgPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyLnByb3RvdHlwZS5zZWxlY3RQYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLmRhdGFTb3VyY2UuZGF0YVNldCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ3NlbGVjdGlvbkNoYW5nZWQnKTsgLy8qZXZlbnRzP1xyXG4gICAgfTtcclxuICAgIFNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyLnByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuZGF0YVNvdXJjZS5maWx0ZXJlZERhdGFTZXQsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlLiRlbWl0KCdzZWxlY3Rpb25DaGFuZ2VkJyk7IC8vKmV2ZW50cz9cclxuICAgIH07XHJcbiAgICBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJQYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLmRhdGFTb3VyY2UuZGF0YVNldCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlLiRlbWl0KCdzZWxlY3Rpb25DaGFuZ2VkJyk7IC8vKmV2ZW50cz9cclxuICAgIH07XHJcbiAgICBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuZGF0YVNvdXJjZS5maWx0ZXJlZERhdGFTZXQsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRzY29wZS4kZW1pdCgnc2VsZWN0aW9uQ2hhbmdlZCcpOyAvLypldmVudHM/XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgX19ib29sZWFuLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TZWxlY3Rpb25Db250cm9sQ29udHJvbGxlciA9IFNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBzZWxlY3Rpb25Db250cm9sKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3NlbGVjdGlvbkNvbnRyb2wuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnc2VsZWN0aW9uJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBjb250YWluZXJTZXJ2aWNlOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zZWxlY3Rpb25Db250cm9sID0gc2VsZWN0aW9uQ29udHJvbDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19ib29sZWFuLm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHNlbGVjdGlvbkNvbnRyb2wpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdGlvbkNvbnRyb2wuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc2VsZWN0aW9uQ29udHJvbC9zZWxlY3Rpb25Db250cm9sLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2PlxcclxcblxcdDxkaXYgc3R5bGU9XFxcIm1hcmdpbi1ib3R0b206IDVweFxcXCI+XFxyXFxuXFx0XFx0PHNwYW4+PHN0cm9uZz57e3NlbGVjdGlvbi5zZWxlY3RlZEl0ZW1zfX08L3N0cm9uZz4gaXRlbXMgc2VsZWN0ZWQ8L3NwYW4+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBzdHlsZT1cXFwibWFyZ2luLWJvdHRvbTogNXB4XFxcIiBuZy1pZj1cXFwic2VsZWN0aW9uLnBhZ2luZ0VuYWJsZWRcXFwiPlxcclxcblxcdFxcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0aW9uLnNlbGVjdFBhZ2UoKVxcXCI+U2VsZWN0IHBhZ2U8L2J1dHRvbj5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xpY2s9XFxcInNlbGVjdGlvbi5jbGVhclBhZ2UoKVxcXCI+Q2xlYXIgcGFnZTwvYnV0dG9uPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXY+XFxyXFxuXFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Rpb24uc2VsZWN0QWxsKClcXFwiPlNlbGVjdCBhbGw8L2J1dHRvbj5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xpY2s9XFxcInNlbGVjdGlvbi5jbGVhckFsbCgpXFxcIj5DbGVhciBhbGw8L2J1dHRvbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NlbGVjdGlvbkNvbnRyb2wvc2VsZWN0aW9uQ29udHJvbC5odG1sXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9qcXVlcnkvanF1ZXJ5LmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fYXJyYXkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYXJyYXk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBkYXRhU291cmNlc19tb2R1bGVfMSA9IHJlcXVpcmUoJy4vZGF0YVNvdXJjZXMvZGF0YVNvdXJjZXMubW9kdWxlJyk7XHJcbnZhciBzb3J0c19tb2R1bGVfMSA9IHJlcXVpcmUoJy4vc29ydHMvc29ydHMubW9kdWxlJyk7XHJcbnZhciBicmVha3BvaW50XzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50Jyk7XHJcbnZhciBjYXJkQ29udGFpbmVyX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmRDb250YWluZXInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRDb250YWluZXJDb250cm9sbGVyJztcclxuZXhwb3J0cy5kZWZhdWx0TWF4Q29sdW1uU29ydHMgPSAyO1xyXG5leHBvcnRzLmRlZmF1bHRTZWxlY3Rpb25UaXRsZSA9ICdTZWxlY3QgY2FyZCc7XHJcbnZhciBDYXJkQ29udGFpbmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYXJkQ29udGFpbmVyQ29udHJvbGxlcigkc2NvcGUsICRhdHRycywgb2JqZWN0LCBhcnJheSwgZGF0YVBhZ2VyRmFjdG9yeSwgcGFyZW50Q2hpbGQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxuICAgICAgICB0aGlzLmRhdGFQYWdlckZhY3RvcnkgPSBkYXRhUGFnZXJGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQgPSBwYXJlbnRDaGlsZDtcclxuICAgICAgICB0aGlzLm51bWJlclNlbGVjdGVkID0gMDtcclxuICAgICAgICB0aGlzLmFkZFZpZXdEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfLmVhY2goX3RoaXMuZGF0YVNvdXJjZS5yYXdEYXRhU2V0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoaXRlbS52aWV3RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnZpZXdEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZURpc2FibGVkU2VsZWN0aW9ucygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jbGVhckZpbHRlcmVkU2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5vblZpc2libGVJdGVtcyA9IF8uZGlmZmVyZW5jZShfdGhpcy5kYXRhU291cmNlLnJhd0RhdGFTZXQsIF90aGlzLmRhdGFTb3VyY2UuZmlsdGVyZWREYXRhU2V0KTtcclxuICAgICAgICAgICAgXy5lYWNoKG5vblZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGl0ZW0udmlld0RhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52aWV3RGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpdGVtLnZpZXdEYXRhLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnZpZXdEYXRhLnNlbGVjdGlvblRpdGxlID0gZXhwb3J0cy5kZWZhdWx0U2VsZWN0aW9uVGl0bGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVTZWxlY3RlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMubnVtYmVyU2VsZWN0ZWQgPSBfLmZpbHRlcihfdGhpcy5kYXRhU291cmNlLmZpbHRlcmVkRGF0YVNldCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnZpZXdEYXRhICE9IG51bGwgJiYgaXRlbS52aWV3RGF0YS5zZWxlY3RlZDtcclxuICAgICAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51cGRhdGVEaXNhYmxlZFNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5kaXNhYmxpbmdTZWxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goX3RoaXMuZGF0YVNvdXJjZS5yYXdEYXRhU2V0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZFJlYXNvbiA9IF90aGlzLmRpc2FibGVTZWxlY3Rpb24oeyBpdGVtOiBpdGVtIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuZGlzYWJsZWRTZWxlY3Rpb24gPSAoZGlzYWJsZWRSZWFzb24gIT0gbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5zZWxlY3Rpb25UaXRsZSA9IChpdGVtLnZpZXdEYXRhLmRpc2FibGVkU2VsZWN0aW9uID8gZGlzYWJsZWRSZWFzb24gOiBleHBvcnRzLmRlZmF1bHRTZWxlY3Rpb25UaXRsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuYnVpbGRlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlci5zZXRDYXJkQ29udGFpbmVyUHJvcGVydGllcyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wZXJtYW5lbnRGb290ZXJzID0gXy5pc1VuZGVmaW5lZCh0aGlzLnBlcm1hbmVudEZvb3RlcnMpID8gZmFsc2UgOiB0aGlzLnBlcm1hbmVudEZvb3RlcnM7XHJcbiAgICAgICAgdGhpcy5tYXhDb2xTb3J0cyA9IHRoaXMubWF4Q29sdW1uU29ydHMgIT0gbnVsbCA/IHRoaXMubWF4Q29sdW1uU29ydHMgOiBleHBvcnRzLmRlZmF1bHRNYXhDb2x1bW5Tb3J0cztcclxuICAgICAgICB0aGlzLmRpc2FibGluZ1NlbGVjdGlvbnMgPSBvYmplY3QuaXNOdWxsT3JXaGl0ZXNwYWNlKCRhdHRycy5kaXNhYmxlU2VsZWN0aW9uKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zb3J0RGlyZWN0aW9uID0gc29ydHNfbW9kdWxlXzEuU29ydERpcmVjdGlvbjtcclxuICAgICAgICB0aGlzLnN5bmNGaWx0ZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zZXR1cFBhZ2luZygpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRDb2x1bW5TaXplcygpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGVDYXJkcykge1xyXG4gICAgICAgICAgICAvLyp1c2UgY2FyZCBjb250YWluZXIgZXZlbnQgc2VydmljZT9cclxuICAgICAgICAgICAgJHNjb3BlLiRvbignc2VsZWN0aW9uQ2hhbmdlZCcsIHRoaXMudXBkYXRlU2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAkc2NvcGUuJG9uKCd1cGRhdGVEaXNhYmxlZFNlbGVjdGlvbnMnLCB0aGlzLnVwZGF0ZURpc2FibGVkU2VsZWN0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS53YXRjaCh0aGlzLmFkZFZpZXdEYXRhLCAnY2hhbmdlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uud2F0Y2godGhpcy5jbGVhckZpbHRlcmVkU2VsZWN0aW9ucywgJ3JlZHJhd2luZycpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFZpZXdEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ29sdW1uID0ge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmxpcFNvcnQ6IHRydWUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2Uuc29ydHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHNjb3BlLmNvbnRhaW5lclNlcnZpY2UgPSBuZXcgY2FyZENvbnRhaW5lcl9zZXJ2aWNlXzEuQ2FyZENvbnRhaW5lclNlcnZpY2UodGhpcyk7XHJcbiAgICAgICAgJHNjb3BlLmNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGE7XHJcbiAgICB9XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuc29ydFNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc29ydCh0aGlzLnNlbGVjdGlvbkNvbHVtbik7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLm9wZW5DYXJkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiZWhhdmlvcnMgPSB0aGlzLnBhcmVudENoaWxkLmdldEFsbENoaWxkQmVoYXZpb3JzKHRoaXMuZGF0YVNvdXJjZS5kYXRhU2V0KTtcclxuICAgICAgICByZXR1cm4gXy5hbGwoXy5tYXAoYmVoYXZpb3JzLCBmdW5jdGlvbiAoYmVoYXZpb3IpIHsgcmV0dXJuIGJlaGF2aW9yLmNsb3NlKCk7IH0pKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcclxuICAgICAgICB2YXIgc29ydExpc3QgPSB0aGlzLmRhdGFTb3VyY2Uuc29ydHM7XHJcbiAgICAgICAgdmFyIGZpcnN0U29ydCA9IHNvcnRMaXN0WzBdO1xyXG4gICAgICAgIC8vIElmIGNvbHVtbiBpcyBhbHJlYWR5IHRoZSBwcmltYXJ5IHNvcnQsIGNoYW5nZSB0aGUgZGlyZWN0aW9uXHJcbiAgICAgICAgaWYgKGZpcnN0U29ydCAhPSBudWxsXHJcbiAgICAgICAgICAgICYmIGZpcnN0U29ydC5jb2x1bW4gPT09IGNvbHVtbikge1xyXG4gICAgICAgICAgICBmaXJzdFNvcnQuZGlyZWN0aW9uID0gc29ydHNfbW9kdWxlXzEuU29ydERpcmVjdGlvbi50b2dnbGUoZmlyc3RTb3J0LmRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIC8vIENsZWFyIHNvcnRcclxuICAgICAgICAgICAgaWYgKGZpcnN0U29ydC5kaXJlY3Rpb24gPT09IHNvcnRzX21vZHVsZV8xLlNvcnREaXJlY3Rpb24ubm9uZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclZpc3VhbFNvcnRJbmRpY2F0b3IoZmlyc3RTb3J0KTtcclxuICAgICAgICAgICAgICAgIGZpcnN0U29ydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29sdW1uIGhhcyBzZWNvbmRhcnkgc29ydHMgZG9uJ3QgZmFsbCBiYWNrIHRvIGFcclxuICAgICAgICAgICAgICAgIC8vICBzZWNvbmRhcnkgc29ydCwgaW5zdGVhZCBqdXN0IGNsZWFyIGFsbCBzb3J0c1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5zZWNvbmRhcnlTb3J0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydExpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRMaXN0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEVsc2UgbWFrZSBjb2x1bW4gcHJpbWFyeSBhc2NlbmRpbmcgc29ydFxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIG5vbi1wcmltYXJ5IHNvcnRzIG9uIGNvbHVtblxyXG4gICAgICAgICAgICB0aGlzLmFycmF5LnJlbW92ZShzb3J0TGlzdCwgZnVuY3Rpb24gKHNvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4gPT09IHNvcnQuY29sdW1uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gQnVpbGQgYXNjZW5kaW5nIHNvcnQgZm9yIGNvbHVtblxyXG4gICAgICAgICAgICB2YXIgbmV3U29ydCA9IHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBzb3J0c19tb2R1bGVfMS5Tb3J0RGlyZWN0aW9uLmFzY2VuZGluZyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc29ydExpc3QudW5zaGlmdChuZXdTb3J0KTtcclxuICAgICAgICAgICAgZmlyc3RTb3J0ID0gbmV3U29ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWxDb2x1bW5Tb3J0aW5nKCk7XHJcbiAgICAgICAgLy8gSWYgY29sdW1uIGhhcyBzZWNvbmRhcnkgc29ydHMsIHdpcGUgdGhlIHNvcnQgb3JkZXIgYW5kIGp1c3QgYXBwbHkgdGhlIHNlY29uZGFyeSBzb3J0c1xyXG4gICAgICAgIGlmIChmaXJzdFNvcnQgIT0gbnVsbCAmJiBjb2x1bW4uc2Vjb25kYXJ5U29ydHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzb3J0TGlzdC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB2YXIgc2Vjb25kYXJ5U29ydHMgPSB0aGlzLmJ1aWxkU2Vjb25kYXJ5U29ydHMoZmlyc3RTb3J0LmRpcmVjdGlvbiwgY29sdW1uLnNlY29uZGFyeVNvcnRzKTtcclxuICAgICAgICAgICAgc29ydExpc3QucHVzaChmaXJzdFNvcnQpO1xyXG4gICAgICAgICAgICBzb3J0TGlzdC5wdXNoLmFwcGx5KHNvcnRMaXN0LCBzZWNvbmRhcnlTb3J0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiBub3QgdXNpbmcgY29sdW1uIHNlY29uZGFyeSBzb3J0cywgbGltaXQgdGhlIG1heGltdW0gbnVtYmVyXHJcbiAgICAgICAgICAgIC8vICBvZiBzb3J0cyBhcHBsaWVkIHRvIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzb3J0c1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydHMgPSBfLnRha2Uoc29ydExpc3QsIHRoaXMubWF4Q29sU29ydHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWQoKTtcclxuICAgICAgICB0aGlzLiRzY29wZS4kZW1pdCgnc2VsZWN0aW9uQ2hhbmdlZCcpO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5zeW5jRmlsdGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXJzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCBmaWx0ZXIgYXJyYXkgdG8gZGljdGlvbmFyeSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheSh0aGlzLmZpbHRlcnMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSB0aGlzLmFycmF5LnRvRGljdGlvbmFyeSh0aGlzLmZpbHRlcnMsIGZ1bmN0aW9uIChmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlci50eXBlOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZmlsdGVycyA9IHRoaXMuZmlsdGVycztcclxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kYXRhU291cmNlLmZpbHRlcnMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSB0aGlzLmRhdGFTb3VyY2UuZmlsdGVycztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnNldHVwUGFnaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIElmIHBhZ2luZyBmbGFnIGlzIHNwZWNpZmllZCwgY2FyZCBjb250YWluZXIgY29udHJvbHMgcGFnZXIgaW5zdGFuY2VcclxuICAgICAgICBpZiAodGhpcy5wYWdpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYWdpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UucGFnZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlciA9IHRoaXMuZGF0YVBhZ2VyRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnBhZ2VyID0gdGhpcy5wYWdlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmRhdGFTb3VyY2UucGFnZXIpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHBhZ2luZyBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSBkYXRhU291cmNlIGhhcyBhIHBhZ2VyLCBzYXZlIGEgcmVmZXJlbmNlIGhlcmVcclxuICAgICAgICAgICAgdGhpcy5wYWdlciA9IHRoaXMuZGF0YVNvdXJjZS5wYWdlcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLmJ1aWxkQ29sdW1uU2l6ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfLmVhY2godGhpcy5jb2x1bW5zLCBmdW5jdGlvbiAoY29sdW1uKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplcyA9IGNvbHVtbi5zaXplO1xyXG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChzaXplcykpIHtcclxuICAgICAgICAgICAgICAgIHNpemVzW2JyZWFrcG9pbnRfMS54c10gPSBfdGhpcy5vYmplY3QudmFsdWVPckRlZmF1bHQoc2l6ZXNbYnJlYWtwb2ludF8xLnhzXSwgMCk7XHJcbiAgICAgICAgICAgICAgICBzaXplc1ticmVha3BvaW50XzEuc21dID0gX3RoaXMub2JqZWN0LnZhbHVlT3JEZWZhdWx0KHNpemVzW2JyZWFrcG9pbnRfMS5zbV0sIHNpemVzW2JyZWFrcG9pbnRfMS54c10pO1xyXG4gICAgICAgICAgICAgICAgc2l6ZXNbYnJlYWtwb2ludF8xLm1kXSA9IF90aGlzLm9iamVjdC52YWx1ZU9yRGVmYXVsdChzaXplc1ticmVha3BvaW50XzEubWRdLCBzaXplc1ticmVha3BvaW50XzEuc21dKTtcclxuICAgICAgICAgICAgICAgIHNpemVzW2JyZWFrcG9pbnRfMS5sZ10gPSBfdGhpcy5vYmplY3QudmFsdWVPckRlZmF1bHQoc2l6ZXNbYnJlYWtwb2ludF8xLmxnXSwgc2l6ZXNbYnJlYWtwb2ludF8xLm1kXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4uc2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4czogc2l6ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgc206IHNpemVzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1kOiBzaXplcyxcclxuICAgICAgICAgICAgICAgICAgICBsZzogc2l6ZXMsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLmxvb2t1cENvbHVtbiA9IGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgICAgIHJldHVybiBfLmZpbmQodGhpcy5jb2x1bW5zLCBmdW5jdGlvbiAoY29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4ubGFiZWwgPT09IGxhYmVsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5idWlsZFNlY29uZGFyeVNvcnRzID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgc2Vjb25kYXJ5U29ydHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzb3J0TGlzdCA9IHNlY29uZGFyeVNvcnRzW3NvcnRzX21vZHVsZV8xLlNvcnREaXJlY3Rpb24uZ2V0RnVsbE5hbWUoZGlyZWN0aW9uKV07XHJcbiAgICAgICAgcmV0dXJuIF8ubWFwKHNvcnRMaXN0LCBmdW5jdGlvbiAoc29ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBzb3J0LmRpcmVjdGlvbixcclxuICAgICAgICAgICAgICAgIGNvbHVtbjogX3RoaXMubG9va3VwQ29sdW1uKHNvcnQuY29sdW1uKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlVmlzdWFsQ29sdW1uU29ydGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLmRhdGFTb3VyY2Uuc29ydHMsIGZ1bmN0aW9uIChzb3J0LCBpbmRleCkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGZpcnN0IHNvcnQgc2hvdWxkIGhhdmUgdmlzaWJsZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVWaXN1YWxTb3J0SW5kaWNhdG9yKHNvcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJWaXN1YWxTb3J0SW5kaWNhdG9yKHNvcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVZpc3VhbFNvcnRJbmRpY2F0b3IgPSBmdW5jdGlvbiAoc29ydCkge1xyXG4gICAgICAgIHNvcnQuY29sdW1uLnNvcnREaXJlY3Rpb24gPSBzb3J0LmRpcmVjdGlvbjtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJWaXN1YWxTb3J0SW5kaWNhdG9yID0gZnVuY3Rpb24gKHNvcnQpIHtcclxuICAgICAgICBzb3J0LmNvbHVtbi5zb3J0RGlyZWN0aW9uID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGF0dHJzJywgX19vYmplY3Quc2VydmljZU5hbWUsIF9fYXJyYXkuc2VydmljZU5hbWUsIGRhdGFTb3VyY2VzX21vZHVsZV8xLmRhdGFQYWdlci5mYWN0b3J5TmFtZSwgX19wYXJlbnRDaGlsZC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQ2FyZENvbnRhaW5lckNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIgPSBDYXJkQ29udGFpbmVyQ29udHJvbGxlcjtcclxuY2FyZENvbnRhaW5lci4kaW5qZWN0ID0gWyckY29tcGlsZSddO1xyXG5mdW5jdGlvbiBjYXJkQ29udGFpbmVyKCRjb21waWxlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2NhcmRDb250YWluZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IGEgYnVpbGRlciBmb3IgdGhlIGNhcmQgY29udGFpbmVyXHJcbiAgICAgICAgICAgIGJ1aWxkZXI6ICc9JyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogVGhlIGRhdGEgc291cmNlIGZvciB0aGUgY2FyZCBjb250YWluZXJcclxuICAgICAgICAgICAgLy8gcmVtYXJrczogQ2FuIGJlIGFuIGFycmF5IG9mIG9iamVjdHMsIG9yIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBkYXRhIHNvdXJjZSBjb250cmFjdDoge1xyXG4gICAgICAgICAgICAvLyAgICAgc29ydHM6IEEgbGlzdCBvZiBzb3J0cyB0byBhcHBseSB0byB0aGUgZGF0YS4gU29ydHMgc2hvdWxkIGJlIGluIHRoaXMgZm9ybWF0OiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgY29sdW1uOiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uIHRvIHNvcnQgb24sXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgZGlyZWN0aW9uOiBTb3J0IGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIChzb3J0RGlyZWN0aW9uLmpzKVxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIGZpbHRlcnM6IEEgbGlzdCBvZiBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBkYXRhIHNvdXJjZSxcclxuICAgICAgICAgICAgLy8gICAgIHBhZ2VyOiBBIHBhZ2VyIHRoYXQgY2FuIGJlIG9wdGlvbmFsbHkgdXNlZCB0byBwYWdlIHRoZSBkYXRhOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihkYXRhU2V0KSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIFRha2VzIHRoZSBkYXRhIHNldCBhbmQgZmlsdGVycyBpdCBkb3duIHRvIHBhZ2VzXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIHJlZnJlc2g6IFtmdW5jdGlvbl0gQ2FsbCB0byB0cmlnZ2VyIHRoZSBkYXRhIHNvdXJjZSB0byByZWZyZXNoLFxyXG4gICAgICAgICAgICAvLyAgICAgZGF0YVNldDogV2lsbCBjb250YWluIHRoZSByZXN1bHRpbmcgZGF0YSBwcm92aWRlZCBieSB0aGUgc291cmNlLCBhZnRlciBzb3J0cyBhbmQgZmlsdGVycyBhcmUgYXBwbGllZCxcclxuICAgICAgICAgICAgLy8gICAgIGNvdW50OiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGF2YWlsYWJsZSBpbiB0aGUgZGF0YSBzZXQgKHVzZWQgZm9yIHBhZ2luZykuXHJcbiAgICAgICAgICAgIC8vICAgICBsb2FkaW5nRGF0YVNldDogQSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGRhdGFTZXQgaXMgYmVpbmcgcmVmcmVzaGVkIC8gbG9hZGVkLFxyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIHNvdXJjZTogJz0nLFxyXG4gICAgICAgICAgICAvLyBzdW1tYXJ5OiBBIGxpc3Qgb2YgZmlsdGVycyB0byBiZSBhcHBsaWVkIHRvIHRoZSBkYXRhIHNvdXJjZVxyXG4gICAgICAgICAgICAvLyByZW1hcmtzOiBFYWNoIGZpbHRlciBzaG91bGQgaW1wbGVtZW50IHRoZSBkYXRhIGZpbHRlciBjb250cmFjdDoge1xyXG4gICAgICAgICAgICAvLyAgICAgdHlwZTogQSBuYW1lIHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9vayB1cCB0aGUgZmlsdGVyLFxyXG4gICAgICAgICAgICAvLyAgICAgZmlsdGVyOiBmdW5jdGlvbihpdGVtKSB7IHRha2VzIGFuIGl0ZW0gYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgZGF0YSBzZXQgfSxcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICBmaWx0ZXJzOiAnPScsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IFR1cm4gcGFnaW5nIG9uIG9yIG9mZiAodHJ1ZSAvIGZhbHNlKVxyXG4gICAgICAgICAgICBwYWdpbmc6ICc9JyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogQSBsaXN0IG9mIHRoZSBjb2x1bW5zIGZvciBidWlsZGluZyB0aGUgY29sdW1uIGhlYWRlciBhbmQgY2FyZCBoZWFkZXJzLlxyXG4gICAgICAgICAgICAvLyByZW1hcmtzOiBFYWNoIGNvbHVtbiBvYmplY3Qgc2hvdWxkIGJlIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiB7XHJcbiAgICAgICAgICAgIC8vICAgICBsYWJlbDogVGhlIGxhYmVsIGZvciB0aGUgY29sdW1uIGhlYWRlcixcclxuICAgICAgICAgICAgLy8gICAgIGRlc2NyaXB0aW9uOiBBIGRlc2NyaXB0aW9uIGZvciB0aGUgY29sdW1uOyBzaG93biBpbiB0b29sdGlwcyxcclxuICAgICAgICAgICAgLy8gICAgIHNpemU6IEEgZGVzY3JpcHRpb24gb2YgdGhlIGNvbHVtbiBzaXplIGF0IGJyZWFrcG9pbnRzOyBlaXRoZXIgYSBjb25zdGFudCBpbnQgKGZvciBjb25zdGFudCBzaXplKSBvciBicmVha3BvaW50IGRldGFpbCBvYmplY3Q6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBbeHNdOiBvcHRpb25hbCBzaXplIGZvciB4cyBicmVha3BvaW50IChkZWZhdWx0cyB0byAwKSxcclxuICAgICAgICAgICAgLy8gICAgICAgICBbc21dOiBvcHRpb25hbCBzaXplIGZvciBzbSBicmVha3BvaW50IChkZWZhdWx0cyB0byB4cyksXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgW21kXTogb3B0aW9uYWwgc2l6ZSBmb3IgbWQgYnJlYWtwb2ludCAoZGVmYXVsdHMgdG8gc20pLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFtsZ106IG9wdGlvbmFsIHNpemUgZm9yIGxnIGJyZWFrcG9pbnQgKGRlZmF1bHRzIHRvIG1kKSxcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICBnZXRWYWx1ZTogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZGF0YSByZWNvcmQgYW5kIHJldHJpZXZlcyB0aGUgdmFsdWUgZm9yIHRoZSBjb2x1bW4sXHJcbiAgICAgICAgICAgIC8vICAgICBoZWFkZXJUZW1wbGF0ZVVybDogVGhlIHBhdGggdG8gYW4gSFRNTCB0ZW1wbGF0ZSBmb3IgdGhlIGNvbHVtbiBoZWFkZXIsXHJcbiAgICAgICAgICAgIC8vICAgICBoZWFkZXJUZW1wbGF0ZTogQW4gSFRNTCB0ZW1wbGF0ZSBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gaGVhZGVyIChvdmVycmlkZW4gYnkgaGVhZGVyVGVtcGxhdGVVcmwgaWYgcHJlc2VudCksXHJcbiAgICAgICAgICAgIC8vICAgICB0ZW1wbGF0ZVVybDogVGhlIHBhdGggdG8gYW4gSFRNTCB0ZW1wbGF0ZSBmb3IgdGhlIGNhcmQgaGVhZGVyLFxyXG4gICAgICAgICAgICAvLyAgICAgdGVtcGxhdGU6IEFuIEhUTUwgdGVtcGxhdGUgc3RyaW5nIGZvciB0aGUgY2FyZCBoZWFkZXIgKG92ZXJyaWRlbiBieSB0ZW1wbGF0ZVVybCBpZiBwcmVzZW50KSxcclxuICAgICAgICAgICAgLy8gICAgIHNlY29uZGFyeVNvcnRzOiBBIHNldCBvZiBzZWNvbmRhcnkgc29ydHMgdG8gYXBwbHkgb24gb3RoZXIgY29sdW1ucyB3aGVuIHRoaXMgY29sdW1uIGlzIHNvcnRlZCAoYXNjZW5kaW5nIGFuZCAvIG9yIGRlc2NlbmRpbmcpOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBzb3J0RGlyZWN0aW9uLmFzY2VuZGluZyAoJ2FzYycpOiAgW1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBjb2x1bW46IFRoZSBsYWJlbCBvZiBhbm90aGVyIGNvbHVtbiB0byBzb3J0IG9uLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBUaGUgZGlyZWN0aW9uIHRvIHNvcnQgdGhlIGNvbHVtbixcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgLi4uXHJcbiAgICAgICAgICAgIC8vICAgICAgICBdLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgc29ydERpcmVjdGlvbi5kZXNjZW5kaW5nICgnZGVzYycpOiBbXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGNvbHVtbjogVGhlIGxhYmVsIG9mIGFub3RoZXIgY29sdW1uIHRvIHNvcnQgb24sXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFRoZSBkaXJlY3Rpb24gdG8gc29ydCB0aGUgY29sdW1uLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAuLi5cclxuICAgICAgICAgICAgLy8gICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgY29sdW1uczogJz0nLFxyXG4gICAgICAgICAgICAvLyBzdW1tYXJ5OiBjb250YWluZXItd2lkZSBkYXRhIGF2YWlsYWJsZSBpbiBjYXJkc1xyXG4gICAgICAgICAgICBjb250YWluZXJEYXRhOiAnPScsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IGNvbnRyb2xsZXIgc2hhcmVkIGJ5IGFsbCBjb21wb25lbnRzIG9uIGEgY2FyZFxyXG4gICAgICAgICAgICAvLyByZW1hcmtzOiB0aGlzIGNvbnRyb2xsZXIgY2Fubm90IG92ZXJyaWRlIGFueSBvZiB0aGUgZm9sbG93aW5nIHZhcmlhYmxlIG5hbWVzOlxyXG4gICAgICAgICAgICAvLyAgICAgICAgICBjb2x1bW5zXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGl0ZW1cclxuICAgICAgICAgICAgLy8gICAgICAgICAgY29udGVudFRlbXBsYXRlXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGZvb3RlclRlbXBsYXRlXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGNsaWNrYWJsZVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICBjYXJkQ29udHJvbGxlclxyXG4gICAgICAgICAgICAvLyAgICAgICAgICBjYXJkQ29udHJvbGxlckFzXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGNhcmRBc1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICBzaG93Q29udGVudFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICB0b2dnbGVDb250ZW50XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIGNvbGxhcHNlXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgIHNldFNlbGVjdGVkXHJcbiAgICAgICAgICAgIGNhcmRDb250cm9sbGVyOiAnQCcsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IGNvbnRyb2xsZXIgYWxpYXMgc3BlY2lmaWVkIHVzaW5nIGNvbnRyb2xsZXJBcyBzeW50YXhcclxuICAgICAgICAgICAgY2FyZENvbnRyb2xsZXJBczogJ0AnLFxyXG4gICAgICAgICAgICAvLyBzdW1tYXJ5OiBuYW1lIHVzZWQgdG8gYWNjZXNzIHRoZSBjYXJkIGRhdGFcclxuICAgICAgICAgICAgY2FyZEFzOiAnQCcsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgc2hvdyBhY3RpdmUgc3RhdGUgb24gbW91c2Ugb3ZlclxyXG4gICAgICAgICAgICBjbGlja2FibGVDYXJkczogJz0nLFxyXG4gICAgICAgICAgICAvLyBzdW1tYXJ5OiBUaGUgbnVtYmVyIG9mIHNvcnRzIHRoYXQgY2FuIGJlIGFwcGxpZWQgYXQgYSB0aW1lLlxyXG4gICAgICAgICAgICBtYXhDb2x1bW5Tb3J0czogJz0nLFxyXG4gICAgICAgICAgICBwZXJtYW5lbnRGb290ZXJzOiAnPScsXHJcbiAgICAgICAgICAgIC8vIHN1bW1hcnk6IElmIHRydWUsIHR1cm5zIG9uIHNlbGVjdGlvbiBmb3IgY2FyZHMgdmlhIHRoZSBjYXJkRGF0YS52aWV3RGF0YS5zZWxlY3RlZCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBzZWxlY3RhYmxlQ2FyZHM6ICc9JyxcclxuICAgICAgICAgICAgLy8gc3VtbWFyeTogRnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCBpdGVtLiBJZiB0cnVlIGlzIHJldHVybmVkIHNlbGVjdGlvbiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBpdGVtLlxyXG4gICAgICAgICAgICAvLyAgICAgICAgICBJZiBmdW5jdGlvbiBpcyBub3QgZGVmaW5lZCwgc2VsZWN0aW9uIGlzIGVuYWJsZWQgZm9yIGFsbCBieSBkZWZhdWx0LlxyXG4gICAgICAgICAgICBkaXNhYmxlU2VsZWN0aW9uOiAnJicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250cm9sbGVyLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJBcmVhID0gZWxlbWVudC5maW5kKCcuY29udGFpbmVyLWhlYWRlci10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICB2YXIgZm9vdGVyQXJlYSA9IGVsZW1lbnQuZmluZCgnLmNvbnRhaW5lci1mb290ZXItdGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5tYWtlQ2FyZCA9IHRyYW5zY2x1ZGU7XHJcbiAgICAgICAgICAgIHRyYW5zY2x1ZGUoc2NvcGUsIGZ1bmN0aW9uIChjbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGNsb25lLmZpbHRlcigncmwtY29udGFpbmVyLWhlYWRlcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEhlYWRlciA9IHJlcXVpcmUoJy4vZGVmYXVsdENhcmRDb250YWluZXJIZWFkZXIuaHRtbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciA9ICRjb21waWxlKGRlZmF1bHRIZWFkZXIpKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhlYWRlckFyZWEuYXBwZW5kKGhlYWRlcik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9vdGVyID0gY2xvbmUuZmlsdGVyKCdybC1jb250YWluZXItZm9vdGVyJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9vdGVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0Rm9vdGVyID0gcmVxdWlyZSgnLi9kZWZhdWx0Q2FyZENvbnRhaW5lckZvb3Rlci5odG1sJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9vdGVyID0gJGNvbXBpbGUoZGVmYXVsdEZvb3Rlcikoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9vdGVyQXJlYS5hcHBlbmQoZm9vdGVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNhcmRDb250YWluZXIgPSBjYXJkQ29udGFpbmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJkQ29udGFpbmVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIENhcmRDb250YWluZXJTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhcmRDb250YWluZXJTZXJ2aWNlKGNhcmRDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNhcmRDb250YWluZXIgPSBjYXJkQ29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMucGFnZXIgPSBjYXJkQ29udGFpbmVyLnBhZ2VyO1xyXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGNhcmRDb250YWluZXIuZGF0YVNvdXJjZTtcclxuICAgICAgICB0aGlzLmZpbHRlcnMgPSBjYXJkQ29udGFpbmVyLmZpbHRlcnM7XHJcbiAgICB9XHJcbiAgICBDYXJkQ29udGFpbmVyU2VydmljZS5wcm90b3R5cGUubG9va3VwRmlsdGVyID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzW3R5cGVdO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJkQ29udGFpbmVyU2VydmljZS5wcm90b3R5cGUsIFwibnVtYmVyU2VsZWN0ZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXJkQ29udGFpbmVyLm51bWJlclNlbGVjdGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIENhcmRDb250YWluZXJTZXJ2aWNlO1xyXG59KSgpO1xyXG5leHBvcnRzLkNhcmRDb250YWluZXJTZXJ2aWNlID0gQ2FyZENvbnRhaW5lclNlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmRDb250YWluZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImNhcmQtY29udGFpbmVyXFxcIj5cXHJcXG5cXHQ8ZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGFpbmVyLWhlYWRlclxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWhlYWRlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0PC9kaXY+XFxyXFxuXFxyXFxuXFx0XFx0PHJsLWdlbmVyaWMtY29udGFpbmVyIHNlbGVjdG9yPVxcXCJjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkc1xcXCI+XFxyXFxuXFx0XFx0XFx0PHRlbXBsYXRlIHdoZW4tc2VsZWN0b3I9XFxcImZhbHNlXFxcIiBkZWZhdWx0PlxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQtY29sdW1ucy1oZWFkZXJcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctcmVwZWF0PVxcXCJjb2x1bW4gaW4gY2FyZENvbnRhaW5lci5jb2x1bW5zXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8cmwtY29sdW1uLWhlYWRlciBzb3J0PVxcXCJjYXJkQ29udGFpbmVyLnNvcnQoY29sdW1uKVxcXCIgc29ydGluZz1cXFwiY29sdW1uLnNvcnREaXJlY3Rpb25cXFwiIGNvbHVtbj1cXFwiY29sdW1uXFxcIj48L3JsLWNvbHVtbi1oZWFkZXI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDwvdGVtcGxhdGU+XFxyXFxuXFx0XFx0XFx0PHRlbXBsYXRlIHdoZW4tc2VsZWN0b3I9XFxcInRydWVcXFwiPlxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQtY29sdW1ucy1oZWFkZXJcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInNlbGVjdC1ncm91cFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic2VsZWN0LWNvbHVtblxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrXFxcIiBzdHlsZT1cXFwibWFyZ2luLWxlZnQ6IDZweDsgY3Vyc29yOiBwb2ludGVyXFxcIiBuZy1jbGljaz1cXFwiY2FyZENvbnRhaW5lci5zb3J0U2VsZWN0ZWQoKVxcXCI+PC9pPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIG5nLXNob3c9XFxcImNhcmRDb250YWluZXIuc29ydENvbHVtbi5zb3J0RGlyZWN0aW9uID09PSBjYXJkQ29udGFpbmVyLnNvcnREaXJlY3Rpb24uYXNjZW5kaW5nXFxcIiBjbGFzcz1cXFwiZmEgZmEtc29ydC1hc2NcXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBuZy1zaG93PVxcXCJjYXJkQ29udGFpbmVyLnNvcnRDb2x1bW4uc29ydERpcmVjdGlvbiA9PT0gY2FyZENvbnRhaW5lci5zb3J0RGlyZWN0aW9uLmRlc2NlbmRpbmdcXFwiIGNsYXNzPVxcXCJmYSBmYS1zb3J0LWRlc2NcXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtY29udGVudFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1yZXBlYXQ9XFxcImNvbHVtbiBpbiBjYXJkQ29udGFpbmVyLmNvbHVtbnNcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxybC1jb2x1bW4taGVhZGVyIHNvcnQ9XFxcImNhcmRDb250YWluZXIuc29ydChjb2x1bW4pXFxcIiBzb3J0aW5nPVxcXCJjb2x1bW4uc29ydERpcmVjdGlvblxcXCIgY29sdW1uPVxcXCJjb2x1bW5cXFwiPjwvcmwtY29sdW1uLWhlYWRlcj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0PC90ZW1wbGF0ZT5cXHJcXG5cXHRcXHQ8L3JsLWdlbmVyaWMtY29udGFpbmVyPlxcclxcblxcclxcblxcdFxcdDxkaXYgbmctcmVwZWF0PVxcXCJjYXJkIGluIGNhcmRDb250YWluZXIuZGF0YVNvdXJjZS5kYXRhU2V0XFxcIj5cXHJcXG5cXHRcXHRcXHQ8cmwtY2FyZCBjb2x1bW5zPVxcXCJjYXJkQ29udGFpbmVyLmNvbHVtbnNcXFwiIGl0ZW09XFxcImNhcmRcXFwiXFxyXFxuXFx0XFx0XFx0XFx0XFx0IGNsaWNrYWJsZT1cXFwiY2FyZENvbnRhaW5lci5jbGlja2FibGVDYXJkc1xcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgc2VsZWN0YWJsZT1cXFwiY2FyZENvbnRhaW5lci5zZWxlY3RhYmxlQ2FyZHNcXFwiXFxyXFxuXFx0XFx0XFx0XFx0XFx0IHNlbGVjdGlvbi1jaGFuZ2VkPVxcXCJjYXJkQ29udGFpbmVyLnNlbGVjdGlvbkNoYW5nZWQoKVxcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgY29udGFpbmVyLWRhdGE9XFxcImNhcmRDb250YWluZXIuY29udGFpbmVyRGF0YVxcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgc291cmNlPVxcXCJjYXJkQ29udGFpbmVyLmRhdGFTb3VyY2VcXFwiXFxyXFxuXFx0XFx0XFx0XFx0XFx0IHBlcm1hbmVudC1mb290ZXI9XFxcImNhcmRDb250YWluZXIucGVybWFuZW50Rm9vdGVyc1xcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgY2FyZC1jb250cm9sbGVyPVxcXCJjYXJkQ29udGFpbmVyLmNhcmRDb250cm9sbGVyXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdCBjYXJkLWNvbnRyb2xsZXItYXM9XFxcImNhcmRDb250YWluZXIuY2FyZENvbnRyb2xsZXJBc1xcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgY2FyZC1hcz1cXFwiY2FyZENvbnRhaW5lci5jYXJkQXNcXFwiPjwvcmwtY2FyZD5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHRcXHQ8ZGl2PlxcclxcblxcdFxcdFxcdDxybC1idXN5IGxvYWRpbmc9XFxcImNhcmRDb250YWluZXIuZGF0YVNvdXJjZS5sb2FkaW5nRGF0YVNldFxcXCIgc2l6ZT1cXFwiMnhcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjYXJkLWNvbnRhaW5lci1mb290ZXJcXFwiPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mb290ZXItdGVtcGxhdGVcXFwiPjwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZENvbnRhaW5lci5odG1sXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC14cy0xMiBjb2wtc20tOVxcXCI+XFxyXFxuXFx0XFx0PHJsLWNhcmQtc2VhcmNoIGNvbnRhaW5lci1zZXJ2aWNlPVxcXCJjb250YWluZXJTZXJ2aWNlXFxcIj48L3JsLWNhcmQtc2VhcmNoPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImhpZGRlbi14cyBjb2wtc20tM1xcXCI+XFxyXFxuXFx0XFx0PHJsLXBhZ2Utc2l6ZSBjb250YWluZXItc2VydmljZT1cXFwiY29udGFpbmVyU2VydmljZVxcXCI+PC9ybC1wYWdlLXNpemU+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kZWZhdWx0Q2FyZENvbnRhaW5lckhlYWRlci5odG1sXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcblxcdDxkaXYgbmctaWY9XFxcIiFjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkc1xcXCIgY2xhc3M9XFxcImNvbC1zbS02XFxcIj5cXHJcXG5cXHRcXHQ8cmwtaXRlbS1jb3VudCBjb250YWluZXItc2VydmljZT1cXFwiY29udGFpbmVyU2VydmljZVxcXCI+PC9ybC1pdGVtLWNvdW50PlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxzcGFuIG5nLWlmPVxcXCJjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkc1xcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTNcXFwiPlxcclxcblxcdFxcdFxcdDxybC1zZWxlY3Rpb24tY29udHJvbCBjb250YWluZXItc2VydmljZT1cXFwiY29udGFpbmVyU2VydmljZVxcXCI+PC9ybC1zZWxlY3Rpb24tY29udHJvbD5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tM1xcXCI+XFxyXFxuXFx0XFx0XFx0PHJsLWl0ZW0tY291bnQgY29udGFpbmVyLXNlcnZpY2U9XFxcImNvbnRhaW5lclNlcnZpY2VcXFwiPjwvcmwtaXRlbS1jb3VudD5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3NwYW4+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLXNtLTZcXFwiPlxcclxcblxcdFxcdDxybC1wYWdlciBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCIgY29udGFpbmVyLXNlcnZpY2U9XFxcImNvbnRhaW5lclNlcnZpY2VcXFwiPjwvcmwtcGFnZXI+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kZWZhdWx0Q2FyZENvbnRhaW5lckZvb3Rlci5odG1sXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fZ2VuZXJpY1NlYXJjaEZpbHRlciA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5nZW5lcmljU2VhcmNoRmlsdGVyO1xyXG52YXIgZGF0YVNvdXJjZXMgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VzLm1vZHVsZScpO1xyXG52YXIgZmlsdGVyR3JvdXAgPSByZXF1aXJlKCcuL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAubW9kdWxlJyk7XHJcbnZhciBzZWxlY3RGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5tb2R1bGUnKTtcclxudmFyIGNvbHVtblNlYXJjaEZpbHRlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL2ZpbHRlcnMvY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnY2FyZENvbnRhaW5lckJ1aWxkZXInO1xyXG52YXIgQ2FyZENvbnRhaW5lckJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZENvbnRhaW5lckJ1aWxkZXIoJGluamVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gbmV3IERhdGFTb3VyY2VCdWlsZGVyKCRpbmplY3RvciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gbmV3IEZpbHRlckJ1aWxkZXIoJGluamVjdG9yLCB0aGlzKTtcclxuICAgICAgICB0aGlzLl9jb2x1bW5zID0gW107XHJcbiAgICB9XHJcbiAgICBDYXJkQ29udGFpbmVyQnVpbGRlci5wcm90b3R5cGUudXNlU2VhcmNoID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuJGluamVjdG9yLmdldChfX2dlbmVyaWNTZWFyY2hGaWx0ZXIuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgICAgICBmaWx0ZXIgPSBmYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NlYXJjaEZpbHRlciA9IGZpbHRlcjtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoRmlsdGVyO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJCdWlsZGVyLnByb3RvdHlwZS51c2VQYWdpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFnaW5nID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQnVpbGRlci5wcm90b3R5cGUuYWRkQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgIHRoaXMuX2NvbHVtbnMucHVzaChjb2x1bW4pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJCdWlsZGVyLnByb3RvdHlwZS51c2VDbGlja2FibGVDYXJkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jbGlja2FibGVDYXJkcyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckJ1aWxkZXIucHJvdG90eXBlLnVzZVBlcm1hbmVudEZvb3RlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcGVybWFuZW50Rm9vdGVycyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckJ1aWxkZXIucHJvdG90eXBlLnVzZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9zZWxlY3RhYmxlQ2FyZHMgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJkQ29udGFpbmVyQnVpbGRlci5wcm90b3R5cGUsIFwiZGlzYWJsZVNlbGVjdGlvblwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RhYmxlQ2FyZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXNlU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVNlbGVjdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ2FyZENvbnRhaW5lckJ1aWxkZXIucHJvdG90eXBlLnNldENhcmRDb250YWluZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNhcmRDb250YWluZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2VhcmNoRmlsdGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsdGVycy5wdXNoKHRoaXMuX3NlYXJjaEZpbHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhcmRDb250YWluZXIuc291cmNlID0gdGhpcy5fZGF0YVNvdXJjZTtcclxuICAgICAgICBjYXJkQ29udGFpbmVyLmZpbHRlcnMgPSB0aGlzLl9maWx0ZXJzO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIucGFnaW5nID0gdGhpcy5fcGFnaW5nO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIuY29sdW1ucyA9IHRoaXMuX2NvbHVtbnM7XHJcbiAgICAgICAgY2FyZENvbnRhaW5lci5jb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIuY2FyZENvbnRyb2xsZXIgPSB0aGlzLmNhcmRDb250cm9sbGVyO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIuY2FyZENvbnRyb2xsZXJBcyA9IHRoaXMuY2FyZENvbnRyb2xsZXJBcztcclxuICAgICAgICBjYXJkQ29udGFpbmVyLmNhcmRBcyA9IHRoaXMuY2FyZEFzO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIuY2xpY2thYmxlQ2FyZHMgPSB0aGlzLl9jbGlja2FibGVDYXJkcztcclxuICAgICAgICBjYXJkQ29udGFpbmVyLm1heENvbHVtblNvcnRzID0gdGhpcy5tYXhDb2x1bW5Tb3J0cztcclxuICAgICAgICBjYXJkQ29udGFpbmVyLnBlcm1hbmVudEZvb3RlcnMgPSB0aGlzLl9wZXJtYW5lbnRGb290ZXJzO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIuc2VsZWN0YWJsZUNhcmRzID0gdGhpcy5fc2VsZWN0YWJsZUNhcmRzO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIuZGlzYWJsZVNlbGVjdGlvbiA9IHRoaXMuX2Rpc2FibGVTZWxlY3Rpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhcmRDb250YWluZXJCdWlsZGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkNhcmRDb250YWluZXJCdWlsZGVyID0gQ2FyZENvbnRhaW5lckJ1aWxkZXI7XHJcbnZhciBEYXRhU291cmNlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhU291cmNlQnVpbGRlcigkaW5qZWN0b3IsIHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMuJGluamVjdG9yID0gJGluamVjdG9yO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGRhdGFTb3VyY2VzLnNpbXBsZURhdGFTb3VyY2UuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgIHBhcmVudC5fZGF0YVNvdXJjZSA9IGZhY3RvcnkuZ2V0SW5zdGFuY2UoW10pO1xyXG4gICAgfVxyXG4gICAgRGF0YVNvdXJjZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkU2ltcGxlRGF0YVNvdXJjZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoZGF0YVNvdXJjZXMuc2ltcGxlRGF0YVNvdXJjZS5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2RhdGFTb3VyY2UgPSBmYWN0b3J5LmdldEluc3RhbmNlKGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZGF0YVNvdXJjZTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQnVpbGRlci5wcm90b3R5cGUuYnVpbGREYXRhU2VydmljZURhdGFTb3VyY2UgPSBmdW5jdGlvbiAoZ2V0RGF0YVNldCkge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGRhdGFTb3VyY2VzLmRhdGFTZXJ2aWNlRGF0YVNvdXJjZS5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2RhdGFTb3VyY2UgPSBmYWN0b3J5LmdldEluc3RhbmNlKGdldERhdGFTZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZGF0YVNvdXJjZTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRTZXJ2ZXJTZWFyY2hEYXRhU291cmNlID0gZnVuY3Rpb24gKGdldERhdGFTZXQsIGdldEZpbHRlck1vZGVsLCB2YWxpZGF0ZU1vZGVsKSB7XHJcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5wYXJlbnQuX3NlYXJjaEZpbHRlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXNlU2VhcmNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGRhdGFTb3VyY2VzLnNlcnZlclNlYXJjaERhdGFTb3VyY2UuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9kYXRhU291cmNlID0gZmFjdG9yeS5nZXRJbnN0YW5jZShnZXREYXRhU2V0LCB0aGlzLnBhcmVudC5fc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Ll9kYXRhU291cmNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRhU291cmNlQnVpbGRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5EYXRhU291cmNlQnVpbGRlciA9IERhdGFTb3VyY2VCdWlsZGVyO1xyXG52YXIgRmlsdGVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWx0ZXJCdWlsZGVyKCRpbmplY3RvciwgcGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZpbHRlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkRmlsdGVyR3JvdXAgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuJGluamVjdG9yLmdldChmaWx0ZXJHcm91cC5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGZhY3RvcnkuZ2V0SW5zdGFuY2Uoc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTW9kZUZpbHRlckdyb3VwID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoZmlsdGVyR3JvdXAubW9kZUZpbHRlckdyb3VwLmZhY3RvcnlOYW1lKTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZmFjdG9yeS5nZXRJbnN0YW5jZShzZXR0aW5ncyk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyQnVpbGRlci5wcm90b3R5cGUuYnVpbGRSYW5nZUZpbHRlckdyb3VwID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoZmlsdGVyR3JvdXAucmFuZ2VGaWx0ZXJHcm91cC5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGZhY3RvcnkuZ2V0SW5zdGFuY2Uoc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkU2VsZWN0RmlsdGVyID0gZnVuY3Rpb24gKHZhbHVlU2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuJGluamVjdG9yLmdldChzZWxlY3RGaWx0ZXIuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBmYWN0b3J5LmdldEluc3RhbmNlKHZhbHVlU2VsZWN0b3IpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkQ29sdW1uU2VhcmNoRmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGNvbHVtblNlYXJjaEZpbHRlcl9zZXJ2aWNlXzEuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBmYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyQnVpbGRlci5wcm90b3R5cGUuYWRkQ3VzdG9tRmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmlsdGVyQnVpbGRlcjtcclxufSkoKTtcclxuZXhwb3J0cy5GaWx0ZXJCdWlsZGVyID0gRmlsdGVyQnVpbGRlcjtcclxuY2FyZENvbnRhaW5lckJ1aWxkZXJGYWN0b3J5LiRpbmplY3QgPSBbJyRpbmplY3RvciddO1xyXG5mdW5jdGlvbiBjYXJkQ29udGFpbmVyQnVpbGRlckZhY3RvcnkoJGluamVjdG9yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FyZENvbnRhaW5lckJ1aWxkZXIoJGluamVjdG9yKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNhcmRDb250YWluZXJCdWlsZGVyRmFjdG9yeSA9IGNhcmRDb250YWluZXJCdWlsZGVyRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZENvbnRhaW5lckJ1aWxkZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyQnVpbGRlci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sdW1uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NvbHVtbi5qc1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNoZWNrYm94JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQ2hlY2tib3gnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NoZWNrYm94Q29udHJvbGxlcic7XHJcbnZhciBDaGVja2JveENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hlY2tib3hDb250cm9sbGVyKCRlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5uZ01vZGVsID0gJGVsZW1lbnQuY29udHJvbGxlcignbmdNb2RlbCcpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoZWNrYm94Q29udHJvbGxlci5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5nTW9kZWwuJHZpZXdWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENoZWNrYm94Q29udHJvbGxlci4kaW5qZWN0ID0gWyckZWxlbWVudCddO1xyXG4gICAgcmV0dXJuIENoZWNrYm94Q29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5DaGVja2JveENvbnRyb2xsZXIgPSBDaGVja2JveENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGNoZWNrYm94KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2NoZWNrYm94Lmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2NoZWNrYm94JyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jaGVja2JveCA9IGNoZWNrYm94O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGNoZWNrYm94KVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQ2hlY2tib3hDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NoZWNrYm94L2NoZWNrYm94LmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGFiZWw+XFxyXFxuXFx0PGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBuZy1jaGVja2VkPVxcXCJjaGVja2JveC5jaGVja2VkXFxcIiBuZy1kaXNhYmxlZD1cXFwiY2hlY2tib3gubmdEaXNhYmxlZFxcXCIgLz5cXHJcXG5cXHQ8c3BhbiBuZy10cmFuc2NsdWRlPjwvc3Bhbj5cXHJcXG48L2xhYmVsPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NoZWNrYm94L2NoZWNrYm94Lmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY29tbWFMaXN0JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQ29tbWFMaXN0JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdDb21tYUxpc3RDb250cm9sbGVyJztcclxudmFyIENvbW1hTGlzdENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tbWFMaXN0Q29udHJvbGxlcigkYXR0cnMsIG9iamVjdCkge1xyXG4gICAgICAgIHRoaXMucmVtYWluaW5nSXRlbXMgPSAwO1xyXG4gICAgICAgIHRoaXMuaGFzVHJhbnNmb3JtID0gb2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSgkYXR0cnMudHJhbnNmb3JtKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5saXN0ID0gdGhpcy5nZXRGaXJzdEl0ZW1zKHRoaXMuaW5MaXN0KTtcclxuICAgIH1cclxuICAgIENvbW1hTGlzdENvbnRyb2xsZXIucHJvdG90eXBlLmdldEZpcnN0SXRlbXMgPSBmdW5jdGlvbiAobGlzdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIGxpc3QgPSBfLm1hcChsaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybSh7IGl0ZW06IGl0ZW0gfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgdmFyIG5ld0xpc3Q7XHJcbiAgICAgICAgaWYgKHRoaXMubWF4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbmV3TGlzdCA9IF8udGFrZShsaXN0LCB0aGlzLm1heCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nSXRlbXMgPSBsaXN0Lmxlbmd0aCAtIHRoaXMubWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3TGlzdCA9IF8uY2xvbmUobGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdMaXN0O1xyXG4gICAgfTtcclxuICAgIENvbW1hTGlzdENvbnRyb2xsZXIuJGluamVjdCA9IFsnJGF0dHJzJywgX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIENvbW1hTGlzdENvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQ29tbWFMaXN0Q29udHJvbGxlciA9IENvbW1hTGlzdENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGNvbW1hTGlzdCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8c3Bhbj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBuZy1yZXBlYXQ9XFxcIml0ZW0gaW4gY29tbWFMaXN0Lmxpc3QgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8c3Bhbj57e2l0ZW19fTwvc3Bhbj48c3BhbiBuZy1oaWRlPVxcXCIkbGFzdFxcXCI+LCA8L3NwYW4+XFxuXFx0XFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIG5nLXNob3c9XFxcImNvbW1hTGlzdC5yZW1haW5pbmdJdGVtcyA+IDBcXFwiPi4uLiB7e2NvbW1hTGlzdC5yZW1haW5pbmdJdGVtc319IG1vcmUgaXRlbXM8L3NwYW4+XFxuXFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY29tbWFMaXN0JyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBpbkxpc3Q6ICc9bGlzdCcsXHJcbiAgICAgICAgICAgIG1heDogJz0nLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICcmJyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBjb21tYUxpc3QpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBDb21tYUxpc3RDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWFMaXN0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jb21tYUxpc3QvY29tbWFMaXN0LmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9ib290c3RyYXBEYXRlVGltZVBpY2tlci5kLnRzJyAvPlxyXG5yZXF1aXJlKCcuLi8uLi8uLi9saWJyYXJpZXMvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL2luZGV4Jyk7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19kYXRlVGltZUZvcm1hdFN0cmluZ3MgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZGF0ZTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuZGF0ZVRpbWUnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxEYXRlVGltZSc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnRGF0ZVRpbWVDb250cm9sbGVyJztcclxudmFyIERhdGVUaW1lQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRlVGltZUNvbnRyb2xsZXIoJHNjb3BlLCBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdW5yZWdpc3RlciA9ICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubmdNb2RlbDsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfdGhpcy52YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRlVGltZVZhbGlkYXRvciA9IGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkuZ2V0SW5zdGFuY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5nTW9kZWw6IF90aGlzLm5nTW9kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlOiAkc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW190aGlzLnZhbGlkYXRvcl0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBEYXRlVGltZUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gRGF0ZVRpbWVDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkRhdGVUaW1lQ29udHJvbGxlciA9IERhdGVUaW1lQ29udHJvbGxlcjtcclxuZGF0ZVRpbWUuJGluamVjdCA9IFt0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMubW9tZW50LnNlcnZpY2VOYW1lLCBfX2RhdGVUaW1lRm9ybWF0U3RyaW5ncy5kYXRlVGltZUZvcm1hdFNlcnZpY2VOYW1lLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIGRhdGVUaW1lKG1vbWVudCwgZGF0ZVRpbWVGb3JtYXRTdHJpbmdzLCBvYmplY3QpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9kYXRlVGltZS5odG1sJyksXHJcbiAgICAgICAgcmVxdWlyZTogJz9ebmdNb2RlbCcsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdkYXRlVGltZScsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgbWludXRlU3RlcHBpbmc6ICc9JyxcclxuICAgICAgICAgICAgdXNlRGF0ZTogJz0nLFxyXG4gICAgICAgICAgICB1c2VUaW1lOiAnPScsXHJcbiAgICAgICAgICAgIG1pbjogJz0nLFxyXG4gICAgICAgICAgICBtYXg6ICc9JyxcclxuICAgICAgICAgICAgdmFsaWRhdG9yOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRlVGltZSA9IHNjb3BlLmRhdGVUaW1lO1xyXG4gICAgICAgICAgICBkYXRlVGltZS5uZ01vZGVsID0gbmdNb2RlbDtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICB2YXIgaGFzRGF0ZSA9IF8uaXNVbmRlZmluZWQoZGF0ZVRpbWUudXNlRGF0ZSkgPyB0cnVlIDogZGF0ZVRpbWUudXNlRGF0ZTtcclxuICAgICAgICAgICAgdmFyIGhhc1RpbWUgPSBfLmlzVW5kZWZpbmVkKGRhdGVUaW1lLnVzZVRpbWUpID8gdHJ1ZSA6IGRhdGVUaW1lLnVzZVRpbWU7XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IGVsZW1lbnQuZGF0ZXRpbWVwaWNrZXIuZGVmYXVsdHM7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBkYXRlVGltZS5taW4gIT0gbnVsbCA/IGRhdGVUaW1lLm1pbiA6IGRlZmF1bHRzLm1pbkRhdGU7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBkYXRlVGltZS5tYXggIT0gbnVsbCA/IGRhdGVUaW1lLm1heCA6IGRlZmF1bHRzLm1heERhdGU7XHJcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBuZ01vZGVsLiR2aWV3VmFsdWU7IH0sIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZVRpbWUudmFsaWRGb3JtYXQgPSBvYmplY3QuaXNOdWxsT3JFbXB0eShuZXdWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA/IHRydWVcclxuICAgICAgICAgICAgICAgICAgICA6IG1vbWVudChuZXdWYWx1ZSkuaXNWYWxpZCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gLS0tIEltcGxlbWVudGF0aW9uIC0tLVxyXG4gICAgICAgICAgICBlbGVtZW50LmRhdGV0aW1lcGlja2VyKHtcclxuICAgICAgICAgICAgICAgIHN0ZXBwaW5nOiBkYXRlVGltZS5taW51dGVTdGVwcGluZyB8fCAxLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBkYXRlVGltZS5mb3JtYXQgfHwgZGVmYXVsdEZvcm1hdChoYXNEYXRlLCBoYXNUaW1lKSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JvdHRvbScsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50SGVpZ2h0OiAzMixcclxuICAgICAgICAgICAgICAgIHBpY2tEYXRlOiBoYXNEYXRlLFxyXG4gICAgICAgICAgICAgICAgcGlja1RpbWU6IGhhc1RpbWUsXHJcbiAgICAgICAgICAgICAgICBtaW5EYXRlOiBtaW4sXHJcbiAgICAgICAgICAgICAgICBtYXhEYXRlOiBtYXgsXHJcbiAgICAgICAgICAgIH0pLm9uKCdjaGFuZ2UuZHAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAkKHRoaXMpLmZpbmQoJ2lucHV0JykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWZhdWx0Rm9ybWF0KGhhc0RhdGUsIGhhc1RpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEYXRlICYmIGhhc1RpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVRpbWVGb3JtYXRTdHJpbmdzLmRhdGVUaW1lRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlVGltZUZvcm1hdFN0cmluZ3MuZGF0ZUZvcm1hdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc1RpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVRpbWVGb3JtYXRTdHJpbmdzLnRpbWVGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgdG8gZGVmYXVsdCBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFt0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMubW9tZW50Lm1vZHVsZU5hbWUsIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5kYXRlLm1vZHVsZU5hbWUsIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEubW9kdWxlTmFtZSwgX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgZGF0ZVRpbWUpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBEYXRlVGltZUNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlVGltZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvZGF0ZVRpbWUvZGF0ZVRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzJyk7XHJcbnJlcXVpcmUoJy4vYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYnJhcmllcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxyXFxuICogRGF0ZXRpbWVwaWNrZXIgZm9yIEJvb3RzdHJhcCB2M1xcclxcbi8vISB2ZXJzaW9uIDogMy4xLjNcXHJcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRW9uYXNkYW4vYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL1xcclxcbiAqL1xcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHtcXHJcXG4gIHRvcDogMDtcXHJcXG4gIGxlZnQ6IDA7XFxyXFxuICB3aWR0aDogMjUwcHg7XFxyXFxuICBwYWRkaW5nOiA0cHg7XFxyXFxuICBtYXJnaW4tdG9wOiAxcHg7XFxyXFxuICB6LWluZGV4OiA5OTk5OSAhaW1wb3J0YW50O1xcclxcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC50aW1lcGlja2VyLXNicyB7XFxyXFxuICB3aWR0aDogNjAwcHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0LmJvdHRvbTpiZWZvcmUge1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICBib3JkZXItbGVmdDogN3B4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcbiAgYm9yZGVyLXJpZ2h0OiA3cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBib3JkZXItYm90dG9tOiA3cHggc29saWQgI2NjYztcXHJcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4yKTtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogLTdweDtcXHJcXG4gIGxlZnQ6IDdweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQuYm90dG9tOmFmdGVyIHtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgYm9yZGVyLWxlZnQ6IDZweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG4gIGJvcmRlci1yaWdodDogNnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcbiAgYm9yZGVyLWJvdHRvbTogNnB4IHNvbGlkIHdoaXRlO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAtNnB4O1xcclxcbiAgbGVmdDogOHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC50b3A6YmVmb3JlIHtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgYm9yZGVyLWxlZnQ6IDdweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG4gIGJvcmRlci1yaWdodDogN3B4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcbiAgYm9yZGVyLXRvcDogN3B4IHNvbGlkICNjY2M7XFxyXFxuICBib3JkZXItdG9wLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMik7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBib3R0b206IC03cHg7XFxyXFxuICBsZWZ0OiA2cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0LnRvcDphZnRlciB7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIGJvcmRlci1sZWZ0OiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBib3JkZXItcmlnaHQ6IDZweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG4gIGJvcmRlci10b3A6IDZweCBzb2xpZCB3aGl0ZTtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGJvdHRvbTogLTZweDtcXHJcXG4gIGxlZnQ6IDdweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgLmRvdyB7XFxyXFxuICB3aWR0aDogMTQuMjg1NyU7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0LnB1bGwtcmlnaHQ6YmVmb3JlIHtcXHJcXG4gIGxlZnQ6IGF1dG87XFxyXFxuICByaWdodDogNnB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC5wdWxsLXJpZ2h0OmFmdGVyIHtcXHJcXG4gIGxlZnQ6IGF1dG87XFxyXFxuICByaWdodDogN3B4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCA+IHVsIHtcXHJcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgYVtkYXRhLWFjdGlvbl0ge1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgYVtkYXRhLWFjdGlvbl06YWN0aXZlIHtcXHJcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IC50aW1lcGlja2VyIHtcXHJcXG4gIG1hcmdpbjogMCA0cHggNHB4IDRweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgLnRpbWVwaWNrZXItaG91cixcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCAudGltZXBpY2tlci1taW51dGUsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgLnRpbWVwaWNrZXItc2Vjb25kIHtcXHJcXG4gIHdpZHRoOiA1NHB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICBmb250LXNpemU6IDEuMmVtO1xcclxcbiAgbWFyZ2luLXRvcDogNHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCBidXR0b25bZGF0YS1hY3Rpb25dIHtcXHJcXG4gIHBhZGRpbmc6IDZweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGFibGVbZGF0YS1ob3VyLWZvcm1hdD1cXFwiMTJcXFwiXSAuc2VwYXJhdG9yIHtcXHJcXG4gIHdpZHRoOiA0cHg7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCAuZGF0ZXBpY2tlciA+IGRpdiB7XFxyXFxuICBkaXNwbGF5OiBub25lO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCAucGlja2VyLXN3aXRjaCB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRhYmxlIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZCxcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aCB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkIHtcXHJcXG4gIGhlaWdodDogMjVweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcclxcbiAgd2lkdGg6IDU0cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLmN3IHtcXHJcXG4gIGZvbnQtc2l6ZTogMTBweDtcXHJcXG4gIGhlaWdodDogMjBweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcclxcbiAgY29sb3I6ICM3Nzc3Nzc7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLmRheSB7XFxyXFxuICBoZWlnaHQ6IDIwcHg7XFxyXFxuICBsaW5lLWhlaWdodDogMjBweDtcXHJcXG4gIHdpZHRoOiAyMHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5kYXk6aG92ZXIsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQuaG91cjpob3ZlcixcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5taW51dGU6aG92ZXIsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQuc2Vjb25kOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNlZWVlZWU7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLm9sZCxcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5uZXcge1xcclxcbiAgY29sb3I6ICM3Nzc3Nzc7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLnRvZGF5IHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQudG9kYXk6YmVmb3JlIHtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgYm9yZGVyLWxlZnQ6IDdweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG4gIGJvcmRlci1ib3R0b206IDdweCBzb2xpZCAjNDI4YmNhO1xcclxcbiAgYm9yZGVyLXRvcC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYm90dG9tOiA0cHg7XFxyXFxuICByaWdodDogNHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5hY3RpdmUsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQuYWN0aXZlOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0MjhiY2E7XFxyXFxuICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gIHRleHQtc2hhZG93OiAwIC0xcHggMCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5hY3RpdmUudG9kYXk6YmVmb3JlIHtcXHJcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNmZmY7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLmRpc2FibGVkLFxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLmRpc2FibGVkOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxyXFxuICBjb2xvcjogIzc3Nzc3NztcXHJcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkIHNwYW4ge1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgd2lkdGg6IDU0cHg7XFxyXFxuICBoZWlnaHQ6IDI1cHg7XFxyXFxuICBsaW5lLWhlaWdodDogMjVweDtcXHJcXG4gIG1hcmdpbjogMHB4IDEuNXB4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZCBzcGFuOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNlZWVlZWU7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkIHNwYW4uYWN0aXZlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0MjhiY2E7XFxyXFxuICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gIHRleHQtc2hhZG93OiAwIC0xcHggMCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZCBzcGFuLm9sZCB7XFxyXFxuICBjb2xvcjogIzc3Nzc3NztcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQgc3Bhbi5kaXNhYmxlZCxcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZCBzcGFuLmRpc2FibGVkOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxyXFxuICBjb2xvcjogIzc3Nzc3NztcXHJcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRoIHtcXHJcXG4gIGhlaWdodDogMjBweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcclxcbiAgd2lkdGg6IDIwcHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRoLnBpY2tlci1zd2l0Y2gge1xcclxcbiAgd2lkdGg6IDE0NXB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aC5uZXh0LFxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRoLnByZXYge1xcclxcbiAgZm9udC1zaXplOiAyMXB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aC5kaXNhYmxlZCxcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aC5kaXNhYmxlZDpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiBub25lO1xcclxcbiAgY29sb3I6ICM3Nzc3Nzc7XFxyXFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aCB7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRoZWFkIHRyOmZpcnN0LWNoaWxkIHRoOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNlZWVlZWU7XFxyXFxufVxcclxcbi5pbnB1dC1ncm91cC5kYXRlIC5pbnB1dC1ncm91cC1hZGRvbiBzcGFuIHtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgd2lkdGg6IDE2cHg7XFxyXFxuICBoZWlnaHQ6IDE2cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0LmxlZnQtb3JpZW50ZWQ6YmVmb3JlIHtcXHJcXG4gIGxlZnQ6IGF1dG87XFxyXFxuICByaWdodDogNnB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC5sZWZ0LW9yaWVudGVkOmFmdGVyIHtcXHJcXG4gIGxlZnQ6IGF1dG87XFxyXFxuICByaWdodDogN3B4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB1bC5saXN0LXVuc3R5bGVkIGxpIGRpdi50aW1lcGlja2VyIGRpdi50aW1lcGlja2VyLXBpY2tlciB0YWJsZS50YWJsZS1jb25kZW5zZWQgdGJvZHkgPiB0ciA+IHRkIHtcXHJcXG4gIHBhZGRpbmc6IDBweCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcclxcbiAgLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQudGltZXBpY2tlci1zYnMge1xcclxcbiAgICB3aWR0aDogMjgzcHg7XFxyXFxuICB9XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9saWJyYXJpZXMvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5jc3NcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuLy8hIHZlcnNpb24gOiAzLjEuM1xyXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLmpzXHJcbmh0dHBzOi8vZ2l0aHViLmNvbS9Fb25hc2Rhbi9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXJcclxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG5cclxuQ29weXJpZ2h0IChjKSAyMDE0IEpvbmF0aGFuIFBldGVyc29uXHJcblxyXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcblRIRSBTT0ZUV0FSRS5cclxuKi9cclxuOyAoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHQndXNlIHN0cmljdCc7XHJcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdFx0Ly8gQU1EIGlzIHVzZWQgLSBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG5cdFx0ZGVmaW5lKFsnanF1ZXJ5JywgJ21vbWVudCddLCBmYWN0b3J5KTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0ZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSwgcmVxdWlyZSgnbW9tZW50JykpO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdC8vIE5laXRoZXIgQU1EIG9yIENvbW1vbkpTIHVzZWQuIFVzZSBnbG9iYWwgdmFyaWFibGVzLlxyXG5cdFx0aWYgKCFqUXVlcnkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIgcmVxdWlyZXMgalF1ZXJ5IHRvIGJlIGxvYWRlZCBmaXJzdCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFtb21lbnQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIgcmVxdWlyZXMgbW9tZW50LmpzIHRvIGJlIGxvYWRlZCBmaXJzdCcpO1xyXG5cdFx0fVxyXG5cdFx0ZmFjdG9yeShyb290LmpRdWVyeSwgbW9tZW50KTtcclxuXHR9XHJcbn0odGhpcywgZnVuY3Rpb24gKCQsIG1vbWVudCkge1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRpZiAodHlwZW9mIG1vbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignbW9tZW50anMgaXMgcmVxdWlyZWQnKTtcclxuXHR9XHJcblxyXG5cdHZhciBkcGdJZCA9IDAsXHJcblxyXG4gICAgRGF0ZVRpbWVQaWNrZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgXHR2YXIgZGVmYXVsdHMgPSAkLmZuLmRhdGV0aW1lcGlja2VyLmRlZmF1bHRzLFxyXG5cclxuICAgICAgICAgICAgaWNvbnMgPSB7XHJcbiAgICAgICAgICAgIFx0dGltZTogJ2ZhIGZhLWNsb2NrLW8nLFxyXG4gICAgICAgICAgICBcdGRhdGU6ICdmYSBmYS1jYWxlbmRhcicsXHJcbiAgICAgICAgICAgIFx0dXA6ICdmYSBmYS1jaGV2cm9uLXVwJyxcclxuICAgICAgICAgICAgXHRkb3duOiAnZmEgZmEtY2hldnJvbi1kb3duJ1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgcGlja2VyID0gdGhpcyxcclxuICAgICAgICAgICAgZXJyb3JlZCA9IGZhbHNlLFxyXG4gICAgICAgICAgICBkRGF0ZSxcclxuXHJcbiAgICAgICAgaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdHZhciBpY29uID0gZmFsc2UsIGxvY2FsZURhdGEsIHJJbnRlcnZhbDtcclxuICAgICAgICBcdHBpY2tlci5vcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcclxuICAgICAgICBcdHBpY2tlci5vcHRpb25zLmljb25zID0gJC5leHRlbmQoe30sIGljb25zLCBwaWNrZXIub3B0aW9ucy5pY29ucyk7XHJcblxyXG4gICAgICAgIFx0cGlja2VyLmVsZW1lbnQgPSAkKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICBcdGRhdGFUb09wdGlvbnMoKTtcclxuXHJcbiAgICAgICAgXHRpZiAoIShwaWNrZXIub3B0aW9ucy5waWNrVGltZSB8fCBwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSkpIHtcclxuICAgICAgICBcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGNob29zZSBhdCBsZWFzdCBvbmUgcGlja2VyJyk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0cGlja2VyLmlkID0gZHBnSWQrKztcclxuICAgICAgICBcdG1vbWVudC5sb2NhbGUocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xyXG4gICAgICAgIFx0cGlja2VyLmRhdGUgPSBtb21lbnQoKTtcclxuICAgICAgICBcdHBpY2tlci51bnNldCA9IGZhbHNlO1xyXG4gICAgICAgIFx0cGlja2VyLmlzSW5wdXQgPSBwaWNrZXIuZWxlbWVudC5pcygnaW5wdXQnKTtcclxuICAgICAgICBcdHBpY2tlci5jb21wb25lbnQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgXHRpZiAocGlja2VyLmVsZW1lbnQuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwJykpIHtcclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5lbGVtZW50LmZpbmQoJy5kYXRlcGlja2VyYnV0dG9uJykuc2l6ZSgpID09PSAwKSB7Ly9pbiBjYXNlIHRoZXJlIGlzIG1vcmUgdGhlbiBvbmUgJ2lucHV0LWdyb3VwLWFkZG9uJyBJc3N1ZSAjNDhcclxuICAgICAgICBcdFx0XHRwaWNrZXIuY29tcG9uZW50ID0gcGlja2VyLmVsZW1lbnQuZmluZCgnW2NsYXNzXj1cImlucHV0LWdyb3VwLVwiXScpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdHBpY2tlci5jb21wb25lbnQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCcuZGF0ZXBpY2tlcmJ1dHRvbicpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRwaWNrZXIuZm9ybWF0ID0gcGlja2VyLm9wdGlvbnMuZm9ybWF0O1xyXG5cclxuICAgICAgICBcdGxvY2FsZURhdGEgPSBtb21lbnQoKS5sb2NhbGVEYXRhKCk7XHJcblxyXG4gICAgICAgIFx0aWYgKCFwaWNrZXIuZm9ybWF0KSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5mb3JtYXQgPSAocGlja2VyLm9wdGlvbnMucGlja0RhdGUgPyBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KCdMJykgOiAnJyk7XHJcbiAgICAgICAgXHRcdGlmIChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSAmJiBwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xyXG4gICAgICAgIFx0XHRcdHBpY2tlci5mb3JtYXQgKz0gJyAnO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHBpY2tlci5mb3JtYXQgKz0gKHBpY2tlci5vcHRpb25zLnBpY2tUaW1lID8gbG9jYWxlRGF0YS5sb25nRGF0ZUZvcm1hdCgnTFQnKSA6ICcnKTtcclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5vcHRpb25zLnVzZVNlY29uZHMpIHtcclxuICAgICAgICBcdFx0XHRpZiAobG9jYWxlRGF0YS5sb25nRGF0ZUZvcm1hdCgnTFQnKS5pbmRleE9mKCcgQScpICE9PSAtMSkge1xyXG4gICAgICAgIFx0XHRcdFx0cGlja2VyLmZvcm1hdCA9IHBpY2tlci5mb3JtYXQuc3BsaXQoJyBBJylbMF0gKyAnOnNzIEEnO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRlbHNlIHtcclxuICAgICAgICBcdFx0XHRcdHBpY2tlci5mb3JtYXQgKz0gJzpzcyc7XHJcbiAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRwaWNrZXIudXNlMjRob3VycyA9IChwaWNrZXIuZm9ybWF0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYScpIDwgMCAmJiBwaWNrZXIuZm9ybWF0LmluZGV4T2YoJ2gnKSA8IDApO1xyXG5cclxuICAgICAgICBcdGlmIChwaWNrZXIuY29tcG9uZW50KSB7XHJcbiAgICAgICAgXHRcdGljb24gPSBwaWNrZXIuY29tcG9uZW50LmZpbmQoJ3NwYW4nKTtcclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHtcclxuICAgICAgICBcdFx0aWYgKGljb24pIHtcclxuICAgICAgICBcdFx0XHRpY29uLmFkZENsYXNzKHBpY2tlci5vcHRpb25zLmljb25zLnRpbWUpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMucGlja0RhdGUpIHtcclxuICAgICAgICBcdFx0aWYgKGljb24pIHtcclxuICAgICAgICBcdFx0XHRpY29uLnJlbW92ZUNsYXNzKHBpY2tlci5vcHRpb25zLmljb25zLnRpbWUpO1xyXG4gICAgICAgIFx0XHRcdGljb24uYWRkQ2xhc3MocGlja2VyLm9wdGlvbnMuaWNvbnMuZGF0ZSk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRwaWNrZXIub3B0aW9ucy53aWRnZXRQYXJlbnQgPVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBpY2tlci5vcHRpb25zLndpZGdldFBhcmVudCA9PT0gJ3N0cmluZycgJiYgcGlja2VyLm9wdGlvbnMud2lkZ2V0UGFyZW50IHx8XHJcbiAgICAgICAgICAgICAgICBwaWNrZXIuZWxlbWVudC5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIFx0cmV0dXJuICdzY3JvbGwnID09PSAkKHRoaXMpLmNzcygnb3ZlcmZsb3cteScpO1xyXG4gICAgICAgICAgICAgICAgfSkuZ2V0KDApIHx8XHJcbiAgICAgICAgICAgICAgICAnYm9keSc7XHJcblxyXG4gICAgICAgIFx0cGlja2VyLndpZGdldCA9ICQoZ2V0VGVtcGxhdGUoKSkuYXBwZW5kVG8ocGlja2VyLm9wdGlvbnMud2lkZ2V0UGFyZW50KTtcclxuXHJcbiAgICAgICAgXHRwaWNrZXIubWluVmlld01vZGUgPSBwaWNrZXIub3B0aW9ucy5taW5WaWV3TW9kZSB8fCAwO1xyXG4gICAgICAgIFx0aWYgKHR5cGVvZiBwaWNrZXIubWluVmlld01vZGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgXHRcdHN3aXRjaCAocGlja2VyLm1pblZpZXdNb2RlKSB7XHJcbiAgICAgICAgXHRcdFx0Y2FzZSAnbW9udGhzJzpcclxuICAgICAgICBcdFx0XHRcdHBpY2tlci5taW5WaWV3TW9kZSA9IDE7XHJcbiAgICAgICAgXHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRjYXNlICd5ZWFycyc6XHJcbiAgICAgICAgXHRcdFx0XHRwaWNrZXIubWluVmlld01vZGUgPSAyO1xyXG4gICAgICAgIFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0ZGVmYXVsdDpcclxuICAgICAgICBcdFx0XHRcdHBpY2tlci5taW5WaWV3TW9kZSA9IDA7XHJcbiAgICAgICAgXHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cGlja2VyLnZpZXdNb2RlID0gcGlja2VyLm9wdGlvbnMudmlld01vZGUgfHwgMDtcclxuICAgICAgICBcdGlmICh0eXBlb2YgcGlja2VyLnZpZXdNb2RlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIFx0XHRzd2l0Y2ggKHBpY2tlci52aWV3TW9kZSkge1xyXG4gICAgICAgIFx0XHRcdGNhc2UgJ21vbnRocyc6XHJcbiAgICAgICAgXHRcdFx0XHRwaWNrZXIudmlld01vZGUgPSAxO1xyXG4gICAgICAgIFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0Y2FzZSAneWVhcnMnOlxyXG4gICAgICAgIFx0XHRcdFx0cGlja2VyLnZpZXdNb2RlID0gMjtcclxuICAgICAgICBcdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgIFx0XHRcdGRlZmF1bHQ6XHJcbiAgICAgICAgXHRcdFx0XHRwaWNrZXIudmlld01vZGUgPSAwO1xyXG4gICAgICAgIFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRwaWNrZXIudmlld01vZGUgPSBNYXRoLm1heChwaWNrZXIudmlld01vZGUsIHBpY2tlci5taW5WaWV3TW9kZSk7XHJcblxyXG4gICAgICAgIFx0cGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlcyA9IGluZGV4R2l2ZW5EYXRlcyhwaWNrZXIub3B0aW9ucy5kaXNhYmxlZERhdGVzKTtcclxuICAgICAgICBcdHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcyA9IGluZGV4R2l2ZW5EYXRlcyhwaWNrZXIub3B0aW9ucy5lbmFibGVkRGF0ZXMpO1xyXG5cclxuICAgICAgICBcdHBpY2tlci5zdGFydFZpZXdNb2RlID0gcGlja2VyLnZpZXdNb2RlO1xyXG4gICAgICAgIFx0cGlja2VyLnNldE1pbkRhdGUocGlja2VyLm9wdGlvbnMubWluRGF0ZSk7XHJcbiAgICAgICAgXHRwaWNrZXIuc2V0TWF4RGF0ZShwaWNrZXIub3B0aW9ucy5tYXhEYXRlKTtcclxuICAgICAgICBcdGZpbGxEb3coKTtcclxuICAgICAgICBcdGZpbGxNb250aHMoKTtcclxuICAgICAgICBcdGZpbGxIb3VycygpO1xyXG4gICAgICAgIFx0ZmlsbE1pbnV0ZXMoKTtcclxuICAgICAgICBcdGZpbGxTZWNvbmRzKCk7XHJcbiAgICAgICAgXHR1cGRhdGUoKTtcclxuICAgICAgICBcdHNob3dNb2RlKCk7XHJcbiAgICAgICAgXHRpZiAoIWdldFBpY2tlcklucHV0KCkucHJvcCgnZGlzYWJsZWQnKSkge1xyXG4gICAgICAgIFx0XHRhdHRhY2hEYXRlUGlja2VyRXZlbnRzKCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMuZGVmYXVsdERhdGUgIT09ICcnICYmIGdldFBpY2tlcklucHV0KCkudmFsKCkgPT09ICcnKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5zZXRWYWx1ZShwaWNrZXIub3B0aW9ucy5kZWZhdWx0RGF0ZSk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmcgIT09IDEpIHtcclxuICAgICAgICBcdFx0ckludGVydmFsID0gcGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmc7XHJcbiAgICAgICAgXHRcdHBpY2tlci5kYXRlLm1pbnV0ZXMoKE1hdGgucm91bmQocGlja2VyLmRhdGUubWludXRlcygpIC8gckludGVydmFsKSAqIHJJbnRlcnZhbCkgJSA2MCkuc2Vjb25kcygwKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRQaWNrZXJJbnB1dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdHZhciBpbnB1dDtcclxuXHJcbiAgICAgICAgXHRpZiAocGlja2VyLmlzSW5wdXQpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIHBpY2tlci5lbGVtZW50O1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aW5wdXQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCcuZGF0ZXBpY2tlcmlucHV0Jyk7XHJcbiAgICAgICAgXHRpZiAoaW5wdXQuc2l6ZSgpID09PSAwKSB7XHJcbiAgICAgICAgXHRcdGlucHV0ID0gcGlja2VyLmVsZW1lbnQuZmluZCgnaW5wdXQnKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGVsc2UgaWYgKCFpbnB1dC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NTUyBjbGFzcyBcImRhdGVwaWNrZXJpbnB1dFwiIGNhbm5vdCBiZSBhcHBsaWVkIHRvIG5vbiBpbnB1dCBlbGVtZW50Jyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRyZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGF0YVRvT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdHZhciBlRGF0YTtcclxuICAgICAgICBcdGlmIChwaWNrZXIuZWxlbWVudC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgIFx0XHRlRGF0YSA9IHBpY2tlci5lbGVtZW50LmRhdGEoKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGVsc2Uge1xyXG4gICAgICAgIFx0XHRlRGF0YSA9IHBpY2tlci5lbGVtZW50LmZpbmQoJ2lucHV0JykuZGF0YSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5mb3JtYXQgPSBlRGF0YS5kYXRlRm9ybWF0O1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVQaWNrZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLnBpY2tEYXRlID0gZURhdGEuZGF0ZVBpY2tkYXRlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVQaWNrdGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLnBpY2tUaW1lID0gZURhdGEuZGF0ZVBpY2t0aW1lO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVVc2VtaW51dGVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMudXNlTWludXRlcyA9IGVEYXRhLmRhdGVVc2VtaW51dGVzO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVVc2VzZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA9IGVEYXRhLmRhdGVVc2VzZWNvbmRzO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVVc2VjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMudXNlQ3VycmVudCA9IGVEYXRhLmRhdGVVc2VjdXJyZW50O1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmNhbGVuZGFyV2Vla3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5jYWxlbmRhcldlZWtzID0gZURhdGEuY2FsZW5kYXJXZWVrcztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlTWludXRlc3RlcHBpbmcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZyA9IGVEYXRhLmRhdGVNaW51dGVzdGVwcGluZztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlTWluZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLm1pbkRhdGUgPSBlRGF0YS5kYXRlTWluZGF0ZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlTWF4ZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLm1heERhdGUgPSBlRGF0YS5kYXRlTWF4ZGF0ZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlU2hvd3RvZGF5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMuc2hvd1RvZGF5ID0gZURhdGEuZGF0ZVNob3d0b2RheTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlQ29sbGFwc2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5jb2xsYXBzZSA9IGVEYXRhLmRhdGVDb2xsYXBzZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlTGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSA9IGVEYXRhLmRhdGVMYW5ndWFnZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlRGVmYXVsdGRhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5kZWZhdWx0RGF0ZSA9IGVEYXRhLmRhdGVEZWZhdWx0ZGF0ZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlRGlzYWJsZWRkYXRlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLmRpc2FibGVkRGF0ZXMgPSBlRGF0YS5kYXRlRGlzYWJsZWRkYXRlcztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlRW5hYmxlZGRhdGVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzID0gZURhdGEuZGF0ZUVuYWJsZWRkYXRlcztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlSWNvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5pY29ucyA9IGVEYXRhLmRhdGVJY29ucztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlVXNlc3RyaWN0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMudXNlU3RyaWN0ID0gZURhdGEuZGF0ZVVzZXN0cmljdDtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlRGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMuZGlyZWN0aW9uID0gZURhdGEuZGF0ZURpcmVjdGlvbjtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlU2lkZWJ5c2lkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLnNpZGVCeVNpZGUgPSBlRGF0YS5kYXRlU2lkZWJ5c2lkZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlRGF0YS5kYXRlRGF5c29md2Vla2Rpc2FibGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkID0gZURhdGEuZGF0ZURheXNvZndlZWtkaXNhYmxlZDtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwbGFjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdHZhciBwb3NpdGlvbiA9ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwaWNrZXIuY29tcG9uZW50ID8gcGlja2VyLmNvbXBvbmVudC5vZmZzZXQoKSA6IHBpY2tlci5lbGVtZW50Lm9mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgJHdpbmRvdyA9ICQod2luZG93KSxcclxuICAgICAgICAgICAgICAgIHBsYWNlUG9zaXRpb247XHJcblxyXG4gICAgICAgIFx0cGlja2VyLndpZHRoID0gcGlja2VyLmNvbXBvbmVudCA/IHBpY2tlci5jb21wb25lbnQub3V0ZXJXaWR0aCgpIDogcGlja2VyLmVsZW1lbnQub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgIFx0b2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBwaWNrZXIuZWxlbWVudC5vdXRlckhlaWdodCgpO1xyXG5cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5kaXJlY3Rpb24gPT09ICd1cCcpIHtcclxuICAgICAgICBcdFx0cGxhY2VQb3NpdGlvbiA9ICd0b3AnO1xyXG4gICAgICAgIFx0fSBlbHNlIGlmIChwaWNrZXIub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICAgICAgXHRcdHBsYWNlUG9zaXRpb24gPSAnYm90dG9tJztcclxuICAgICAgICBcdH0gZWxzZSBpZiAocGlja2VyLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnYXV0bycpIHtcclxuICAgICAgICBcdFx0aWYgKG9mZnNldC50b3AgKyBwaWNrZXIud2lkZ2V0LmhlaWdodCgpID4gJHdpbmRvdy5oZWlnaHQoKSArICR3aW5kb3cuc2Nyb2xsVG9wKCkgJiYgcGlja2VyLndpZGdldC5oZWlnaHQoKSArIHBpY2tlci5lbGVtZW50Lm91dGVySGVpZ2h0KCkgPCBvZmZzZXQudG9wKSB7XHJcbiAgICAgICAgXHRcdFx0cGxhY2VQb3NpdGlvbiA9ICd0b3AnO1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdHBsYWNlUG9zaXRpb24gPSAnYm90dG9tJztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKHBsYWNlUG9zaXRpb24gPT09ICd0b3AnKSB7XHJcbiAgICAgICAgXHRcdG9mZnNldC5ib3R0b20gPSAkd2luZG93LmhlaWdodCgpIC0gb2Zmc2V0LnRvcCArIHBpY2tlci5lbGVtZW50Lm91dGVySGVpZ2h0KCkgKyAzO1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmFkZENsYXNzKCd0b3AnKS5yZW1vdmVDbGFzcygnYm90dG9tJyk7XHJcbiAgICAgICAgXHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRvZmZzZXQudG9wICs9IDE7XHJcbiAgICAgICAgXHRcdG9mZnNldC50b3AgKz0gcGlja2VyLm9wdGlvbnMuZWxlbWVudEhlaWdodDtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5hZGRDbGFzcygnYm90dG9tJykucmVtb3ZlQ2xhc3MoJ3RvcCcpO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQud2lkdGgocGlja2VyLm9wdGlvbnMud2lkdGgpO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuYWRkQ2xhc3MoJ2xlZnQtb3JpZW50ZWQnKTtcclxuICAgICAgICBcdFx0b2Zmc2V0LmxlZnQgPSBvZmZzZXQubGVmdCAtIHBpY2tlci53aWRnZXQud2lkdGgoKSArIDIwO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGlmIChpc0luRml4ZWQoKSkge1xyXG4gICAgICAgIFx0XHRwb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgICAgICAgXHRcdG9mZnNldC50b3AgLT0gJHdpbmRvdy5zY3JvbGxUb3AoKTtcclxuICAgICAgICBcdFx0b2Zmc2V0LmxlZnQgLT0gJHdpbmRvdy5zY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0aWYgKCR3aW5kb3cud2lkdGgoKSA8IG9mZnNldC5sZWZ0ICsgcGlja2VyLndpZGdldC5vdXRlcldpZHRoKCkpIHtcclxuICAgICAgICBcdFx0b2Zmc2V0LnJpZ2h0ID0gJHdpbmRvdy53aWR0aCgpIC0gb2Zmc2V0LmxlZnQgLSBwaWNrZXIud2lkdGg7XHJcbiAgICAgICAgXHRcdG9mZnNldC5sZWZ0ID0gJ2F1dG8nO1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmFkZENsYXNzKCdwdWxsLXJpZ2h0Jyk7XHJcbiAgICAgICAgXHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRvZmZzZXQucmlnaHQgPSAnYXV0byc7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQucmVtb3ZlQ2xhc3MoJ3B1bGwtcmlnaHQnKTtcclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRpZiAocGxhY2VQb3NpdGlvbiA9PT0gJ3RvcCcpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5jc3Moe1xyXG4gICAgICAgIFx0XHRcdHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICBcdFx0XHRib3R0b206IG9mZnNldC5ib3R0b20sXHJcbiAgICAgICAgXHRcdFx0dG9wOiAnYXV0bycsXHJcbiAgICAgICAgXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgXHRcdFx0cmlnaHQ6IG9mZnNldC5yaWdodFxyXG4gICAgICAgIFx0XHR9KTtcclxuICAgICAgICBcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuY3NzKHtcclxuICAgICAgICBcdFx0XHRwb3NpdGlvbjogcG9zaXRpb24sXHJcbiAgICAgICAgXHRcdFx0dG9wOiBvZmZzZXQudG9wLFxyXG4gICAgICAgIFx0XHRcdGJvdHRvbTogJ2F1dG8nLFxyXG4gICAgICAgIFx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0LFxyXG4gICAgICAgIFx0XHRcdHJpZ2h0OiBvZmZzZXQucmlnaHRcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbm90aWZ5Q2hhbmdlID0gZnVuY3Rpb24gKG9sZERhdGUsIGV2ZW50VHlwZSkge1xyXG4gICAgICAgIFx0aWYgKG1vbWVudChwaWNrZXIuZGF0ZSkuaXNTYW1lKG1vbWVudChvbGREYXRlKSkgJiYgIWVycm9yZWQpIHtcclxuICAgICAgICBcdFx0cmV0dXJuO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0ZXJyb3JlZCA9IGZhbHNlO1xyXG4gICAgICAgIFx0cGlja2VyLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgXHRcdHR5cGU6ICdkcC5jaGFuZ2UnLFxyXG4gICAgICAgIFx0XHRkYXRlOiBtb21lbnQocGlja2VyLmRhdGUpLFxyXG4gICAgICAgIFx0XHRvbGREYXRlOiBtb21lbnQob2xkRGF0ZSlcclxuICAgICAgICBcdH0pO1xyXG5cclxuICAgICAgICBcdGlmIChldmVudFR5cGUgIT09ICdjaGFuZ2UnKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5lbGVtZW50LmNoYW5nZSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICBcdGVycm9yZWQgPSB0cnVlO1xyXG4gICAgICAgIFx0cGlja2VyLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICAgICAgXHRcdHR5cGU6ICdkcC5lcnJvcicsXHJcbiAgICAgICAgXHRcdGRhdGU6IG1vbWVudChkYXRlLCBwaWNrZXIuZm9ybWF0LCBwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QpXHJcbiAgICAgICAgXHR9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1cGRhdGUgPSBmdW5jdGlvbiAobmV3RGF0ZSkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHR2YXIgZGF0ZVN0ciA9IG5ld0RhdGU7XHJcbiAgICAgICAgXHRpZiAoIWRhdGVTdHIpIHtcclxuICAgICAgICBcdFx0ZGF0ZVN0ciA9IGdldFBpY2tlcklucHV0KCkudmFsKCk7XHJcbiAgICAgICAgXHRcdGlmIChkYXRlU3RyKSB7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmRhdGUgPSBtb21lbnQoZGF0ZVN0ciwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRpZiAoIXBpY2tlci5kYXRlKSB7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmRhdGUgPSBtb21lbnQoKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cGlja2VyLnZpZXdEYXRlID0gbW9tZW50KHBpY2tlci5kYXRlKS5zdGFydE9mKCdtb250aCcpO1xyXG4gICAgICAgIFx0ZmlsbERhdGUoKTtcclxuICAgICAgICBcdGZpbGxUaW1lKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlsbERvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdG1vbWVudC5sb2NhbGUocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xyXG4gICAgICAgIFx0dmFyIGh0bWwgPSAkKCc8dHI+JyksIHdlZWtkYXlzTWluID0gbW9tZW50LndlZWtkYXlzTWluKCksIGk7XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMuY2FsZW5kYXJXZWVrcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIFx0XHRodG1sLmFwcGVuZCgnPHRoIGNsYXNzPVwiY3dcIj4jPC90aD4nKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChtb21lbnQoKS5sb2NhbGVEYXRhKCkuX3dlZWsuZG93ID09PSAwKSB7IC8vIHN0YXJ0cyBvbiBTdW5kYXlcclxuICAgICAgICBcdFx0Zm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgIFx0XHRcdGh0bWwuYXBwZW5kKCc8dGggY2xhc3M9XCJkb3dcIj4nICsgd2Vla2RheXNNaW5baV0gKyAnPC90aD4nKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0Zm9yIChpID0gMTsgaSA8IDg7IGkrKykge1xyXG4gICAgICAgIFx0XHRcdGlmIChpID09PSA3KSB7XHJcbiAgICAgICAgXHRcdFx0XHRodG1sLmFwcGVuZCgnPHRoIGNsYXNzPVwiZG93XCI+JyArIHdlZWtkYXlzTWluWzBdICsgJzwvdGg+Jyk7XHJcbiAgICAgICAgXHRcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRcdGh0bWwuYXBwZW5kKCc8dGggY2xhc3M9XCJkb3dcIj4nICsgd2Vla2RheXNNaW5baV0gKyAnPC90aD4nKTtcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0aGVhZCcpLmFwcGVuZChodG1sKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaWxsTW9udGhzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHR2YXIgaHRtbCA9ICcnLCBpLCBtb250aHNTaG9ydCA9IG1vbWVudC5tb250aHNTaG9ydCgpO1xyXG4gICAgICAgIFx0Zm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICBcdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCJtb250aFwiPicgKyBtb250aHNTaG9ydFtpXSArICc8L3NwYW4+JztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRkJykuYXBwZW5kKGh0bWwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpbGxEYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0aWYgKCFwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSkge1xyXG4gICAgICAgIFx0XHRyZXR1cm47XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRtb21lbnQubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgICAgICBcdHZhciB5ZWFyID0gcGlja2VyLnZpZXdEYXRlLnllYXIoKSxcclxuICAgICAgICAgICAgICAgIG1vbnRoID0gcGlja2VyLnZpZXdEYXRlLm1vbnRoKCksXHJcbiAgICAgICAgICAgICAgICBzdGFydFllYXIgPSBwaWNrZXIub3B0aW9ucy5taW5EYXRlLnllYXIoKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TW9udGggPSBwaWNrZXIub3B0aW9ucy5taW5EYXRlLm1vbnRoKCksXHJcbiAgICAgICAgICAgICAgICBlbmRZZWFyID0gcGlja2VyLm9wdGlvbnMubWF4RGF0ZS55ZWFyKCksXHJcbiAgICAgICAgICAgICAgICBlbmRNb250aCA9IHBpY2tlci5vcHRpb25zLm1heERhdGUubW9udGgoKSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLFxyXG4gICAgICAgICAgICAgICAgcHJldk1vbnRoLCBuZXh0TW9udGgsIGh0bWwgPSBbXSwgcm93LCBjbHNOYW1lLCBpLCBkYXlzLCB5ZWFyQ29udCwgY3VycmVudFllYXIsIG1vbnRocyA9IG1vbWVudC5tb250aHMoKTtcclxuXHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMnKS5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJykuZmluZCgnLmRpc2FibGVkJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJykuZmluZCgnLmRpc2FibGVkJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcblxyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoOmVxKDEpJykudGV4dChcclxuICAgICAgICAgICAgICAgIG1vbnRoc1ttb250aF0gKyAnICcgKyB5ZWFyKTtcclxuXHJcbiAgICAgICAgXHRwcmV2TW9udGggPSBtb21lbnQocGlja2VyLnZpZXdEYXRlLCBwaWNrZXIuZm9ybWF0LCBwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QpLnN1YnRyYWN0KDEsICdtb250aHMnKTtcclxuICAgICAgICBcdGRheXMgPSBwcmV2TW9udGguZGF5c0luTW9udGgoKTtcclxuICAgICAgICBcdHByZXZNb250aC5kYXRlKGRheXMpLnN0YXJ0T2YoJ3dlZWsnKTtcclxuICAgICAgICBcdGlmICgoeWVhciA9PT0gc3RhcnRZZWFyICYmIG1vbnRoIDw9IHN0YXJ0TW9udGgpIHx8IHllYXIgPCBzdGFydFllYXIpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoOmVxKDApJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoKHllYXIgPT09IGVuZFllYXIgJiYgbW9udGggPj0gZW5kTW9udGgpIHx8IHllYXIgPiBlbmRZZWFyKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0aDplcSgyKScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdG5leHRNb250aCA9IG1vbWVudChwcmV2TW9udGgpLmFkZCg0MiwgJ2QnKTtcclxuICAgICAgICBcdHdoaWxlIChwcmV2TW9udGguaXNCZWZvcmUobmV4dE1vbnRoKSkge1xyXG4gICAgICAgIFx0XHRpZiAocHJldk1vbnRoLndlZWtkYXkoKSA9PT0gbW9tZW50KCkuc3RhcnRPZignd2VlaycpLndlZWtkYXkoKSkge1xyXG4gICAgICAgIFx0XHRcdHJvdyA9ICQoJzx0cj4nKTtcclxuICAgICAgICBcdFx0XHRodG1sLnB1c2gocm93KTtcclxuICAgICAgICBcdFx0XHRpZiAocGlja2VyLm9wdGlvbnMuY2FsZW5kYXJXZWVrcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIFx0XHRcdFx0cm93LmFwcGVuZCgnPHRkIGNsYXNzPVwiY3dcIj4nICsgcHJldk1vbnRoLndlZWsoKSArICc8L3RkPicpO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRjbHNOYW1lID0gJyc7XHJcbiAgICAgICAgXHRcdGlmIChwcmV2TW9udGgueWVhcigpIDwgeWVhciB8fCAocHJldk1vbnRoLnllYXIoKSA9PT0geWVhciAmJiBwcmV2TW9udGgubW9udGgoKSA8IG1vbnRoKSkge1xyXG4gICAgICAgIFx0XHRcdGNsc05hbWUgKz0gJyBvbGQnO1xyXG4gICAgICAgIFx0XHR9IGVsc2UgaWYgKHByZXZNb250aC55ZWFyKCkgPiB5ZWFyIHx8IChwcmV2TW9udGgueWVhcigpID09PSB5ZWFyICYmIHByZXZNb250aC5tb250aCgpID4gbW9udGgpKSB7XHJcbiAgICAgICAgXHRcdFx0Y2xzTmFtZSArPSAnIG5ldyc7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0aWYgKHByZXZNb250aC5pc1NhbWUobW9tZW50KHsgeTogcGlja2VyLmRhdGUueWVhcigpLCBNOiBwaWNrZXIuZGF0ZS5tb250aCgpLCBkOiBwaWNrZXIuZGF0ZS5kYXRlKCkgfSkpKSB7XHJcbiAgICAgICAgXHRcdFx0Y2xzTmFtZSArPSAnIGFjdGl2ZSc7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0aWYgKGlzSW5EaXNhYmxlRGF0ZXMocHJldk1vbnRoLCAnZGF5JykgfHwgIWlzSW5FbmFibGVEYXRlcyhwcmV2TW9udGgpKSB7XHJcbiAgICAgICAgXHRcdFx0Y2xzTmFtZSArPSAnIGRpc2FibGVkJztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRpZiAocGlja2VyLm9wdGlvbnMuc2hvd1RvZGF5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgXHRcdFx0aWYgKHByZXZNb250aC5pc1NhbWUobW9tZW50KCksICdkYXknKSkge1xyXG4gICAgICAgIFx0XHRcdFx0Y2xzTmFtZSArPSAnIHRvZGF5JztcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5vcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZCkge1xyXG4gICAgICAgIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwaWNrZXIub3B0aW9ucy5kYXlzT2ZXZWVrRGlzYWJsZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBcdFx0XHRcdGlmIChwcmV2TW9udGguZGF5KCkgPT09IHBpY2tlci5vcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZFtpXSkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRjbHNOYW1lICs9ICcgZGlzYWJsZWQnO1xyXG4gICAgICAgIFx0XHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0cm93LmFwcGVuZCgnPHRkIGNsYXNzPVwiZGF5JyArIGNsc05hbWUgKyAnXCI+JyArIHByZXZNb250aC5kYXRlKCkgKyAnPC90ZD4nKTtcclxuXHJcbiAgICAgICAgXHRcdGN1cnJlbnREYXRlID0gcHJldk1vbnRoLmRhdGUoKTtcclxuICAgICAgICBcdFx0cHJldk1vbnRoLmFkZCgxLCAnZCcpO1xyXG5cclxuICAgICAgICBcdFx0aWYgKGN1cnJlbnREYXRlID09PSBwcmV2TW9udGguZGF0ZSgpKSB7XHJcbiAgICAgICAgXHRcdFx0cHJldk1vbnRoLmFkZCgxLCAnZCcpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGJvZHknKS5lbXB0eSgpLmFwcGVuZChodG1sKTtcclxuICAgICAgICBcdGN1cnJlbnRZZWFyID0gcGlja2VyLmRhdGUueWVhcigpO1xyXG4gICAgICAgIFx0bW9udGhzID0gcGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMnKS5maW5kKCd0aDplcSgxKScpLnRleHQoeWVhcikuZW5kKCkuZmluZCgnc3BhbicpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICBcdGlmIChjdXJyZW50WWVhciA9PT0geWVhcikge1xyXG4gICAgICAgIFx0XHRtb250aHMuZXEocGlja2VyLmRhdGUubW9udGgoKSkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKHllYXIgLSAxIDwgc3RhcnRZZWFyKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRoOmVxKDApJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoeWVhciArIDEgPiBlbmRZZWFyKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRoOmVxKDIpJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgIFx0XHRpZiAoKHllYXIgPT09IHN0YXJ0WWVhciAmJiBzdGFydE1vbnRoID4gaSkgfHwgKHllYXIgPCBzdGFydFllYXIpKSB7XHJcbiAgICAgICAgXHRcdFx0JChtb250aHNbaV0pLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIFx0XHR9IGVsc2UgaWYgKCh5ZWFyID09PSBlbmRZZWFyICYmIGVuZE1vbnRoIDwgaSkgfHwgKHllYXIgPiBlbmRZZWFyKSkge1xyXG4gICAgICAgIFx0XHRcdCQobW9udGhzW2ldKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGh0bWwgPSAnJztcclxuICAgICAgICBcdHllYXIgPSBwYXJzZUludCh5ZWFyIC8gMTAsIDEwKSAqIDEwO1xyXG4gICAgICAgIFx0eWVhckNvbnQgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJykuZmluZChcclxuICAgICAgICAgICAgICAgICd0aDplcSgxKScpLnRleHQoeWVhciArICctJyArICh5ZWFyICsgOSkpLnBhcmVudHMoJ3RhYmxlJykuZmluZCgndGQnKTtcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKCd0aCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIFx0aWYgKHN0YXJ0WWVhciA+IHllYXIpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci15ZWFycycpLmZpbmQoJ3RoOmVxKDApJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZW5kWWVhciA8IHllYXIgKyA5KSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKCd0aDplcSgyKScpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0eWVhciAtPSAxO1xyXG4gICAgICAgIFx0Zm9yIChpID0gLTE7IGkgPCAxMTsgaSsrKSB7XHJcbiAgICAgICAgXHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwieWVhcicgKyAoaSA9PT0gLTEgfHwgaSA9PT0gMTAgPyAnIG9sZCcgOiAnJykgKyAoY3VycmVudFllYXIgPT09IHllYXIgPyAnIGFjdGl2ZScgOiAnJykgKyAoKHllYXIgPCBzdGFydFllYXIgfHwgeWVhciA+IGVuZFllYXIpID8gJyBkaXNhYmxlZCcgOiAnJykgKyAnXCI+JyArIHllYXIgKyAnPC9zcGFuPic7XHJcbiAgICAgICAgXHRcdHllYXIgKz0gMTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHllYXJDb250Lmh0bWwoaHRtbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlsbEhvdXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHR2YXIgdGFibGUgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLWhvdXJzIHRhYmxlJyksIGh0bWwgPSAnJywgY3VycmVudCwgaSwgajtcclxuICAgICAgICBcdHRhYmxlLnBhcmVudCgpLmhpZGUoKTtcclxuICAgICAgICBcdGlmIChwaWNrZXIudXNlMjRob3Vycykge1xyXG4gICAgICAgIFx0XHRjdXJyZW50ID0gMDtcclxuICAgICAgICBcdFx0Zm9yIChpID0gMDsgaSA8IDY7IGkgKz0gMSkge1xyXG4gICAgICAgIFx0XHRcdGh0bWwgKz0gJzx0cj4nO1xyXG4gICAgICAgIFx0XHRcdGZvciAoaiA9IDA7IGogPCA0OyBqICs9IDEpIHtcclxuICAgICAgICBcdFx0XHRcdGh0bWwgKz0gJzx0ZCBjbGFzcz1cImhvdXJcIj4nICsgcGFkTGVmdChjdXJyZW50LnRvU3RyaW5nKCkpICsgJzwvdGQ+JztcclxuICAgICAgICBcdFx0XHRcdGN1cnJlbnQrKztcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0aHRtbCArPSAnPC90cj4nO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRlbHNlIHtcclxuICAgICAgICBcdFx0Y3VycmVudCA9IDE7XHJcbiAgICAgICAgXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpICs9IDEpIHtcclxuICAgICAgICBcdFx0XHRodG1sICs9ICc8dHI+JztcclxuICAgICAgICBcdFx0XHRmb3IgKGogPSAwOyBqIDwgNDsgaiArPSAxKSB7XHJcbiAgICAgICAgXHRcdFx0XHRodG1sICs9ICc8dGQgY2xhc3M9XCJob3VyXCI+JyArIHBhZExlZnQoY3VycmVudC50b1N0cmluZygpKSArICc8L3RkPic7XHJcbiAgICAgICAgXHRcdFx0XHRjdXJyZW50Kys7XHJcbiAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdGh0bWwgKz0gJzwvdHI+JztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0dGFibGUuaHRtbChodG1sKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaWxsTWludXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdHZhciB0YWJsZSA9IHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItbWludXRlcyB0YWJsZScpLCBodG1sID0gJycsIGN1cnJlbnQgPSAwLCBpLCBqLCBzdGVwID0gcGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmc7XHJcbiAgICAgICAgXHR0YWJsZS5wYXJlbnQoKS5oaWRlKCk7XHJcbiAgICAgICAgXHRpZiAoc3RlcCA9PT0gMSkge1xyXG4gICAgICAgIFx0XHRzdGVwID0gNTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGZvciAoaSA9IDA7IGkgPCBNYXRoLmNlaWwoNjAgLyBzdGVwIC8gNCkgOyBpKyspIHtcclxuICAgICAgICBcdFx0aHRtbCArPSAnPHRyPic7XHJcbiAgICAgICAgXHRcdGZvciAoaiA9IDA7IGogPCA0OyBqICs9IDEpIHtcclxuICAgICAgICBcdFx0XHRpZiAoY3VycmVudCA8IDYwKSB7XHJcbiAgICAgICAgXHRcdFx0XHRodG1sICs9ICc8dGQgY2xhc3M9XCJtaW51dGVcIj4nICsgcGFkTGVmdChjdXJyZW50LnRvU3RyaW5nKCkpICsgJzwvdGQ+JztcclxuICAgICAgICBcdFx0XHRcdGN1cnJlbnQgKz0gc3RlcDtcclxuICAgICAgICBcdFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdFx0aHRtbCArPSAnPHRkPjwvdGQ+JztcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0aHRtbCArPSAnPC90cj4nO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0dGFibGUuaHRtbChodG1sKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaWxsU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdHZhciB0YWJsZSA9IHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItc2Vjb25kcyB0YWJsZScpLCBodG1sID0gJycsIGN1cnJlbnQgPSAwLCBpLCBqO1xyXG4gICAgICAgIFx0dGFibGUucGFyZW50KCkuaGlkZSgpO1xyXG4gICAgICAgIFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgIFx0XHRodG1sICs9ICc8dHI+JztcclxuICAgICAgICBcdFx0Zm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xyXG4gICAgICAgIFx0XHRcdGh0bWwgKz0gJzx0ZCBjbGFzcz1cInNlY29uZFwiPicgKyBwYWRMZWZ0KGN1cnJlbnQudG9TdHJpbmcoKSkgKyAnPC90ZD4nO1xyXG4gICAgICAgIFx0XHRcdGN1cnJlbnQgKz0gNTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRodG1sICs9ICc8L3RyPic7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHR0YWJsZS5odG1sKGh0bWwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpbGxUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0aWYgKCFwaWNrZXIuZGF0ZSkge1xyXG4gICAgICAgIFx0XHRyZXR1cm47XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHR2YXIgdGltZUNvbXBvbmVudHMgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIHNwYW5bZGF0YS10aW1lLWNvbXBvbmVudF0nKSxcclxuICAgICAgICAgICAgICAgIGhvdXIgPSBwaWNrZXIuZGF0ZS5ob3VycygpLFxyXG4gICAgICAgICAgICAgICAgcGVyaW9kID0gcGlja2VyLmRhdGUuZm9ybWF0KCdBJyk7XHJcbiAgICAgICAgXHRpZiAoIXBpY2tlci51c2UyNGhvdXJzKSB7XHJcbiAgICAgICAgXHRcdGlmIChob3VyID09PSAwKSB7XHJcbiAgICAgICAgXHRcdFx0aG91ciA9IDEyO1xyXG4gICAgICAgIFx0XHR9IGVsc2UgaWYgKGhvdXIgIT09IDEyKSB7XHJcbiAgICAgICAgXHRcdFx0aG91ciA9IGhvdXIgJSAxMjtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIFtkYXRhLWFjdGlvbj10b2dnbGVQZXJpb2RdJykudGV4dChwZXJpb2QpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0dGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1ob3Vyc10nKS50ZXh0KHBhZExlZnQoaG91cikpO1xyXG4gICAgICAgIFx0dGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1taW51dGVzXScpLnRleHQocGFkTGVmdChwaWNrZXIuZGF0ZS5taW51dGVzKCkpKTtcclxuICAgICAgICBcdHRpbWVDb21wb25lbnRzLmZpbHRlcignW2RhdGEtdGltZS1jb21wb25lbnQ9c2Vjb25kc10nKS50ZXh0KHBhZExlZnQocGlja2VyLmRhdGUuc2Vjb25kKCkpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGljayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIFx0cGlja2VyLnVuc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgXHR2YXIgdGFyZ2V0ID0gJChlLnRhcmdldCkuY2xvc2VzdCgnc3BhbiwgdGQsIHRoJyksIG1vbnRoLCB5ZWFyLCBzdGVwLCBkYXksIG9sZERhdGUgPSBtb21lbnQocGlja2VyLmRhdGUpO1xyXG4gICAgICAgIFx0aWYgKHRhcmdldC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBcdFx0aWYgKCF0YXJnZXQuaXMoJy5kaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgXHRcdFx0c3dpdGNoICh0YXJnZXRbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgIFx0XHRcdFx0Y2FzZSAndGgnOlxyXG4gICAgICAgIFx0XHRcdFx0XHRzd2l0Y2ggKHRhcmdldFswXS5jbGFzc05hbWUpIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRjYXNlICdwaWNrZXItc3dpdGNoJzpcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdHNob3dNb2RlKDEpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0Y2FzZSAncHJldic6XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0Y2FzZSAnbmV4dCc6XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRzdGVwID0gZHBHbG9iYWwubW9kZXNbcGlja2VyLnZpZXdNb2RlXS5uYXZTdGVwO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldFswXS5jbGFzc05hbWUgPT09ICdwcmV2Jykge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0XHRzdGVwID0gc3RlcCAqIC0xO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0cGlja2VyLnZpZXdEYXRlLmFkZChzdGVwLCBkcEdsb2JhbC5tb2Rlc1twaWNrZXIudmlld01vZGVdLm5hdkZuYyk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRmaWxsRGF0ZSgpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0XHRjYXNlICdzcGFuJzpcclxuICAgICAgICBcdFx0XHRcdFx0aWYgKHRhcmdldC5pcygnLm1vbnRoJykpIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcclxuICAgICAgICBcdFx0XHRcdFx0XHRwaWNrZXIudmlld0RhdGUubW9udGgobW9udGgpO1xyXG4gICAgICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCkgfHwgMDtcclxuICAgICAgICBcdFx0XHRcdFx0XHRwaWNrZXIudmlld0RhdGUueWVhcih5ZWFyKTtcclxuICAgICAgICBcdFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdFx0XHRpZiAocGlja2VyLnZpZXdNb2RlID09PSBwaWNrZXIubWluVmlld01vZGUpIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRwaWNrZXIuZGF0ZSA9IG1vbWVudCh7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHR5OiBwaWNrZXIudmlld0RhdGUueWVhcigpLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0TTogcGlja2VyLnZpZXdEYXRlLm1vbnRoKCksXHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRkOiBwaWNrZXIudmlld0RhdGUuZGF0ZSgpLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0aDogcGlja2VyLmRhdGUuaG91cnMoKSxcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdG06IHBpY2tlci5kYXRlLm1pbnV0ZXMoKSxcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdHM6IHBpY2tlci5kYXRlLnNlY29uZHMoKVxyXG4gICAgICAgIFx0XHRcdFx0XHRcdH0pO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdHNldCgpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xyXG4gICAgICAgIFx0XHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0XHRcdHNob3dNb2RlKC0xKTtcclxuICAgICAgICBcdFx0XHRcdFx0ZmlsbERhdGUoKTtcclxuICAgICAgICBcdFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0XHRjYXNlICd0ZCc6XHJcbiAgICAgICAgXHRcdFx0XHRcdGlmICh0YXJnZXQuaXMoJy5kYXknKSkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdGRheSA9IHBhcnNlSW50KHRhcmdldC50ZXh0KCksIDEwKSB8fCAxO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdG1vbnRoID0gcGlja2VyLnZpZXdEYXRlLm1vbnRoKCk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0eWVhciA9IHBpY2tlci52aWV3RGF0ZS55ZWFyKCk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0aWYgKHRhcmdldC5pcygnLm9sZCcpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRpZiAobW9udGggPT09IDApIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdFx0bW9udGggPSAxMTtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdFx0eWVhciAtPSAxO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdFx0bW9udGggLT0gMTtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5pcygnLm5ldycpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRpZiAobW9udGggPT09IDExKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gMDtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdFx0eWVhciArPSAxO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdFx0bW9udGggKz0gMTtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0cGlja2VyLmRhdGUgPSBtb21lbnQoe1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0eTogeWVhcixcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdE06IG1vbnRoLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0ZDogZGF5LFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0aDogcGlja2VyLmRhdGUuaG91cnMoKSxcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdG06IHBpY2tlci5kYXRlLm1pbnV0ZXMoKSxcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdHM6IHBpY2tlci5kYXRlLnNlY29uZHMoKVxyXG4gICAgICAgIFx0XHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdHBpY2tlci52aWV3RGF0ZSA9IG1vbWVudCh7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHR5OiB5ZWFyLCBNOiBtb250aCwgZDogTWF0aC5taW4oMjgsIGRheSlcclxuICAgICAgICBcdFx0XHRcdFx0XHR9KTtcclxuICAgICAgICBcdFx0XHRcdFx0XHRmaWxsRGF0ZSgpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdHNldCgpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xyXG4gICAgICAgIFx0XHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFjdGlvbnMgPSB7XHJcbiAgICAgICAgXHRpbmNyZW1lbnRIb3VyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHRjaGVja0RhdGUoJ2FkZCcsICdob3VycycsIDEpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRpbmNyZW1lbnRNaW51dGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdGNoZWNrRGF0ZSgnYWRkJywgJ21pbnV0ZXMnLCBwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZyk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdGluY3JlbWVudFNlY29uZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdFx0Y2hlY2tEYXRlKCdhZGQnLCAnc2Vjb25kcycsIDEpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRkZWNyZW1lbnRIb3VyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHRjaGVja0RhdGUoJ3N1YnRyYWN0JywgJ2hvdXJzJywgMSk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdGRlY3JlbWVudE1pbnV0ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdFx0Y2hlY2tEYXRlKCdzdWJ0cmFjdCcsICdtaW51dGVzJywgcGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmcpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRkZWNyZW1lbnRTZWNvbmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdGNoZWNrRGF0ZSgnc3VidHJhY3QnLCAnc2Vjb25kcycsIDEpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHR0b2dnbGVQZXJpb2Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdFx0dmFyIGhvdXIgPSBwaWNrZXIuZGF0ZS5ob3VycygpO1xyXG4gICAgICAgIFx0XHRpZiAoaG91ciA+PSAxMikge1xyXG4gICAgICAgIFx0XHRcdGhvdXIgLT0gMTI7XHJcbiAgICAgICAgXHRcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdFx0aG91ciArPSAxMjtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRwaWNrZXIuZGF0ZS5ob3Vycyhob3VyKTtcclxuICAgICAgICBcdH0sXHJcblxyXG4gICAgICAgIFx0c2hvd1BpY2tlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyID4gZGl2Om5vdCgudGltZXBpY2tlci1waWNrZXIpJykuaGlkZSgpO1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLnNob3coKTtcclxuICAgICAgICBcdH0sXHJcblxyXG4gICAgICAgIFx0c2hvd0hvdXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItcGlja2VyJykuaGlkZSgpO1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLWhvdXJzJykuc2hvdygpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRzaG93TWludXRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLmhpZGUoKTtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1taW51dGVzJykuc2hvdygpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRzaG93U2Vjb25kczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXBpY2tlcicpLmhpZGUoKTtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1zZWNvbmRzJykuc2hvdygpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRzZWxlY3RIb3VyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIFx0XHR2YXIgaG91ciA9IHBhcnNlSW50KCQoZS50YXJnZXQpLnRleHQoKSwgMTApO1xyXG4gICAgICAgIFx0XHRpZiAoIXBpY2tlci51c2UyNGhvdXJzKSB7XHJcbiAgICAgICAgXHRcdFx0aWYgKHBpY2tlci5kYXRlLmhvdXJzKCkgPj0gMTIpIHtcclxuICAgICAgICBcdFx0XHRcdGlmIChob3VyICE9PSAxMikge1xyXG4gICAgICAgIFx0XHRcdFx0XHRob3VyICs9IDEyO1xyXG4gICAgICAgIFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdFx0XHRpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICBcdFx0XHRcdFx0aG91ciA9IDA7XHJcbiAgICAgICAgXHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHBpY2tlci5kYXRlLmhvdXJzKGhvdXIpO1xyXG4gICAgICAgIFx0XHRhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRzZWxlY3RNaW51dGU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5kYXRlLm1pbnV0ZXMocGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCkpO1xyXG4gICAgICAgIFx0XHRhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRzZWxlY3RTZWNvbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5kYXRlLnNlY29uZHMocGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCkpO1xyXG4gICAgICAgIFx0XHRhY3Rpb25zLnNob3dQaWNrZXIuY2FsbChwaWNrZXIpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRvQWN0aW9uID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdHZhciBvbGREYXRlID0gbW9tZW50KHBpY2tlci5kYXRlKSxcclxuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdhY3Rpb24nKSxcclxuICAgICAgICAgICAgICAgIHJ2ID0gYWN0aW9uc1thY3Rpb25dLmFwcGx5KHBpY2tlciwgYXJndW1lbnRzKTtcclxuICAgICAgICBcdHN0b3BFdmVudChlKTtcclxuICAgICAgICBcdGlmICghcGlja2VyLmRhdGUpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmRhdGUgPSBtb21lbnQoeyB5OiAxOTcwIH0pO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0c2V0KCk7XHJcbiAgICAgICAgXHRmaWxsVGltZSgpO1xyXG4gICAgICAgIFx0bm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XHJcbiAgICAgICAgXHRyZXR1cm4gcnY7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3RvcEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgXHRlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAga2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRpZiAoZS5rZXlDb2RlID09PSAyNykgeyAvLyBhbGxvdyBlc2NhcGUgdG8gaGlkZSBwaWNrZXJcclxuICAgICAgICBcdFx0cGlja2VyLmhpZGUoKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHR2YXIgaW5wdXQgPSAkKGUudGFyZ2V0KSwgb2xkRGF0ZSA9IG1vbWVudChwaWNrZXIuZGF0ZSksIG5ld0RhdGUgPSBtb21lbnQoaW5wdXQudmFsKCksIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCk7XHJcbiAgICAgICAgXHRpZiAobmV3RGF0ZS5pc1ZhbGlkKCkgJiYgIWlzSW5EaXNhYmxlRGF0ZXMobmV3RGF0ZSkgJiYgaXNJbkVuYWJsZURhdGVzKG5ld0RhdGUpKSB7XHJcbiAgICAgICAgXHRcdHVwZGF0ZSgpO1xyXG4gICAgICAgIFx0XHRwaWNrZXIuc2V0VmFsdWUobmV3RGF0ZSk7XHJcbiAgICAgICAgXHRcdG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xyXG4gICAgICAgIFx0XHRzZXQoKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGVsc2Uge1xyXG4gICAgICAgIFx0XHRwaWNrZXIudmlld0RhdGUgPSBvbGREYXRlO1xyXG4gICAgICAgIFx0XHRwaWNrZXIudW5zZXQgPSB0cnVlO1xyXG4gICAgICAgIFx0XHRub3RpZnlDaGFuZ2Uob2xkRGF0ZSwgZS50eXBlKTtcclxuICAgICAgICBcdFx0bm90aWZ5RXJyb3IobmV3RGF0ZSk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2hvd01vZGUgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgXHRpZiAoZGlyKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci52aWV3TW9kZSA9IE1hdGgubWF4KHBpY2tlci5taW5WaWV3TW9kZSwgTWF0aC5taW4oMiwgcGlja2VyLnZpZXdNb2RlICsgZGlyKSk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyID4gZGl2JykuaGlkZSgpLmZpbHRlcignLmRhdGVwaWNrZXItJyArIGRwR2xvYmFsLm1vZGVzW3BpY2tlci52aWV3TW9kZV0uY2xzTmFtZSkuc2hvdygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGF0dGFjaERhdGVQaWNrZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHR2YXIgJHRoaXMsICRwYXJlbnQsIGV4cGFuZGVkLCBjbG9zZWQsIGNvbGxhcHNlRGF0YTtcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQub24oJ2NsaWNrJywgJy5kYXRlcGlja2VyIConLCAkLnByb3h5KGNsaWNrLCB0aGlzKSk7IC8vIHRoaXMgaGFuZGxlcyBkYXRlIHBpY2tlciBjbGlja3NcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQub24oJ2NsaWNrJywgJ1tkYXRhLWFjdGlvbl0nLCAkLnByb3h5KGRvQWN0aW9uLCB0aGlzKSk7IC8vIHRoaXMgaGFuZGxlcyB0aW1lIHBpY2tlciBjbGlja3NcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQub24oJ21vdXNlZG93bicsICQucHJveHkoc3RvcEV2ZW50LCB0aGlzKSk7XHJcbiAgICAgICAgXHRwaWNrZXIuZWxlbWVudC5vbigna2V5ZG93bicsICQucHJveHkoa2V5ZG93biwgdGhpcykpO1xyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLnBpY2tEYXRlICYmIHBpY2tlci5vcHRpb25zLnBpY2tUaW1lKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQub24oJ2NsaWNrLnRvZ2dsZVBpY2tlcicsICcuYWNjb3JkaW9uLXRvZ2dsZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBcdFx0XHQkdGhpcyA9ICQodGhpcyk7XHJcbiAgICAgICAgXHRcdFx0JHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJ3VsJyk7XHJcbiAgICAgICAgXHRcdFx0ZXhwYW5kZWQgPSAkcGFyZW50LmZpbmQoJy5pbicpO1xyXG4gICAgICAgIFx0XHRcdGNsb3NlZCA9ICRwYXJlbnQuZmluZCgnLmNvbGxhcHNlOm5vdCguaW4pJyk7XHJcblxyXG4gICAgICAgIFx0XHRcdGlmIChleHBhbmRlZCAmJiBleHBhbmRlZC5sZW5ndGgpIHtcclxuICAgICAgICBcdFx0XHRcdGNvbGxhcHNlRGF0YSA9IGV4cGFuZGVkLmRhdGEoJ2NvbGxhcHNlJyk7XHJcbiAgICAgICAgXHRcdFx0XHRpZiAoY29sbGFwc2VEYXRhICYmIGNvbGxhcHNlRGF0YS50cmFuc2l0aW9uaW5nKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdHJldHVybjtcclxuICAgICAgICBcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRcdGV4cGFuZGVkLmNvbGxhcHNlKCdoaWRlJyk7XHJcbiAgICAgICAgXHRcdFx0XHRjbG9zZWQuY29sbGFwc2UoJ3Nob3cnKTtcclxuICAgICAgICBcdFx0XHRcdCR0aGlzLmZpbmQoJ3NwYW4nKS50b2dnbGVDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy50aW1lICsgJyAnICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZGF0ZSk7XHJcbiAgICAgICAgXHRcdFx0XHRpZiAocGlja2VyLmNvbXBvbmVudCkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRwaWNrZXIuY29tcG9uZW50LmZpbmQoJ3NwYW4nKS50b2dnbGVDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy50aW1lICsgJyAnICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZGF0ZSk7XHJcbiAgICAgICAgXHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgIFx0XHR9KTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChwaWNrZXIuaXNJbnB1dCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIuZWxlbWVudC5vbih7XHJcbiAgICAgICAgXHRcdFx0J2NsaWNrJzogJC5wcm94eShwaWNrZXIuc2hvdywgdGhpcyksXHJcbiAgICAgICAgXHRcdFx0J2ZvY3VzJzogJC5wcm94eShwaWNrZXIuc2hvdywgdGhpcyksXHJcbiAgICAgICAgXHRcdFx0J2NoYW5nZSc6ICQucHJveHkoY2hhbmdlLCB0aGlzKSxcclxuICAgICAgICBcdFx0XHQnYmx1cic6ICQucHJveHkocGlja2VyLmhpZGUsIHRoaXMpXHJcbiAgICAgICAgXHRcdH0pO1xyXG4gICAgICAgIFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0cGlja2VyLmVsZW1lbnQub24oe1xyXG4gICAgICAgIFx0XHRcdCdjaGFuZ2UnOiAkLnByb3h5KGNoYW5nZSwgdGhpcylcclxuICAgICAgICBcdFx0fSwgJ2lucHV0Jyk7XHJcbiAgICAgICAgXHRcdGlmIChwaWNrZXIuY29tcG9uZW50KSB7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmNvbXBvbmVudC5vbignY2xpY2snLCAkLnByb3h5KHBpY2tlci5zaG93LCB0aGlzKSk7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmNvbXBvbmVudC5vbignbW91c2Vkb3duJywgJC5wcm94eShzdG9wRXZlbnQsIHRoaXMpKTtcclxuICAgICAgICBcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuZWxlbWVudC5vbignY2xpY2snLCAkLnByb3h5KHBpY2tlci5zaG93LCB0aGlzKSk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci53aWRnZXQub24oJ2NsaWNrLnRvZ2dsZVBpY2tlcicsICcjdG9kYXktYnV0dG9uJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5vcHRpb25zLm1pbnV0ZVN0ZXBwaW5nICE9PSAxKSB7XHJcbiAgICAgICAgXHRcdFx0dmFyIG1EYXRlID0gbW9tZW50KCksXHJcblx0XHRcdFx0XHRcdHJJbnRlcnZhbCA9IHBpY2tlci5vcHRpb25zLm1pbnV0ZVN0ZXBwaW5nO1xyXG4gICAgICAgIFx0XHRcdG1EYXRlLm1pbnV0ZXMoKE1hdGgucm91bmQobURhdGUubWludXRlcygpIC8gckludGVydmFsKSAqIHJJbnRlcnZhbCkgJSA2MCkuc2Vjb25kcygwKTtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuc2V0VmFsdWUobURhdGUuZm9ybWF0KHBpY2tlci5mb3JtYXQpKTtcclxuICAgICAgICBcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuc2V0VmFsdWUobW9tZW50KCkuZm9ybWF0KHBpY2tlci5mb3JtYXQpKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRub3RpZnlDaGFuZ2UoJycsIGUudHlwZSk7XHJcbiAgICAgICAgXHRcdHNldCgpO1xyXG4gICAgICAgIFx0fSk7XHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0Lm9uKCdjbGljay50b2dnbGVQaWNrZXInLCAnI2NsZWFyLWJ1dHRvbicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5zZXRWYWx1ZShudWxsKTtcclxuICAgICAgICBcdFx0bm90aWZ5Q2hhbmdlKCcnLCBlLnR5cGUpO1xyXG4gICAgICAgIFx0fSk7XHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0Lm9uKCdjbGljay50b2dnbGVQaWNrZXInLCAnI2Nsb3NlLWJ1dHRvbicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5oaWRlKCk7XHJcbiAgICAgICAgXHR9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhdHRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0JCh3aW5kb3cpLm9uKFxyXG4gICAgICAgICAgICAgICAgJ3Jlc2l6ZS5kYXRldGltZXBpY2tlcicgKyBwaWNrZXIuaWQsICQucHJveHkocGxhY2UsIHRoaXMpKTtcclxuICAgICAgICBcdGlmICghcGlja2VyLmlzSW5wdXQpIHtcclxuICAgICAgICBcdFx0JChkb2N1bWVudCkub24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlZG93bi5kYXRldGltZXBpY2tlcicgKyBwaWNrZXIuaWQsICQucHJveHkocGlja2VyLmhpZGUsIHRoaXMpKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZXRhY2hEYXRlUGlja2VyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5vZmYoJ2NsaWNrJywgJy5kYXRlcGlja2VyIConLCBwaWNrZXIuY2xpY2spO1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5vZmYoJ2NsaWNrJywgJ1tkYXRhLWFjdGlvbl0nKTtcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQub2ZmKCdtb3VzZWRvd24nLCBwaWNrZXIuc3RvcEV2ZW50KTtcclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSAmJiBwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0Lm9mZignY2xpY2sudG9nZ2xlUGlja2VyJyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAocGlja2VyLmlzSW5wdXQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmVsZW1lbnQub2ZmKHtcclxuICAgICAgICBcdFx0XHQnZm9jdXMnOiBwaWNrZXIuc2hvdyxcclxuICAgICAgICBcdFx0XHQnY2hhbmdlJzogY2hhbmdlLFxyXG4gICAgICAgIFx0XHRcdCdjbGljayc6IHBpY2tlci5zaG93LFxyXG4gICAgICAgIFx0XHRcdCdibHVyJzogcGlja2VyLmhpZGVcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRwaWNrZXIuZWxlbWVudC5vZmYoe1xyXG4gICAgICAgIFx0XHRcdCdjaGFuZ2UnOiBjaGFuZ2VcclxuICAgICAgICBcdFx0fSwgJ2lucHV0Jyk7XHJcbiAgICAgICAgXHRcdGlmIChwaWNrZXIuY29tcG9uZW50KSB7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmNvbXBvbmVudC5vZmYoJ2NsaWNrJywgcGlja2VyLnNob3cpO1xyXG4gICAgICAgIFx0XHRcdHBpY2tlci5jb21wb25lbnQub2ZmKCdtb3VzZWRvd24nLCBwaWNrZXIuc3RvcEV2ZW50KTtcclxuICAgICAgICBcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuZWxlbWVudC5vZmYoJ2NsaWNrJywgcGlja2VyLnNob3cpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGV0YWNoRGF0ZVBpY2tlckdsb2JhbEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdCQod2luZG93KS5vZmYoJ3Jlc2l6ZS5kYXRldGltZXBpY2tlcicgKyBwaWNrZXIuaWQpO1xyXG4gICAgICAgIFx0aWYgKCFwaWNrZXIuaXNJbnB1dCkge1xyXG4gICAgICAgIFx0XHQkKGRvY3VtZW50KS5vZmYoJ21vdXNlZG93bi5kYXRldGltZXBpY2tlcicgKyBwaWNrZXIuaWQpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzSW5GaXhlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdGlmIChwaWNrZXIuZWxlbWVudCkge1xyXG4gICAgICAgIFx0XHR2YXIgcGFyZW50cyA9IHBpY2tlci5lbGVtZW50LnBhcmVudHMoKSwgaW5GaXhlZCA9IGZhbHNlLCBpO1xyXG4gICAgICAgIFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIFx0XHRcdGlmICgkKHBhcmVudHNbaV0pLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICAgIFx0XHRcdFx0aW5GaXhlZCA9IHRydWU7XHJcbiAgICAgICAgXHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0cmV0dXJuIGluRml4ZWQ7XHJcbiAgICAgICAgXHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHR2YXIgZm9ybWF0dGVkID0gJyc7XHJcbiAgICAgICAgXHRpZiAoIXBpY2tlci51bnNldCkge1xyXG4gICAgICAgIFx0XHRmb3JtYXR0ZWQgPSBtb21lbnQocGlja2VyLmRhdGUpLmZvcm1hdChwaWNrZXIuZm9ybWF0KTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGdldFBpY2tlcklucHV0KCkudmFsKGZvcm1hdHRlZCk7XHJcbiAgICAgICAgXHRwaWNrZXIuZWxlbWVudC5kYXRhKCdkYXRlJywgZm9ybWF0dGVkKTtcclxuICAgICAgICBcdGlmICghcGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmhpZGUoKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjaGVja0RhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCB1bml0LCBhbW91bnQpIHtcclxuICAgICAgICBcdG1vbWVudC5sb2NhbGUocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xyXG4gICAgICAgIFx0dmFyIG5ld0RhdGU7XHJcbiAgICAgICAgXHRpZiAoZGlyZWN0aW9uID09PSAnYWRkJykge1xyXG4gICAgICAgIFx0XHRuZXdEYXRlID0gbW9tZW50KHBpY2tlci5kYXRlKTtcclxuICAgICAgICBcdFx0aWYgKG5ld0RhdGUuaG91cnMoKSA9PT0gMjMpIHtcclxuICAgICAgICBcdFx0XHRuZXdEYXRlLmFkZChhbW91bnQsIHVuaXQpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdG5ld0RhdGUuYWRkKGFtb3VudCwgdW5pdCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRlbHNlIHtcclxuICAgICAgICBcdFx0bmV3RGF0ZSA9IG1vbWVudChwaWNrZXIuZGF0ZSkuc3VidHJhY3QoYW1vdW50LCB1bml0KTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChpc0luRGlzYWJsZURhdGVzKG1vbWVudChuZXdEYXRlLnN1YnRyYWN0KGFtb3VudCwgdW5pdCkpKSB8fCBpc0luRGlzYWJsZURhdGVzKG5ld0RhdGUpKSB7XHJcbiAgICAgICAgXHRcdG5vdGlmeUVycm9yKG5ld0RhdGUuZm9ybWF0KHBpY2tlci5mb3JtYXQpKTtcclxuICAgICAgICBcdFx0cmV0dXJuO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGlmIChkaXJlY3Rpb24gPT09ICdhZGQnKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5kYXRlLmFkZChhbW91bnQsIHVuaXQpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0ZWxzZSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5kYXRlLnN1YnRyYWN0KGFtb3VudCwgdW5pdCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRwaWNrZXIudW5zZXQgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0luRGlzYWJsZURhdGVzID0gZnVuY3Rpb24gKGRhdGUsIHRpbWVVbml0KSB7XHJcbiAgICAgICAgXHRtb21lbnQubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgICAgICBcdHZhciBtYXhEYXRlID0gbW9tZW50KHBpY2tlci5vcHRpb25zLm1heERhdGUsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCksXHJcbiAgICAgICAgICAgICAgICBtaW5EYXRlID0gbW9tZW50KHBpY2tlci5vcHRpb25zLm1pbkRhdGUsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCk7XHJcblxyXG4gICAgICAgIFx0aWYgKHRpbWVVbml0KSB7XHJcbiAgICAgICAgXHRcdG1heERhdGUgPSBtYXhEYXRlLmVuZE9mKHRpbWVVbml0KTtcclxuICAgICAgICBcdFx0bWluRGF0ZSA9IG1pbkRhdGUuc3RhcnRPZih0aW1lVW5pdCk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0aWYgKGRhdGUuaXNBZnRlcihtYXhEYXRlKSB8fCBkYXRlLmlzQmVmb3JlKG1pbkRhdGUpKSB7XHJcbiAgICAgICAgXHRcdHJldHVybiB0cnVlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLmRpc2FibGVkRGF0ZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgXHRcdHJldHVybiBmYWxzZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHJldHVybiBwaWNrZXIub3B0aW9ucy5kaXNhYmxlZERhdGVzW2RhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyldID09PSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNJbkVuYWJsZURhdGVzID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICBcdG1vbWVudC5sb2NhbGUocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIHRydWU7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRyZXR1cm4gcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzW2RhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyldID09PSB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGluZGV4R2l2ZW5EYXRlcyA9IGZ1bmN0aW9uIChnaXZlbkRhdGVzQXJyYXkpIHtcclxuICAgICAgICBcdC8vIFN0b3JlIGdpdmVuIGVuYWJsZWREYXRlcyBhbmQgZGlzYWJsZWREYXRlcyBhcyBrZXlzLlxyXG4gICAgICAgIFx0Ly8gVGhpcyB3YXkgd2UgY2FuIGNoZWNrIHRoZWlyIGV4aXN0ZW5jZSBpbiBPKDEpIHRpbWUgaW5zdGVhZCBvZiBsb29waW5nIHRocm91Z2ggd2hvbGUgYXJyYXkuXHJcbiAgICAgICAgXHQvLyAoZm9yIGV4YW1wbGU6IHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlc1snMjAxNC0wMi0yNyddID09PSB0cnVlKVxyXG4gICAgICAgIFx0dmFyIGdpdmVuRGF0ZXNJbmRleGVkID0ge30sIGdpdmVuRGF0ZXNDb3VudCA9IDAsIGk7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAwOyBpIDwgZ2l2ZW5EYXRlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgXHRcdGlmIChtb21lbnQuaXNNb21lbnQoZ2l2ZW5EYXRlc0FycmF5W2ldKSB8fCBnaXZlbkRhdGVzQXJyYXlbaV0gaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgXHRcdFx0ZERhdGUgPSBtb21lbnQoZ2l2ZW5EYXRlc0FycmF5W2ldKTtcclxuICAgICAgICBcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRkRGF0ZSA9IG1vbWVudChnaXZlbkRhdGVzQXJyYXlbaV0sIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0aWYgKGREYXRlLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIFx0XHRcdGdpdmVuRGF0ZXNJbmRleGVkW2REYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpXSA9IHRydWU7XHJcbiAgICAgICAgXHRcdFx0Z2l2ZW5EYXRlc0NvdW50Kys7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChnaXZlbkRhdGVzQ291bnQgPiAwKSB7XHJcbiAgICAgICAgXHRcdHJldHVybiBnaXZlbkRhdGVzSW5kZXhlZDtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwYWRMZWZ0ID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIFx0c3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgXHRpZiAoc3RyaW5nLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgXHRcdHJldHVybiBzdHJpbmc7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRyZXR1cm4gJzAnICsgc3RyaW5nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0dmFyXHJcbiAgICAgICAgICAgICAgICBoZWFkVGVtcGxhdGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRoZWFkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwicHJldlwiPiZsc2FxdW87PC90aD48dGggY29sc3Bhbj1cIicgKyAocGlja2VyLm9wdGlvbnMuY2FsZW5kYXJXZWVrcyA/ICc2JyA6ICc1JykgKyAnXCIgY2xhc3M9XCJwaWNrZXItc3dpdGNoXCI+PC90aD48dGggY2xhc3M9XCJuZXh0XCI+JnJzYXF1bzs8L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3RoZWFkPicsXHJcbiAgICAgICAgICAgICAgICBjb250VGVtcGxhdGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRib2R5Pjx0cj48dGQgY29sc3Bhbj1cIicgKyAocGlja2VyLm9wdGlvbnMuY2FsZW5kYXJXZWVrcyA/ICc4JyA6ICc3JykgKyAnXCI+PC90ZD48L3RyPjwvdGJvZHk+JyxcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRheXNcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JyArIGhlYWRUZW1wbGF0ZSArICc8dGJvZHk+PC90Ym9keT48L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLW1vbnRoc1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nICsgaGVhZFRlbXBsYXRlICsgY29udFRlbXBsYXRlICsgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXIteWVhcnNcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JyArIGhlYWRUZW1wbGF0ZSArIGNvbnRUZW1wbGF0ZSArICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicsXHJcbiAgICAgICAgICAgICAgICByZXQgPSAnJztcclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSAmJiBwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xyXG4gICAgICAgIFx0XHRyZXQgPSAnPGRpdiBjbGFzcz1cImJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQnICsgKHBpY2tlci5vcHRpb25zLnNpZGVCeVNpZGUgPyAnIHRpbWVwaWNrZXItc2JzJyA6ICcnKSArIChwaWNrZXIudXNlMjRob3VycyA/ICcgdXNldHdlbnR5Zm91cicgOiAnJykgKyAnIGRyb3Bkb3duLW1lbnVcIiBzdHlsZT1cInotaW5kZXg6OTk5OSAhaW1wb3J0YW50O1wiPic7XHJcbiAgICAgICAgXHRcdGlmIChwaWNrZXIub3B0aW9ucy5zaWRlQnlTaWRlKSB7XHJcbiAgICAgICAgXHRcdFx0cmV0ICs9ICc8ZGl2IGNsYXNzPVwicm93XCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjb2wtc20tNiBkYXRlcGlja2VyXCI+JyArIHRlbXBsYXRlICsgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY29sLXNtLTYgdGltZXBpY2tlclwiPicgKyB0cEdsb2JhbC5nZXRUZW1wbGF0ZSgpICsgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcclxuICAgICAgICBcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRyZXQgKz0gJzx1bCBjbGFzcz1cImxpc3QtdW5zdHlsZWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxsaScgKyAocGlja2VyLm9wdGlvbnMuY29sbGFwc2UgPyAnIGNsYXNzPVwiY29sbGFwc2UgaW5cIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyXCI+JyArIHRlbXBsYXRlICsgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9saT4nICtcclxuXHRcdFx0XHRcdFx0JzxsaT4nICtcclxuXHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiYnRuLWdyb3VwXCIgc3R5bGU9XCJmbG9hdDpsZWZ0OyBtYXJnaW4tbGVmdDo0cHhcIj4nICtcclxuXHRcdFx0XHRcdFx0JzxidXR0b24gY2xhc3M9XCJidG4gYnRuLWluZm9cIlwiIGlkPVwidG9kYXktYnV0dG9uXCI+IE5vdyA8L2J1dHRvbj4nICtcclxuXHRcdFx0XHRcdFx0JzxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRhbmdlclwiIGlkPVwiY2xlYXItYnV0dG9uXCI+IENsZWFyIDwvYnV0dG9uPicgK1xyXG5cdFx0XHRcdFx0XHQnPC9zcGFuPicgK1xyXG5cdFx0XHRcdFx0XHQnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc3VjY2Vzc1wiIGlkPVwiY2xvc2UtYnV0dG9uXCIgc3R5bGU9XCJmbG9hdDpyaWdodDsgbWFyZ2luLXJpZ2h0OjRweDtcIj5Eb25lPC9idXR0b24+JyArXHJcblx0XHRcdFx0XHRcdCc8ZGl2IHN0eWxlPVwiY2xlYXI6Ym90aDsgcGFkZGluZy1ib3R0b206NXB4O1wiPjwvZGl2PicgK1xyXG5cdFx0XHRcdFx0XHQnPC9saT4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxsaScgKyAocGlja2VyLm9wdGlvbnMuY29sbGFwc2UgPyAnIGNsYXNzPVwiY29sbGFwc2VcIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyXCI+JyArIHRwR2xvYmFsLmdldFRlbXBsYXRlKCkgKyAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2xpPicgK1xyXG4gICAgICAgICAgICAgICAgICAgJzwvdWw+JztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRyZXQgKz0gJzwvZGl2Pic7XHJcbiAgICAgICAgXHRcdHJldHVybiByZXQ7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgZHJvcGRvd24tbWVudVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXJcIj4nICsgdHBHbG9iYWwuZ2V0VGVtcGxhdGUoKSArICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+J1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgZHJvcGRvd24tbWVudVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlclwiPicgKyB0ZW1wbGF0ZSArICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZHBHbG9iYWwgPSB7XHJcbiAgICAgICAgXHRtb2RlczogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHRjbHNOYW1lOiAnZGF5cycsXHJcbiAgICAgICAgICAgICAgICBcdG5hdkZuYzogJ21vbnRoJyxcclxuICAgICAgICAgICAgICAgIFx0bmF2U3RlcDogMVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFx0Y2xzTmFtZTogJ21vbnRocycsXHJcbiAgICAgICAgICAgICAgICBcdG5hdkZuYzogJ3llYXInLFxyXG4gICAgICAgICAgICAgICAgXHRuYXZTdGVwOiAxXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHRjbHNOYW1lOiAneWVhcnMnLFxyXG4gICAgICAgICAgICAgICAgXHRuYXZGbmM6ICd5ZWFyJyxcclxuICAgICAgICAgICAgICAgIFx0bmF2U3RlcDogMTBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICBcdF1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0cEdsb2JhbCA9IHtcclxuICAgICAgICBcdGhvdXJUZW1wbGF0ZTogJzxzcGFuIGRhdGEtYWN0aW9uPVwic2hvd0hvdXJzXCIgICBkYXRhLXRpbWUtY29tcG9uZW50PVwiaG91cnNcIiAgIGNsYXNzPVwidGltZXBpY2tlci1ob3VyXCI+PC9zcGFuPicsXHJcbiAgICAgICAgXHRtaW51dGVUZW1wbGF0ZTogJzxzcGFuIGRhdGEtYWN0aW9uPVwic2hvd01pbnV0ZXNcIiBkYXRhLXRpbWUtY29tcG9uZW50PVwibWludXRlc1wiIGNsYXNzPVwidGltZXBpY2tlci1taW51dGVcIj48L3NwYW4+JyxcclxuICAgICAgICBcdHNlY29uZFRlbXBsYXRlOiAnPHNwYW4gZGF0YS1hY3Rpb249XCJzaG93U2Vjb25kc1wiICBkYXRhLXRpbWUtY29tcG9uZW50PVwic2Vjb25kc1wiIGNsYXNzPVwidGltZXBpY2tlci1zZWNvbmRcIj48L3NwYW4+J1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgXHR0cEdsb2JhbC5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIFx0XHRyZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLXBpY2tlclwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQ+PGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiIGRhdGEtYWN0aW9uPVwiaW5jcmVtZW50SG91cnNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy51cCArICdcIj48L3NwYW4+PC9hPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQ+JyArIChwaWNrZXIub3B0aW9ucy51c2VNaW51dGVzID8gJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImluY3JlbWVudE1pbnV0ZXNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy51cCArICdcIj48L3NwYW4+PC9hPicgOiAnJykgKyAnPC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwaWNrZXIub3B0aW9ucy51c2VTZWNvbmRzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD48dGQ+PGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiIGRhdGEtYWN0aW9uPVwiaW5jcmVtZW50U2Vjb25kc1wiPjxzcGFuIGNsYXNzPVwiJyArIHBpY2tlci5vcHRpb25zLmljb25zLnVwICsgJ1wiPjwvc3Bhbj48L2E+PC90ZD4nIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwaWNrZXIudXNlMjRob3VycyA/ICcnIDogJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+JykgKyAnPHRkPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgdHBHbG9iYWwuaG91clRlbXBsYXRlICsgJzwvdGQ+ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjo8L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgKHBpY2tlci5vcHRpb25zLnVzZU1pbnV0ZXMgPyB0cEdsb2JhbC5taW51dGVUZW1wbGF0ZSA6ICc8c3BhbiBjbGFzcz1cInRpbWVwaWNrZXItbWludXRlXCI+MDA8L3NwYW4+JykgKyAnPC90ZD4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjo8L3RkPjx0ZD4nICsgdHBHbG9iYWwuc2Vjb25kVGVtcGxhdGUgKyAnPC90ZD4nIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwaWNrZXIudXNlMjRob3VycyA/ICcnIDogJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgZGF0YS1hY3Rpb249XCJ0b2dnbGVQZXJpb2RcIj48L2J1dHRvbj48L3RkPicpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImRlY3JlbWVudEhvdXJzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZG93biArICdcIj48L3NwYW4+PC9hPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQ+JyArIChwaWNrZXIub3B0aW9ucy51c2VNaW51dGVzID8gJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImRlY3JlbWVudE1pbnV0ZXNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kb3duICsgJ1wiPjwvc3Bhbj48L2E+JyA6ICcnKSArICc8L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBpY2tlci5vcHRpb25zLnVzZVNlY29uZHMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPjx0ZD48YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCIgZGF0YS1hY3Rpb249XCJkZWNyZW1lbnRTZWNvbmRzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMuZG93biArICdcIj48L3NwYW4+PC9hPjwvdGQ+JyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGlja2VyLnVzZTI0aG91cnMgPyAnJyA6ICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPicpICsgJzx0ZD48L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1ob3Vyc1wiIGRhdGEtYWN0aW9uPVwic2VsZWN0SG91clwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj48L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLW1pbnV0ZXNcIiBkYXRhLWFjdGlvbj1cInNlbGVjdE1pbnV0ZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj48L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgKHBpY2tlci5vcHRpb25zLnVzZVNlY29uZHMgP1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlci1zZWNvbmRzXCIgZGF0YS1hY3Rpb249XCJzZWxlY3RTZWNvbmRcIj48dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj48L3RhYmxlPjwvZGl2PicgOiAnJylcclxuICAgICAgICAgICAgKTtcclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXHRcdGRldGFjaERhdGVQaWNrZXJFdmVudHMoKTtcclxuICAgIFx0XHRkZXRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzKCk7XHJcbiAgICBcdFx0cGlja2VyLndpZGdldC5yZW1vdmUoKTtcclxuICAgIFx0XHRwaWNrZXIuZWxlbWVudC5yZW1vdmVEYXRhKCdEYXRlVGltZVBpY2tlcicpO1xyXG4gICAgXHRcdGlmIChwaWNrZXIuY29tcG9uZW50KSB7XHJcbiAgICBcdFx0XHRwaWNrZXIuY29tcG9uZW50LnJlbW92ZURhdGEoJ0RhdGVUaW1lUGlja2VyJyk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0cGlja2VyLnNob3cgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgXHRcdGlmIChnZXRQaWNrZXJJbnB1dCgpLnByb3AoJ2Rpc2FibGVkJykpIHtcclxuICAgIFx0XHRcdHJldHVybjtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aWYgKHBpY2tlci5vcHRpb25zLnVzZUN1cnJlbnQpIHtcclxuICAgIFx0XHRcdGlmIChnZXRQaWNrZXJJbnB1dCgpLnZhbCgpID09PSAnJykge1xyXG4gICAgXHRcdFx0XHRpZiAocGlja2VyLm9wdGlvbnMuZmlsbEVtcHR5KSB7XHJcbiAgICBcdFx0XHRcdFx0aWYgKHBpY2tlci5vcHRpb25zLm1pbnV0ZVN0ZXBwaW5nICE9PSAxKSB7XHJcbiAgICBcdFx0XHRcdFx0XHR2YXIgbURhdGUgPSBtb21lbnQoKSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgckludGVydmFsID0gcGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmc7XHJcbiAgICBcdFx0XHRcdFx0XHRtRGF0ZS5taW51dGVzKChNYXRoLnJvdW5kKG1EYXRlLm1pbnV0ZXMoKSAvIHJJbnRlcnZhbCkgKiBySW50ZXJ2YWwpICUgNjApLnNlY29uZHMoMCk7XHJcbiAgICBcdFx0XHRcdFx0XHRwaWNrZXIuc2V0VmFsdWUobURhdGUuZm9ybWF0KHBpY2tlci5mb3JtYXQpKTtcclxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gICAgXHRcdFx0XHRcdFx0cGlja2VyLnNldFZhbHVlKG1vbWVudCgpLmZvcm1hdChwaWNrZXIuZm9ybWF0KSk7XHJcbiAgICBcdFx0XHRcdFx0fVxyXG4gICAgXHRcdFx0XHRcdG5vdGlmeUNoYW5nZSgnJywgZS50eXBlKTtcclxuICAgIFx0XHRcdFx0fVxyXG4gICAgXHRcdFx0fSBlbHNlXHJcbiAgICBcdFx0XHRcdHBpY2tlci5zZXRWYWx1ZShnZXRQaWNrZXJJbnB1dCgpLnZhbCgpKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0Ly8gaWYgdGhpcyBpcyBhIGNsaWNrIGV2ZW50IG9uIHRoZSBpbnB1dCBmaWVsZCBhbmQgcGlja2VyIGlzIGFscmVhZHkgb3BlbiBkb24ndCBoaWRlIGl0XHJcbiAgICBcdFx0aWYgKGUgJiYgZS50eXBlID09PSAnY2xpY2snICYmIHBpY2tlci5pc0lucHV0ICYmIHBpY2tlci53aWRnZXQuaGFzQ2xhc3MoJ3BpY2tlci1vcGVuJykpIHtcclxuICAgIFx0XHRcdHJldHVybjtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aWYgKHBpY2tlci53aWRnZXQuaGFzQ2xhc3MoJ3BpY2tlci1vcGVuJykpIHtcclxuICAgIFx0XHRcdHBpY2tlci53aWRnZXQuaGlkZSgpO1xyXG4gICAgXHRcdFx0cGlja2VyLndpZGdldC5yZW1vdmVDbGFzcygncGlja2VyLW9wZW4nKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0ZWxzZSB7XHJcbiAgICBcdFx0XHRwaWNrZXIud2lkZ2V0LnNob3coKTtcclxuICAgIFx0XHRcdHBpY2tlci53aWRnZXQuYWRkQ2xhc3MoJ3BpY2tlci1vcGVuJyk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHBpY2tlci5oZWlnaHQgPSBwaWNrZXIuY29tcG9uZW50ID8gcGlja2VyLmNvbXBvbmVudC5vdXRlckhlaWdodCgpIDogcGlja2VyLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcclxuICAgIFx0XHRwbGFjZSgpO1xyXG4gICAgXHRcdHBpY2tlci5lbGVtZW50LnRyaWdnZXIoe1xyXG4gICAgXHRcdFx0dHlwZTogJ2RwLnNob3cnLFxyXG4gICAgXHRcdFx0ZGF0ZTogbW9tZW50KHBpY2tlci5kYXRlKVxyXG4gICAgXHRcdH0pO1xyXG4gICAgXHRcdGF0dGFjaERhdGVQaWNrZXJHbG9iYWxFdmVudHMoKTtcclxuICAgIFx0XHRpZiAoZSkge1xyXG4gICAgXHRcdFx0c3RvcEV2ZW50KGUpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXHRcdHZhciBpbnB1dCA9IGdldFBpY2tlcklucHV0KCk7XHJcbiAgICBcdFx0aWYgKGlucHV0LnByb3AoJ2Rpc2FibGVkJykpIHtcclxuICAgIFx0XHRcdHJldHVybjtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aW5wdXQucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcclxuICAgIFx0XHRkZXRhY2hEYXRlUGlja2VyRXZlbnRzKCk7XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXHRcdHZhciBpbnB1dCA9IGdldFBpY2tlcklucHV0KCk7XHJcbiAgICBcdFx0aWYgKCFpbnB1dC5wcm9wKCdkaXNhYmxlZCcpKSB7XHJcbiAgICBcdFx0XHRyZXR1cm47XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGlucHV0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG4gICAgXHRcdGF0dGFjaERhdGVQaWNrZXJFdmVudHMoKTtcclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXHRcdC8vIElnbm9yZSBldmVudCBpZiBpbiB0aGUgbWlkZGxlIG9mIGEgcGlja2VyIHRyYW5zaXRpb25cclxuICAgIFx0XHR2YXIgY29sbGFwc2UgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy5jb2xsYXBzZScpLCBpLCBjb2xsYXBzZURhdGE7XHJcbiAgICBcdFx0Zm9yIChpID0gMDsgaSA8IGNvbGxhcHNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBcdFx0XHRjb2xsYXBzZURhdGEgPSBjb2xsYXBzZS5lcShpKS5kYXRhKCdjb2xsYXBzZScpO1xyXG4gICAgXHRcdFx0aWYgKGNvbGxhcHNlRGF0YSAmJiBjb2xsYXBzZURhdGEudHJhbnNpdGlvbmluZykge1xyXG4gICAgXHRcdFx0XHRyZXR1cm47XHJcbiAgICBcdFx0XHR9XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHBpY2tlci53aWRnZXQuaGlkZSgpO1xyXG4gICAgXHRcdHBpY2tlci53aWRnZXQucmVtb3ZlQ2xhc3MoJ3BpY2tlci1vcGVuJyk7XHJcbiAgICBcdFx0cGlja2VyLnZpZXdNb2RlID0gcGlja2VyLnN0YXJ0Vmlld01vZGU7XHJcbiAgICBcdFx0c2hvd01vZGUoKTtcclxuICAgIFx0XHRwaWNrZXIuZWxlbWVudC50cmlnZ2VyKHtcclxuICAgIFx0XHRcdHR5cGU6ICdkcC5oaWRlJyxcclxuICAgIFx0XHRcdGRhdGU6IG1vbWVudChwaWNrZXIuZGF0ZSlcclxuICAgIFx0XHR9KTtcclxuICAgIFx0XHRkZXRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzKCk7XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuc2V0VmFsdWUgPSBmdW5jdGlvbiAobmV3RGF0ZSkge1xyXG4gICAgXHRcdG1vbWVudC5sb2NhbGUocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xyXG4gICAgXHRcdGlmICghbmV3RGF0ZSkge1xyXG4gICAgXHRcdFx0cGlja2VyLnVuc2V0ID0gdHJ1ZTtcclxuICAgIFx0XHRcdHNldCgpO1xyXG4gICAgXHRcdH0gZWxzZSB7XHJcbiAgICBcdFx0XHRwaWNrZXIudW5zZXQgPSBmYWxzZTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aWYgKCFtb21lbnQuaXNNb21lbnQobmV3RGF0ZSkpIHtcclxuICAgIFx0XHRcdG5ld0RhdGUgPSAobmV3RGF0ZSBpbnN0YW5jZW9mIERhdGUpID8gbW9tZW50KG5ld0RhdGUpIDogbW9tZW50KG5ld0RhdGUsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCk7XHJcbiAgICBcdFx0fSBlbHNlIHtcclxuICAgIFx0XHRcdG5ld0RhdGUgPSBuZXdEYXRlLmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGlmIChuZXdEYXRlLmlzVmFsaWQoKSkge1xyXG4gICAgXHRcdFx0cGlja2VyLmRhdGUgPSBuZXdEYXRlO1xyXG4gICAgXHRcdFx0c2V0KCk7XHJcbiAgICBcdFx0XHRwaWNrZXIudmlld0RhdGUgPSBtb21lbnQoeyB5OiBwaWNrZXIuZGF0ZS55ZWFyKCksIE06IHBpY2tlci5kYXRlLm1vbnRoKCkgfSk7XHJcbiAgICBcdFx0XHRmaWxsRGF0ZSgpO1xyXG4gICAgXHRcdFx0ZmlsbFRpbWUoKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0ZWxzZSB7XHJcbiAgICBcdFx0XHRub3RpZnlFcnJvcihuZXdEYXRlKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuZ2V0RGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIFx0XHRpZiAocGlja2VyLnVuc2V0KSB7XHJcbiAgICBcdFx0XHRyZXR1cm4gbnVsbDtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0cmV0dXJuIG1vbWVudChwaWNrZXIuZGF0ZSk7XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuc2V0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICBcdFx0dmFyIG9sZERhdGUgPSBtb21lbnQocGlja2VyLmRhdGUpO1xyXG4gICAgXHRcdGlmICghZGF0ZSkge1xyXG4gICAgXHRcdFx0cGlja2VyLnNldFZhbHVlKG51bGwpO1xyXG4gICAgXHRcdH0gZWxzZSB7XHJcbiAgICBcdFx0XHRwaWNrZXIuc2V0VmFsdWUoZGF0ZSk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdG5vdGlmeUNoYW5nZShvbGREYXRlLCAnZnVuY3Rpb24nKTtcclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5zZXREaXNhYmxlZERhdGVzID0gZnVuY3Rpb24gKGRhdGVzKSB7XHJcbiAgICBcdFx0cGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlcyA9IGluZGV4R2l2ZW5EYXRlcyhkYXRlcyk7XHJcbiAgICBcdFx0aWYgKHBpY2tlci52aWV3RGF0ZSkge1xyXG4gICAgXHRcdFx0dXBkYXRlKCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0cGlja2VyLnNldEVuYWJsZWREYXRlcyA9IGZ1bmN0aW9uIChkYXRlcykge1xyXG4gICAgXHRcdHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcyA9IGluZGV4R2l2ZW5EYXRlcyhkYXRlcyk7XHJcbiAgICBcdFx0aWYgKHBpY2tlci52aWV3RGF0ZSkge1xyXG4gICAgXHRcdFx0dXBkYXRlKCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0cGlja2VyLnNldE1heERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgXHRcdGlmIChkYXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgIFx0XHRcdHJldHVybjtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aWYgKG1vbWVudC5pc01vbWVudChkYXRlKSB8fCBkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgXHRcdFx0cGlja2VyLm9wdGlvbnMubWF4RGF0ZSA9IG1vbWVudChkYXRlKTtcclxuICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgXHRcdFx0cGlja2VyLm9wdGlvbnMubWF4RGF0ZSA9IG1vbWVudChkYXRlLCBwaWNrZXIuZm9ybWF0LCBwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRpZiAocGlja2VyLnZpZXdEYXRlKSB7XHJcbiAgICBcdFx0XHR1cGRhdGUoKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuc2V0TWluRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICBcdFx0aWYgKGRhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgXHRcdFx0cmV0dXJuO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRpZiAobW9tZW50LmlzTW9tZW50KGRhdGUpIHx8IGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICBcdFx0XHRwaWNrZXIub3B0aW9ucy5taW5EYXRlID0gbW9tZW50KGRhdGUpO1xyXG4gICAgXHRcdH0gZWxzZSB7XHJcbiAgICBcdFx0XHRwaWNrZXIub3B0aW9ucy5taW5EYXRlID0gbW9tZW50KGRhdGUsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGlmIChwaWNrZXIudmlld0RhdGUpIHtcclxuICAgIFx0XHRcdHVwZGF0ZSgpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fTtcclxuXHJcbiAgICBcdGluaXQoKTtcclxuICAgIH07XHJcblxyXG5cdCQuZm4uZGF0ZXRpbWVwaWNrZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyksXHJcbiAgICAgICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnRGF0ZVRpbWVQaWNrZXInKTtcclxuXHRcdFx0aWYgKCFkYXRhKSB7XHJcblx0XHRcdFx0JHRoaXMuZGF0YSgnRGF0ZVRpbWVQaWNrZXInLCBuZXcgRGF0ZVRpbWVQaWNrZXIodGhpcywgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHQkLmZuLmRhdGV0aW1lcGlja2VyLmRlZmF1bHRzID0ge1xyXG5cdFx0Zm9ybWF0OiBmYWxzZSxcclxuXHRcdHBpY2tEYXRlOiB0cnVlLFxyXG5cdFx0cGlja1RpbWU6IHRydWUsXHJcblx0XHR1c2VNaW51dGVzOiB0cnVlLFxyXG5cdFx0dXNlU2Vjb25kczogZmFsc2UsXHJcblx0XHR1c2VDdXJyZW50OiB0cnVlLFxyXG5cdFx0Y2FsZW5kYXJXZWVrczogZmFsc2UsXHJcblx0XHRtaW51dGVTdGVwcGluZzogMSxcclxuXHRcdG1pbkRhdGU6IG1vbWVudCh7IHk6IDE5MDAgfSksXHJcblx0XHRtYXhEYXRlOiBtb21lbnQoKS5hZGQoMTAwLCAneScpLFxyXG5cdFx0c2hvd1RvZGF5OiB0cnVlLFxyXG5cdFx0Y29sbGFwc2U6IGZhbHNlLFxyXG5cdFx0bGFuZ3VhZ2U6IG1vbWVudC5sb2NhbGUoKSxcclxuXHRcdGRlZmF1bHREYXRlOiAnJyxcclxuXHRcdGRpc2FibGVkRGF0ZXM6IGZhbHNlLFxyXG5cdFx0ZW5hYmxlZERhdGVzOiBmYWxzZSxcclxuXHRcdGljb25zOiB7fSxcclxuXHRcdHVzZVN0cmljdDogZmFsc2UsXHJcblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcclxuXHRcdHNpZGVCeVNpZGU6IGZhbHNlLFxyXG5cdFx0ZGF5c09mV2Vla0Rpc2FibGVkOiBbXSxcclxuXHRcdHdpZGdldFBhcmVudDogZmFsc2UsXHJcblx0XHRmaWxsRW1wdHk6IGZhbHNlXHJcblx0fTtcclxufSkpO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHRoaXNbXCJtb21lbnRcIl07IH0oKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIm1vbWVudFwiXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3ZhbGlkYXRpb24gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudmFsaWRhdGlvbjtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLnNlcnZpY2VzLmNvbXBvbmVudFZhbGlkYXRvcic7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnY29tcG9uZW50VmFsaWRhdG9yJztcclxudmFyIENvbXBvbmVudFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnRWYWxpZGF0b3IodmFsaWRhdGlvblNlcnZpY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gb3B0aW9ucy4kc2NvcGU7XHJcbiAgICAgICAgdGhpcy5uZ01vZGVsID0gb3B0aW9ucy5uZ01vZGVsO1xyXG4gICAgICAgIHRoaXMuZm9ybSA9IG9wdGlvbnMuZm9ybTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRpb25TZXJ2aWNlLmJ1aWxkQ3VzdG9tVmFsaWRhdG9yKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF8uZWFjaChvcHRpb25zLnZhbGlkYXRvcnMsIGZ1bmN0aW9uIChjdXN0b21WYWxpZGF0b3IpIHtcclxuICAgICAgICAgICAgX3RoaXMudmFsaWRhdG9yLnJlZ2lzdGVyVmFsaWRhdGlvbkhhbmRsZXIoY3VzdG9tVmFsaWRhdG9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNldFZhbGlkYXRvcigpO1xyXG4gICAgfVxyXG4gICAgQ29tcG9uZW50VmFsaWRhdG9yLnByb3RvdHlwZS5zZXRWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy4kc2NvcGUuJHdhdGNoKHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlLmJpbmQodGhpcy52YWxpZGF0b3IpLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF90aGlzLm5nTW9kZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5uZ01vZGVsLiRzZXRWYWxpZGl0eSgnY3VzdG9tVmFsaWRhdGlvbicsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChfdGhpcy5mb3JtKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZm9ybS4kc2V0VmFsaWRpdHkoJ2N1c3RvbVZhbGlkYXRpb24nLCB2YWx1ZSwgJ2dyb3VwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKF90aGlzLnNldFZhbGlkaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VmFsaWRpdHkodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudFZhbGlkYXRvcjtcclxufSkoKTtcclxuZXhwb3J0cy5Db21wb25lbnRWYWxpZGF0b3IgPSBDb21wb25lbnRWYWxpZGF0b3I7XHJcbmNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkuJGluamVjdCA9IFtfX3ZhbGlkYXRpb24uc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5KHZhbGlkYXRpb25TZXJ2aWNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudFZhbGlkYXRvcih2YWxpZGF0aW9uU2VydmljZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5ID0gY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX192YWxpZGF0aW9uLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudFZhbGlkYXRvci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvY29tcG9uZW50VmFsaWRhdG9yL2NvbXBvbmVudFZhbGlkYXRvci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ2YWxpZGF0aW9uLWlucHV0LWdyb3VwXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cCB2YWxpZGF0aW9uLWlucHV0XFxcIiBuZy1jbGFzcz1cXFwieyAnaGFzLXdhcm5pbmcnOiAhZGF0ZVRpbWUudmFsaWRGb3JtYXQsICdlcnJvcic6IGRhdGVUaW1lLm5nTW9kZWwuJGludmFsaWQsICdyZXF1aXJlZC1lcnJvcic6IGRhdGVUaW1lLm5nTW9kZWwuJGVycm9yLnJlcXVpcmVkIH1cXFwiPlxcclxcblxcdFxcdDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiZGF0ZVRpbWUubmdNb2RlbC4kdmlld1ZhbHVlXFxcIiAvPlxcclxcblxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcclxcblxcdFxcdFxcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBzaG93LWRhdGUtcGlja2VyXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlKClcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYWxlbmRhclxcXCI+PC9pPjwvYnV0dG9uPlxcclxcblxcdFxcdDwvc3Bhbj5cXHJcXG5cXHRcXHQ8c3BhbiBjbGFzcz1cXFwiZXJyb3Itc3RyaW5nXFxcIiBuZy1oaWRlPVxcXCJkYXRlVGltZS5kYXRlVGltZVZhbGlkYXRvci5lcnJvciB8IGlzRW1wdHlcXFwiPnt7ZGF0ZVRpbWUuZGF0ZVRpbWVWYWxpZGF0b3IuZXJyb3J9fTwvc3Bhbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9kYXRlVGltZS9kYXRlVGltZS5odG1sXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIganF1ZXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZScpO1xyXG52YXIgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5nZW5lcmljQ29udGFpbmVyJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsR2VuZXJpY0NvbnRhaW5lcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXInO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIoJHNjb3BlLCBvYmplY3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0b3I7IH0sIGZ1bmN0aW9uIChuZXdUeXBlLCBvbGRUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vYmplY3QuYXJlRXF1YWwobmV3VHlwZSwgb2xkVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBfdGhpcy5yZXNvbHZlVGVtcGxhdGUobmV3VHlwZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnN3YXBUZW1wbGF0ZXModGVtcGxhdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5yZXNvbHZlVGVtcGxhdGUodGhpcy5zZWxlY3Rvcik7XHJcbiAgICAgICAgdGhpcy5zd2FwVGVtcGxhdGVzKHRlbXBsYXRlKTtcclxuICAgIH07XHJcbiAgICBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVzb2x2ZVRlbXBsYXRlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoXy5oYXModGhpcy50ZW1wbGF0ZXMsIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlc1t0eXBlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdlbmVyaWNDb250YWluZXJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsIF9fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5HZW5lcmljQ29udGFpbmVyQ29udHJvbGxlciA9IEdlbmVyaWNDb250YWluZXJDb250cm9sbGVyO1xyXG5nZW5lcmljQ29udGFpbmVyLiRpbmplY3QgPSBbXHJcbiAgICAnJGNvbXBpbGUnLFxyXG4gICAgJyRpbnRlcnBvbGF0ZScsXHJcbiAgICBqcXVlcnlfc2VydmljZV8xLnNlcnZpY2VOYW1lLFxyXG4gICAgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xLnNlcnZpY2VOYW1lLFxyXG4gICAgX19vYmplY3Quc2VydmljZU5hbWUsXHJcbl07XHJcbmZ1bmN0aW9uIGdlbmVyaWNDb250YWluZXIoJGNvbXBpbGUsICRpbnRlcnBvbGF0ZSwganF1ZXJ5LCB0ZW1wbGF0ZUxvYWRlciwgb2JqZWN0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGlkPVwiY29udGFpbmVyXCI+PC9kaXY+JyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnZ2VuZXJpY0NvbnRhaW5lcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICc9JyxcclxuICAgICAgICAgICAgY29uZmlndXJlZFRlbXBsYXRlczogJz10ZW1wbGF0ZXMnLFxyXG4gICAgICAgICAgICBkZWZhdWx0VGVtcGxhdGU6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cmlidXRlcywgY29udHJvbGxlciwgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICBpbml0RGVmYXVsdHMoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBlbGVtZW50LmZpbmQoJyNjb250YWluZXInKTtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlUmVzdWx0ID0gdGVtcGxhdGVMb2FkZXIubG9hZFRlbXBsYXRlcyh0cmFuc2NsdWRlKTtcclxuICAgICAgICAgICAgY29udHJvbGxlci50ZW1wbGF0ZXMgPSBfLmV4dGVuZChjb250cm9sbGVyLnRlbXBsYXRlcywgdGVtcGxhdGVSZXN1bHQudGVtcGxhdGVzKTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5kZWZhdWx0ID0gdGVtcGxhdGVSZXN1bHQuZGVmYXVsdDtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlU2NvcGUgPSB0ZW1wbGF0ZVJlc3VsdC50cmFuc2NsdXNpb25TY29wZTtcclxuICAgICAgICAgICAgaWYgKCFjb250cm9sbGVyLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZGVmYXVsdCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdj48L2Rpdj4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdERlZmF1bHRzKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZGVmYXVsdCA9IGNvbnRyb2xsZXIuZGVmYXVsdFRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci50ZW1wbGF0ZXMgPSBjb250cm9sbGVyLmNvbmZpZ3VyZWRUZW1wbGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICA/IF8ubWFwKGNvbnRyb2xsZXIuY29uZmlndXJlZFRlbXBsYXRlcywgZnVuY3Rpb24gKHRlbXBsYXRlKSB7IHJldHVybiBhbmd1bGFyLmVsZW1lbnQodGVtcGxhdGUpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIDoge307XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnN3YXBUZW1wbGF0ZXMgPSBzd2FwVGVtcGxhdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN3YXBUZW1wbGF0ZXModGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIGpxdWVyeS5yZXBsYWNlQ29udGVudChjb250YWluZXIsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gJGNvbXBpbGUodGVtcGxhdGUpKHRlbXBsYXRlU2NvcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtqcXVlcnlfc2VydmljZV8xLm1vZHVsZU5hbWUsIF9fb2JqZWN0Lm1vZHVsZU5hbWUsIHRlbXBsYXRlTG9hZGVyX3NlcnZpY2VfMS5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBnZW5lcmljQ29udGFpbmVyKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmljQ29udGFpbmVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9nZW5lcmljQ29udGFpbmVyL2dlbmVyaWNDb250YWluZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi90eXBpbmdzL2pxdWVyeS9qcXVlcnkuZC50c1wiIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51dGlsaXRpZXMuc2VydmljZXMuanF1ZXJ5JztcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICdqcXVlcnlVdGlsaXR5JztcclxudmFyIEpRdWVyeVV0aWxpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSlF1ZXJ5VXRpbGl0eSgpIHtcclxuICAgIH1cclxuICAgIEpRdWVyeVV0aWxpdHkucHJvdG90eXBlLnJlcGxhY2VDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnRBcmVhLCBuZXdDb250ZW50KSB7XHJcbiAgICAgICAgY29udGVudEFyZWEuZW1wdHkoKTtcclxuICAgICAgICBjb250ZW50QXJlYS5hcHBlbmQobmV3Q29udGVudCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEpRdWVyeVV0aWxpdHk7XHJcbn0pKCk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBKUXVlcnlVdGlsaXR5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anF1ZXJ5LnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9qcXVlcnkvanF1ZXJ5LnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudXRpbGl0aWVzLnNlcnZpY2VzLnRlbXBsYXRlTG9hZGVyJztcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICd0ZW1wbGF0ZUxvYWRlcic7XHJcbnZhciBUZW1wbGF0ZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZUxvYWRlcigkaW50ZXJwb2xhdGUsIHRlbXBsYXRlU2VsZWN0b3JWYWx1ZSwgb2JqZWN0VXRpbGl0eSkge1xyXG4gICAgICAgIHRoaXMuJGludGVycG9sYXRlID0gJGludGVycG9sYXRlO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVTZWxlY3RvclZhbHVlID0gdGVtcGxhdGVTZWxlY3RvclZhbHVlO1xyXG4gICAgICAgIHRoaXMub2JqZWN0VXRpbGl0eSA9IG9iamVjdFV0aWxpdHk7XHJcbiAgICB9XHJcbiAgICBUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubG9hZFRlbXBsYXRlcyA9IGZ1bmN0aW9uICh0cmFuc2NsdWRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IHt9LFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgICAgICB0cmFuc2NsdXNpb25TY29wZTogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIExvYWQgdGVtcGxhdGVzIGZyb20gdGhlIERPTVxyXG4gICAgICAgIHRyYW5zY2x1ZGUoZnVuY3Rpb24gKGNsb25lLCB0cmFuc2NsdXNpb25TY29wZSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVzID0gY2xvbmUuZmlsdGVyKF90aGlzLnRlbXBsYXRlU2VsZWN0b3JWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlcy5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlSHRtbCA9IHRlbXBsYXRlRWxlbWVudC5odG1sKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRFbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KHRlbXBsYXRlSHRtbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlckF0dHJpYnV0ZSA9IHRlbXBsYXRlRWxlbWVudC5hdHRyKCd3aGVuLXNlbGVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9iamVjdFV0aWxpdHkuaXNOdWxsT3JXaGl0ZXNwYWNlKHRyaWdnZXJBdHRyaWJ1dGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWdnZXIgPSBfdGhpcy4kaW50ZXJwb2xhdGUodHJpZ2dlckF0dHJpYnV0ZSkodHJhbnNjbHVzaW9uU2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC50ZW1wbGF0ZXNbdHJpZ2dlcl0gPSBjaGlsZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNEZWZhdWx0ID0gdGVtcGxhdGVFbGVtZW50LmF0dHIoJ2RlZmF1bHQnKTtcclxuICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChpc0RlZmF1bHQpICYmIGlzRGVmYXVsdC50b0xvd2VyQ2FzZSgpICE9PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlZmF1bHQgPSBjaGlsZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXN1bHQudHJhbnNjbHVzaW9uU2NvcGUgPSB0cmFuc2NsdXNpb25TY29wZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlTG9hZGVyLiRpbmplY3QgPSBbJyRpbnRlcnBvbGF0ZScsICd0ZW1wbGF0ZVNlbGVjdG9yVmFsdWUnLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gVGVtcGxhdGVMb2FkZXI7XHJcbn0pKCk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLnZhbHVlKCd0ZW1wbGF0ZVNlbGVjdG9yVmFsdWUnLCAndGVtcGxhdGUnKVxyXG4gICAgLnNlcnZpY2UoZXhwb3J0cy5zZXJ2aWNlTmFtZSwgVGVtcGxhdGVMb2FkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZUxvYWRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMubGF6eUxvYWQnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxMYXp5TG9hZCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnTGF6eUxvYWRDb250cm9sbGVyJztcclxudmFyIExhenlMb2FkQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMYXp5TG9hZENvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgdW5iaW5kID0gJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaG93OyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHVuYmluZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBMYXp5TG9hZENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gTGF6eUxvYWRDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkxhenlMb2FkQ29udHJvbGxlciA9IExhenlMb2FkQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gbGF6eUxvYWQoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8ZGl2IG5nLWlmPVxcXCJsYXp5TG9hZC5pbml0XFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcImxhenlMb2FkLnNob3dcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2xhenlMb2FkJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBzaG93OiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBsYXp5TG9hZClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIExhenlMb2FkQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhenlMb2FkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9sYXp5TG9hZC9sYXp5TG9hZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wcm9taXNlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnByb21pc2U7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmxvbmdDbGlja0J1dHRvbic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybExvbmdDbGlja0J1dHRvbic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlcic7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIoJHNjb3BlLCAkaW50ZXJ2YWwsICR0aW1lb3V0LCBvYmplY3RVdGlsaXR5LCBwcm9taXNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRpbnRlcnZhbCA9ICRpbnRlcnZhbDtcclxuICAgICAgICB0aGlzLiR0aW1lb3V0ID0gJHRpbWVvdXQ7XHJcbiAgICAgICAgdGhpcy5vYmplY3RVdGlsaXR5ID0gb2JqZWN0VXRpbGl0eTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAyNTtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMTUwMDtcclxuICAgICAgICB0aGlzLmJ1dHRvblRleHQgPSB0aGlzLnRleHQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy50eXBlICE9IG51bGwgPyB0aGlzLnR5cGUgOiAnZGVmYXVsdCc7XHJcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5zaXplICE9IG51bGwgPyAnYnRuLScgKyB0aGlzLnNpemUgOiBudWxsO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYnV0dG9uVGV4dDsgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy53aWR0aCA9ICQoJyNhY3Rpb25CdXR0b24nKS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci5wcm90b3R5cGUuc3RhcnRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUgfHwgdGhpcy5idXN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3Rpb25Qcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uSW50ZXJ2YWwgPSB0aGlzLiRpbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvblByb2dyZXNzICs9IF90aGlzLmludGVydmFsO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aW9uUHJvZ3Jlc3MgPj0gX3RoaXMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmJ1dHRvblRleHQgPSBfdGhpcy50ZXh0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcy5pbnRlcnZhbCk7XHJcbiAgICB9O1xyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci5wcm90b3R5cGUuc3RvcEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uUHJvZ3Jlc3MgPCB0aGlzLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLiRpbnRlcnZhbC5jYW5jZWwodGhpcy5hY3Rpb25JbnRlcnZhbCk7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25Qcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9iamVjdFV0aWxpdHkuaXNOdWxsT3JFbXB0eSh0aGlzLm9uU2hvcnRDbGlja1RleHQpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRleHQgPSB0aGlzLm9uU2hvcnRDbGlja1RleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuYnVzeSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1c3kgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hY3Rpb24oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvbWlzZS5pc1Byb21pc2UocmVzdWx0KSAmJiBfLmlzRnVuY3Rpb24ocmVzdWx0LmZpbmFsbHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZmluYWxseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGludGVydmFsJywgJyR0aW1lb3V0JywgX19vYmplY3Quc2VydmljZU5hbWUsIF9fcHJvbWlzZS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5Mb25nQ2xpY2tCdXR0b25Db250cm9sbGVyID0gTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gbG9uZ0NsaWNrQnV0dG9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2xvbmdDbGlja0J1dHRvbi5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdidXR0b24nLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJyYnLFxyXG4gICAgICAgICAgICB0ZXh0OiAnQCcsXHJcbiAgICAgICAgICAgIG9uU2hvcnRDbGlja1RleHQ6ICdAJyxcclxuICAgICAgICAgICAgaWNvbjogJ0AnLFxyXG4gICAgICAgICAgICBidXN5OiAnPScsXHJcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25lZDogJz0nLFxyXG4gICAgICAgICAgICB0eXBlOiAnQCcsXHJcbiAgICAgICAgICAgIG5nRGlzYWJsZWQ6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBsb25nQ2xpY2tCdXR0b24pXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9uZ0NsaWNrQnV0dG9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9sb25nQ2xpY2tCdXR0b24vbG9uZ0NsaWNrQnV0dG9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibG9uZy1jbGljay1idXR0b25cXFwiPlxcclxcblxcdDxidXR0b24gaWQ9XFxcImFjdGlvbkJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b24udHlwZX19IHt7YnV0dG9uLnNpemV9fVxcXCIgbmctbW91c2Vkb3duPVxcXCJidXR0b24uc3RhcnRBY3Rpb24oKVxcXCIgbmctbW91c2VsZWF2ZT1cXFwiYnV0dG9uLnN0b3BBY3Rpb24oKVxcXCIgbmctbW91c2V1cD1cXFwiYnV0dG9uLnN0b3BBY3Rpb24oKVxcXCIgbmctZGlzYWJsZWQ9XFxcImJ1dHRvbi5idXN5IHx8IGJ1dHRvbi5uZ0Rpc2FibGVkXFxcIj5cXHJcXG5cXHRcXHQ8cmwtYnVzeSBsb2FkaW5nPVxcXCJidXR0b24uYnVzeVxcXCIgbmctaWY9XFxcImJ1dHRvbi5yaWdodEFsaWduZWRcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHRcXHQ8aSBuZy1zaG93PVxcXCJidXR0b24uaWNvbiAhPSBudWxsXFxcIiBjbGFzcz1cXFwiZmEgZmEte3tidXR0b24uaWNvbn19XFxcIj48L2k+IHt7YnV0dG9uLmJ1dHRvblRleHR9fVxcclxcblxcdFxcdDxybC1idXN5IGxvYWRpbmc9XFxcImJ1dHRvbi5idXN5XFxcIiBuZy1pZj1cXFwiIWJ1dHRvbi5yaWdodEFsaWduZWRcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHQ8L2J1dHRvbj5cXHJcXG5cXHQ8cmwtcmF0aW5nLWJhciBuZy1pZj1cXFwiYnV0dG9uLmFjdGl2ZVxcXCIgd2lkdGg9XFxcImJ1dHRvbi53aWR0aFxcXCIgaGVpZ2h0PVxcXCI1XFxcIiBtaW49XFxcIjBcXFwiIG1heD1cXFwiYnV0dG9uLmR1cmF0aW9uXFxcIlxcclxcblxcdFxcdFxcdFxcdHZhbHVlPVxcXCJidXR0b24uYWN0aW9uUHJvZ3Jlc3NcXFwiIGJhY2tncm91bmQ9XFxcInRyYW5zcGFyZW50XFxcIj48L3JsLXJhdGluZy1iYXI+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbG9uZ0NsaWNrQnV0dG9uL2xvbmdDbGlja0J1dHRvbi5odG1sXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIGpxdWVyeV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9qcXVlcnkvanF1ZXJ5LnNlcnZpY2UnKTtcclxudmFyIG1lc3NhZ2VMb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9tZXNzYWdlTG9nLnNlcnZpY2UnKTtcclxudmFyIG1lc3NhZ2VMb2dfZGlyZWN0aXZlXzEgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cuZGlyZWN0aXZlJyk7XHJcbnZhciBlZGl0YWJsZU1lc3NhZ2VMb2dfMSA9IHJlcXVpcmUoJy4vZWRpdGFibGVNZXNzYWdlTG9nJyk7XHJcbnZhciB0ZW1wbGF0ZUxvYWRlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy90ZW1wbGF0ZUxvYWRlci90ZW1wbGF0ZUxvYWRlci5zZXJ2aWNlJyk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vbWVzc2FnZUxvZy5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL21lc3NhZ2VMb2cuZGlyZWN0aXZlJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5tZXNzYWdlTG9nJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZSwganF1ZXJ5X3NlcnZpY2VfMS5tb2R1bGVOYW1lLCB0ZW1wbGF0ZUxvYWRlcl9zZXJ2aWNlXzEubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShtZXNzYWdlTG9nX3NlcnZpY2VfMS5mYWN0b3J5TmFtZSwgbWVzc2FnZUxvZ19zZXJ2aWNlXzEubWVzc2FnZUxvZ0ZhY3RvcnkpXHJcbiAgICAuZGlyZWN0aXZlKG1lc3NhZ2VMb2dfZGlyZWN0aXZlXzEuZGlyZWN0aXZlTmFtZSwgbWVzc2FnZUxvZ19kaXJlY3RpdmVfMS5tZXNzYWdlTG9nKVxyXG4gICAgLmNvbnRyb2xsZXIobWVzc2FnZUxvZ19kaXJlY3RpdmVfMS5jb250cm9sbGVyTmFtZSwgbWVzc2FnZUxvZ19kaXJlY3RpdmVfMS5NZXNzYWdlTG9nQ29udHJvbGxlcilcclxuICAgIC5kaXJlY3RpdmUoZWRpdGFibGVNZXNzYWdlTG9nXzEuZGlyZWN0aXZlTmFtZSwgZWRpdGFibGVNZXNzYWdlTG9nXzEuZWRpdGFibGVNZXNzYWdlTG9nKVxyXG4gICAgLmNvbnRyb2xsZXIoZWRpdGFibGVNZXNzYWdlTG9nXzEuY29udHJvbGxlck5hbWUsIGVkaXRhYmxlTWVzc2FnZUxvZ18xLkVkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlTG9nLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ21lc3NhZ2VMb2cnO1xyXG5leHBvcnRzLmRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG52YXIgTWVzc2FnZUxvZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXNzYWdlTG9nKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5faGFzRm9yd2FyZE1lc3NhZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFzQmFja3dhcmRNZXNzYWdlcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3BhZ2VTaXplID0gZXhwb3J0cy5kZWZhdWx0UGFnZVNpemU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUxvZy5wcm90b3R5cGUsIFwicGFnZVNpemVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFnZVNpemU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VTaXplID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlTG9nLnByb3RvdHlwZSwgXCJoYXNGb3J3YXJkTWVzc2FnZXNcIiwge1xyXG4gICAgICAgIC8qIHRzbGludDplbmFibGUgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZvcndhcmRNZXNzYWdlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlTG9nLnByb3RvdHlwZSwgXCJoYXNCYWNrd2FyZE1lc3NhZ2VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0JhY2t3YXJkTWVzc2FnZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUxvZy5wcm90b3R5cGUsIFwiZGF0YVNlcnZpY2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNlcnZpY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTZXJ2aWNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVNZXNzYWdlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRQYWdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qIHRzbGludDplbmFibGUgKi9cclxuICAgIE1lc3NhZ2VMb2cucHJvdG90eXBlLmFkZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2Uuc2F2ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmdldFRvcFBhZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5nZXROZXh0UGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzRm9yd2FyZE1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlICs9IHRoaXMucGFnZVNpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5nZXRQcmV2aW91c1BhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0JhY2t3YXJkTWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydGluZ01lc3NhZ2UgLT0gdGhpcy5wYWdlU2l6ZTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGFydGluZ01lc3NhZ2UgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDdXJyZW50UGFnZSgpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2cucHJvdG90eXBlLmdldFRvcFBhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDdXJyZW50UGFnZSgpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2cucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS51cGRhdGVDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGFTZXJ2aWNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVzeSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZ2V0TWVzc2FnZXModGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlLCB0aGlzLnBhZ2VTaXplKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgX3RoaXMudmlzaWJsZU1lc3NhZ2VzID0gcmVzdWx0Lm1lc3NhZ2VzO1xyXG4gICAgICAgICAgICBfdGhpcy5faGFzRm9yd2FyZE1lc3NhZ2VzID0gcmVzdWx0Lmhhc01vcmVNZXNzYWdlcztcclxuICAgICAgICAgICAgX3RoaXMuX2hhc0JhY2t3YXJkTWVzc2FnZXMgPSAoX3RoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSA+IDApO1xyXG4gICAgICAgICAgICBfdGhpcy5idXN5ID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1lc3NhZ2VMb2c7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTWVzc2FnZUxvZyA9IE1lc3NhZ2VMb2c7XHJcbmZ1bmN0aW9uIG1lc3NhZ2VMb2dGYWN0b3J5KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VMb2coKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm1lc3NhZ2VMb2dGYWN0b3J5ID0gbWVzc2FnZUxvZ0ZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VMb2cuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIganF1ZXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZScpO1xyXG52YXIgbWVzc2FnZUxvZ19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cuc2VydmljZScpO1xyXG52YXIgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxNZXNzYWdlTG9nJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdNZXNzYWdlTG9nQ29udHJvbGxlcic7XHJcbnZhciBNZXNzYWdlTG9nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXNzYWdlTG9nQ29udHJvbGxlcigkc2NvcGUsIG1lc3NhZ2VMb2dGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1lc3NhZ2VMb2cgPSB0aGlzLm1lc3NhZ2VMb2dCaW5kaW5nIHx8IG1lc3NhZ2VMb2dGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLnZpc2libGVNZXNzYWdlczsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm1lc3NhZ2VzID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLmhhc0ZvcndhcmRNZXNzYWdlczsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhc05leHRQYWdlID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLmhhc0JhY2t3YXJkTWVzc2FnZXM7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5oYXNQcmV2aW91c1BhZ2UgPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1lc3NhZ2VMb2cuYnVzeTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdJbml0aWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VydmljZTsgfSwgZnVuY3Rpb24gKHNlcnZpY2UpIHtcclxuICAgICAgICAgICAgX3RoaXMubWVzc2FnZUxvZy5kYXRhU2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmdJbml0aWFsID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VMb2cucGFnZVNpemUgPSB0aGlzLnBhZ2VTaXplICE9IG51bGwgPyB0aGlzLnBhZ2VTaXplIDogODtcclxuICAgIH1cclxuICAgIE1lc3NhZ2VMb2dDb250cm9sbGVyLnByb3RvdHlwZS5nZXRFbnRyeVNlbGVjdG9yID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcodGhpcy5zZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5W3RoaXMuc2VsZWN0b3JdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfLmlzRnVuY3Rpb24odGhpcy5zZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IoZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0T2xkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUxvZy5nZXROZXh0UGFnZSgpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2dDb250cm9sbGVyLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUxvZy5nZXRUb3BQYWdlKCk7XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZ0NvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgbWVzc2FnZUxvZ19zZXJ2aWNlXzEuZmFjdG9yeU5hbWVdO1xyXG4gICAgcmV0dXJuIE1lc3NhZ2VMb2dDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLk1lc3NhZ2VMb2dDb250cm9sbGVyID0gTWVzc2FnZUxvZ0NvbnRyb2xsZXI7XHJcbm1lc3NhZ2VMb2cuJGluamVjdCA9IFtcclxuICAgICckaW50ZXJwb2xhdGUnLFxyXG4gICAganF1ZXJ5X3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSxcclxuICAgIHRlbXBsYXRlTG9hZGVyX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSxcclxuICAgIF9fb2JqZWN0LnNlcnZpY2VOYW1lLFxyXG5dO1xyXG5mdW5jdGlvbiBtZXNzYWdlTG9nKCRpbnRlcnBvbGF0ZSwganF1ZXJ5LCB0ZW1wbGF0ZUxvYWRlciwgb2JqZWN0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vbWVzc2FnZUxvZy5odG1sJyksXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2xvZycsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgbWVzc2FnZURhdGE6IFwiPVwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBzZXJ2aWNlOiAnPScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnPScsXHJcbiAgICAgICAgICAgIHBhZ2VTaXplOiAnPScsXHJcbiAgICAgICAgICAgIG1lc3NhZ2VMb2dCaW5kaW5nOiAnPW1lc3NhZ2VMb2cnLFxyXG4gICAgICAgICAgICBtZXNzYWdlQXM6IFwiQFwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRyaWJ1dGVzLCBjb250cm9sbGVyLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVtcGxhdGVzID0gdGVtcGxhdGVMb2FkZXIubG9hZFRlbXBsYXRlcyh0cmFuc2NsdWRlKS50ZW1wbGF0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm1lc3NhZ2VMb2cgPSBtZXNzYWdlTG9nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlTG9nLmRpcmVjdGl2ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLmRpcmVjdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXY+XFxyXFxuXFx0PHJsLWJ1c3kgbG9hZGluZz1cXFwibG9nLmxvYWRpbmdJbml0aWFsXFxcIiBzaXplPVxcXCIyeFxcXCI+PC9ybC1idXN5PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbnRlbnQtZ3JvdXBcXFwiIG5nLXJlcGVhdD1cXFwiZW50cnkgaW4gbG9nLm1lc3NhZ2VzXFxcIiBybC1hbGlhcz1cXFwiZW50cnkgYXMge3tsb2cubWVzc2FnZUFzfX1cXFwiPlxcclxcblxcdFxcdDxybC1nZW5lcmljLWNvbnRhaW5lciBzZWxlY3Rvcj1cXFwibG9nLmdldEVudHJ5U2VsZWN0b3IoZW50cnkpXFxcIiB0ZW1wbGF0ZXM9XFxcImxvZy50ZW1wbGF0ZXNcXFwiPlxcclxcblxcdFxcdFxcdDx0ZW1wbGF0ZSBkZWZhdWx0PlxcclxcblxcdFxcdFxcdFxcdDxkaXYgbmctYmluZC1odG1sPVxcXCJlbnRyeS5tZXNzYWdlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJieWxpbmVcXFwiPnt7ZW50cnkuY3JlYXRlZEJ5fX08L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJieWxpbmVcXFwiPnt7ZW50cnkuY3JlYXRlZERhdGUgfCBkYXRlOidzaG9ydCd9fSBVVEM8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L3RlbXBsYXRlPlxcclxcblxcdFxcdDwvcmwtZ2VuZXJpYy1jb250YWluZXI+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC1ncm91cFxcXCIgbmctaWY9XFxcIihsb2cubWVzc2FnZXMgfCBpc0VtcHR5KSAmJiAhbG9nLmxvYWRpbmdJbml0aWFsXFxcIj5ObyBleGlzdGluZyBtZXNzYWdlczwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sLXhzLTEyXFxcIj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PHJsLWJ1dHRvbi1hc3luYyB0eXBlPVxcXCJkZWZhdWx0XFxcIiBhY3Rpb249XFxcImxvZy5nZXRUb3AoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImxvZy5sb2FkaW5nXFxcIiBidXR0b24tcmlnaHQtYWxpZ25lZD1cXFwidHJ1ZVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PHNwYW4gbmctc2hvdz1cXFwibG9nLmhhc1ByZXZpb3VzUGFnZVxcXCI+VG9wPC9zcGFuPlxcclxcblxcdFxcdFxcdFxcdFxcdDxzcGFuIG5nLWhpZGU9XFxcImxvZy5oYXNQcmV2aW91c1BhZ2VcXFwiPlJlZnJlc2g8L3NwYW4+XFxyXFxuXFx0XFx0XFx0XFx0PC9ybC1idXR0b24tYXN5bmM+XFxyXFxuXFx0XFx0XFx0XFx0PHJsLWJ1dHRvbi1hc3luYyB0eXBlPVxcXCJkZWZhdWx0XFxcIiBuZy1kaXNhYmxlZD1cXFwibG9nLmhhc05leHRQYWdlID09IGZhbHNlIHx8IGxvZy5sb2FkaW5nXFxcIiBhY3Rpb249XFxcImxvZy5nZXRPbGRlcigpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRPbGRlciA8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1yaWdodFxcXCI+PC9pPlxcclxcblxcdFxcdFxcdFxcdDwvcmwtYnV0dG9uLWFzeW5jPlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5odG1sXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBtZXNzYWdlTG9nX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vbWVzc2FnZUxvZy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEVkaXRhYmxlTWVzc2FnZUxvZyc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlcic7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbjtcclxudmFyIEVkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlcigkc2NvcGUsIG1lc3NhZ2VMb2dGYWN0b3J5LCBvYmplY3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMubWVzc2FnZUxvZ1NlcnZpY2UgPSBtZXNzYWdlTG9nRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWVzc2FnZUxvZ1NlcnZpY2UuYnVzeTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmJ1c3kgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNhdmluZ01lc3NhZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmJ1c3kgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSh0aGlzLm5ld01lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNhdmluZ01lc3NhZ2UgPSB0cnVlO1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5uZXdNZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubmV3TWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VMb2dTZXJ2aWNlLmFkZE1lc3NhZ2UoeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xyXG4gICAgfTtcclxuICAgIEVkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgbWVzc2FnZUxvZ19zZXJ2aWNlXzEuZmFjdG9yeU5hbWUsIF9fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLkVkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXIgPSBFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBlZGl0YWJsZU1lc3NhZ2VMb2coKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGZvcm0gbmctc3VibWl0PVxcXCJsb2cuYWRkKClcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmctbW9kZWw9XFxcImxvZy5uZXdNZXNzYWdlXFxcIiBwbGFjZWhvbGRlcj1cXFwiRW50ZXIgbG9nIG1lc3NhZ2VcXFwiIC8+XFxuXFx0XFx0XFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiB0eXBlPVxcXCJzdWJtaXRcXFwiIG5nLWRpc2FibGVkPVxcXCJsb2cuYnVzeVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHJsLWJ1c3kgbG9hZGluZz1cXFwibG9nLnNhdmluZ01lc3NhZ2VcXFwiPjwvcmwtYnVzeT4gQWRkXFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9idXR0b24+XFxuXFx0XFx0XFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcIm1lc3NhZ2UtbG9nXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8cmwtbWVzc2FnZS1sb2cgc2VydmljZT1cXFwibG9nLnNlcnZpY2VcXFwiIHBhZ2Utc2l6ZT1cXFwibG9nLnBhZ2VTaXplXFxcIiBtZXNzYWdlLWxvZz1cXFwibG9nLm1lc3NhZ2VMb2dTZXJ2aWNlXFxcIj48L3JsLW1lc3NhZ2UtbG9nPlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZm9ybT5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2xvZycsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc2VydmljZTogJz0nLFxyXG4gICAgICAgICAgICBwYWdlU2l6ZTogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZWRpdGFibGVNZXNzYWdlTG9nID0gZWRpdGFibGVNZXNzYWdlTG9nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZGl0YWJsZU1lc3NhZ2VMb2cuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvZWRpdGFibGVNZXNzYWdlTG9nLmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLm11bHRpU3RlcEluZGljYXRvcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybE11bHRpU3RlcEluZGljYXRvcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlcic7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIoJHN0YXRlLCAkcSwgb2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy4kc3RhdGUgPSAkc3RhdGU7XHJcbiAgICAgICAgdGhpcy4kcSA9ICRxO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJlU3RlcHMoKTtcclxuICAgIH1cclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hbnlMb2FkaW5nKCkpIHtcclxuICAgICAgICAgICAgc3RlcC5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy4kcS53aGVuKHN0ZXAub25DbGljaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHN0ZXAubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci5wcm90b3R5cGUuYW55TG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXy5hbnkodGhpcy5zdGVwcywgZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ZXAubG9hZGluZztcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyLnByb3RvdHlwZS5jb25maWd1cmVTdGVwcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLnN0ZXBzLCBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgICAgICBzdGVwLmhhc0NvdW50ID0gXy5pc0Z1bmN0aW9uKHN0ZXAuY291bnQpO1xyXG4gICAgICAgICAgICBzdGVwLmdldENvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdldElzQ29tcGxldGVkKHN0ZXApOyB9O1xyXG4gICAgICAgICAgICBzdGVwLmdldFZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0SXNWYWxpZChzdGVwKTsgfTtcclxuICAgICAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oc3RlcC5vbkNsaWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9iamVjdC5pc051bGxPcldoaXRlc3BhY2Uoc3RlcC5zdGF0ZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcC5pbmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZWRpcmVjdFRvU3RhdGUoc3RlcCk7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiRzdGF0ZS5pbmNsdWRlcyhzdGVwLnN0YXRlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcC5pc0N1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZGlyZWN0VG9TdGF0ZSA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy4kc3RhdGUuZ28oc3RlcC5zdGF0ZU5hbWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jbGVhckN1cnJlbnRTdGF0ZSgpO1xyXG4gICAgICAgICAgICBzdGVwLmlzQ3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJDdXJyZW50U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuc3RlcHMsIGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAuaXNDdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24oc3RlcC5pc0NvbXBsZXRlZClcclxuICAgICAgICAgICAgPyBzdGVwLmlzQ29tcGxldGVkKClcclxuICAgICAgICAgICAgOiBzdGVwLmlzQ29tcGxldGVkO1xyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLnNldElzQ29tcGxldGVkID0gZnVuY3Rpb24gKHN0ZXAsIGlzQ29tcGxldGVkKSB7XHJcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oc3RlcC5pc0NvbXBsZXRlZCkpIHtcclxuICAgICAgICAgICAgc3RlcC5pc0NvbXBsZXRlZCA9IGlzQ29tcGxldGVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyLnByb3RvdHlwZS5nZXRJc1ZhbGlkID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHN0ZXAuaXNWYWxpZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ZXAuaXNWYWxpZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChzdGVwLmlzVmFsaWQgIT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ZXAuaXNWYWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzdGF0ZScsICckcScsIF9fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLk11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIgPSBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBtdWx0aVN0ZXBJbmRpY2F0b3IoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vbXVsdGlTdGVwSW5kaWNhdG9yLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2JyZWFkY3J1bWInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHN0ZXBzOiAnPScsXHJcbiAgICAgICAgICAgIG51bWJlcmVkOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgbXVsdGlTdGVwSW5kaWNhdG9yKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpU3RlcEluZGljYXRvci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm11bHRpLXN0ZXAgY2hlY2tlZFxcXCIgbmctY2xhc3M9XFxcInsgJ251bWJlcmVkJzogYnJlYWRjcnVtYi5udW1iZXJlZCB9XFxcIj5cXHJcXG5cXHQ8b2w+XFxyXFxuXFx0XFx0PGxpIG5nLXJlcGVhdD1cXFwic3RlcCBpbiBicmVhZGNydW1iLnN0ZXBzXFxcIiBuZy1jbGljaz1cXFwiYnJlYWRjcnVtYi5vbkNsaWNrKHN0ZXApXFxcIlxcclxcblxcdFxcdFxcdG5nLWNsYXNzPVxcXCJ7ICdjb21wbGV0ZWQnOiBzdGVwLmdldENvbXBsZXRlZCgpLCAnY3VycmVudCc6IHN0ZXAuaXNDdXJyZW50LCAnYWN0aXZlJzogIXN0ZXAuaW5hY3RpdmUgJiYgIWJyZWFkY3J1bWIuYW55TG9hZGluZygpIH1cXFwiPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcIndyYXBcXFwiPlxcclxcblxcdFxcdFxcdFxcdDxwIGNsYXNzPVxcXCJiYWRnZVxcXCIgbmctc2hvdz1cXFwic3RlcC5oYXNDb3VudFxcXCI+e3tzdGVwLmNvdW50KCl9fTwvcD5cXHJcXG5cXHRcXHRcXHRcXHQ8cCBjbGFzcz1cXFwiZXJyb3JcXFwiIG5nLWlmPVxcXCIhc3RlcC5nZXRWYWxpZCgpXFxcIj48L3A+XFxyXFxuXFx0XFx0XFx0XFx0PHAgY2xhc3M9XFxcInRpdGxlXFxcIj57e3N0ZXAudGl0bGV9fSA8cmwtYnVzeSBsb2FkaW5nPVxcXCJzdGVwLmxvYWRpbmdcXFwiPjwvcmwtYnVzeT48L3A+XFxyXFxuXFx0XFx0XFx0XFx0PHAgY2xhc3M9XFxcInN1YnRpdGxlXFxcIj57e3N0ZXAuc3VidGl0bGV9fTwvcD5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdDwvb2w+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvci5odG1sXG4gKiogbW9kdWxlIGlkID0gMTEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgcmFkaW9Hcm91cF8xID0gcmVxdWlyZSgnLi9yYWRpb0dyb3VwJyk7XHJcbmV4cG9ydHMucmFkaW9Hcm91cERpcmVjdGl2ZU5hbWUgPSByYWRpb0dyb3VwXzEuZGlyZWN0aXZlTmFtZTtcclxuZXhwb3J0cy5yYWRpb0dyb3VwID0gcmFkaW9Hcm91cF8xLnJhZGlvR3JvdXA7XHJcbmV4cG9ydHMucmFkaW9Hcm91cENvbnRyb2xsZXJOYW1lID0gcmFkaW9Hcm91cF8xLmNvbnRyb2xsZXJOYW1lO1xyXG5leHBvcnRzLlJhZGlvR3JvdXBDb250cm9sbGVyID0gcmFkaW9Hcm91cF8xLlJhZGlvR3JvdXBDb250cm9sbGVyO1xyXG52YXIgcmFkaW9fMSA9IHJlcXVpcmUoJy4vcmFkaW8nKTtcclxuZXhwb3J0cy5yYWRpb0RpcmVjdGl2ZU5hbWUgPSByYWRpb18xLmRpcmVjdGl2ZU5hbWU7XHJcbmV4cG9ydHMucmFkaW8gPSByYWRpb18xLnJhZGlvO1xyXG5leHBvcnRzLnJhZGlvQ29udHJvbGxlck5hbWUgPSByYWRpb18xLmNvbnRyb2xsZXJOYW1lO1xyXG5leHBvcnRzLlJhZGlvQ29udHJvbGxlciA9IHJhZGlvXzEuUmFkaW9Db250cm9sbGVyO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwyMS5jb21wb25lbnRzLnJhZGlvJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKHJhZGlvR3JvdXBfMS5kaXJlY3RpdmVOYW1lLCByYWRpb0dyb3VwXzEucmFkaW9Hcm91cClcclxuICAgIC5jb250cm9sbGVyKHJhZGlvR3JvdXBfMS5jb250cm9sbGVyTmFtZSwgcmFkaW9Hcm91cF8xLlJhZGlvR3JvdXBDb250cm9sbGVyKVxyXG4gICAgLmRpcmVjdGl2ZShyYWRpb18xLmRpcmVjdGl2ZU5hbWUsIHJhZGlvXzEucmFkaW8pXHJcbiAgICAuY29udHJvbGxlcihyYWRpb18xLmNvbnRyb2xsZXJOYW1lLCByYWRpb18xLlJhZGlvQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhZGlvLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8ubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFJhZGlvR3JvdXAnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1JhZGlvR3JvdXBDb250cm9sbGVyJztcclxudmFyIFJhZGlvR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmFkaW9Hcm91cCgkc2NvcGUsIG5nTW9kZWwsIG5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBuZ01vZGVsLiR2aWV3VmFsdWU7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdGlvbjsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmFkaW9Hcm91cDtcclxufSkoKTtcclxuZXhwb3J0cy5SYWRpb0dyb3VwID0gUmFkaW9Hcm91cDtcclxudmFyIFJhZGlvR3JvdXBDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhZGlvR3JvdXBDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCAkZWxlbWVudCwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgaWYgKCFvYmplY3QuaXNOdWxsT3JXaGl0ZXNwYWNlKCRhdHRycy5ybFJhZGlvR3JvdXApKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAkYXR0cnMucmxSYWRpb0dyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSgkYXR0cnMubmFtZSkpIHtcclxuICAgICAgICAgICAgbmFtZSA9ICRhdHRycy5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmFtZSA9ICdSYWRpb0dyb3VwJyArIHRoaXMuZ2V0TmV4dElkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZ01vZGVsID0gJGVsZW1lbnQuY29udHJvbGxlcignbmdNb2RlbCcpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgUmFkaW9Hcm91cCgkc2NvcGUsIG5nTW9kZWwsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgUmFkaW9Hcm91cENvbnRyb2xsZXIucHJvdG90eXBlLnJlZ2lzdGVyQnV0dG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwO1xyXG4gICAgfTtcclxuICAgIFJhZGlvR3JvdXBDb250cm9sbGVyLnByb3RvdHlwZS5nZXROZXh0SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5leHRJZCA9IFJhZGlvR3JvdXBDb250cm9sbGVyLm5leHRJZC50b1N0cmluZygpO1xyXG4gICAgICAgIFJhZGlvR3JvdXBDb250cm9sbGVyLm5leHRJZCsrO1xyXG4gICAgICAgIHJldHVybiBuZXh0SWQ7XHJcbiAgICB9O1xyXG4gICAgUmFkaW9Hcm91cENvbnRyb2xsZXIubmV4dElkID0gMTtcclxuICAgIFJhZGlvR3JvdXBDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckYXR0cnMnLCAnJGVsZW1lbnQnLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gUmFkaW9Hcm91cENvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmFkaW9Hcm91cENvbnRyb2xsZXIgPSBSYWRpb0dyb3VwQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gcmFkaW9Hcm91cCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmFkaW9Hcm91cCA9IHJhZGlvR3JvdXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhZGlvR3JvdXAuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JhZGlvL3JhZGlvR3JvdXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIHJhZGlvR3JvdXBfMSA9IHJlcXVpcmUoJy4vcmFkaW9Hcm91cCcpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxSYWRpbyc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmFkaW9Db250cm9sbGVyJztcclxudmFyIFJhZGlvQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSYWRpb0NvbnRyb2xsZXIoJHNjb3BlLCAkZWxlbWVudCkge1xyXG4gICAgICAgIHZhciByYWRpb0dyb3VwQ29udHJvbGxlciA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ3JsUmFkaW9Hcm91cCcpO1xyXG4gICAgICAgIGlmIChyYWRpb0dyb3VwQ29udHJvbGxlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cCA9IHJhZGlvR3JvdXBDb250cm9sbGVyLnJlZ2lzdGVyQnV0dG9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbmdNb2RlbCA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ25nTW9kZWwnKTtcclxuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwID0gbmV3IHJhZGlvR3JvdXBfMS5SYWRpb0dyb3VwKCRzY29wZSwgbmdNb2RlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUmFkaW9Db250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckZWxlbWVudCddO1xyXG4gICAgcmV0dXJuIFJhZGlvQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SYWRpb0NvbnRyb2xsZXIgPSBSYWRpb0NvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHJhZGlvKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6IFsnP15ecmxSYWRpb0dyb3VwJywgJz9uZ01vZGVsJ10sXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8bGFiZWw+XFxuXFx0XFx0XFx0XFx0PGlucHV0IGlkPVxcXCJyYWRpb1xcXCIgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcInt7cmFkaW8ucmFkaW9Hcm91cC5uYW1lfX1cXFwiIG5nLW1vZGVsPVxcXCJyYWRpby5yYWRpb0dyb3VwLnNlbGVjdGlvblxcXCIgbmctdmFsdWU9XFxcInJhZGlvLnZhbHVlXFxcIiAvPlxcblxcdFxcdFxcdFxcdDxzcGFuIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXFx0XFx0XFx0PC9sYWJlbD5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3JhZGlvJyxcclxuICAgICAgICBzY29wZTogdHJ1ZSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yYWRpbyA9IHJhZGlvO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWRpby5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciByYXRpbmdCYXJCYWNrZ3JvdW5kc19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL3JhdGluZ0JhckJhY2tncm91bmRzLnNlcnZpY2UnKTtcclxudmFyIHJhdGluZ0JhckNsYXNzX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vcmF0aW5nQmFyQ2xhc3Muc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5yYXRpbmdCYXInO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxSYXRpbmdCYXInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1JhdGluZ0JhckNvbnRyb2xsZXInO1xyXG52YXIgUmF0aW5nQmFyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSYXRpbmdCYXJDb250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdmFyIHJhdGluZ0JhckJhY2tncm91bmRzID0gbmV3IHJhdGluZ0JhckJhY2tncm91bmRzX3NlcnZpY2VfMS5SYXRpbmdCYXJCYWNrZ3JvdW5kU2VydmljZTtcclxuICAgICAgICB0aGlzLnJhdGluZ0JhckNsYXNzID0gbmV3IHJhdGluZ0JhckNsYXNzX3NlcnZpY2VfMS5SYXRpbmdCYXJDbGFzc1NlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ2xhc3MgPSByYXRpbmdCYXJCYWNrZ3JvdW5kcy5nZXRCYWNrZ3JvdW5kKHRoaXMuYmFja2dyb3VuZCk7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy52YWx1ZTsgfSwgZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRvdGFsV2lkdGg7IH0sIGZ1bmN0aW9uIChuZXdXaWR0aCkge1xyXG4gICAgICAgICAgICBfdGhpcy5kaW1lbnNpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoICsgMixcclxuICAgICAgICAgICAgICAgIGhlaWdodDogX3RoaXMuaGVpZ2h0ICsgMixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlVmFsdWUoX3RoaXMudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgUmF0aW5nQmFyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICB2YXIgY29uZmlkZW5jZVNjb3JlID0gKG5ld1ZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xyXG4gICAgICAgIHRoaXMuYmFyQ2xhc3MgPSB0aGlzLnJhdGluZ0JhckNsYXNzLmdldENsYXNzKGNvbmZpZGVuY2VTY29yZSk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgucm91bmQoY29uZmlkZW5jZVNjb3JlICogdGhpcy50b3RhbFdpZHRoKTtcclxuICAgIH07XHJcbiAgICBSYXRpbmdCYXJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIFJhdGluZ0JhckNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmF0aW5nQmFyQ29udHJvbGxlciA9IFJhdGluZ0JhckNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHJhdGluZ0JhcigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJyYXRpbmctYmFyXFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ7e3JhdGluZ0Jhci5iYWNrZ3JvdW5kQ2xhc3N9fVxcXCIgbmctY2xhc3M9XFxcInsgZW1wdHk6IHJhdGluZ0Jhci52YWx1ZSA9PSBtaW4gfVxcXCIgbmctc3R5bGU9XFxcInJhdGluZ0Jhci5kaW1lbnNpb25zXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLWNsYXNzPVxcXCJyYXRpbmdCYXIuYmFyQ2xhc3NcXFwiIG5nLXN0eWxlPVxcXCJ7IHdpZHRoOiByYXRpbmdCYXIud2lkdGgsIGhlaWdodDogcmF0aW5nQmFyLmhlaWdodCB9XFxcIj48L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3JhdGluZ0JhcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgdG90YWxXaWR0aDogJz13aWR0aCcsXHJcbiAgICAgICAgICAgIGhlaWdodDogJz0nLFxyXG4gICAgICAgICAgICB2YWx1ZTogJz0nLFxyXG4gICAgICAgICAgICBtaW46ICc9JyxcclxuICAgICAgICAgICAgbWF4OiAnPScsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJhdGluZ0JhciA9IHJhdGluZ0JhcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCByYXRpbmdCYXIpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBSYXRpbmdCYXJDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmF0aW5nQmFyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyLmpzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBSYXRpbmdCYXJCYWNrZ3JvdW5kU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSYXRpbmdCYXJCYWNrZ3JvdW5kU2VydmljZSgpIHtcclxuICAgICAgICB0aGlzLnN0YW5kYXJkID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnc3RhbmRhcmQnLFxyXG4gICAgICAgICAgICBjbGFzczogJ2JhY2tncm91bmQnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kYXJrID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnZGFyaycsXHJcbiAgICAgICAgICAgIGNsYXNzOiAnYmFja2dyb3VuZC1kYXJrJyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIGNsYXNzOiAnYmFja2dyb3VuZC10cmFuc3BhcmVudCcsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlLnByb3RvdHlwZS5nZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdGhpcy5kYXJrLnR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGFyay5jbGFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gdGhpcy50cmFuc3BhcmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcGFyZW50LmNsYXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhbmRhcmQuY2xhc3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBSYXRpbmdCYXJCYWNrZ3JvdW5kU2VydmljZTtcclxufSkoKTtcclxuZXhwb3J0cy5SYXRpbmdCYXJCYWNrZ3JvdW5kU2VydmljZSA9IFJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRpbmdCYXJCYWNrZ3JvdW5kcy5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyQmFja2dyb3VuZHMuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhdGluZ0JhckNsYXNzU2VydmljZSgpIHtcclxuICAgIH1cclxuICAgIFJhdGluZ0JhckNsYXNzU2VydmljZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29uZmlkZW5jZSkge1xyXG4gICAgICAgIGlmIChjb25maWRlbmNlID49IDAuOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3ZlcnktaGlnaCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZGVuY2UgPj0gMC42KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnaGlnaCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZGVuY2UgPj0gMC40KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbWVkaXVtJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlkZW5jZSA+PSAwLjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdsb3cnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICd2ZXJ5LWxvdyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBSYXRpbmdCYXJDbGFzc1NlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlID0gUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRpbmdCYXJDbGFzcy5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYXRpbmdCYXIvcmF0aW5nQmFyQ2xhc3Muc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnJlcXVpcmUoJ25nLXdpZy9kaXN0L2Nzcy9uZy13aWcuY3NzJyk7XHJcbnJlcXVpcmUoJ25nLXdpZy9kaXN0L25nLXdpZycpO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIHJpY2hUZXh0RWRpdG9yX2NvbmZpZ18xID0gcmVxdWlyZSgnLi9yaWNoVGV4dEVkaXRvci5jb25maWcnKTtcclxudmFyIGhlYWRlckJ1dHRvbl8xID0gcmVxdWlyZSgnLi9oZWFkZXJCdXR0b24nKTtcclxudmFyIHBhcmFncmFwaEJ1dHRvbl8xID0gcmVxdWlyZSgnLi9wYXJhZ3JhcGhCdXR0b24nKTtcclxudmFyIGV4dGVybmFsUHJvdmlkZXJOYW1lID0gcmljaFRleHRFZGl0b3JfY29uZmlnXzEucHJvdmlkZXJOYW1lICsgJ1Byb3ZpZGVyJztcclxuZXhwb3J0cy5wcm92aWRlck5hbWUgPSBleHRlcm5hbFByb3ZpZGVyTmFtZTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMucmljaFRleHRFZGl0b3InO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxSaWNoVGV4dEVkaXRvcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmljaFRleHRFZGl0b3JDb250cm9sbGVyJztcclxudmFyIFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSaWNoVGV4dEVkaXRvckNvbnRyb2xsZXIob2JqZWN0LCBwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMudG9vbGJhciA9ICdoMSwgcGFyYWdyYXBoLCBib2xkLCBpdGFsaWMsIHVuZGVybGluZSwgbGlzdDEsIGxpc3QyLCBpbmRlbnQsIG91dGRlbnQnO1xyXG4gICAgICAgIGlmICghb2JqZWN0LmlzTnVsbE9yRW1wdHkodGhpcy5jdXN0b21CdXR0b25zKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2xiYXIgKz0gJywgJyArIHRoaXMuY3VzdG9tQnV0dG9ucztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBSaWNoVGV4dEVkaXRvckNvbnRyb2xsZXIuJGluamVjdCA9IFtfX29iamVjdC5zZXJ2aWNlTmFtZSwgcmljaFRleHRFZGl0b3JfY29uZmlnXzEucHJvdmlkZXJOYW1lXTtcclxuICAgIHJldHVybiBSaWNoVGV4dEVkaXRvckNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuUmljaFRleHRFZGl0b3JDb250cm9sbGVyID0gUmljaFRleHRFZGl0b3JDb250cm9sbGVyO1xyXG5mdW5jdGlvbiByaWNoVGV4dEVkaXRvcigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9yaWNoVGV4dEVkaXRvci5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdlZGl0b3InLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIG5nTW9kZWw6ICc9JyxcclxuICAgICAgICAgICAgY3VzdG9tQnV0dG9uczogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmljaFRleHRFZGl0b3IgPSByaWNoVGV4dEVkaXRvcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbJ25nV2lnJywgX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgcmljaFRleHRFZGl0b3IpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBSaWNoVGV4dEVkaXRvckNvbnRyb2xsZXIpXHJcbiAgICAuZGlyZWN0aXZlKGhlYWRlckJ1dHRvbl8xLmhlYWRlckJ1dHRvbkRpcmVjdGl2ZU5hbWUsIGhlYWRlckJ1dHRvbl8xLmhlYWRlckJ1dHRvbilcclxuICAgIC5kaXJlY3RpdmUocGFyYWdyYXBoQnV0dG9uXzEucGFyYWdyYXBoQnV0dG9uRGlyZWN0aXZlTmFtZSwgcGFyYWdyYXBoQnV0dG9uXzEucGFyYWdyYXBoQnV0dG9uKVxyXG4gICAgLnByb3ZpZGVyKHJpY2hUZXh0RWRpdG9yX2NvbmZpZ18xLnByb3ZpZGVyTmFtZSwgcmljaFRleHRFZGl0b3JfY29uZmlnXzEucmljaFRleHRFZGl0b3JQcm92aWRlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpY2hUZXh0RWRpdG9yLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL25nLXdpZy5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL25nLXdpZy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL25nLXdpZy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L25nLXdpZy9kaXN0L2Nzcy9uZy13aWcuY3NzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9mb250LWF3ZXNvbWUvNC40LjAvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzKTtcIiwgXCJcIl0pO1xuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIC0tLS0tLS0tIE5HLVdJRyAtLS0tLS0tLSAqL1xcbi8qKlxcbiAqXFxuICogIFJFU0VUIEJPWCBNT0RFTFxcbiAqXFxuICovXFxuLm5nLXdpZyxcXG5bY2xhc3NePVxcXCJudy1cXFwiXSB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAtby1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLW1zLWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG5cXG4vKipcXG4gKiAgIG1haW4gd3JhcHBlciBmb3IgdGhlIGVkaXRvclxcbiAqXFxuICogIC5uZy13aWdcXG4gKlxcbiAqL1xcbi5uZy13aWcge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG5cXG4vKipcXG4gKiAgc3R5bGluZyBmb3IgdG9vbGJhciBhbmQgaXRzIGl0ZW1zXFxuICpcXG4gKiAgLm53LXRvb2xiYXJcXG4gKiAgICAmX19pdGVtXFxuICpcXG4gKi9cXG4ubnctdG9vbGJhciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xcbiAgcGFkZGluZzogMCAhaW1wb3J0YW50O1xcbiAgbGlzdC1zdHlsZTogbm9uZSAhaW1wb3J0YW50O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY29sb3I6ICM2QjcyNzc7XFxuXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCg5MGRlZywgI2ZmZmZmZiAwJSwgI2Y5ZjlmOSAxMDAlKTtcXG4gIGJhY2tncm91bmQ6ICAgIC1tb3otbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjZmZmZmZmIDAlLCAjZjlmOWY5IDEwMCUpO1xcbiAgYmFja2dyb3VuZDogICAgICAgICBsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCAjZmZmZmZmIDAlLCAjZjlmOWY5IDEwMCUpO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0NDQ0NDQztcXG4gIGJvcmRlci1yYWRpdXM6IDNweCAzcHggMCAwO1xcbn1cXG5cXG4ubnctdG9vbGJhcl9faXRlbSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcblxcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI0RFREVERTtcXG59XFxuXFxuLm53LXRvb2xiYXIgbGFiZWwge1xcbiAgbGluZS1oZWlnaHQ6IDMwcHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwYWRkaW5nOiAwIDZweCAwIDNweDtcXG59XFxuXFxuLm53LXRvb2xiYXIgaW5wdXRbdHlwZT1jaGVja2JveF0ge1xcbiAgdmVydGljYWwtYWxpZ246IC0zcHg7XFxuICBtYXJnaW4tcmlnaHQ6IC0xcHg7XFxufVxcblxcbi8qKlxcbiAqICBzdHlsaW5nIGZvciB0aGUgZWRpdG9yIHBhcnQ6IHNvdXJjZSBjb2RlIChvcmlnaW5hbCB0ZXh0YXJlYSkgYW5kIHJlc3VsdGluZyBkaXZcXG4gKlxcbiAqICAubnctZWRpdG9yXFxuICogICAgJl9fc3JjXFxuICogICAgJl9fcmVzXFxuICpcXG4gKi9cXG4ubnctZWRpdG9yIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbiAgLyogRGVmYXVsdCB3aGVuIGhlaWdodCBpcyBub3Qgc2V0ICovXFxuICBtaW4taGVpZ2h0OiAzMDBweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBjdXJzb3I6IHRleHQ7XFxufVxcblxcbi5udy1pbnZpc2libGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLm53LWVkaXRvci1jb250YWluZXIge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI0NDQ0NDQztcXG4gIGJvcmRlci10b3A6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAwIDAgM3B4IDNweDtcXG59XFxuXFxuLm53LWVkaXRvcl9fcmVzIHtcXG4gIG1pbi1oZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW46IC0xcHggMDtcXG4gIHBhZGRpbmc6IDFweCAwO1xcbn1cXG5cXG4ubnctZWRpdG9yX19zcmMsXFxuLm53LWVkaXRvcl9fcmVzIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3JkZXI6IG5vbmU7XFxufVxcblxcbi5udy1lZGl0b3JfX3NyYyB7XFxuICByZXNpemU6IG5vbmU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICBwYWRkaW5nOiA4cHg7XFxufVxcblxcblxcbi8qKlxcbiAqICBzdHlsaW5nIGZvciB0b29sYmFyIGJ1dHRvbiwgaGFzIHR3byBtb2RpZmllcnM6IGFjdGl2ZSBhbmQgdHlwZSBvZiBpY29uIGZvciBiYWNrZ3JvdW5kXFxuICpcXG4gKiAgLm53LWJ1dHRvblxcbiAqICAgICYtLWFjdGl2ZVxcbiAqICAgICYtLXtidXR0b24gdHlwZX1cXG4gKlxcbiAqL1xcbi5udy1idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgLW1vei1hcHBlYXJhbmNlOiAgICBub25lO1xcbiAgYXBwZWFyYW5jZTogICAgICAgICBub25lO1xcblxcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMzBweDtcXG4gIGhlaWdodDogMzBweDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBvcGFjaXR5OiAwLjU7XFxuXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcblxcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4ubnctYnV0dG9uOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi5udy1idXR0b246aG92ZXIsXFxuLm53LWJ1dHRvbi5udy1idXR0b24tLWFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxXFxufVxcblxcbi5udy1idXR0b24tLWFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRUVFRUVFO1xcbn1cXG5cXG4vKipcXG4gKiAgc3R5bGluZyAmIGZvcm1hdHRpbmcgb2YgY29udGVudCBpbnNpZGUgY29udGVudGVkaXRhYmxlIGRpdlxcbiAqXFxuICogIC5udy1jb250ZW50XFxuICpcXG4gKi9cXG4ubnctY29udGVudCB7XFxuICBwYWRkaW5nOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcblxcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBsaW5lLWhlaWdodDogMjRweDtcXG59XFxuXFxuLm53LXNlbGVjdCB7XFxuICBoZWlnaHQ6IDMwcHg7XFxuICBwYWRkaW5nOiA2cHg7XFxuICBjb2xvcjogIzU1NTtcXG4gIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxuICBib3JkZXI6IDA7XFxufVxcblxcbi5udy1zZWxlY3Q6Zm9jdXMgeyBvdXRsaW5lOiBub25lOyB9XFxuXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vbmctd2lnL2Rpc3QvY3NzL25nLXdpZy5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogdmVyc2lvbjogMi4yLjBcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ25nV2lnJywgWyduZ3dpZy1hcHAtdGVtcGxhdGVzJ10pO1xuXG5hbmd1bGFyLm1vZHVsZSgnbmdXaWcnKVxuICAuZGlyZWN0aXZlKCduZ1dpZycsIFtcIiR3aW5kb3dcIiwgXCIkZG9jdW1lbnRcIiwgXCJuZ1dpZ1Rvb2xiYXJcIiwgZnVuY3Rpb24gKCR3aW5kb3csICRkb2N1bWVudCwgbmdXaWdUb29sYmFyKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgY29udGVudDogJz1uZ1dpZycsXG4gICAgICAgIG9uUGFzdGU6ICc9J1xuICAgICAgfSxcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgdGVtcGxhdGVVcmw6ICduZy13aWcvdmlld3Mvbmctd2lnLmh0bWwnLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuXG4gICAgICAgIHNjb3BlLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgICAgIHNjb3BlLmF1dG9leHBhbmQgPSAhKCdhdXRvZXhwYW5kJyBpbiBhdHRycykgfHwgYXR0cnNbJ2F1dG9leHBhbmQnXSAhPT0gJ29mZic7XG4gICAgICAgIHNjb3BlLnRvb2xiYXJCdXR0b25zID0gbmdXaWdUb29sYmFyLmdldFRvb2xiYXJCdXR0b25zKGF0dHJzLmJ1dHRvbnMgJiYgc3RyaW5nMmFycmF5KGF0dHJzLmJ1dHRvbnMpKTtcblxuICAgICAgICBmdW5jdGlvbiBzdHJpbmcyYXJyYXkoa2V5c1N0cmluZyl7XG4gICAgICAgICAgcmV0dXJuIGtleXNTdHJpbmcuc3BsaXQoJywnKS5tYXAoRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsIFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS50b2dnbGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY29wZS5lZGl0TW9kZSA9ICFzY29wZS5lZGl0TW9kZTtcblxuICAgICAgICAgIGlmICgkd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcykge1xuICAgICAgICAgICAgJHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCwgb3B0aW9ucykge1xuICAgICAgICAgIGlmKHNjb3BlLmVkaXRNb2RlICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGNvbW1hbmQgPT09ICdjcmVhdGVsaW5rJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb21wdCgnUGxlYXNlIGVudGVyIHRoZSBVUkwnLCAnaHR0cDovLycpO1xuICAgICAgICAgICAgaWYoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzY29wZS4kYnJvYWRjYXN0KCdleGVjQ29tbWFuZCcsIHtjb21tYW5kOiBjb21tYW5kLCBvcHRpb25zOiBvcHRpb25zfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XVxuKTtcblxuXG5hbmd1bGFyLm1vZHVsZSgnbmdXaWcnKVxuICAuZGlyZWN0aXZlKCduZ1dpZ0VkaXRhYmxlJywgW1wiJGRvY3VtZW50XCIsIGZ1bmN0aW9uICgkZG9jdW1lbnQpIHtcbiAgICBmdW5jdGlvbiBpbml0KHNjb3BlLCAkZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDb250cm9sbGVyKSB7XG5cbiAgICAgICRlbGVtZW50LmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuXG4gICAgICAvL21vZGVsIC0tPiB2aWV3XG4gICAgICBuZ01vZGVsQ29udHJvbGxlci4kcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkZWxlbWVudC5odG1sKG5nTW9kZWxDb250cm9sbGVyLiR2aWV3VmFsdWUgfHwgJycpO1xuICAgICAgfTtcblxuICAgICAgLy92aWV3IC0tPiBtb2RlbFxuICAgICAgZnVuY3Rpb24gdmlld1RvTW9kZWwoKSB7XG4gICAgICAgIG5nTW9kZWxDb250cm9sbGVyLiRzZXRWaWV3VmFsdWUoJGVsZW1lbnQuaHRtbCgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2ZW50c1RvQmluZCA9IFtcbiAgICAgICAgJ2JsdXInLFxuICAgICAgICAna2V5dXAnLFxuICAgICAgICAnY2hhbmdlJyxcbiAgICAgICAgJ2ZvY3VzJyxcbiAgICAgICAgJ2NsaWNrJ1xuICAgICAgXTtcblxuICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzY29wZS5vblBhc3RlKSkge1xuICAgICAgICAkZWxlbWVudC5vbigncGFzdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgc2NvcGUub25QYXN0ZShlLCAkZWxlbWVudC5odG1sKCkpLnRoZW4oZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAkZWxlbWVudC5odG1sKHZhbCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZXZlbnRzVG9CaW5kLnB1c2goJ3Bhc3RlJyk7XG4gICAgICB9XG5cbiAgICAgICRlbGVtZW50LmJpbmQoZXZlbnRzVG9CaW5kLmpvaW4oJyAnKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZpZXdUb01vZGVsKCk7XG4gICAgICAgIHNjb3BlLiRhcHBseUFzeW5jKCk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuaXNFZGl0b3JBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkZWxlbWVudFswXSA9PT0gJGRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICBzY29wZS4kb24oJ2V4ZWNDb21tYW5kJywgZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgJGVsZW1lbnRbMF0uZm9jdXMoKTtcblxuICAgICAgICB2YXIgaWVTdHlsZVRleHRTZWxlY3Rpb24gPSAkZG9jdW1lbnRbMF0uc2VsZWN0aW9uLFxuICAgICAgICAgIGNvbW1hbmQgPSBwYXJhbXMuY29tbWFuZCxcbiAgICAgICAgICBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGllU3R5bGVUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIHRleHRSYW5nZSA9IGllU3R5bGVUZXh0U2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGRvY3VtZW50WzBdLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCAmJiAhJGRvY3VtZW50WzBdLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjb21tYW5kKSkge1xuICAgICAgICAgIHRocm93ICdUaGUgY29tbWFuZCBcIicgKyBjb21tYW5kICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgJGRvY3VtZW50WzBdLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoaWVTdHlsZVRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB0ZXh0UmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgIHRleHRSYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXdUb01vZGVsKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBsaW5rOiBpbml0XG4gICAgfVxuICB9XVxuKTtcblxuYW5ndWxhci5tb2R1bGUoJ25nV2lnJylcbiAgICAuZGlyZWN0aXZlKCduZ1dpZ1BsdWdpbicsIFtcIiRjb21waWxlXCIsIGZ1bmN0aW9uICgkY29tcGlsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gJzwnICsgc2NvcGUuYnV0dG9uLnBsdWdpbk5hbWUgKyAnIC8+JyxcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQgPSAkY29tcGlsZSh0ZW1wbGF0ZSkoc2NvcGUpO1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChjb21waWxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCduZ1dpZycpLnByb3ZpZGVyKCduZ1dpZ1Rvb2xiYXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGJ1dHRvbkxpYnJhcnkgPSB7XG4gICAgbGlzdDE6IHt0aXRsZTogJ1Vub3JkZXJlZCBMaXN0JywgY29tbWFuZDogJ2luc2VydHVub3JkZXJlZGxpc3QnLCBzdHlsZUNsYXNzOiAnZmEtbGlzdC11bCd9LFxuICAgIGxpc3QyOiB7dGl0bGU6ICdPcmRlcmVkIExpc3QnLCBjb21tYW5kOiAnaW5zZXJ0b3JkZXJlZGxpc3QnLCBzdHlsZUNsYXNzOiAnZmEtbGlzdC1vbCd9LFxuICAgIGJvbGQ6IHt0aXRsZTogJ0JvbGQnLCBjb21tYW5kOiAnYm9sZCcsIHN0eWxlQ2xhc3M6ICdmYS1ib2xkJ30sXG4gICAgaXRhbGljOiB7dGl0bGU6ICdJdGFsaWMnLCBjb21tYW5kOiAnaXRhbGljJywgc3R5bGVDbGFzczogJ2ZhLWl0YWxpYyd9LFxuICAgIGxpbms6IHt0aXRsZTogJ0xpbmsnLCBjb21tYW5kOiAnY3JlYXRlbGluaycsIHN0eWxlQ2xhc3M6ICdmYS1saW5rJ31cbiAgfTtcblxuICB2YXIgZGVmYXVsdEJ1dHRvbnNMaXN0ID0gWydsaXN0MScsICdsaXN0MicsICdib2xkJywgJ2l0YWxpYycsICdsaW5rJ107XG5cbiAgdmFyIGlzQnV0dG9uQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmQgJiYgZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUodGhpcy5jb21tYW5kKTtcbiAgfTtcblxuICB0aGlzLnNldEJ1dHRvbnMgPSBmdW5jdGlvbihidXR0b25zKSB7XG4gICAgaWYoIWFuZ3VsYXIuaXNBcnJheShidXR0b25zKSkge1xuICAgICAgdGhyb3cgJ0FyZ3VtZW50IFwiYnV0dG9uc1wiIHNob3VsZCBiZSBhbiBhcnJheSc7XG4gICAgfVxuXG4gICAgZGVmYXVsdEJ1dHRvbnNMaXN0ID0gYnV0dG9ucztcbiAgfTtcblxuICB0aGlzLmFkZFN0YW5kYXJkQnV0dG9uID0gZnVuY3Rpb24gKG5hbWUsIHRpdGxlLCBjb21tYW5kLCBzdHlsZUNsYXNzKSB7XG4gICAgaWYoIW5hbWUgfHwgIXRpdGxlIHx8ICFjb21tYW5kKSB7XG4gICAgICB0aHJvdyAnQXJndW1lbnRzIFwibmFtZVwiLCBcInRpdGxlXCIgYW5kIFwiY29tbWFuZFwiIGFyZSByZXF1aXJlZCc7XG4gICAgfVxuXG4gICAgc3R5bGVDbGFzcyA9IHN0eWxlQ2xhc3MgfHwgJyc7XG4gICAgYnV0dG9uTGlicmFyeVtuYW1lXSA9IHt0aXRsZTogdGl0bGUsIGNvbW1hbmQ6IGNvbW1hbmQsIHN0eWxlQ2xhc3M6IHN0eWxlQ2xhc3N9XG4gICAgZGVmYXVsdEJ1dHRvbnNMaXN0LnB1c2gobmFtZSk7XG4gIH07XG5cbiAgdGhpcy5hZGRDdXN0b21CdXR0b24gPSBmdW5jdGlvbiAobmFtZSwgcGx1Z2luTmFtZSkge1xuICAgIGlmKCFuYW1lIHx8ICFwbHVnaW5OYW1lKSB7XG4gICAgICB0aHJvdyAnQXJndW1lbnRzIFwibmFtZVwiIGFuZCBcInBsdWdpbk5hbWVcIiBhcmUgcmVxdWlyZWQnO1xuICAgIH1cblxuICAgIGJ1dHRvbkxpYnJhcnlbbmFtZV0gPSB7cGx1Z2luTmFtZTogcGx1Z2luTmFtZSwgaXNDb21wbGV4OiB0cnVlfTtcbiAgICBkZWZhdWx0QnV0dG9uc0xpc3QucHVzaChuYW1lKTtcbiAgfTtcblxuICB0aGlzLiRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFRvb2xiYXJCdXR0b25zOiBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIHZhciB0b29sYmFyQnV0dG9ucyA9IFtdO1xuICAgICAgICAobGlzdCB8fCBkZWZhdWx0QnV0dG9uc0xpc3QpLmZvckVhY2goZnVuY3Rpb24oYnV0dG9uS2V5KSB7XG4gICAgICAgICAgaWYoIWJ1dHRvbkxpYnJhcnlbYnV0dG9uS2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgJ1RoZXJlIGlzIG5vIFwiJyArIGJ1dHRvbktleSArICdcIiBpbiB5b3VyIGxpYnJhcnkuIFBvc3NpYmxlIHZhcmlhbnRzOiAnICsgT2JqZWN0LmtleXMoYnV0dG9uTGlicmFyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJ1dHRvbiA9IGFuZ3VsYXIuY29weShidXR0b25MaWJyYXJ5W2J1dHRvbktleV0pO1xuXG4gICAgICAgICAgaWYoIWFuZ3VsYXIuaXNGdW5jdGlvbihidXR0b24uaXNBY3RpdmUpKSB7XG4gICAgICAgICAgICBidXR0b24uaXNBY3RpdmUgPSBpc0J1dHRvbkFjdGl2ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b29sYmFyQnV0dG9ucy5wdXNoKGJ1dHRvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9vbGJhckJ1dHRvbnM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuXG59KTtcbmFuZ3VsYXIubW9kdWxlKCduZ1dpZycpXG4gICAgLmNvbmZpZyhbJ25nV2lnVG9vbGJhclByb3ZpZGVyJywgZnVuY3Rpb24gKG5nV2lnVG9vbGJhclByb3ZpZGVyKSB7XG4gICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkQ3VzdG9tQnV0dG9uKCdmb3JtYXRzJywgJ253LWZvcm1hdHMtYnV0dG9uJyk7XG4gICAgfV0pXG4gICAgLmRpcmVjdGl2ZSgnbndGb3JtYXRzQnV0dG9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPHNlbGVjdCBjbGFzcz1cIm53LXNlbGVjdFwiIG5nLW1vZGVsPVwiZm9ybWF0XCIgbmctY2hhbmdlPVwiZXhlY0NvbW1hbmQoXFwnZm9ybWF0YmxvY2tcXCcsIGZvcm1hdC52YWx1ZSlcIiBuZy1vcHRpb25zPVwiZm9ybWF0Lm5hbWUgZm9yIGZvcm1hdCBpbiBmb3JtYXRzXCIgbmctZGlzYWJsZWQ9XCJlZGl0TW9kZVwiPjwvc2VsZWN0PicsXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5mb3JtYXRzID0gW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ05vcm1hbCB0ZXh0JywgdmFsdWU6ICdwJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnSGVhZGVyIDEnLCB2YWx1ZTogJ2gxJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnSGVhZGVyIDInLCB2YWx1ZTogJ2gyJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnSGVhZGVyIDMnLCB2YWx1ZTogJ2gzJ31cbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZm9ybWF0ID0gc2NvcGUuZm9ybWF0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuXG5hbmd1bGFyLm1vZHVsZSgnbmd3aWctYXBwLXRlbXBsYXRlcycsIFsnbmctd2lnL3ZpZXdzL25nLXdpZy5odG1sJ10pO1xuXG5hbmd1bGFyLm1vZHVsZShcIm5nLXdpZy92aWV3cy9uZy13aWcuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcIm5nLXdpZy92aWV3cy9uZy13aWcuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwibmctd2lnXFxcIj5cXG5cIiArXG4gICAgXCIgIDx1bCBjbGFzcz1cXFwibnctdG9vbGJhclxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxsaSBjbGFzcz1cXFwibnctdG9vbGJhcl9faXRlbVxcXCIgbmctcmVwZWF0PVxcXCJidXR0b24gaW4gdG9vbGJhckJ1dHRvbnNcXFwiID5cXG5cIiArXG4gICAgXCIgICAgICAgIDxkaXYgbmctaWY9XFxcIiFidXR0b24uaXNDb21wbGV4XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJudy1idXR0b25cXFwiIHRpdGxlPVxcXCJ7e2J1dHRvbi50aXRsZX19XFxcIiBuZy1jbGljaz1cXFwiZXhlY0NvbW1hbmQoYnV0dG9uLmNvbW1hbmQpXFxcIiBuZy1jbGFzcz1cXFwieyAnbnctYnV0dG9uLS1hY3RpdmUnOiBpc0VkaXRvckFjdGl2ZSgpICYmIGJ1dHRvbi5pc0FjdGl2ZSgpIH1cXFwiIG5nLWRpc2FibGVkPVxcXCJlZGl0TW9kZVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIHt7YnV0dG9uLnN0eWxlQ2xhc3N9fVxcXCI+PC9pPlxcblwiICtcbiAgICBcIiAgICAgICAgICA8L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgICAgIDwvZGl2PlxcblwiICtcbiAgICBcIiAgICAgICAgPGRpdiBuZy1pZj1cXFwiYnV0dG9uLmlzQ29tcGxleFxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICAgIDxuZy13aWctcGx1Z2luIHBsdWdpbj1cXFwie3tidXR0b259fVxcXCI+PC9uZy13aWctcGx1Z2luPlxcblwiICtcbiAgICBcIiAgICAgICAgPC9kaXY+XFxuXCIgK1xuICAgIFwiICAgIDwvbGk+PCEtLVxcblwiICtcbiAgICBcIiAgICAtLT48bGkgY2xhc3M9XFxcIm53LXRvb2xiYXJfX2l0ZW1cXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwibnctYnV0dG9uIG53LWJ1dHRvbi0tc291cmNlXFxcIiBuZy1jbGFzcz1cXFwieyAnbnctYnV0dG9uLS1hY3RpdmUnOiBlZGl0TW9kZSB9XFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlRWRpdE1vZGUoKVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXBlbmNpbFxcXCI+PC9pPjwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICA8L2xpPlxcblwiICtcbiAgICBcIiAgPC91bD5cXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcIm53LWVkaXRvci1jb250YWluZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJudy1lZGl0b3JcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZXh0YXJlYSAgY2xhc3M9XFxcIm53LWVkaXRvcl9fc3JjXFxcIiBuZy1zaG93PVxcXCJlZGl0TW9kZVxcXCIgbmctbW9kZWw9XFxcImNvbnRlbnRcXFwiPjwvdGV4dGFyZWE+XFxuXCIgK1xuICAgIFwiICAgICAgPGRpdiB0YWJpbmRleD1cXFwiLTFcXFwiIG5nLWNsYXNzPVxcXCJ7J253LWludmlzaWJsZSc6IGVkaXRNb2RlLCAnbnctYXV0b2V4cGFuZCc6IGF1dG9leHBhbmR9XFxcIiBjbGFzcz1cXFwibnctZWRpdG9yX19yZXNcXFwiIG5nLW1vZGVsPVxcXCJjb250ZW50XFxcIiBuZy13aWctZWRpdGFibGUgb24tcGFzdGU9XFxcIm9uUGFzdGVcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L25nLXdpZy9kaXN0L25nLXdpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLnByb3ZpZGVyTmFtZSA9ICdyaWNoVGV4dEVkaXRvcic7XHJcbnJpY2hUZXh0RWRpdG9yUHJvdmlkZXIuJGluamVjdCA9IFsnbmdXaWdUb29sYmFyUHJvdmlkZXInXTtcclxuZnVuY3Rpb24gcmljaFRleHRFZGl0b3JQcm92aWRlcihuZ1dpZ1Rvb2xiYXJQcm92aWRlcikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRDdXN0b21CdXR0b246IGZ1bmN0aW9uIChuYW1lLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkQ3VzdG9tQnV0dG9uKG5hbWUsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRTdGFuZGFyZEJ1dHRvbjogZnVuY3Rpb24gKG5hbWUsIHRvb2x0aXAsIGNvbW1hbmQsIGljb24pIHtcclxuICAgICAgICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkU3RhbmRhcmRCdXR0b24obmFtZSwgdG9vbGJhciwgY29tbWFuZCwgJ2ZhLScgKyBpY29uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkQ3VzdG9tQnV0dG9uKCdwYXJhZ3JhcGgnLCAncmwtcGFyYWdyYXBoLWJ1dHRvbicpO1xyXG4gICAgICAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRDdXN0b21CdXR0b24oJ2gxJywgJ3JsLWhlYWRlci1idXR0b24nKTtcclxuICAgICAgICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkU3RhbmRhcmRCdXR0b24oJ3VuZGVybGluZScsICdVbmRlcmxpbmUnLCAndW5kZXJsaW5lJywgJ2ZhLXVuZGVybGluZScpO1xyXG4gICAgICAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRTdGFuZGFyZEJ1dHRvbignaW5kZW50JywgJ0luZGVudCcsICdpbmRlbnQnLCAnZmEtaW5kZW50Jyk7XHJcbiAgICAgICAgICAgIG5nV2lnVG9vbGJhclByb3ZpZGVyLmFkZFN0YW5kYXJkQnV0dG9uKCdvdXRkZW50JywgJ091dGRlbnQnLCAnb3V0ZGVudCcsICdmYS1vdXRkZW50Jyk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yaWNoVGV4dEVkaXRvclByb3ZpZGVyID0gcmljaFRleHRFZGl0b3JQcm92aWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmljaFRleHRFZGl0b3IuY29uZmlnLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5jb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmhlYWRlckJ1dHRvbkRpcmVjdGl2ZU5hbWUgPSAncmxIZWFkZXJCdXR0b24nO1xyXG5mdW5jdGlvbiBoZWFkZXJCdXR0b24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJudy1idXR0b25cXFwiIG5nLWNsaWNrPVxcXCJ0cmlnZ2VyKClcXFwiIG5nLWRpc2FibGVkPVxcXCJlZGl0TW9kZVxcXCIgdGl0bGU9XFxcIkhlYWRlciAxXFxcIj5cXG5cXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtaGVhZGVyXFxcIj48L2k+XFxuXFx0XFx0XFx0PC9idXR0b24+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5leGVjQ29tbWFuZCgnZm9ybWF0YmxvY2snLCAnaDEnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmhlYWRlckJ1dHRvbiA9IGhlYWRlckJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyQnV0dG9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9oZWFkZXJCdXR0b24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLnBhcmFncmFwaEJ1dHRvbkRpcmVjdGl2ZU5hbWUgPSAncmxQYXJhZ3JhcGhCdXR0b24nO1xyXG5mdW5jdGlvbiBwYXJhZ3JhcGhCdXR0b24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJudy1idXR0b25cXFwiIG5nLWNsaWNrPVxcXCJ0cmlnZ2VyKClcXFwiIG5nLWRpc2FibGVkPVxcXCJlZGl0TW9kZVxcXCIgdGl0bGU9XFxcInBhcmFncmFwaFxcXCI+XFxuXFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLXBhcmFncmFwaFxcXCI+PC9pPlxcblxcdFxcdFxcdDwvYnV0dG9uPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSkge1xyXG4gICAgICAgICAgICBzY29wZS50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuZXhlY0NvbW1hbmQoJ2Zvcm1hdGJsb2NrJywgJ3AnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnBhcmFncmFwaEJ1dHRvbiA9IHBhcmFncmFwaEJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYWdyYXBoQnV0dG9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9wYXJhZ3JhcGhCdXR0b24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8dGV4dGFyZWEgY2xhc3M9XFxcInJpY2gtdGV4dC1lZGl0b3JcXFwiIG5nLXdpZz1cXFwiZWRpdG9yLm5nTW9kZWxcXFwiIGJ1dHRvbnM9XFxcInt7ZWRpdG9yLnRvb2xiYXJ9fVxcXCI+PC90ZXh0YXJlYT5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5odG1sXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxucmVxdWlyZSgndWktc2VsZWN0Jyk7XHJcbnJlcXVpcmUoJ3VpLXNlbGVjdC9kaXN0L3NlbGVjdC5jc3MnKTtcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvY29tcG9uZW50VmFsaWRhdG9yL2NvbXBvbmVudFZhbGlkYXRvci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnNlbGVjdCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFNlbGVjdCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnU2VsZWN0Q29udHJvbGxlcic7XHJcbnZhciBTZWxlY3RDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlbGVjdENvbnRyb2xsZXIoJGVsZW1lbnQsICRzY29wZSwgJHEsIGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnksIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kcSA9ICRxO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuX251bGxPcHRpb24gPSB7XHJcbiAgICAgICAgICAgIF9faXNOdWxsT3B0aW9uOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5uZ01vZGVsID0gJGVsZW1lbnQuY29udHJvbGxlcignbmdNb2RlbCcpO1xyXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMub3B0aW9ucykpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkSXRlbXMoKS50aGVuKGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZ3VyZU9wdGlvbnModGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMudmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdFZhbGlkYXRvciA9IGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkuZ2V0SW5zdGFuY2Uoe1xyXG4gICAgICAgICAgICAgICAgbmdNb2RlbDogdGhpcy5uZ01vZGVsLFxyXG4gICAgICAgICAgICAgICAgJHNjb3BlOiAkc2NvcGUsXHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiBbdGhpcy52YWxpZGF0b3JdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VsZWN0Q29udHJvbGxlci5wcm90b3R5cGUsIFwic2VsZWN0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmdNb2RlbC4kdmlld1ZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLl9faXNOdWxsT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5nTW9kZWwuJHNldFZpZXdWYWx1ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2VsZWN0Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmIChpdGVtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLl9faXNOdWxsT3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bGxPcHRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24odGhpcy5zZWxlY3RvcilcclxuICAgICAgICAgICAgPyB0aGlzLnNlbGVjdG9yKGl0ZW0pXHJcbiAgICAgICAgICAgIDogaXRlbVt0aGlzLnNlbGVjdG9yXTtcclxuICAgIH07XHJcbiAgICBTZWxlY3RDb250cm9sbGVyLnByb3RvdHlwZS5sb2FkSXRlbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZTtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuZ2V0T3B0aW9ucykpIHtcclxuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuZ2V0T3B0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuJHEud2hlbih0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBfdGhpcy5jb25maWd1cmVPcHRpb25zKG9wdGlvbnMpOyB9KTtcclxuICAgIH07XHJcbiAgICBTZWxlY3RDb250cm9sbGVyLnByb3RvdHlwZS5jb25maWd1cmVPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIXRoaXMub2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSh0aGlzLm51bGxPcHRpb24pKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudW5zaGlmdCh0aGlzLl9udWxsT3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0Q29udHJvbGxlci4kaW5qZWN0ID0gWyckZWxlbWVudCcsICckc2NvcGUnLCAnJHEnLCBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLmZhY3RvcnlOYW1lLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gU2VsZWN0Q29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TZWxlY3RDb250cm9sbGVyID0gU2VsZWN0Q29udHJvbGxlcjtcclxuZnVuY3Rpb24gc2VsZWN0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zZWxlY3QuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnc2VsZWN0JyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBvcHRpb25zOiAnPScsXHJcbiAgICAgICAgICAgIGdldE9wdGlvbnM6ICcmJyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICc9JyxcclxuICAgICAgICAgICAgdmFsaWRhdG9yOiAnPScsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnQCcsXHJcbiAgICAgICAgICAgIG5nRGlzYWJsZWQ6ICc9JyxcclxuICAgICAgICAgICAgbnVsbE9wdGlvbjogJ0AnLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFsndWkuc2VsZWN0JywgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5tb2R1bGVOYW1lLCBfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBzZWxlY3QpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBTZWxlY3RDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIHVpLXNlbGVjdFxuICogaHR0cDovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1zZWxlY3RcbiAqIFZlcnNpb246IDAuMTMuMiAtIDIwMTUtMTAtMDlUMTU6MzQ6MjQuMDQwWlxuICogTGljZW5zZTogTUlUXG4gKi9cblxuXG4oZnVuY3Rpb24gKCkgeyBcblwidXNlIHN0cmljdFwiO1xuXG52YXIgS0VZID0ge1xuICAgIFRBQjogOSxcbiAgICBFTlRFUjogMTMsXG4gICAgRVNDOiAyNyxcbiAgICBTUEFDRTogMzIsXG4gICAgTEVGVDogMzcsXG4gICAgVVA6IDM4LFxuICAgIFJJR0hUOiAzOSxcbiAgICBET1dOOiA0MCxcbiAgICBTSElGVDogMTYsXG4gICAgQ1RSTDogMTcsXG4gICAgQUxUOiAxOCxcbiAgICBQQUdFX1VQOiAzMyxcbiAgICBQQUdFX0RPV046IDM0LFxuICAgIEhPTUU6IDM2LFxuICAgIEVORDogMzUsXG4gICAgQkFDS1NQQUNFOiA4LFxuICAgIERFTEVURTogNDYsXG4gICAgQ09NTUFORDogOTEsXG5cbiAgICBNQVA6IHsgOTEgOiBcIkNPTU1BTkRcIiwgOCA6IFwiQkFDS1NQQUNFXCIgLCA5IDogXCJUQUJcIiAsIDEzIDogXCJFTlRFUlwiICwgMTYgOiBcIlNISUZUXCIgLCAxNyA6IFwiQ1RSTFwiICwgMTggOiBcIkFMVFwiICwgMTkgOiBcIlBBVVNFQlJFQUtcIiAsIDIwIDogXCJDQVBTTE9DS1wiICwgMjcgOiBcIkVTQ1wiICwgMzIgOiBcIlNQQUNFXCIgLCAzMyA6IFwiUEFHRV9VUFwiLCAzNCA6IFwiUEFHRV9ET1dOXCIgLCAzNSA6IFwiRU5EXCIgLCAzNiA6IFwiSE9NRVwiICwgMzcgOiBcIkxFRlRcIiAsIDM4IDogXCJVUFwiICwgMzkgOiBcIlJJR0hUXCIgLCA0MCA6IFwiRE9XTlwiICwgNDMgOiBcIitcIiAsIDQ0IDogXCJQUklOVFNDUkVFTlwiICwgNDUgOiBcIklOU0VSVFwiICwgNDYgOiBcIkRFTEVURVwiLCA0OCA6IFwiMFwiICwgNDkgOiBcIjFcIiAsIDUwIDogXCIyXCIgLCA1MSA6IFwiM1wiICwgNTIgOiBcIjRcIiAsIDUzIDogXCI1XCIgLCA1NCA6IFwiNlwiICwgNTUgOiBcIjdcIiAsIDU2IDogXCI4XCIgLCA1NyA6IFwiOVwiICwgNTkgOiBcIjtcIiwgNjEgOiBcIj1cIiAsIDY1IDogXCJBXCIgLCA2NiA6IFwiQlwiICwgNjcgOiBcIkNcIiAsIDY4IDogXCJEXCIgLCA2OSA6IFwiRVwiICwgNzAgOiBcIkZcIiAsIDcxIDogXCJHXCIgLCA3MiA6IFwiSFwiICwgNzMgOiBcIklcIiAsIDc0IDogXCJKXCIgLCA3NSA6IFwiS1wiICwgNzYgOiBcIkxcIiwgNzcgOiBcIk1cIiAsIDc4IDogXCJOXCIgLCA3OSA6IFwiT1wiICwgODAgOiBcIlBcIiAsIDgxIDogXCJRXCIgLCA4MiA6IFwiUlwiICwgODMgOiBcIlNcIiAsIDg0IDogXCJUXCIgLCA4NSA6IFwiVVwiICwgODYgOiBcIlZcIiAsIDg3IDogXCJXXCIgLCA4OCA6IFwiWFwiICwgODkgOiBcIllcIiAsIDkwIDogXCJaXCIsIDk2IDogXCIwXCIgLCA5NyA6IFwiMVwiICwgOTggOiBcIjJcIiAsIDk5IDogXCIzXCIgLCAxMDAgOiBcIjRcIiAsIDEwMSA6IFwiNVwiICwgMTAyIDogXCI2XCIgLCAxMDMgOiBcIjdcIiAsIDEwNCA6IFwiOFwiICwgMTA1IDogXCI5XCIsIDEwNiA6IFwiKlwiICwgMTA3IDogXCIrXCIgLCAxMDkgOiBcIi1cIiAsIDExMCA6IFwiLlwiICwgMTExIDogXCIvXCIsIDExMiA6IFwiRjFcIiAsIDExMyA6IFwiRjJcIiAsIDExNCA6IFwiRjNcIiAsIDExNSA6IFwiRjRcIiAsIDExNiA6IFwiRjVcIiAsIDExNyA6IFwiRjZcIiAsIDExOCA6IFwiRjdcIiAsIDExOSA6IFwiRjhcIiAsIDEyMCA6IFwiRjlcIiAsIDEyMSA6IFwiRjEwXCIgLCAxMjIgOiBcIkYxMVwiICwgMTIzIDogXCJGMTJcIiwgMTQ0IDogXCJOVU1MT0NLXCIgLCAxNDUgOiBcIlNDUk9MTExPQ0tcIiAsIDE4NiA6IFwiO1wiICwgMTg3IDogXCI9XCIgLCAxODggOiBcIixcIiAsIDE4OSA6IFwiLVwiICwgMTkwIDogXCIuXCIgLCAxOTEgOiBcIi9cIiAsIDE5MiA6IFwiYFwiICwgMjE5IDogXCJbXCIgLCAyMjAgOiBcIlxcXFxcIiAsIDIyMSA6IFwiXVwiICwgMjIyIDogXCInXCJcbiAgICB9LFxuXG4gICAgaXNDb250cm9sOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgayA9IGUud2hpY2g7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlIEtFWS5DT01NQU5EOlxuICAgICAgICBjYXNlIEtFWS5TSElGVDpcbiAgICAgICAgY2FzZSBLRVkuQ1RSTDpcbiAgICAgICAgY2FzZSBLRVkuQUxUOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5tZXRhS2V5KSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc0Z1bmN0aW9uS2V5OiBmdW5jdGlvbiAoaykge1xuICAgICAgICBrID0gay53aGljaCA/IGsud2hpY2ggOiBrO1xuICAgICAgICByZXR1cm4gayA+PSAxMTIgJiYgayA8PSAxMjM7XG4gICAgfSxcbiAgICBpc1ZlcnRpY2FsTW92ZW1lbnQ6IGZ1bmN0aW9uIChrKXtcbiAgICAgIHJldHVybiB+W0tFWS5VUCwgS0VZLkRPV05dLmluZGV4T2Yoayk7XG4gICAgfSxcbiAgICBpc0hvcml6b250YWxNb3ZlbWVudDogZnVuY3Rpb24gKGspe1xuICAgICAgcmV0dXJuIH5bS0VZLkxFRlQsS0VZLlJJR0hULEtFWS5CQUNLU1BBQ0UsS0VZLkRFTEVURV0uaW5kZXhPZihrKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIHF1ZXJ5U2VsZWN0b3JBbGwoKSB0byBqcUxpdGUuXG4gKlxuICoganFMaXRlIGZpbmQoKSBpcyBsaW1pdGVkIHRvIGxvb2t1cHMgYnkgdGFnIG5hbWUuXG4gKiBUT0RPIFRoaXMgd2lsbCBjaGFuZ2Ugd2l0aCBmdXR1cmUgdmVyc2lvbnMgb2YgQW5ndWxhckpTLCB0byBiZSByZW1vdmVkIHdoZW4gdGhpcyBoYXBwZW5zXG4gKlxuICogU2VlIGpxTGl0ZS5maW5kIC0gd2h5IG5vdCB1c2UgcXVlcnlTZWxlY3RvckFsbD8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvMzU4NlxuICogU2VlIGZlYXQoanFMaXRlKTogdXNlIHF1ZXJ5U2VsZWN0b3JBbGwgaW5zdGVhZCBvZiBnZXRFbGVtZW50c0J5VGFnTmFtZSBpbiBqcUxpdGUuZmluZCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3B1bGwvMzU5OFxuICovXG5pZiAoYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID09PSB1bmRlZmluZWQpIHtcbiAgYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gYW5ndWxhci5lbGVtZW50KHRoaXNbMF0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB9O1xufVxuXG4vKipcbiAqIEFkZCBjbG9zZXN0KCkgdG8ganFMaXRlLlxuICovXG5pZiAoYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuICAgIHZhciBtYXRjaGVzU2VsZWN0b3IgPSBlbGVtLm1hdGNoZXMgfHwgZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yLmJpbmQoZWxlbSkoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG52YXIgbGF0ZXN0SWQgPSAwO1xuXG52YXIgdWlzID0gYW5ndWxhci5tb2R1bGUoJ3VpLnNlbGVjdCcsIFtdKVxuXG4uY29uc3RhbnQoJ3VpU2VsZWN0Q29uZmlnJywge1xuICB0aGVtZTogJ2Jvb3RzdHJhcCcsXG4gIHNlYXJjaEVuYWJsZWQ6IHRydWUsXG4gIHNvcnRhYmxlOiBmYWxzZSxcbiAgcGxhY2Vob2xkZXI6ICcnLCAvLyBFbXB0eSBieSBkZWZhdWx0LCBsaWtlIEhUTUwgdGFnIDxzZWxlY3Q+XG4gIHJlZnJlc2hEZWxheTogMTAwMCwgLy8gSW4gbWlsbGlzZWNvbmRzXG4gIGNsb3NlT25TZWxlY3Q6IHRydWUsXG4gIGRyb3Bkb3duUG9zaXRpb246ICdhdXRvJyxcbiAgZ2VuZXJhdGVJZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhdGVzdElkKys7XG4gIH0sXG4gIGFwcGVuZFRvQm9keTogZmFsc2Vcbn0pXG5cbi8vIFNlZSBSZW5hbWUgbWluRXJyIGFuZCBtYWtlIGl0IGFjY2Vzc2libGUgZnJvbSBvdXRzaWRlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvaXNzdWVzLzY5MTNcbi5zZXJ2aWNlKCd1aVNlbGVjdE1pbkVycicsIGZ1bmN0aW9uKCkge1xuICB2YXIgbWluRXJyID0gYW5ndWxhci4kJG1pbkVycigndWkuc2VsZWN0Jyk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXJyb3IgPSBtaW5FcnIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKCdcXG5odHRwOi8vZXJyb3JzLmFuZ3VsYXJqcy5vcmcvLionKSwgJycpO1xuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH07XG59KVxuXG4vLyBSZWNyZWF0ZXMgb2xkIGJlaGF2aW9yIG9mIG5nLXRyYW5zY2x1ZGUuIFVzZWQgaW50ZXJuYWxseS5cbi5kaXJlY3RpdmUoJ3Vpc1RyYW5zY2x1ZGVBcHBlbmQnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCwgdHJhbnNjbHVkZSkge1xuICAgICAgICB0cmFuc2NsdWRlKHNjb3BlLCBmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBlbGVtZW50LmFwcGVuZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG59KVxuXG4vKipcbiAqIEhpZ2hsaWdodHMgdGV4dCB0aGF0IG1hdGNoZXMgJHNlbGVjdC5zZWFyY2guXG4gKlxuICogVGFrZW4gZnJvbSBBbmd1bGFyVUkgQm9vdHN0cmFwIFR5cGVhaGVhZFxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL2Jvb3RzdHJhcC9ibG9iLzAuMTAuMC9zcmMvdHlwZWFoZWFkL3R5cGVhaGVhZC5qcyNMMzQwXG4gKi9cbi5maWx0ZXIoJ2hpZ2hsaWdodCcsIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xuICAgIHJldHVybiBxdWVyeVRvRXNjYXBlLnJlcGxhY2UoLyhbLj8qK14kW1xcXVxcXFwoKXt9fC1dKS9nLCAnXFxcXCQxJyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24obWF0Y2hJdGVtLCBxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeSAmJiBtYXRjaEl0ZW0gPyBtYXRjaEl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ2V4cChxdWVyeSksICdnaScpLCAnPHNwYW4gY2xhc3M9XCJ1aS1zZWxlY3QtaGlnaGxpZ2h0XCI+JCY8L3NwYW4+JykgOiBtYXRjaEl0ZW07XG4gIH07XG59KVxuXG4vKipcbiAqIEEgcmVhZC1vbmx5IGVxdWl2YWxlbnQgb2YgalF1ZXJ5J3Mgb2Zmc2V0IGZ1bmN0aW9uOiBodHRwOi8vYXBpLmpxdWVyeS5jb20vb2Zmc2V0L1xuICpcbiAqIFRha2VuIGZyb20gQW5ndWxhclVJIEJvb3RzdHJhcCBQb3NpdGlvbjpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS9ib290c3RyYXAvYmxvYi9tYXN0ZXIvc3JjL3Bvc2l0aW9uL3Bvc2l0aW9uLmpzI0w3MFxuICovXG4uZmFjdG9yeSgndWlzT2Zmc2V0JyxcbiAgWyckZG9jdW1lbnQnLCAnJHdpbmRvdycsXG4gIGZ1bmN0aW9uICgkZG9jdW1lbnQsICR3aW5kb3cpIHtcblxuICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHZhciBib3VuZGluZ0NsaWVudFJlY3QgPSBlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogYm91bmRpbmdDbGllbnRSZWN0LndpZHRoIHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSxcbiAgICAgIGhlaWdodDogYm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCB8fCBlbGVtZW50LnByb3AoJ29mZnNldEhlaWdodCcpLFxuICAgICAgdG9wOiBib3VuZGluZ0NsaWVudFJlY3QudG9wICsgKCR3aW5kb3cucGFnZVlPZmZzZXQgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgbGVmdDogYm91bmRpbmdDbGllbnRSZWN0LmxlZnQgKyAoJHdpbmRvdy5wYWdlWE9mZnNldCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpXG4gICAgfTtcbiAgfTtcbn1dKTtcblxudWlzLmRpcmVjdGl2ZSgndWlTZWxlY3RDaG9pY2VzJyxcbiAgWyd1aVNlbGVjdENvbmZpZycsICd1aXNSZXBlYXRQYXJzZXInLCAndWlTZWxlY3RNaW5FcnInLCAnJGNvbXBpbGUnLFxuICBmdW5jdGlvbih1aVNlbGVjdENvbmZpZywgUmVwZWF0UGFyc2VyLCB1aVNlbGVjdE1pbkVyciwgJGNvbXBpbGUpIHtcblxuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcXVpcmU6ICdedWlTZWxlY3QnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24odEVsZW1lbnQpIHtcbiAgICAgIC8vIEdldHMgdGhlbWUgYXR0cmlidXRlIGZyb20gcGFyZW50ICh1aS1zZWxlY3QpXG4gICAgICB2YXIgdGhlbWUgPSB0RWxlbWVudC5wYXJlbnQoKS5hdHRyKCd0aGVtZScpIHx8IHVpU2VsZWN0Q29uZmlnLnRoZW1lO1xuICAgICAgcmV0dXJuIHRoZW1lICsgJy9jaG9pY2VzLnRwbC5odG1sJztcbiAgICB9LFxuXG4gICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xuXG4gICAgICBpZiAoIXRBdHRycy5yZXBlYXQpIHRocm93IHVpU2VsZWN0TWluRXJyKCdyZXBlYXQnLCBcIkV4cGVjdGVkICdyZXBlYXQnIGV4cHJlc3Npb24uXCIpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbGluayhzY29wZSwgZWxlbWVudCwgYXR0cnMsICRzZWxlY3QsIHRyYW5zY2x1ZGVGbikge1xuXG4gICAgICAgIC8vIHZhciByZXBlYXQgPSBSZXBlYXRQYXJzZXIucGFyc2UoYXR0cnMucmVwZWF0KTtcbiAgICAgICAgdmFyIGdyb3VwQnlFeHAgPSBhdHRycy5ncm91cEJ5O1xuICAgICAgICB2YXIgZ3JvdXBGaWx0ZXJFeHAgPSBhdHRycy5ncm91cEZpbHRlcjtcblxuICAgICAgICAkc2VsZWN0LnBhcnNlUmVwZWF0QXR0cihhdHRycy5yZXBlYXQsIGdyb3VwQnlFeHAsIGdyb3VwRmlsdGVyRXhwKTsgLy9SZXN1bHQgcmVhZHkgYXQgJHNlbGVjdC5wYXJzZXJSZXN1bHRcblxuICAgICAgICAkc2VsZWN0LmRpc2FibGVDaG9pY2VFeHByZXNzaW9uID0gYXR0cnMudWlEaXNhYmxlQ2hvaWNlO1xuICAgICAgICAkc2VsZWN0Lm9uSGlnaGxpZ2h0Q2FsbGJhY2sgPSBhdHRycy5vbkhpZ2hsaWdodDtcblxuICAgICAgICAkc2VsZWN0LmRyb3Bkb3duUG9zaXRpb24gPSBhdHRycy5wb3NpdGlvbiA/IGF0dHJzLnBvc2l0aW9uLnRvTG93ZXJDYXNlKCkgOiB1aVNlbGVjdENvbmZpZy5kcm9wZG93blBvc2l0aW9uO1xuXG4gICAgICAgIGlmKGdyb3VwQnlFeHApIHtcbiAgICAgICAgICB2YXIgZ3JvdXBzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudWktc2VsZWN0LWNob2ljZXMtZ3JvdXAnKTtcbiAgICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCAhPT0gMSkgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ3Jvd3MnLCBcIkV4cGVjdGVkIDEgLnVpLXNlbGVjdC1jaG9pY2VzLWdyb3VwIGJ1dCBnb3QgJ3swfScuXCIsIGdyb3Vwcy5sZW5ndGgpO1xuICAgICAgICAgIGdyb3Vwcy5hdHRyKCduZy1yZXBlYXQnLCBSZXBlYXRQYXJzZXIuZ2V0R3JvdXBOZ1JlcGVhdEV4cHJlc3Npb24oKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hvaWNlcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnVpLXNlbGVjdC1jaG9pY2VzLXJvdycpO1xuICAgICAgICBpZiAoY2hvaWNlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycigncm93cycsIFwiRXhwZWN0ZWQgMSAudWktc2VsZWN0LWNob2ljZXMtcm93IGJ1dCBnb3QgJ3swfScuXCIsIGNob2ljZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob2ljZXMuYXR0cignbmctcmVwZWF0JywgJHNlbGVjdC5wYXJzZXJSZXN1bHQucmVwZWF0RXhwcmVzc2lvbihncm91cEJ5RXhwKSlcbiAgICAgICAgICAgIC5hdHRyKCduZy1pZicsICckc2VsZWN0Lm9wZW4nKSAvL1ByZXZlbnQgdW5uZWNlc3Nhcnkgd2F0Y2hlcyB3aGVuIGRyb3Bkb3duIGlzIGNsb3NlZFxuICAgICAgICAgICAgLmF0dHIoJ25nLWNsaWNrJywgJyRzZWxlY3Quc2VsZWN0KCcgKyAkc2VsZWN0LnBhcnNlclJlc3VsdC5pdGVtTmFtZSArICcsZmFsc2UsJGV2ZW50KScpO1xuXG4gICAgICAgIHZhciByb3dzSW5uZXIgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtY2hvaWNlcy1yb3ctaW5uZXInKTtcbiAgICAgICAgaWYgKHJvd3NJbm5lci5sZW5ndGggIT09IDEpIHRocm93IHVpU2VsZWN0TWluRXJyKCdyb3dzJywgXCJFeHBlY3RlZCAxIC51aS1zZWxlY3QtY2hvaWNlcy1yb3ctaW5uZXIgYnV0IGdvdCAnezB9Jy5cIiwgcm93c0lubmVyLmxlbmd0aCk7XG4gICAgICAgIHJvd3NJbm5lci5hdHRyKCd1aXMtdHJhbnNjbHVkZS1hcHBlbmQnLCAnJyk7IC8vQWRkaW5nIHVpc1RyYW5zY2x1ZGVBcHBlbmQgZGlyZWN0aXZlIHRvIHJvdyBlbGVtZW50IGFmdGVyIGNob2ljZXMgZWxlbWVudCBoYXMgbmdSZXBlYXRcblxuICAgICAgICAkY29tcGlsZShlbGVtZW50LCB0cmFuc2NsdWRlRm4pKHNjb3BlKTsgLy9QYXNzaW5nIGN1cnJlbnQgdHJhbnNjbHVkZUZuIHRvIGJlIGFibGUgdG8gYXBwZW5kIGVsZW1lbnRzIGNvcnJlY3RseSBmcm9tIHVpc1RyYW5zY2x1ZGVBcHBlbmRcblxuICAgICAgICBzY29wZS4kd2F0Y2goJyRzZWxlY3Quc2VhcmNoJywgZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICBpZihuZXdWYWx1ZSAmJiAhJHNlbGVjdC5vcGVuICYmICRzZWxlY3QubXVsdGlwbGUpICRzZWxlY3QuYWN0aXZhdGUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICRzZWxlY3QuYWN0aXZlSW5kZXggPSAkc2VsZWN0LnRhZ2dpbmcuaXNBY3RpdmF0ZWQgPyAtMSA6IDA7XG4gICAgICAgICAgJHNlbGVjdC5yZWZyZXNoKGF0dHJzLnJlZnJlc2gpO1xuICAgICAgICB9KTtcblxuICAgICAgICBhdHRycy4kb2JzZXJ2ZSgncmVmcmVzaERlbGF5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gJGV2YWwoKSBpcyBuZWVkZWQgb3RoZXJ3aXNlIHdlIGdldCBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgbnVtYmVyXG4gICAgICAgICAgdmFyIHJlZnJlc2hEZWxheSA9IHNjb3BlLiRldmFsKGF0dHJzLnJlZnJlc2hEZWxheSk7XG4gICAgICAgICAgJHNlbGVjdC5yZWZyZXNoRGVsYXkgPSByZWZyZXNoRGVsYXkgIT09IHVuZGVmaW5lZCA/IHJlZnJlc2hEZWxheSA6IHVpU2VsZWN0Q29uZmlnLnJlZnJlc2hEZWxheTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyoqXG4gKiBDb250YWlucyB1aS1zZWxlY3QgXCJpbnRlbGxpZ2VuY2VcIi5cbiAqXG4gKiBUaGUgZ29hbCBpcyB0byBsaW1pdCBkZXBlbmRlbmN5IG9uIHRoZSBET00gd2hlbmV2ZXIgcG9zc2libGUgYW5kXG4gKiBwdXQgYXMgbXVjaCBsb2dpYyBpbiB0aGUgY29udHJvbGxlciAoaW5zdGVhZCBvZiB0aGUgbGluayBmdW5jdGlvbnMpIGFzIHBvc3NpYmxlIHNvIGl0IGNhbiBiZSBlYXNpbHkgdGVzdGVkLlxuICovXG51aXMuY29udHJvbGxlcigndWlTZWxlY3RDdHJsJyxcbiAgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJHRpbWVvdXQnLCAnJGZpbHRlcicsICd1aXNSZXBlYXRQYXJzZXInLCAndWlTZWxlY3RNaW5FcnInLCAndWlTZWxlY3RDb25maWcnLCAnJHBhcnNlJyxcbiAgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJHRpbWVvdXQsICRmaWx0ZXIsIFJlcGVhdFBhcnNlciwgdWlTZWxlY3RNaW5FcnIsIHVpU2VsZWN0Q29uZmlnLCAkcGFyc2UpIHtcblxuICB2YXIgY3RybCA9IHRoaXM7XG5cbiAgdmFyIEVNUFRZX1NFQVJDSCA9ICcnO1xuXG4gIGN0cmwucGxhY2Vob2xkZXIgPSB1aVNlbGVjdENvbmZpZy5wbGFjZWhvbGRlcjtcbiAgY3RybC5zZWFyY2hFbmFibGVkID0gdWlTZWxlY3RDb25maWcuc2VhcmNoRW5hYmxlZDtcbiAgY3RybC5zb3J0YWJsZSA9IHVpU2VsZWN0Q29uZmlnLnNvcnRhYmxlO1xuICBjdHJsLnJlZnJlc2hEZWxheSA9IHVpU2VsZWN0Q29uZmlnLnJlZnJlc2hEZWxheTtcblxuICBjdHJsLnJlbW92ZVNlbGVjdGVkID0gZmFsc2U7IC8vSWYgc2VsZWN0ZWQgaXRlbShzKSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyb3Bkb3duIGxpc3RcbiAgY3RybC5jbG9zZU9uU2VsZWN0ID0gdHJ1ZTsgLy9Jbml0aWFsaXplZCBpbnNpZGUgdWlTZWxlY3QgZGlyZWN0aXZlIGxpbmsgZnVuY3Rpb25cbiAgY3RybC5zZWFyY2ggPSBFTVBUWV9TRUFSQ0g7XG5cbiAgY3RybC5hY3RpdmVJbmRleCA9IDA7IC8vRHJvcGRvd24gb2YgY2hvaWNlc1xuICBjdHJsLml0ZW1zID0gW107IC8vQWxsIGF2YWlsYWJsZSBjaG9pY2VzXG5cbiAgY3RybC5vcGVuID0gZmFsc2U7XG4gIGN0cmwuZm9jdXMgPSBmYWxzZTtcbiAgY3RybC5kaXNhYmxlZCA9IGZhbHNlO1xuICBjdHJsLnNlbGVjdGVkID0gdW5kZWZpbmVkO1xuXG4gIGN0cmwuZHJvcGRvd25Qb3NpdGlvbiA9ICdhdXRvJztcblxuICBjdHJsLmZvY3Vzc2VyID0gdW5kZWZpbmVkOyAvL1JlZmVyZW5jZSB0byBpbnB1dCBlbGVtZW50IHVzZWQgdG8gaGFuZGxlIGZvY3VzIGV2ZW50c1xuICBjdHJsLnJlc2V0U2VhcmNoSW5wdXQgPSB0cnVlO1xuICBjdHJsLm11bHRpcGxlID0gdW5kZWZpbmVkOyAvLyBJbml0aWFsaXplZCBpbnNpZGUgdWlTZWxlY3QgZGlyZWN0aXZlIGxpbmsgZnVuY3Rpb25cbiAgY3RybC5kaXNhYmxlQ2hvaWNlRXhwcmVzc2lvbiA9IHVuZGVmaW5lZDsgLy8gSW5pdGlhbGl6ZWQgaW5zaWRlIHVpU2VsZWN0Q2hvaWNlcyBkaXJlY3RpdmUgbGluayBmdW5jdGlvblxuICBjdHJsLnRhZ2dpbmcgPSB7aXNBY3RpdmF0ZWQ6IGZhbHNlLCBmY3Q6IHVuZGVmaW5lZH07XG4gIGN0cmwudGFnZ2luZ1Rva2VucyA9IHtpc0FjdGl2YXRlZDogZmFsc2UsIHRva2VuczogdW5kZWZpbmVkfTtcbiAgY3RybC5sb2NrQ2hvaWNlRXhwcmVzc2lvbiA9IHVuZGVmaW5lZDsgLy8gSW5pdGlhbGl6ZWQgaW5zaWRlIHVpU2VsZWN0TWF0Y2ggZGlyZWN0aXZlIGxpbmsgZnVuY3Rpb25cbiAgY3RybC5jbGlja1RyaWdnZXJlZFNlbGVjdCA9IGZhbHNlO1xuICBjdHJsLiRmaWx0ZXIgPSAkZmlsdGVyO1xuXG4gIGN0cmwuc2VhcmNoSW5wdXQgPSAkZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dC51aS1zZWxlY3Qtc2VhcmNoJyk7XG4gIGlmIChjdHJsLnNlYXJjaElucHV0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IHVpU2VsZWN0TWluRXJyKCdzZWFyY2hJbnB1dCcsIFwiRXhwZWN0ZWQgMSBpbnB1dC51aS1zZWxlY3Qtc2VhcmNoIGJ1dCBnb3QgJ3swfScuXCIsIGN0cmwuc2VhcmNoSW5wdXQubGVuZ3RoKTtcbiAgfVxuICBcbiAgY3RybC5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFuZ3VsYXIuaXNVbmRlZmluZWQoY3RybC5zZWxlY3RlZCkgfHwgY3RybC5zZWxlY3RlZCA9PT0gbnVsbCB8fCBjdHJsLnNlbGVjdGVkID09PSAnJztcbiAgfTtcblxuICAvLyBNb3N0IG9mIHRoZSB0aW1lIHRoZSB1c2VyIGRvZXMgbm90IHdhbnQgdG8gZW1wdHkgdGhlIHNlYXJjaCBpbnB1dCB3aGVuIGluIHR5cGVhaGVhZCBtb2RlXG4gIGZ1bmN0aW9uIF9yZXNldFNlYXJjaElucHV0KCkge1xuICAgIGlmIChjdHJsLnJlc2V0U2VhcmNoSW5wdXQgfHwgKGN0cmwucmVzZXRTZWFyY2hJbnB1dCA9PT0gdW5kZWZpbmVkICYmIHVpU2VsZWN0Q29uZmlnLnJlc2V0U2VhcmNoSW5wdXQpKSB7XG4gICAgICBjdHJsLnNlYXJjaCA9IEVNUFRZX1NFQVJDSDtcbiAgICAgIC8vcmVzZXQgYWN0aXZlSW5kZXhcbiAgICAgIGlmIChjdHJsLnNlbGVjdGVkICYmIGN0cmwuaXRlbXMubGVuZ3RoICYmICFjdHJsLm11bHRpcGxlKSB7XG4gICAgICAgIGN0cmwuYWN0aXZlSW5kZXggPSBjdHJsLml0ZW1zLmluZGV4T2YoY3RybC5zZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgICBmdW5jdGlvbiBfZ3JvdXBzRmlsdGVyKGdyb3VwcywgZ3JvdXBOYW1lcykge1xuICAgICAgdmFyIGksIGosIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgZ3JvdXBOYW1lcy5sZW5ndGggO2krKyl7XG4gICAgICAgIGZvcihqID0gMDsgaiA8IGdyb3Vwcy5sZW5ndGggO2orKyl7XG4gICAgICAgICAgaWYoZ3JvdXBzW2pdLm5hbWUgPT0gW2dyb3VwTmFtZXNbaV1dKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdyb3Vwc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAvLyBXaGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB1aS1zZWxlY3QsIGRpc3BsYXlzIHRoZSBkcm9wZG93biBsaXN0XG4gIGN0cmwuYWN0aXZhdGUgPSBmdW5jdGlvbihpbml0U2VhcmNoVmFsdWUsIGF2b2lkUmVzZXQpIHtcbiAgICBpZiAoIWN0cmwuZGlzYWJsZWQgICYmICFjdHJsLm9wZW4pIHtcbiAgICAgIGlmKCFhdm9pZFJlc2V0KSBfcmVzZXRTZWFyY2hJbnB1dCgpO1xuXG4gICAgICAkc2NvcGUuJGJyb2FkY2FzdCgndWlzOmFjdGl2YXRlJyk7XG5cbiAgICAgIGN0cmwub3BlbiA9IHRydWU7XG5cbiAgICAgIGN0cmwuYWN0aXZlSW5kZXggPSBjdHJsLmFjdGl2ZUluZGV4ID49IGN0cmwuaXRlbXMubGVuZ3RoID8gMCA6IGN0cmwuYWN0aXZlSW5kZXg7XG5cbiAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBpbmRleCBpcyBzZXQgdG8gemVybyBmb3IgdGFnZ2luZyB2YXJpYW50c1xuICAgICAgLy8gdGhhdCB3aGVyZSBmaXJzdCBvcHRpb24gaXMgYXV0by1zZWxlY3RlZFxuICAgICAgaWYgKCBjdHJsLmFjdGl2ZUluZGV4ID09PSAtMSAmJiBjdHJsLnRhZ2dpbmdMYWJlbCAhPT0gZmFsc2UgKSB7XG4gICAgICAgIGN0cmwuYWN0aXZlSW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBHaXZlIGl0IHRpbWUgdG8gYXBwZWFyIGJlZm9yZSBmb2N1c1xuICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN0cmwuc2VhcmNoID0gaW5pdFNlYXJjaFZhbHVlIHx8IGN0cmwuc2VhcmNoO1xuICAgICAgICBjdHJsLnNlYXJjaElucHV0WzBdLmZvY3VzKCk7XG4gICAgICAgIGlmKCFjdHJsLnRhZ2dpbmcuaXNBY3RpdmF0ZWQgJiYgY3RybC5pdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgX2Vuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGN0cmwuZmluZEdyb3VwQnlOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBjdHJsLmdyb3VwcyAmJiBjdHJsLmdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIHJldHVybiBncm91cC5uYW1lID09PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9O1xuXG4gIGN0cmwucGFyc2VSZXBlYXRBdHRyID0gZnVuY3Rpb24ocmVwZWF0QXR0ciwgZ3JvdXBCeUV4cCwgZ3JvdXBGaWx0ZXJFeHApIHtcbiAgICBmdW5jdGlvbiB1cGRhdGVHcm91cHMoaXRlbXMpIHtcbiAgICAgIHZhciBncm91cEZuID0gJHNjb3BlLiRldmFsKGdyb3VwQnlFeHApO1xuICAgICAgY3RybC5ncm91cHMgPSBbXTtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgZ3JvdXBOYW1lID0gYW5ndWxhci5pc0Z1bmN0aW9uKGdyb3VwRm4pID8gZ3JvdXBGbihpdGVtKSA6IGl0ZW1bZ3JvdXBGbl07XG4gICAgICAgIHZhciBncm91cCA9IGN0cmwuZmluZEdyb3VwQnlOYW1lKGdyb3VwTmFtZSk7XG4gICAgICAgIGlmKGdyb3VwKSB7XG4gICAgICAgICAgZ3JvdXAuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHJsLmdyb3Vwcy5wdXNoKHtuYW1lOiBncm91cE5hbWUsIGl0ZW1zOiBbaXRlbV19KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZihncm91cEZpbHRlckV4cCl7XG4gICAgICAgIHZhciBncm91cEZpbHRlckZuID0gJHNjb3BlLiRldmFsKGdyb3VwRmlsdGVyRXhwKTtcbiAgICAgICAgaWYoIGFuZ3VsYXIuaXNGdW5jdGlvbihncm91cEZpbHRlckZuKSl7XG4gICAgICAgICAgY3RybC5ncm91cHMgPSBncm91cEZpbHRlckZuKGN0cmwuZ3JvdXBzKTtcbiAgICAgICAgfSBlbHNlIGlmKGFuZ3VsYXIuaXNBcnJheShncm91cEZpbHRlckZuKSl7XG4gICAgICAgICAgY3RybC5ncm91cHMgPSBfZ3JvdXBzRmlsdGVyKGN0cmwuZ3JvdXBzLCBncm91cEZpbHRlckZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3RybC5pdGVtcyA9IFtdO1xuICAgICAgY3RybC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuICAgICAgICBjdHJsLml0ZW1zID0gY3RybC5pdGVtcy5jb25jYXQoZ3JvdXAuaXRlbXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UGxhaW5JdGVtcyhpdGVtcykge1xuICAgICAgY3RybC5pdGVtcyA9IGl0ZW1zO1xuICAgIH1cblxuICAgIGN0cmwuc2V0SXRlbXNGbiA9IGdyb3VwQnlFeHAgPyB1cGRhdGVHcm91cHMgOiBzZXRQbGFpbkl0ZW1zO1xuXG4gICAgY3RybC5wYXJzZXJSZXN1bHQgPSBSZXBlYXRQYXJzZXIucGFyc2UocmVwZWF0QXR0cik7XG5cbiAgICBjdHJsLmlzR3JvdXBlZCA9ICEhZ3JvdXBCeUV4cDtcbiAgICBjdHJsLml0ZW1Qcm9wZXJ0eSA9IGN0cmwucGFyc2VyUmVzdWx0Lml0ZW1OYW1lO1xuXG4gICAgLy9JZiBjb2xsZWN0aW9uIGlzIGFuIE9iamVjdCwgY29udmVydCBpdCB0byBBcnJheVxuXG4gICAgdmFyIG9yaWdpbmFsU291cmNlID0gY3RybC5wYXJzZXJSZXN1bHQuc291cmNlO1xuICAgIFxuICAgIC8vV2hlbiBhbiBvYmplY3QgaXMgdXNlZCBhcyBzb3VyY2UsIHdlIGJldHRlciBjcmVhdGUgYW4gYXJyYXkgYW5kIHVzZSBpdCBhcyAnc291cmNlJ1xuICAgIHZhciBjcmVhdGVBcnJheUZyb21PYmplY3QgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIG9yaWdTcmMgPSBvcmlnaW5hbFNvdXJjZSgkc2NvcGUpO1xuICAgICAgJHNjb3BlLiR1aXNTb3VyY2UgPSBPYmplY3Qua2V5cyhvcmlnU3JjKS5tYXAoZnVuY3Rpb24odil7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0W2N0cmwucGFyc2VyUmVzdWx0LmtleU5hbWVdID0gdjtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gb3JpZ1NyY1t2XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY3RybC5wYXJzZXJSZXN1bHQua2V5TmFtZSl7IC8vIENoZWNrIGZvciAoa2V5LHZhbHVlKSBzeW50YXhcbiAgICAgIGNyZWF0ZUFycmF5RnJvbU9iamVjdCgpO1xuICAgICAgY3RybC5wYXJzZXJSZXN1bHQuc291cmNlID0gJHBhcnNlKCckdWlzU291cmNlJyArIGN0cmwucGFyc2VyUmVzdWx0LmZpbHRlcnMpO1xuICAgICAgJHNjb3BlLiR3YXRjaChvcmlnaW5hbFNvdXJjZSwgZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpe1xuICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIGNyZWF0ZUFycmF5RnJvbU9iamVjdCgpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY3RybC5yZWZyZXNoSXRlbXMgPSBmdW5jdGlvbiAoZGF0YSl7XG4gICAgICBkYXRhID0gZGF0YSB8fCBjdHJsLnBhcnNlclJlc3VsdC5zb3VyY2UoJHNjb3BlKTtcbiAgICAgIHZhciBzZWxlY3RlZEl0ZW1zID0gY3RybC5zZWxlY3RlZDtcbiAgICAgIC8vVE9ETyBzaG91bGQgaW1wbGVtZW50IGZvciBzaW5nbGUgbW9kZSByZW1vdmVTZWxlY3RlZFxuICAgICAgaWYgKGN0cmwuaXNFbXB0eSgpIHx8IChhbmd1bGFyLmlzQXJyYXkoc2VsZWN0ZWRJdGVtcykgJiYgIXNlbGVjdGVkSXRlbXMubGVuZ3RoKSB8fCAhY3RybC5yZW1vdmVTZWxlY3RlZCkge1xuICAgICAgICBjdHJsLnNldEl0ZW1zRm4oZGF0YSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihpKSB7cmV0dXJuIHNlbGVjdGVkSXRlbXMgJiYgc2VsZWN0ZWRJdGVtcy5pbmRleE9mKGkpIDwgMDt9KTtcbiAgICAgICAgICBjdHJsLnNldEl0ZW1zRm4oZmlsdGVyZWRJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdHJsLmRyb3Bkb3duUG9zaXRpb24gPT09ICdhdXRvJyB8fCBjdHJsLmRyb3Bkb3duUG9zaXRpb24gPT09ICd1cCcpe1xuICAgICAgICAkc2NvcGUuY2FsY3VsYXRlRHJvcGRvd25Qb3MoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvYmxvYi92MS4yLjE1L3NyYy9uZy9kaXJlY3RpdmUvbmdSZXBlYXQuanMjTDI1OVxuICAgICRzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKGN0cmwucGFyc2VyUmVzdWx0LnNvdXJjZSwgZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgIGlmIChpdGVtcyA9PT0gdW5kZWZpbmVkIHx8IGl0ZW1zID09PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllcyB1bmRlZmluZWQgb3IgbnVsbCA9PiByZXNldCB0aGUgY29sbGVjdGlvblxuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IGl0ZW1zIGNhbiBiZSB1bmRlZmluZWQgaWYgdGhlIHVzZXIgZGlkIG5vdCBpbml0aWFsaXplZCB0aGUgY29sbGVjdGlvbiBvbiB0aGUgc2NvcGVcbiAgICAgICAgLy8gaS5lICRzY29wZS5hZGRyZXNzZXMgPSBbXSBpcyBtaXNzaW5nXG4gICAgICAgIGN0cmwuaXRlbXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghYW5ndWxhci5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgIHRocm93IHVpU2VsZWN0TWluRXJyKCdpdGVtcycsIFwiRXhwZWN0ZWQgYW4gYXJyYXkgYnV0IGdvdCAnezB9Jy5cIiwgaXRlbXMpOyAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL1JlbW92ZSBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zIChleDogd2hpbGUgc2VhcmNoaW5nKVxuICAgICAgICAgIC8vVE9ETyBTaG91bGQgYWRkIGEgdGVzdFxuICAgICAgICAgIGN0cmwucmVmcmVzaEl0ZW1zKGl0ZW1zKTtcbiAgICAgICAgICBjdHJsLm5nTW9kZWwuJG1vZGVsVmFsdWUgPSBudWxsOyAvL0ZvcmNlIHNjb3BlIG1vZGVsIHZhbHVlIGFuZCBuZ01vZGVsIHZhbHVlIHRvIGJlIG91dCBvZiBzeW5jIHRvIHJlLXJ1biBmb3JtYXR0ZXJzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gIHZhciBfcmVmcmVzaERlbGF5UHJvbWlzZTtcblxuICAvKipcbiAgICogVHlwZWFoZWFkIG1vZGU6IGxldHMgdGhlIHVzZXIgcmVmcmVzaCB0aGUgY29sbGVjdGlvbiB1c2luZyBoaXMgb3duIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBTZWUgRXhwb3NlICRzZWxlY3Quc2VhcmNoIGZvciBleHRlcm5hbCAvIHJlbW90ZSBmaWx0ZXJpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktc2VsZWN0L3B1bGwvMzFcbiAgICovXG4gIGN0cmwucmVmcmVzaCA9IGZ1bmN0aW9uKHJlZnJlc2hBdHRyKSB7XG4gICAgaWYgKHJlZnJlc2hBdHRyICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgLy8gRGVib3VuY2VcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS9ib290c3RyYXAvYmxvYi8wLjEwLjAvc3JjL3R5cGVhaGVhZC90eXBlYWhlYWQuanMjTDE1NVxuICAgICAgLy8gRllJIEFuZ3VsYXJTdHJhcCB0eXBlYWhlYWQgZG9lcyBub3QgaGF2ZSBkZWJvdW5jaW5nOiBodHRwczovL2dpdGh1Yi5jb20vbWdjcmVhL2FuZ3VsYXItc3RyYXAvYmxvYi92Mi4wLjAtcmMuNC9zcmMvdHlwZWFoZWFkL3R5cGVhaGVhZC5qcyNMMTc3XG4gICAgICBpZiAoX3JlZnJlc2hEZWxheVByb21pc2UpIHtcbiAgICAgICAgJHRpbWVvdXQuY2FuY2VsKF9yZWZyZXNoRGVsYXlQcm9taXNlKTtcbiAgICAgIH1cbiAgICAgIF9yZWZyZXNoRGVsYXlQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS4kZXZhbChyZWZyZXNoQXR0cik7XG4gICAgICB9LCBjdHJsLnJlZnJlc2hEZWxheSk7XG4gICAgfVxuICB9O1xuXG4gIGN0cmwuaXNBY3RpdmUgPSBmdW5jdGlvbihpdGVtU2NvcGUpIHtcbiAgICBpZiAoICFjdHJsLm9wZW4gKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpdGVtSW5kZXggPSBjdHJsLml0ZW1zLmluZGV4T2YoaXRlbVNjb3BlW2N0cmwuaXRlbVByb3BlcnR5XSk7XG4gICAgdmFyIGlzQWN0aXZlID0gIGl0ZW1JbmRleCA9PT0gY3RybC5hY3RpdmVJbmRleDtcblxuICAgIGlmICggIWlzQWN0aXZlIHx8ICggaXRlbUluZGV4IDwgMCAmJiBjdHJsLnRhZ2dpbmdMYWJlbCAhPT0gZmFsc2UgKSB8fCggaXRlbUluZGV4IDwgMCAmJiBjdHJsLnRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UpICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0FjdGl2ZSAmJiAhYW5ndWxhci5pc1VuZGVmaW5lZChjdHJsLm9uSGlnaGxpZ2h0Q2FsbGJhY2spKSB7XG4gICAgICBpdGVtU2NvcGUuJGV2YWwoY3RybC5vbkhpZ2hsaWdodENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNBY3RpdmU7XG4gIH07XG5cbiAgY3RybC5pc0Rpc2FibGVkID0gZnVuY3Rpb24oaXRlbVNjb3BlKSB7XG5cbiAgICBpZiAoIWN0cmwub3BlbikgcmV0dXJuO1xuXG4gICAgdmFyIGl0ZW1JbmRleCA9IGN0cmwuaXRlbXMuaW5kZXhPZihpdGVtU2NvcGVbY3RybC5pdGVtUHJvcGVydHldKTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIHZhciBpdGVtO1xuXG4gICAgaWYgKGl0ZW1JbmRleCA+PSAwICYmICFhbmd1bGFyLmlzVW5kZWZpbmVkKGN0cmwuZGlzYWJsZUNob2ljZUV4cHJlc3Npb24pKSB7XG4gICAgICBpdGVtID0gY3RybC5pdGVtc1tpdGVtSW5kZXhdO1xuICAgICAgaXNEaXNhYmxlZCA9ICEhKGl0ZW1TY29wZS4kZXZhbChjdHJsLmRpc2FibGVDaG9pY2VFeHByZXNzaW9uKSk7IC8vIGZvcmNlIHRoZSBib29sZWFuIHZhbHVlXG4gICAgICBpdGVtLl91aVNlbGVjdENob2ljZURpc2FibGVkID0gaXNEaXNhYmxlZDsgLy8gc3RvcmUgdGhpcyBmb3IgbGF0ZXIgcmVmZXJlbmNlXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGlzYWJsZWQ7XG4gIH07XG5cblxuICAvLyBXaGVuIHRoZSB1c2VyIHNlbGVjdHMgYW4gaXRlbSB3aXRoIEVOVEVSIG9yIGNsaWNrcyB0aGUgZHJvcGRvd25cbiAgY3RybC5zZWxlY3QgPSBmdW5jdGlvbihpdGVtLCBza2lwRm9jdXNzZXIsICRldmVudCkge1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgIWl0ZW0uX3VpU2VsZWN0Q2hvaWNlRGlzYWJsZWQpIHtcblxuICAgICAgaWYgKCAhIGN0cmwuaXRlbXMgJiYgISBjdHJsLnNlYXJjaCApIHJldHVybjtcblxuICAgICAgaWYgKCFpdGVtIHx8ICFpdGVtLl91aVNlbGVjdENob2ljZURpc2FibGVkKSB7XG4gICAgICAgIGlmKGN0cmwudGFnZ2luZy5pc0FjdGl2YXRlZCkge1xuICAgICAgICAgIC8vIGlmIHRhZ2dpbmdMYWJlbCBpcyBkaXNhYmxlZCwgd2UgcHVsbCBmcm9tIGN0cmwuc2VhcmNoIHZhbFxuICAgICAgICAgIGlmICggY3RybC50YWdnaW5nTGFiZWwgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgaWYgKCBjdHJsLmFjdGl2ZUluZGV4IDwgMCApIHtcbiAgICAgICAgICAgICAgaXRlbSA9IGN0cmwudGFnZ2luZy5mY3QgIT09IHVuZGVmaW5lZCA/IGN0cmwudGFnZ2luZy5mY3QoY3RybC5zZWFyY2gpIDogY3RybC5zZWFyY2g7XG4gICAgICAgICAgICAgIGlmICghaXRlbSB8fCBhbmd1bGFyLmVxdWFscyggY3RybC5pdGVtc1swXSwgaXRlbSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8ga2V5Ym9hcmQgbmF2IGhhcHBlbmVkIGZpcnN0LCB1c2VyIHNlbGVjdGVkIGZyb20gZHJvcGRvd25cbiAgICAgICAgICAgICAgaXRlbSA9IGN0cmwuaXRlbXNbY3RybC5hY3RpdmVJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRhZ2dpbmcgYWx3YXlzIG9wZXJhdGVzIGF0IGluZGV4IHplcm8sIHRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UgcHVzaGVzXG4gICAgICAgICAgICAvLyB0aGUgY3RybC5zZWFyY2ggdmFsdWUgd2l0aG91dCBoYXZpbmcgaXQgaW5qZWN0ZWRcbiAgICAgICAgICAgIGlmICggY3RybC5hY3RpdmVJbmRleCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgLy8gY3RybC50YWdnaW5nIHB1c2hlcyBpdGVtcyB0byBjdHJsLml0ZW1zLCBzbyB3ZSBvbmx5IGhhdmUgZW1wdHkgdmFsXG4gICAgICAgICAgICAgIC8vIGZvciBgaXRlbWAgaWYgaXQgaXMgYSBkZXRlY3RlZCBkdXBsaWNhdGVcbiAgICAgICAgICAgICAgaWYgKCBpdGVtID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBpdGVtIG9uIHRoZSBmbHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIG9uZTtcbiAgICAgICAgICAgICAgLy8gdXNlIHRhZ2dpbmcgZnVuY3Rpb24gaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgICAgICAgaWYgKCBjdHJsLnRhZ2dpbmcuZmN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBjdHJsLnRhZ2dpbmcuZmN0KGN0cmwuc2VhcmNoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICAgICAgICAgICAgLy8gaWYgaXRlbSB0eXBlIGlzICdzdHJpbmcnLCBhcHBseSB0aGUgdGFnZ2luZyBsYWJlbFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJpbSB0aGUgdHJhaWxpbmcgc3BhY2VcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKGN0cmwudGFnZ2luZ0xhYmVsLCcnKS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2VhcmNoIGN0cmwuc2VsZWN0ZWQgZm9yIGR1cGVzIHBvdGVudGlhbGx5IGNhdXNlZCBieSB0YWdnaW5nIGFuZCByZXR1cm4gZWFybHkgaWYgZm91bmRcbiAgICAgICAgICBpZiAoIGN0cmwuc2VsZWN0ZWQgJiYgYW5ndWxhci5pc0FycmF5KGN0cmwuc2VsZWN0ZWQpICYmIGN0cmwuc2VsZWN0ZWQuZmlsdGVyKCBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7IHJldHVybiBhbmd1bGFyLmVxdWFscyhzZWxlY3Rpb24sIGl0ZW0pOyB9KS5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgY3RybC5jbG9zZShza2lwRm9jdXNzZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCd1aXM6c2VsZWN0JywgaXRlbSk7XG5cbiAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xuICAgICAgICBsb2NhbHNbY3RybC5wYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gaXRlbTtcblxuICAgICAgICAkdGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIGN0cmwub25TZWxlY3RDYWxsYmFjaygkc2NvcGUsIHtcbiAgICAgICAgICAgICRpdGVtOiBpdGVtLFxuICAgICAgICAgICAgJG1vZGVsOiBjdHJsLnBhcnNlclJlc3VsdC5tb2RlbE1hcHBlcigkc2NvcGUsIGxvY2FscylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGN0cmwuY2xvc2VPblNlbGVjdCkge1xuICAgICAgICAgIGN0cmwuY2xvc2Uoc2tpcEZvY3Vzc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGV2ZW50ICYmICRldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgY3RybC5jbGlja1RyaWdnZXJlZFNlbGVjdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2xvc2VzIHRoZSBkcm9wZG93blxuICBjdHJsLmNsb3NlID0gZnVuY3Rpb24oc2tpcEZvY3Vzc2VyKSB7XG4gICAgaWYgKCFjdHJsLm9wZW4pIHJldHVybjtcbiAgICBpZiAoY3RybC5uZ01vZGVsICYmIGN0cmwubmdNb2RlbC4kc2V0VG91Y2hlZCkgY3RybC5uZ01vZGVsLiRzZXRUb3VjaGVkKCk7XG4gICAgX3Jlc2V0U2VhcmNoSW5wdXQoKTtcbiAgICBjdHJsLm9wZW4gPSBmYWxzZTtcblxuICAgICRzY29wZS4kYnJvYWRjYXN0KCd1aXM6Y2xvc2UnLCBza2lwRm9jdXNzZXIpO1xuXG4gIH07XG5cbiAgY3RybC5zZXRGb2N1cyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKCFjdHJsLmZvY3VzKSBjdHJsLmZvY3VzSW5wdXRbMF0uZm9jdXMoKTtcbiAgfTtcblxuICBjdHJsLmNsZWFyID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgY3RybC5zZWxlY3QodW5kZWZpbmVkKTtcbiAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBjdHJsLmZvY3Vzc2VyWzBdLmZvY3VzKCk7XG4gICAgfSwgMCwgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFRvZ2dsZSBkcm9wZG93blxuICBjdHJsLnRvZ2dsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoY3RybC5vcGVuKSB7XG4gICAgICBjdHJsLmNsb3NlKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHJsLmFjdGl2YXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIGN0cmwuaXNMb2NrZWQgPSBmdW5jdGlvbihpdGVtU2NvcGUsIGl0ZW1JbmRleCkge1xuICAgICAgdmFyIGlzTG9ja2VkLCBpdGVtID0gY3RybC5zZWxlY3RlZFtpdGVtSW5kZXhdO1xuXG4gICAgICBpZiAoaXRlbSAmJiAhYW5ndWxhci5pc1VuZGVmaW5lZChjdHJsLmxvY2tDaG9pY2VFeHByZXNzaW9uKSkge1xuICAgICAgICAgIGlzTG9ja2VkID0gISEoaXRlbVNjb3BlLiRldmFsKGN0cmwubG9ja0Nob2ljZUV4cHJlc3Npb24pKTsgLy8gZm9yY2UgdGhlIGJvb2xlYW4gdmFsdWVcbiAgICAgICAgICBpdGVtLl91aVNlbGVjdENob2ljZUxvY2tlZCA9IGlzTG9ja2VkOyAvLyBzdG9yZSB0aGlzIGZvciBsYXRlciByZWZlcmVuY2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzTG9ja2VkO1xuICB9O1xuXG4gIHZhciBzaXplV2F0Y2ggPSBudWxsO1xuICBjdHJsLnNpemVTZWFyY2hJbnB1dCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGlucHV0ID0gY3RybC5zZWFyY2hJbnB1dFswXSxcbiAgICAgICAgY29udGFpbmVyID0gY3RybC5zZWFyY2hJbnB1dC5wYXJlbnQoKS5wYXJlbnQoKVswXSxcbiAgICAgICAgY2FsY3VsYXRlQ29udGFpbmVyV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNvbnRhaW5lciB3aWR0aCBvbmx5IGlmIHRoZSBzZWFyY2ggaW5wdXQgaXMgdmlzaWJsZVxuICAgICAgICAgIHJldHVybiBjb250YWluZXIuY2xpZW50V2lkdGggKiAhIWlucHV0Lm9mZnNldFBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlSWZWaXNpYmxlID0gZnVuY3Rpb24oY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVyV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlucHV0V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGlucHV0Lm9mZnNldExlZnQgLSAxMDtcbiAgICAgICAgICBpZiAoaW5wdXRXaWR0aCA8IDUwKSBpbnB1dFdpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gICAgICAgICAgY3RybC5zZWFyY2hJbnB1dC5jc3MoJ3dpZHRoJywgaW5wdXRXaWR0aCsncHgnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIGN0cmwuc2VhcmNoSW5wdXQuY3NzKCd3aWR0aCcsICcxMHB4Jyk7XG4gICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7IC8vR2l2ZSB0YWdzIHRpbWUgdG8gcmVuZGVyIGNvcnJlY3RseVxuICAgICAgaWYgKHNpemVXYXRjaCA9PT0gbnVsbCAmJiAhdXBkYXRlSWZWaXNpYmxlKGNhbGN1bGF0ZUNvbnRhaW5lcldpZHRoKCkpKSB7XG4gICAgICAgIHNpemVXYXRjaCA9ICRzY29wZS4kd2F0Y2goY2FsY3VsYXRlQ29udGFpbmVyV2lkdGgsIGZ1bmN0aW9uKGNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZUlmVmlzaWJsZShjb250YWluZXJXaWR0aCkpIHtcbiAgICAgICAgICAgIHNpemVXYXRjaCgpO1xuICAgICAgICAgICAgc2l6ZVdhdGNoID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9oYW5kbGVEcm9wRG93blNlbGVjdGlvbihrZXkpIHtcbiAgICB2YXIgcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBLRVkuRE9XTjpcbiAgICAgICAgaWYgKCFjdHJsLm9wZW4gJiYgY3RybC5tdWx0aXBsZSkgY3RybC5hY3RpdmF0ZShmYWxzZSwgdHJ1ZSk7IC8vSW4gY2FzZSBpdHMgdGhlIHNlYXJjaCBpbnB1dCBpbiAnbXVsdGlwbGUnIG1vZGVcbiAgICAgICAgZWxzZSBpZiAoY3RybC5hY3RpdmVJbmRleCA8IGN0cmwuaXRlbXMubGVuZ3RoIC0gMSkgeyBjdHJsLmFjdGl2ZUluZGV4Kys7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWS5VUDpcbiAgICAgICAgaWYgKCFjdHJsLm9wZW4gJiYgY3RybC5tdWx0aXBsZSkgY3RybC5hY3RpdmF0ZShmYWxzZSwgdHJ1ZSk7IC8vSW4gY2FzZSBpdHMgdGhlIHNlYXJjaCBpbnB1dCBpbiAnbXVsdGlwbGUnIG1vZGVcbiAgICAgICAgZWxzZSBpZiAoY3RybC5hY3RpdmVJbmRleCA+IDAgfHwgKGN0cmwuc2VhcmNoLmxlbmd0aCA9PT0gMCAmJiBjdHJsLnRhZ2dpbmcuaXNBY3RpdmF0ZWQgJiYgY3RybC5hY3RpdmVJbmRleCA+IC0xKSkgeyBjdHJsLmFjdGl2ZUluZGV4LS07IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWS5UQUI6XG4gICAgICAgIGlmICghY3RybC5tdWx0aXBsZSB8fCBjdHJsLm9wZW4pIGN0cmwuc2VsZWN0KGN0cmwuaXRlbXNbY3RybC5hY3RpdmVJbmRleF0sIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZLkVOVEVSOlxuICAgICAgICBpZihjdHJsLm9wZW4gJiYgKGN0cmwudGFnZ2luZy5pc0FjdGl2YXRlZCB8fCBjdHJsLmFjdGl2ZUluZGV4ID49IDApKXtcbiAgICAgICAgICBjdHJsLnNlbGVjdChjdHJsLml0ZW1zW2N0cmwuYWN0aXZlSW5kZXhdKTsgLy8gTWFrZSBzdXJlIGF0IGxlYXN0IG9uZSBkcm9wZG93biBpdGVtIGlzIGhpZ2hsaWdodGVkIGJlZm9yZSBhZGRpbmcgaWYgbm90IGluIHRhZ2dpbmcgbW9kZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0cmwuYWN0aXZhdGUoZmFsc2UsIHRydWUpOyAvL0luIGNhc2UgaXRzIHRoZSBzZWFyY2ggaW5wdXQgaW4gJ211bHRpcGxlJyBtb2RlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWS5FU0M6XG4gICAgICAgIGN0cmwuY2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgfVxuXG4gIC8vIEJpbmQgdG8ga2V5Ym9hcmQgc2hvcnRjdXRzXG4gIGN0cmwuc2VhcmNoSW5wdXQub24oJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICB2YXIga2V5ID0gZS53aGljaDtcblxuICAgIC8vIGlmKH5bS0VZLkVTQyxLRVkuVEFCXS5pbmRleE9mKGtleSkpe1xuICAgIC8vICAgLy9UT0RPOiBTRUdVUk8/XG4gICAgLy8gICBjdHJsLmNsb3NlKCk7XG4gICAgLy8gfVxuXG4gICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHRhZ2dlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoY3RybC5pdGVtcy5sZW5ndGggPiAwIHx8IGN0cmwudGFnZ2luZy5pc0FjdGl2YXRlZCkge1xuICAgICAgICBfaGFuZGxlRHJvcERvd25TZWxlY3Rpb24oa2V5KTtcbiAgICAgICAgaWYgKCBjdHJsLnRhZ2dpbmdUb2tlbnMuaXNBY3RpdmF0ZWQgKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLnRhZ2dpbmdUb2tlbnMudG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIGN0cmwudGFnZ2luZ1Rva2Vucy50b2tlbnNbaV0gPT09IEtFWS5NQVBbZS5rZXlDb2RlXSApIHtcbiAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgbmV3IHZhbHVlIHRvIHB1c2ggdmlhIHRhZ2dpbmdcbiAgICAgICAgICAgICAgaWYgKCBjdHJsLnNlYXJjaC5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIHRhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCB0YWdnZWQgKSB7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY3RybC5zZWFyY2hJbnB1dC50cmlnZ2VySGFuZGxlcigndGFnZ2VkJyk7XG4gICAgICAgICAgICAgIHZhciBuZXdJdGVtID0gY3RybC5zZWFyY2gucmVwbGFjZShLRVkuTUFQW2Uua2V5Q29kZV0sJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKCBjdHJsLnRhZ2dpbmcuZmN0ICkge1xuICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBjdHJsLnRhZ2dpbmcuZmN0KCBuZXdJdGVtICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5ld0l0ZW0pIGN0cmwuc2VsZWN0KG5ld0l0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIGlmKEtFWS5pc1ZlcnRpY2FsTW92ZW1lbnQoa2V5KSAmJiBjdHJsLml0ZW1zLmxlbmd0aCA+IDApe1xuICAgICAgX2Vuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSBLRVkuRU5URVIgfHwga2V5ID09PSBLRVkuRVNDKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBJZiB0YWdnaW5nIHRyeSB0byBzcGxpdCBieSB0b2tlbnMgYW5kIGFkZCBpdGVtc1xuICBjdHJsLnNlYXJjaElucHV0Lm9uKCdwYXN0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRhdGEgPSBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwICYmIGN0cmwudGFnZ2luZ1Rva2Vucy5pc0FjdGl2YXRlZCAmJiBjdHJsLnRhZ2dpbmcuZmN0KSB7XG4gICAgICB2YXIgaXRlbXMgPSBkYXRhLnNwbGl0KGN0cmwudGFnZ2luZ1Rva2Vucy50b2tlbnNbMF0pOyAvLyBzcGxpdCBieSBmaXJzdCB0b2tlbiBvbmx5XG4gICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgdmFyIG5ld0l0ZW0gPSBjdHJsLnRhZ2dpbmcuZmN0KGl0ZW0pO1xuICAgICAgICAgIGlmIChuZXdJdGVtKSB7XG4gICAgICAgICAgICBjdHJsLnNlbGVjdChuZXdJdGVtLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjdHJsLnNlYXJjaElucHV0Lm9uKCd0YWdnZWQnLCBmdW5jdGlvbigpIHtcbiAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXNldFNlYXJjaElucHV0KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIvYmxvYi8zLjQuNi9zZWxlY3QyLmpzI0wxNDMxXG4gIGZ1bmN0aW9uIF9lbnN1cmVIaWdobGlnaHRWaXNpYmxlKCkge1xuICAgIHZhciBjb250YWluZXIgPSAkZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudWktc2VsZWN0LWNob2ljZXMtY29udGVudCcpO1xuICAgIHZhciBjaG9pY2VzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtY2hvaWNlcy1yb3cnKTtcbiAgICBpZiAoY2hvaWNlcy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycignY2hvaWNlcycsIFwiRXhwZWN0ZWQgbXVsdGlwbGUgLnVpLXNlbGVjdC1jaG9pY2VzLXJvdyBidXQgZ290ICd7MH0nLlwiLCBjaG9pY2VzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKGN0cmwuYWN0aXZlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhpZ2hsaWdodGVkID0gY2hvaWNlc1tjdHJsLmFjdGl2ZUluZGV4XTtcbiAgICB2YXIgcG9zWSA9IGhpZ2hsaWdodGVkLm9mZnNldFRvcCArIGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCAtIGNvbnRhaW5lclswXS5zY3JvbGxUb3A7XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBpZiAocG9zWSA+IGhlaWdodCkge1xuICAgICAgY29udGFpbmVyWzBdLnNjcm9sbFRvcCArPSBwb3NZIC0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zWSA8IGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCkge1xuICAgICAgaWYgKGN0cmwuaXNHcm91cGVkICYmIGN0cmwuYWN0aXZlSW5kZXggPT09IDApXG4gICAgICAgIGNvbnRhaW5lclswXS5zY3JvbGxUb3AgPSAwOyAvL1RvIG1ha2UgZ3JvdXAgaGVhZGVyIHZpc2libGUgd2hlbiBnb2luZyBhbGwgdGhlIHdheSB1cFxuICAgICAgZWxzZVxuICAgICAgICBjb250YWluZXJbMF0uc2Nyb2xsVG9wIC09IGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCAtIHBvc1k7XG4gICAgfVxuICB9XG5cbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICBjdHJsLnNlYXJjaElucHV0Lm9mZigna2V5dXAga2V5ZG93biB0YWdnZWQgYmx1ciBwYXN0ZScpO1xuICB9KTtcblxufV0pO1xuXG51aXMuZGlyZWN0aXZlKCd1aVNlbGVjdCcsXG4gIFsnJGRvY3VtZW50JywgJ3VpU2VsZWN0Q29uZmlnJywgJ3VpU2VsZWN0TWluRXJyJywgJ3Vpc09mZnNldCcsICckY29tcGlsZScsICckcGFyc2UnLCAnJHRpbWVvdXQnLFxuICBmdW5jdGlvbigkZG9jdW1lbnQsIHVpU2VsZWN0Q29uZmlnLCB1aVNlbGVjdE1pbkVyciwgdWlzT2Zmc2V0LCAkY29tcGlsZSwgJHBhcnNlLCAkdGltZW91dCkge1xuXG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcbiAgICAgIHZhciB0aGVtZSA9IHRBdHRycy50aGVtZSB8fCB1aVNlbGVjdENvbmZpZy50aGVtZTtcbiAgICAgIHJldHVybiB0aGVtZSArIChhbmd1bGFyLmlzRGVmaW5lZCh0QXR0cnMubXVsdGlwbGUpID8gJy9zZWxlY3QtbXVsdGlwbGUudHBsLmh0bWwnIDogJy9zZWxlY3QudHBsLmh0bWwnKTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXF1aXJlOiBbJ3VpU2VsZWN0JywgJ15uZ01vZGVsJ10sXG4gICAgc2NvcGU6IHRydWUsXG5cbiAgICBjb250cm9sbGVyOiAndWlTZWxlY3RDdHJsJyxcbiAgICBjb250cm9sbGVyQXM6ICckc2VsZWN0JyxcbiAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG5cbiAgICAgIC8vTXVsdGlwbGUgb3IgU2luZ2xlIGRlcGVuZGluZyBpZiBtdWx0aXBsZSBhdHRyaWJ1dGUgcHJlc2VuY2VcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCh0QXR0cnMubXVsdGlwbGUpKVxuICAgICAgICB0RWxlbWVudC5hcHBlbmQoJzx1aS1zZWxlY3QtbXVsdGlwbGUvPicpLnJlbW92ZUF0dHIoJ211bHRpcGxlJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRFbGVtZW50LmFwcGVuZCgnPHVpLXNlbGVjdC1zaW5nbGUvPicpO1xuXG4gICAgICBpZiAodEF0dHJzLmlucHV0SWQpXG4gICAgICAgIHRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LnVpLXNlbGVjdC1zZWFyY2gnKVswXS5pZCA9IHRBdHRycy5pbnB1dElkO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscywgdHJhbnNjbHVkZUZuKSB7XG5cbiAgICAgICAgdmFyICRzZWxlY3QgPSBjdHJsc1swXTtcbiAgICAgICAgdmFyIG5nTW9kZWwgPSBjdHJsc1sxXTtcblxuICAgICAgICAkc2VsZWN0LmdlbmVyYXRlZElkID0gdWlTZWxlY3RDb25maWcuZ2VuZXJhdGVJZCgpO1xuICAgICAgICAkc2VsZWN0LmJhc2VUaXRsZSA9IGF0dHJzLnRpdGxlIHx8ICdTZWxlY3QgYm94JztcbiAgICAgICAgJHNlbGVjdC5mb2N1c3NlclRpdGxlID0gJHNlbGVjdC5iYXNlVGl0bGUgKyAnIGZvY3VzJztcbiAgICAgICAgJHNlbGVjdC5mb2N1c3NlcklkID0gJ2ZvY3Vzc2VyLScgKyAkc2VsZWN0LmdlbmVyYXRlZElkO1xuXG4gICAgICAgICRzZWxlY3QuY2xvc2VPblNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5jbG9zZU9uU2VsZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuICRwYXJzZShhdHRycy5jbG9zZU9uU2VsZWN0KSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdWlTZWxlY3RDb25maWcuY2xvc2VPblNlbGVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcblxuICAgICAgICAkc2VsZWN0Lm9uU2VsZWN0Q2FsbGJhY2sgPSAkcGFyc2UoYXR0cnMub25TZWxlY3QpO1xuICAgICAgICAkc2VsZWN0Lm9uUmVtb3ZlQ2FsbGJhY2sgPSAkcGFyc2UoYXR0cnMub25SZW1vdmUpO1xuXG4gICAgICAgIC8vTGltaXQgdGhlIG51bWJlciBvZiBzZWxlY3Rpb25zIGFsbG93ZWRcbiAgICAgICAgJHNlbGVjdC5saW1pdCA9IChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5saW1pdCkpID8gcGFyc2VJbnQoYXR0cnMubGltaXQsIDEwKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvL1NldCByZWZlcmVuY2UgdG8gbmdNb2RlbCBmcm9tIHVpU2VsZWN0Q3RybFxuICAgICAgICAkc2VsZWN0Lm5nTW9kZWwgPSBuZ01vZGVsO1xuXG4gICAgICAgICRzZWxlY3QuY2hvaWNlR3JvdXBlZCA9IGZ1bmN0aW9uKGdyb3VwKXtcbiAgICAgICAgICByZXR1cm4gJHNlbGVjdC5pc0dyb3VwZWQgJiYgZ3JvdXAgJiYgZ3JvdXAubmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZihhdHRycy50YWJpbmRleCl7XG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ3RhYmluZGV4JywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICRzZWxlY3QuZm9jdXNJbnB1dC5hdHRyKCd0YWJpbmRleCcsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnc2VhcmNoRW5hYmxlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaEVuYWJsZWQgPSBzY29wZS4kZXZhbChhdHRycy5zZWFyY2hFbmFibGVkKTtcbiAgICAgICAgICAgICRzZWxlY3Quc2VhcmNoRW5hYmxlZCA9IHNlYXJjaEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IHNlYXJjaEVuYWJsZWQgOiB1aVNlbGVjdENvbmZpZy5zZWFyY2hFbmFibGVkO1xuICAgICAgICB9KTtcblxuICAgICAgICBzY29wZS4kd2F0Y2goJ3NvcnRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc29ydGFibGUgPSBzY29wZS4kZXZhbChhdHRycy5zb3J0YWJsZSk7XG4gICAgICAgICAgICAkc2VsZWN0LnNvcnRhYmxlID0gc29ydGFibGUgIT09IHVuZGVmaW5lZCA/IHNvcnRhYmxlIDogdWlTZWxlY3RDb25maWcuc29ydGFibGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdkaXNhYmxlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gdXNlICRldmFsKCkgKHRoYW5rcyB0byBuZy1kaXNhYmxlZCkgc2luY2Ugd2UgYWxyZWFkeSBnZXQgYSBib29sZWFuIGluc3RlYWQgb2YgYSBzdHJpbmdcbiAgICAgICAgICAkc2VsZWN0LmRpc2FibGVkID0gYXR0cnMuZGlzYWJsZWQgIT09IHVuZGVmaW5lZCA/IGF0dHJzLmRpc2FibGVkIDogZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdyZXNldFNlYXJjaElucHV0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gJGV2YWwoKSBpcyBuZWVkZWQgb3RoZXJ3aXNlIHdlIGdldCBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgYm9vbGVhblxuICAgICAgICAgIHZhciByZXNldFNlYXJjaElucHV0ID0gc2NvcGUuJGV2YWwoYXR0cnMucmVzZXRTZWFyY2hJbnB1dCk7XG4gICAgICAgICAgJHNlbGVjdC5yZXNldFNlYXJjaElucHV0ID0gcmVzZXRTZWFyY2hJbnB1dCAhPT0gdW5kZWZpbmVkID8gcmVzZXRTZWFyY2hJbnB1dCA6IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCd0YWdnaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoYXR0cnMudGFnZ2luZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vICRldmFsKCkgaXMgbmVlZGVkIG90aGVyd2lzZSB3ZSBnZXQgYSBzdHJpbmcgaW5zdGVhZCBvZiBhIGJvb2xlYW5cbiAgICAgICAgICAgIHZhciB0YWdnaW5nRXZhbCA9IHNjb3BlLiRldmFsKGF0dHJzLnRhZ2dpbmcpO1xuICAgICAgICAgICAgJHNlbGVjdC50YWdnaW5nID0ge2lzQWN0aXZhdGVkOiB0cnVlLCBmY3Q6IHRhZ2dpbmdFdmFsICE9PSB0cnVlID8gdGFnZ2luZ0V2YWwgOiB1bmRlZmluZWR9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgJHNlbGVjdC50YWdnaW5nID0ge2lzQWN0aXZhdGVkOiBmYWxzZSwgZmN0OiB1bmRlZmluZWR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ3RhZ2dpbmdMYWJlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGF0dHJzLnRhZ2dpbmcgIT09IHVuZGVmaW5lZCApXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gY2hlY2sgZXZhbCBmb3IgRkFMU0UsIGluIHRoaXMgY2FzZSwgd2UgZGlzYWJsZSB0aGUgbGFiZWxzXG4gICAgICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGFnZ2luZ1xuICAgICAgICAgICAgaWYgKCBhdHRycy50YWdnaW5nTGFiZWwgPT09ICdmYWxzZScgKSB7XG4gICAgICAgICAgICAgICRzZWxlY3QudGFnZ2luZ0xhYmVsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICRzZWxlY3QudGFnZ2luZ0xhYmVsID0gYXR0cnMudGFnZ2luZ0xhYmVsICE9PSB1bmRlZmluZWQgPyBhdHRycy50YWdnaW5nTGFiZWwgOiAnKG5ldyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ3RhZ2dpbmdUb2tlbnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoYXR0cnMudGFnZ2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gYXR0cnMudGFnZ2luZ1Rva2VucyAhPT0gdW5kZWZpbmVkID8gYXR0cnMudGFnZ2luZ1Rva2Vucy5zcGxpdCgnfCcpIDogWycsJywnRU5URVInXTtcbiAgICAgICAgICAgICRzZWxlY3QudGFnZ2luZ1Rva2VucyA9IHtpc0FjdGl2YXRlZDogdHJ1ZSwgdG9rZW5zOiB0b2tlbnMgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vQXV0b21hdGljYWxseSBnZXRzIGZvY3VzIHdoZW4gbG9hZGVkXG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5hdXRvZm9jdXMpKXtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgJHNlbGVjdC5zZXRGb2N1cygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9HZXRzIGZvY3VzIGJhc2VkIG9uIHNjb3BlIGV2ZW50IG5hbWUgKGUuZy4gZm9jdXMtb249J1NvbWVFdmVudE5hbWUnKVxuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZm9jdXNPbikpe1xuICAgICAgICAgIHNjb3BlLiRvbihhdHRycy5mb2N1c09uLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkc2VsZWN0LnNldEZvY3VzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoISRzZWxlY3Qub3BlbikgcmV0dXJuOyAvL1NraXAgaXQgaWYgZHJvcGRvd24gaXMgY2xvc2VcblxuICAgICAgICAgIHZhciBjb250YWlucyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHdpbmRvdy5qUXVlcnkpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggMy42IGRvZXMgbm90IHN1cHBvcnQgZWxlbWVudC5jb250YWlucygpXG4gICAgICAgICAgICAvLyBTZWUgTm9kZS5jb250YWlucyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5jb250YWluc1xuICAgICAgICAgICAgY29udGFpbnMgPSB3aW5kb3cualF1ZXJ5LmNvbnRhaW5zKGVsZW1lbnRbMF0sIGUudGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbnMgPSBlbGVtZW50WzBdLmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zICYmICEkc2VsZWN0LmNsaWNrVHJpZ2dlcmVkU2VsZWN0KSB7XG4gICAgICAgICAgICAvL1dpbGwgbG9zZSBmb2N1cyBvbmx5IHdpdGggY2VydGFpbiB0YXJnZXRzXG4gICAgICAgICAgICB2YXIgZm9jdXNhYmxlQ29udHJvbHMgPSBbJ2lucHV0JywnYnV0dG9uJywndGV4dGFyZWEnXTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRDb250cm9sbGVyID0gYW5ndWxhci5lbGVtZW50KGUudGFyZ2V0KS5jb250cm9sbGVyKCd1aVNlbGVjdCcpOyAvL1RvIGNoZWNrIGlmIHRhcmdldCBpcyBvdGhlciB1aS1zZWxlY3RcbiAgICAgICAgICAgIHZhciBza2lwRm9jdXNzZXIgPSB0YXJnZXRDb250cm9sbGVyICYmIHRhcmdldENvbnRyb2xsZXIgIT09ICRzZWxlY3Q7IC8vVG8gY2hlY2sgaWYgdGFyZ2V0IGlzIG90aGVyIHVpLXNlbGVjdFxuICAgICAgICAgICAgaWYgKCFza2lwRm9jdXNzZXIpIHNraXBGb2N1c3NlciA9ICB+Zm9jdXNhYmxlQ29udHJvbHMuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpOyAvL0NoZWNrIGlmIHRhcmdldCBpcyBpbnB1dCwgYnV0dG9uIG9yIHRleHRhcmVhXG4gICAgICAgICAgICAkc2VsZWN0LmNsb3NlKHNraXBGb2N1c3Nlcik7XG4gICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRzZWxlY3QuY2xpY2tUcmlnZ2VyZWRTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlZSBDbGljayBldmVyeXdoZXJlIGJ1dCBoZXJlIGV2ZW50IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI5MzEzNjlcbiAgICAgICAgJGRvY3VtZW50Lm9uKCdjbGljaycsIG9uRG9jdW1lbnRDbGljayk7XG5cbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRkb2N1bWVudC5vZmYoJ2NsaWNrJywgb25Eb2N1bWVudENsaWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTW92ZSB0cmFuc2NsdWRlZCBlbGVtZW50cyB0byB0aGVpciBjb3JyZWN0IHBvc2l0aW9uIGluIG1haW4gdGVtcGxhdGVcbiAgICAgICAgdHJhbnNjbHVkZUZuKHNjb3BlLCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgIC8vIFNlZSBUcmFuc2NsdWRlIGluIEFuZ3VsYXJKUyBodHRwOi8vYmxvZy5vbWthcnBhdGlsLmNvbS8yMDEyLzExL3RyYW5zY2x1ZGUtaW4tYW5ndWxhcmpzLmh0bWxcblxuICAgICAgICAgIC8vIE9uZSBkYXkganFMaXRlIHdpbGwgYmUgcmVwbGFjZWQgYnkgalF1ZXJ5IGFuZCB3ZSB3aWxsIGJlIGFibGUgdG8gd3JpdGU6XG4gICAgICAgICAgLy8gdmFyIHRyYW5zY2x1ZGVkRWxlbWVudCA9IGNsb25lLmZpbHRlcignLm15LWNsYXNzJylcbiAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgaGFja2lzaCBET00gZWxlbWVudDpcbiAgICAgICAgICB2YXIgdHJhbnNjbHVkZWQgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+JykuYXBwZW5kKGNsb25lKTtcblxuICAgICAgICAgIHZhciB0cmFuc2NsdWRlZE1hdGNoID0gdHJhbnNjbHVkZWQucXVlcnlTZWxlY3RvckFsbCgnLnVpLXNlbGVjdC1tYXRjaCcpO1xuICAgICAgICAgIHRyYW5zY2x1ZGVkTWF0Y2gucmVtb3ZlQXR0cigndWktc2VsZWN0LW1hdGNoJyk7IC8vVG8gYXZvaWQgbG9vcCBpbiBjYXNlIGRpcmVjdGl2ZSBhcyBhdHRyXG4gICAgICAgICAgdHJhbnNjbHVkZWRNYXRjaC5yZW1vdmVBdHRyKCdkYXRhLXVpLXNlbGVjdC1tYXRjaCcpOyAvLyBQcm9wZXJseSBoYW5kbGUgSFRNTDUgZGF0YS1hdHRyaWJ1dGVzXG4gICAgICAgICAgaWYgKHRyYW5zY2x1ZGVkTWF0Y2gubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycigndHJhbnNjbHVkZWQnLCBcIkV4cGVjdGVkIDEgLnVpLXNlbGVjdC1tYXRjaCBidXQgZ290ICd7MH0nLlwiLCB0cmFuc2NsdWRlZE1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnVpLXNlbGVjdC1tYXRjaCcpLnJlcGxhY2VXaXRoKHRyYW5zY2x1ZGVkTWF0Y2gpO1xuXG4gICAgICAgICAgdmFyIHRyYW5zY2x1ZGVkQ2hvaWNlcyA9IHRyYW5zY2x1ZGVkLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtY2hvaWNlcycpO1xuICAgICAgICAgIHRyYW5zY2x1ZGVkQ2hvaWNlcy5yZW1vdmVBdHRyKCd1aS1zZWxlY3QtY2hvaWNlcycpOyAvL1RvIGF2b2lkIGxvb3AgaW4gY2FzZSBkaXJlY3RpdmUgYXMgYXR0clxuICAgICAgICAgIHRyYW5zY2x1ZGVkQ2hvaWNlcy5yZW1vdmVBdHRyKCdkYXRhLXVpLXNlbGVjdC1jaG9pY2VzJyk7IC8vIFByb3Blcmx5IGhhbmRsZSBIVE1MNSBkYXRhLWF0dHJpYnV0ZXNcbiAgICAgICAgICBpZiAodHJhbnNjbHVkZWRDaG9pY2VzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ3RyYW5zY2x1ZGVkJywgXCJFeHBlY3RlZCAxIC51aS1zZWxlY3QtY2hvaWNlcyBidXQgZ290ICd7MH0nLlwiLCB0cmFuc2NsdWRlZENob2ljZXMubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudWktc2VsZWN0LWNob2ljZXMnKS5yZXBsYWNlV2l0aCh0cmFuc2NsdWRlZENob2ljZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdXBwb3J0IGZvciBhcHBlbmRpbmcgdGhlIHNlbGVjdCBmaWVsZCB0byB0aGUgYm9keSB3aGVuIGl0cyBvcGVuXG4gICAgICAgIHZhciBhcHBlbmRUb0JvZHkgPSBzY29wZS4kZXZhbChhdHRycy5hcHBlbmRUb0JvZHkpO1xuICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5ICE9PSB1bmRlZmluZWQgPyBhcHBlbmRUb0JvZHkgOiB1aVNlbGVjdENvbmZpZy5hcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICBzY29wZS4kd2F0Y2goJyRzZWxlY3Qub3BlbicsIGZ1bmN0aW9uKGlzT3Blbikge1xuICAgICAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgICBwb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNldERyb3Bkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBNb3ZlIHRoZSBkcm9wZG93biBiYWNrIHRvIGl0cyBvcmlnaW5hbCBsb2NhdGlvbiB3aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWQuIE90aGVyd2lzZVxuICAgICAgICAgIC8vIGl0IG1pZ2h0IHN0aWNrIGFyb3VuZCB3aGVuIHRoZSB1c2VyIHJvdXRlcyBhd2F5IG9yIHRoZSBzZWxlY3QgZmllbGQgaXMgb3RoZXJ3aXNlIHJlbW92ZWRcbiAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXNldERyb3Bkb3duKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIb2xkIG9uIHRvIGEgcmVmZXJlbmNlIHRvIHRoZSAudWktc2VsZWN0LWNvbnRhaW5lciBlbGVtZW50IGZvciBhcHBlbmRUb0JvZHkgc3VwcG9ydFxuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBudWxsLFxuICAgICAgICAgICAgb3JpZ2luYWxXaWR0aCA9ICcnO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uRHJvcGRvd24oKSB7XG4gICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHVpc09mZnNldChlbGVtZW50KTtcblxuICAgICAgICAgIC8vIENsb25lIHRoZSBlbGVtZW50IGludG8gYSBwbGFjZWhvbGRlciBlbGVtZW50IHRvIHRha2UgaXRzIG9yaWdpbmFsIHBsYWNlIGluIHRoZSBET01cbiAgICAgICAgICBwbGFjZWhvbGRlciA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInVpLXNlbGVjdC1wbGFjZWhvbGRlclwiPjwvZGl2PicpO1xuICAgICAgICAgIHBsYWNlaG9sZGVyWzBdLnN0eWxlLndpZHRoID0gb2Zmc2V0LndpZHRoICsgJ3B4JztcbiAgICAgICAgICBwbGFjZWhvbGRlclswXS5zdHlsZS5oZWlnaHQgPSBvZmZzZXQuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICBlbGVtZW50LmFmdGVyKHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZWxlbWVudCB3aWR0aCBpbmxpbmUgc3R5bGUsIHNvIGl0IGNhbiBiZSByZXN0b3JlZFxuICAgICAgICAgIC8vIHdoZW4gdGhlIGRyb3Bkb3duIGlzIGNsb3NlZFxuICAgICAgICAgIG9yaWdpbmFsV2lkdGggPSBlbGVtZW50WzBdLnN0eWxlLndpZHRoO1xuXG4gICAgICAgICAgLy8gTm93IG1vdmUgdGhlIGFjdHVhbCBkcm9wZG93biBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGJvZHlcbiAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZChlbGVtZW50KTtcblxuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUubGVmdCA9IG9mZnNldC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICBlbGVtZW50WzBdLnN0eWxlLnRvcCA9IG9mZnNldC50b3AgKyAncHgnO1xuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUud2lkdGggPSBvZmZzZXQud2lkdGggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzZXREcm9wZG93bigpIHtcbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkcm9wZG93biBoYXMgbm90IGFjdHVhbGx5IGJlZW4gZGlzcGxheSB5ZXQsIHNvIHRoZXJlJ3Mgbm90aGluZyB0byByZXNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1vdmUgdGhlIGRyb3Bkb3duIGVsZW1lbnQgYmFjayB0byBpdHMgb3JpZ2luYWwgbG9jYXRpb24gaW4gdGhlIERPTVxuICAgICAgICAgIHBsYWNlaG9sZGVyLnJlcGxhY2VXaXRoKGVsZW1lbnQpO1xuICAgICAgICAgIHBsYWNlaG9sZGVyID0gbnVsbDtcblxuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgICBlbGVtZW50WzBdLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgICBlbGVtZW50WzBdLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSG9sZCBvbiB0byBhIHJlZmVyZW5jZSB0byB0aGUgLnVpLXNlbGVjdC1kcm9wZG93biBlbGVtZW50IGZvciBkaXJlY3Rpb24gc3VwcG9ydC5cbiAgICAgICAgdmFyIGRyb3Bkb3duID0gbnVsbCxcbiAgICAgICAgICAgIGRpcmVjdGlvblVwQ2xhc3NOYW1lID0gJ2RpcmVjdGlvbi11cCc7XG5cbiAgICAgICAgLy8gU3VwcG9ydCBjaGFuZ2luZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBkcm9wZG93biBpZiB0aGVyZSBpc24ndCBlbm91Z2ggc3BhY2UgdG8gcmVuZGVyIGl0LlxuICAgICAgICBzY29wZS4kd2F0Y2goJyRzZWxlY3Qub3BlbicsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKCRzZWxlY3QuZHJvcGRvd25Qb3NpdGlvbiA9PT0gJ2F1dG8nIHx8ICRzZWxlY3QuZHJvcGRvd25Qb3NpdGlvbiA9PT0gJ3VwJyl7XG4gICAgICAgICAgICBzY29wZS5jYWxjdWxhdGVEcm9wZG93blBvcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2V0RHJvcGRvd25Qb3NVcCA9IGZ1bmN0aW9uKG9mZnNldCwgb2Zmc2V0RHJvcGRvd24pe1xuXG4gICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IHVpc09mZnNldChlbGVtZW50KTtcbiAgICAgICAgICBvZmZzZXREcm9wZG93biA9IG9mZnNldERyb3Bkb3duIHx8IHVpc09mZnNldChkcm9wZG93bik7XG5cbiAgICAgICAgICBkcm9wZG93blswXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUudG9wID0gKG9mZnNldERyb3Bkb3duLmhlaWdodCAqIC0xKSArICdweCc7XG4gICAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhkaXJlY3Rpb25VcENsYXNzTmFtZSk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2V0RHJvcGRvd25Qb3NEb3duID0gZnVuY3Rpb24ob2Zmc2V0LCBvZmZzZXREcm9wZG93bil7XG5cbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRpcmVjdGlvblVwQ2xhc3NOYW1lKTtcblxuICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCB1aXNPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgICAgb2Zmc2V0RHJvcGRvd24gPSBvZmZzZXREcm9wZG93biB8fCB1aXNPZmZzZXQoZHJvcGRvd24pO1xuXG4gICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgICBkcm9wZG93blswXS5zdHlsZS50b3AgPSAnJztcblxuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLmNhbGN1bGF0ZURyb3Bkb3duUG9zID0gZnVuY3Rpb24oKXtcblxuICAgICAgICAgIGlmICgkc2VsZWN0Lm9wZW4pIHtcbiAgICAgICAgICAgIGRyb3Bkb3duID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtZHJvcGRvd24nKTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93bi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIaWRlIHRoZSBkcm9wZG93biBzbyB0aGVyZSBpcyBubyBmbGlja2VyIHVudGlsICR0aW1lb3V0IGlzIGRvbmUgZXhlY3V0aW5nLlxuICAgICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgICAgIC8vIERlbGF5IHBvc2l0aW9uaW5nIHRoZSBkcm9wZG93biB1bnRpbCBhbGwgY2hvaWNlcyBoYXZlIGJlZW4gYWRkZWQgc28gaXRzIGhlaWdodCBpcyBjb3JyZWN0LlxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICBpZiAoJHNlbGVjdC5kcm9wZG93blBvc2l0aW9uID09PSAndXAnKXtcbiAgICAgICAgICAgICAgICAgIC8vR28gVVBcbiAgICAgICAgICAgICAgICAgIHNldERyb3Bkb3duUG9zVXAob2Zmc2V0LCBvZmZzZXREcm9wZG93bik7XG5cbiAgICAgICAgICAgICAgfWVsc2V7IC8vQVVUT1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhkaXJlY3Rpb25VcENsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdWlzT2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXREcm9wZG93biA9IHVpc09mZnNldChkcm9wZG93bik7XG5cbiAgICAgICAgICAgICAgICAvL2h0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNDIzMDcjYzRcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgJGRvY3VtZW50WzBdLmJvZHkuc2Nyb2xsVG9wOyAvL1RvIG1ha2UgaXQgY3Jvc3MgYnJvd3NlciAoYmxpbmssIHdlYmtpdCwgSUUsIEZpcmVmb3gpLlxuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGRyb3Bkb3duIG5lZWRzIHRvIGJlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldC50b3AgKyBvZmZzZXQuaGVpZ2h0ICsgb2Zmc2V0RHJvcGRvd24uaGVpZ2h0ID4gc2Nyb2xsVG9wICsgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIC8vR28gVVBcbiAgICAgICAgICAgICAgICAgIHNldERyb3Bkb3duUG9zVXAob2Zmc2V0LCBvZmZzZXREcm9wZG93bik7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAvL0dvIERPV05cbiAgICAgICAgICAgICAgICAgIHNldERyb3Bkb3duUG9zRG93bihvZmZzZXQsIG9mZnNldERyb3Bkb3duKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIERpc3BsYXkgdGhlIGRyb3Bkb3duIG9uY2UgaXQgaGFzIGJlZW4gcG9zaXRpb25lZC5cbiAgICAgICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZHJvcGRvd24gPT09IG51bGwgfHwgZHJvcGRvd24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBkcm9wZG93bi5cbiAgICAgICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUudG9wID0gJyc7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoZGlyZWN0aW9uVXBDbGFzc05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufV0pO1xuXG51aXMuZGlyZWN0aXZlKCd1aVNlbGVjdE1hdGNoJywgWyd1aVNlbGVjdENvbmZpZycsIGZ1bmN0aW9uKHVpU2VsZWN0Q29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVxdWlyZTogJ151aVNlbGVjdCcsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbih0RWxlbWVudCkge1xuICAgICAgLy8gR2V0cyB0aGVtZSBhdHRyaWJ1dGUgZnJvbSBwYXJlbnQgKHVpLXNlbGVjdClcbiAgICAgIHZhciB0aGVtZSA9IHRFbGVtZW50LnBhcmVudCgpLmF0dHIoJ3RoZW1lJykgfHwgdWlTZWxlY3RDb25maWcudGhlbWU7XG4gICAgICB2YXIgbXVsdGkgPSB0RWxlbWVudC5wYXJlbnQoKS5hdHRyKCdtdWx0aXBsZScpO1xuICAgICAgcmV0dXJuIHRoZW1lICsgKG11bHRpID8gJy9tYXRjaC1tdWx0aXBsZS50cGwuaHRtbCcgOiAnL21hdGNoLnRwbC5odG1sJyk7XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsICRzZWxlY3QpIHtcbiAgICAgICRzZWxlY3QubG9ja0Nob2ljZUV4cHJlc3Npb24gPSBhdHRycy51aUxvY2tDaG9pY2U7XG4gICAgICBhdHRycy4kb2JzZXJ2ZSgncGxhY2Vob2xkZXInLCBmdW5jdGlvbihwbGFjZWhvbGRlcikge1xuICAgICAgICAkc2VsZWN0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCA/IHBsYWNlaG9sZGVyIDogdWlTZWxlY3RDb25maWcucGxhY2Vob2xkZXI7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gc2V0QWxsb3dDbGVhcihhbGxvdykge1xuICAgICAgICAkc2VsZWN0LmFsbG93Q2xlYXIgPSAoYW5ndWxhci5pc0RlZmluZWQoYWxsb3cpKSA/IChhbGxvdyA9PT0gJycpID8gdHJ1ZSA6IChhbGxvdy50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzLiRvYnNlcnZlKCdhbGxvd0NsZWFyJywgc2V0QWxsb3dDbGVhcik7XG4gICAgICBzZXRBbGxvd0NsZWFyKGF0dHJzLmFsbG93Q2xlYXIpO1xuXG4gICAgICBpZigkc2VsZWN0Lm11bHRpcGxlKXtcbiAgICAgICAgJHNlbGVjdC5zaXplU2VhcmNoSW5wdXQoKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfTtcbn1dKTtcblxudWlzLmRpcmVjdGl2ZSgndWlTZWxlY3RNdWx0aXBsZScsIFsndWlTZWxlY3RNaW5FcnInLCckdGltZW91dCcsIGZ1bmN0aW9uKHVpU2VsZWN0TWluRXJyLCAkdGltZW91dCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcXVpcmU6IFsnXnVpU2VsZWN0JywgJ15uZ01vZGVsJ10sXG5cbiAgICBjb250cm9sbGVyOiBbJyRzY29wZScsJyR0aW1lb3V0JywgZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dCl7XG5cbiAgICAgIHZhciBjdHJsID0gdGhpcyxcbiAgICAgICAgICAkc2VsZWN0ID0gJHNjb3BlLiRzZWxlY3QsXG4gICAgICAgICAgbmdNb2RlbDtcblxuICAgICAgLy9XYWl0IGZvciBsaW5rIGZuIHRvIGluamVjdCBpdCBcbiAgICAgICRzY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCl7IG5nTW9kZWwgPSAkc2NvcGUubmdNb2RlbDsgfSk7XG5cbiAgICAgIGN0cmwuYWN0aXZlTWF0Y2hJbmRleCA9IC0xO1xuXG4gICAgICBjdHJsLnVwZGF0ZU1vZGVsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKERhdGUubm93KCkpOyAvL1NldCB0aW1lc3RhbXAgYXMgYSB1bmlxdWUgc3RyaW5nIHRvIGZvcmNlIGNoYW5nZXNcbiAgICAgICAgY3RybC5yZWZyZXNoQ29tcG9uZW50KCk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLnJlZnJlc2hDb21wb25lbnQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvL1JlbW92ZSBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgIC8vZS5nLiBXaGVuIHVzZXIgY2xpY2tzIG9uIGEgc2VsZWN0aW9uLCB0aGUgc2VsZWN0ZWQgYXJyYXkgY2hhbmdlcyBhbmQgXG4gICAgICAgIC8vdGhlIGRyb3Bkb3duIHNob3VsZCByZW1vdmUgdGhhdCBpdGVtXG4gICAgICAgICRzZWxlY3QucmVmcmVzaEl0ZW1zKCk7XG4gICAgICAgICRzZWxlY3Quc2l6ZVNlYXJjaElucHV0KCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBSZW1vdmUgaXRlbSBmcm9tIG11bHRpcGxlIHNlbGVjdFxuICAgICAgY3RybC5yZW1vdmVDaG9pY2UgPSBmdW5jdGlvbihpbmRleCl7XG5cbiAgICAgICAgdmFyIHJlbW92ZWRDaG9pY2UgPSAkc2VsZWN0LnNlbGVjdGVkW2luZGV4XTtcblxuICAgICAgICAvLyBpZiB0aGUgY2hvaWNlIGlzIGxvY2tlZCwgY2FuJ3QgcmVtb3ZlIGl0XG4gICAgICAgIGlmKHJlbW92ZWRDaG9pY2UuX3VpU2VsZWN0Q2hvaWNlTG9ja2VkKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xuICAgICAgICBsb2NhbHNbJHNlbGVjdC5wYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gcmVtb3ZlZENob2ljZTtcblxuICAgICAgICAkc2VsZWN0LnNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGN0cmwuYWN0aXZlTWF0Y2hJbmRleCA9IC0xO1xuICAgICAgICAkc2VsZWN0LnNpemVTZWFyY2hJbnB1dCgpO1xuXG4gICAgICAgIC8vIEdpdmUgc29tZSB0aW1lIGZvciBzY29wZSBwcm9wYWdhdGlvbi5cbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAkc2VsZWN0Lm9uUmVtb3ZlQ2FsbGJhY2soJHNjb3BlLCB7XG4gICAgICAgICAgICAkaXRlbTogcmVtb3ZlZENob2ljZSxcbiAgICAgICAgICAgICRtb2RlbDogJHNlbGVjdC5wYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIoJHNjb3BlLCBsb2NhbHMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0cmwudXBkYXRlTW9kZWwoKTtcblxuICAgICAgfTtcblxuICAgICAgY3RybC5nZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vUmVmYWN0b3Igc2luZ2xlP1xuICAgICAgICBpZigkc2VsZWN0LnNlbGVjdGVkICYmICRzZWxlY3Quc2VsZWN0ZWQubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHJldHVybiAkc2VsZWN0LnBsYWNlaG9sZGVyO1xuICAgICAgfTtcblxuXG4gICAgfV0sXG4gICAgY29udHJvbGxlckFzOiAnJHNlbGVjdE11bHRpcGxlJyxcblxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcblxuICAgICAgdmFyICRzZWxlY3QgPSBjdHJsc1swXTtcbiAgICAgIHZhciBuZ01vZGVsID0gc2NvcGUubmdNb2RlbCA9IGN0cmxzWzFdO1xuICAgICAgdmFyICRzZWxlY3RNdWx0aXBsZSA9IHNjb3BlLiRzZWxlY3RNdWx0aXBsZTtcblxuICAgICAgLy8kc2VsZWN0LnNlbGVjdGVkID0gcmF3IHNlbGVjdGVkIG9iamVjdHMgKGlnbm9yaW5nIGFueSBwcm9wZXJ0eSBiaW5kaW5nKVxuXG4gICAgICAkc2VsZWN0Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICRzZWxlY3QucmVtb3ZlU2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAvL0lucHV0IHRoYXQgd2lsbCBoYW5kbGUgZm9jdXNcbiAgICAgICRzZWxlY3QuZm9jdXNJbnB1dCA9ICRzZWxlY3Quc2VhcmNoSW5wdXQ7XG5cbiAgICAgIC8vRnJvbSB2aWV3IC0tPiBtb2RlbFxuICAgICAgbmdNb2RlbC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvY2FscyA9IHt9LFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9ICRzZWxlY3Quc2VsZWN0ZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBsb2NhbHMgPSB7fTtcbiAgICAgICAgICBsb2NhbHNbJHNlbGVjdC5wYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gJHNlbGVjdC5zZWxlY3RlZFtqXTtcbiAgICAgICAgICByZXN1bHQgPSAkc2VsZWN0LnBhcnNlclJlc3VsdC5tb2RlbE1hcHBlcihzY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICByZXN1bHRNdWx0aXBsZS51bnNoaWZ0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdE11bHRpcGxlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZyb20gbW9kZWwgLS0+IHZpZXdcbiAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMudW5zaGlmdChmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9ICRzZWxlY3QucGFyc2VyUmVzdWx0LnNvdXJjZSAoc2NvcGUsIHsgJHNlbGVjdCA6IHtzZWFyY2g6Jyd9fSksIC8vT3ZlcndyaXRlICRzZWFyY2hcbiAgICAgICAgICAgIGxvY2FscyA9IHt9LFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB2YXIgcmVzdWx0TXVsdGlwbGUgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrRm5NdWx0aXBsZSA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlKXtcbiAgICAgICAgICBpZiAoIWxpc3QgfHwgIWxpc3QubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgZm9yICh2YXIgcCA9IGxpc3QubGVuZ3RoIC0gMTsgcCA+PSAwOyBwLS0pIHtcbiAgICAgICAgICAgIGxvY2Fsc1skc2VsZWN0LnBhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBsaXN0W3BdO1xuICAgICAgICAgICAgcmVzdWx0ID0gJHNlbGVjdC5wYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIoc2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgICBpZigkc2VsZWN0LnBhcnNlclJlc3VsdC50cmFja0J5RXhwKXtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IC9cXC4oLispLy5leGVjKCRzZWxlY3QucGFyc2VyUmVzdWx0LnRyYWNrQnlFeHApO1xuICAgICAgICAgICAgICAgIGlmKG1hdGNoZXMubGVuZ3RoPjAgJiYgcmVzdWx0W21hdGNoZXNbMV1dID09IHZhbHVlW21hdGNoZXNbMV1dKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGUudW5zaGlmdChsaXN0W3BdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuZXF1YWxzKHJlc3VsdCx2YWx1ZSkpe1xuICAgICAgICAgICAgICByZXN1bHRNdWx0aXBsZS51bnNoaWZ0KGxpc3RbcF0pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWlucHV0VmFsdWUpIHJldHVybiByZXN1bHRNdWx0aXBsZTsgLy9JZiBuZ01vZGVsIHdhcyB1bmRlZmluZWRcbiAgICAgICAgZm9yICh2YXIgayA9IGlucHV0VmFsdWUubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAvL0NoZWNrIG1vZGVsIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtcyBcbiAgICAgICAgICBpZiAoIWNoZWNrRm5NdWx0aXBsZSgkc2VsZWN0LnNlbGVjdGVkLCBpbnB1dFZhbHVlW2tdKSl7XG4gICAgICAgICAgICAvL0NoZWNrIG1vZGVsIGFycmF5IG9mIGFsbCBpdGVtcyBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICghY2hlY2tGbk11bHRpcGxlKGRhdGEsIGlucHV0VmFsdWVba10pKXtcbiAgICAgICAgICAgICAgLy9JZiBub3QgZm91bmQgb24gcHJldmlvdXMgbGlzdHMsIGp1c3QgYWRkIGl0IGRpcmVjdGx5IHRvIHJlc3VsdE11bHRpcGxlXG4gICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxlLnVuc2hpZnQoaW5wdXRWYWx1ZVtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRNdWx0aXBsZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvL1dhdGNoIGZvciBleHRlcm5hbCBtb2RlbCBjaGFuZ2VzIFxuICAgICAgc2NvcGUuJHdhdGNoQ29sbGVjdGlvbihmdW5jdGlvbigpeyByZXR1cm4gbmdNb2RlbC4kbW9kZWxWYWx1ZTsgfSwgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBuZXdWYWx1ZSl7XG4gICAgICAgICAgbmdNb2RlbC4kbW9kZWxWYWx1ZSA9IG51bGw7IC8vRm9yY2Ugc2NvcGUgbW9kZWwgdmFsdWUgYW5kIG5nTW9kZWwgdmFsdWUgdG8gYmUgb3V0IG9mIHN5bmMgdG8gcmUtcnVuIGZvcm1hdHRlcnNcbiAgICAgICAgICAkc2VsZWN0TXVsdGlwbGUucmVmcmVzaENvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbmdNb2RlbC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG1vZGVsIHZhbHVlIGlzIGFycmF5XG4gICAgICAgIGlmKCFhbmd1bGFyLmlzQXJyYXkobmdNb2RlbC4kdmlld1ZhbHVlKSl7XG4gICAgICAgICAgLy8gSGF2ZSB0b2xlcmFuY2UgZm9yIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgIGlmKGFuZ3VsYXIuaXNVbmRlZmluZWQobmdNb2RlbC4kdmlld1ZhbHVlKSB8fCBuZ01vZGVsLiR2aWV3VmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgICAgJHNlbGVjdC5zZWxlY3RlZCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycignbXVsdGlhcnInLCBcIkV4cGVjdGVkIG1vZGVsIHZhbHVlIHRvIGJlIGFycmF5IGJ1dCBnb3QgJ3swfSdcIiwgbmdNb2RlbC4kdmlld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHNlbGVjdC5zZWxlY3RlZCA9IG5nTW9kZWwuJHZpZXdWYWx1ZTtcbiAgICAgICAgc2NvcGUuJGV2YWxBc3luYygpOyAvL1RvIGZvcmNlICRkaWdlc3RcbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiRvbigndWlzOnNlbGVjdCcsIGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZigkc2VsZWN0LnNlbGVjdGVkLmxlbmd0aCA+PSAkc2VsZWN0LmxpbWl0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICRzZWxlY3Quc2VsZWN0ZWQucHVzaChpdGVtKTtcbiAgICAgICAgJHNlbGVjdE11bHRpcGxlLnVwZGF0ZU1vZGVsKCk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJG9uKCd1aXM6YWN0aXZhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4ID0gLTE7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCckc2VsZWN0LmRpc2FibGVkJywgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIEFzIHRoZSBzZWFyY2ggaW5wdXQgZmllbGQgbWF5IG5vdyBiZWNvbWUgdmlzaWJsZSwgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byByZWNvbXB1dGUgaXRzIHNpemVcbiAgICAgICAgaWYgKG9sZFZhbHVlICYmICFuZXdWYWx1ZSkgJHNlbGVjdC5zaXplU2VhcmNoSW5wdXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAkc2VsZWN0LnNlYXJjaElucHV0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5ID0gZS53aGljaDtcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAvLyB2YXIgdGFnZ2VkID0gZmFsc2U7IC8vQ2hlY2ttZVxuICAgICAgICAgIGlmKEtFWS5pc0hvcml6b250YWxNb3ZlbWVudChrZXkpKXtcbiAgICAgICAgICAgIHByb2Nlc3NlZCA9IF9oYW5kbGVNYXRjaFNlbGVjdGlvbihrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvY2Vzc2VkICAmJiBrZXkgIT0gS0VZLlRBQikge1xuICAgICAgICAgICAgLy9UT0RPIENoZWNrIHNpIGVsIHRhYiBzZWxlY2Npb25hIGF1biBjb3JyZWN0YW1lbnRlXG4gICAgICAgICAgICAvL0NyZWFyIHRlc3RcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZnVuY3Rpb24gX2dldENhcmV0UG9zaXRpb24oZWwpIHtcbiAgICAgICAgaWYoYW5ndWxhci5pc051bWJlcihlbC5zZWxlY3Rpb25TdGFydCkpIHJldHVybiBlbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgLy8gc2VsZWN0aW9uU3RhcnQgaXMgbm90IHN1cHBvcnRlZCBpbiBJRTggYW5kIHdlIGRvbid0IHdhbnQgaGFja3kgd29ya2Fyb3VuZHMgc28gd2UgY29tcHJvbWlzZVxuICAgICAgICBlbHNlIHJldHVybiBlbC52YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBIYW5kbGVzIHNlbGVjdGVkIG9wdGlvbnMgaW4gXCJtdWx0aXBsZVwiIG1vZGVcbiAgICAgIGZ1bmN0aW9uIF9oYW5kbGVNYXRjaFNlbGVjdGlvbihrZXkpe1xuICAgICAgICB2YXIgY2FyZXRQb3NpdGlvbiA9IF9nZXRDYXJldFBvc2l0aW9uKCRzZWxlY3Quc2VhcmNoSW5wdXRbMF0pLFxuICAgICAgICAgICAgbGVuZ3RoID0gJHNlbGVjdC5zZWxlY3RlZC5sZW5ndGgsXG4gICAgICAgICAgICAvLyBub25lICA9IC0xLFxuICAgICAgICAgICAgZmlyc3QgPSAwLFxuICAgICAgICAgICAgbGFzdCAgPSBsZW5ndGgtMSxcbiAgICAgICAgICAgIGN1cnIgID0gJHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXgsXG4gICAgICAgICAgICBuZXh0ICA9ICRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4KzEsXG4gICAgICAgICAgICBwcmV2ICA9ICRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4LTEsXG4gICAgICAgICAgICBuZXdJbmRleCA9IGN1cnI7XG5cbiAgICAgICAgaWYoY2FyZXRQb3NpdGlvbiA+IDAgfHwgKCRzZWxlY3Quc2VhcmNoLmxlbmd0aCAmJiBrZXkgPT0gS0VZLlJJR0hUKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICRzZWxlY3QuY2xvc2UoKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXROZXdBY3RpdmVNYXRjaEluZGV4KCl7XG4gICAgICAgICAgc3dpdGNoKGtleSl7XG4gICAgICAgICAgICBjYXNlIEtFWS5MRUZUOlxuICAgICAgICAgICAgICAvLyBTZWxlY3QgcHJldmlvdXMvZmlyc3QgaXRlbVxuICAgICAgICAgICAgICBpZih+JHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXgpIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICAvLyBTZWxlY3QgbGFzdCBpdGVtXG4gICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVkuUklHSFQ6XG4gICAgICAgICAgICAgIC8vIE9wZW4gZHJvcC1kb3duXG4gICAgICAgICAgICAgIGlmKCF+JHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggfHwgY3VyciA9PT0gbGFzdCl7XG4gICAgICAgICAgICAgICAgJHNlbGVjdC5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBTZWxlY3QgbmV4dC9sYXN0IGl0ZW1cbiAgICAgICAgICAgICAgZWxzZSByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWS5CQUNLU1BBQ0U6XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtIGFuZCBzZWxlY3QgcHJldmlvdXMvZmlyc3RcbiAgICAgICAgICAgICAgaWYofiRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4KXtcbiAgICAgICAgICAgICAgICAkc2VsZWN0TXVsdGlwbGUucmVtb3ZlQ2hvaWNlKGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFNlbGVjdCBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgZWxzZSByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWS5ERUxFVEU6XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtIGFuZCBzZWxlY3QgbmV4dCBpdGVtXG4gICAgICAgICAgICAgIGlmKH4kc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCl7XG4gICAgICAgICAgICAgICAgJHNlbGVjdE11bHRpcGxlLnJlbW92ZUNob2ljZSgkc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3SW5kZXggPSBnZXROZXdBY3RpdmVNYXRjaEluZGV4KCk7XG5cbiAgICAgICAgaWYoISRzZWxlY3Quc2VsZWN0ZWQubGVuZ3RoIHx8IG5ld0luZGV4ID09PSBmYWxzZSkgJHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggPSAtMTtcbiAgICAgICAgZWxzZSAkc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCA9IE1hdGgubWluKGxhc3QsTWF0aC5tYXgoZmlyc3QsbmV3SW5kZXgpKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgJHNlbGVjdC5zZWFyY2hJbnB1dC5vbigna2V5dXAnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYgKCAhIEtFWS5pc1ZlcnRpY2FsTW92ZW1lbnQoZS53aGljaCkgKSB7XG4gICAgICAgICAgc2NvcGUuJGV2YWxBc3luYyggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNlbGVjdC5hY3RpdmVJbmRleCA9ICRzZWxlY3QudGFnZ2luZ0xhYmVsID09PSBmYWxzZSA/IC0xIDogMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQdXNoIGEgXCJjcmVhdGUgbmV3XCIgaXRlbSBpbnRvIGFycmF5IGlmIHRoZXJlIGlzIGEgc2VhcmNoIHN0cmluZ1xuICAgICAgICBpZiAoICRzZWxlY3QudGFnZ2luZy5pc0FjdGl2YXRlZCAmJiAkc2VsZWN0LnNlYXJjaC5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGggdGhlc2Uga2V5c1xuICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuVEFCIHx8IEtFWS5pc0NvbnRyb2woZSkgfHwgS0VZLmlzRnVuY3Rpb25LZXkoZSkgfHwgZS53aGljaCA9PT0gS0VZLkVTQyB8fCBLRVkuaXNWZXJ0aWNhbE1vdmVtZW50KGUud2hpY2gpICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhbHdheXMgcmVzZXQgdGhlIGFjdGl2ZUluZGV4IHRvIHRoZSBmaXJzdCBpdGVtIHdoZW4gdGFnZ2luZ1xuICAgICAgICAgICRzZWxlY3QuYWN0aXZlSW5kZXggPSAkc2VsZWN0LnRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UgPyAtMSA6IDA7XG4gICAgICAgICAgLy8gdGFnZ2luZ0xhYmVsID09PSBmYWxzZSBieXBhc3NlcyBhbGwgb2YgdGhpc1xuICAgICAgICAgIGlmICgkc2VsZWN0LnRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICAgIHZhciBpdGVtcyA9IGFuZ3VsYXIuY29weSggJHNlbGVjdC5pdGVtcyApO1xuICAgICAgICAgIHZhciBzdGFzaEFyciA9IGFuZ3VsYXIuY29weSggJHNlbGVjdC5pdGVtcyApO1xuICAgICAgICAgIHZhciBuZXdJdGVtO1xuICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgIHZhciBoYXNUYWcgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZHVwZUluZGV4ID0gLTE7XG4gICAgICAgICAgdmFyIHRhZ0l0ZW1zO1xuICAgICAgICAgIHZhciB0YWdJdGVtO1xuXG4gICAgICAgICAgLy8gY2FzZSBmb3Igb2JqZWN0IHRhZ2dpbmcgdmlhIHRyYW5zZm9ybSBgJHNlbGVjdC50YWdnaW5nLmZjdGAgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoICRzZWxlY3QudGFnZ2luZy5mY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFnSXRlbXMgPSAkc2VsZWN0LiRmaWx0ZXIoJ2ZpbHRlcicpKGl0ZW1zLHsnaXNUYWcnOiB0cnVlfSk7XG4gICAgICAgICAgICBpZiAoIHRhZ0l0ZW1zLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgIHRhZ0l0ZW0gPSB0YWdJdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCwgaWYgaXQgaGFzIHRoZSBgaXNUYWdgIHByb3Agd2UgZ2VuZXJhdGUgYSBuZXcgb25lIHdpdGggZWFjaCBrZXl1cCwgc2hhdmluZyB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIGlmICggaXRlbXMubGVuZ3RoID4gMCAmJiB0YWdJdGVtICkge1xuICAgICAgICAgICAgICBoYXNUYWcgPSB0cnVlO1xuICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDEsaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgc3Rhc2hBcnIgPSBzdGFzaEFyci5zbGljZSgxLHN0YXNoQXJyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtID0gJHNlbGVjdC50YWdnaW5nLmZjdCgkc2VsZWN0LnNlYXJjaCk7XG4gICAgICAgICAgICBuZXdJdGVtLmlzVGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSB0aGUgdGhlIHRhZyBkb2Vzbid0IG1hdGNoIHRoZSB2YWx1ZSBvZiBhbiBleGlzdGluZyBpdGVtXG4gICAgICAgICAgICBpZiAoIHN0YXNoQXJyLmZpbHRlciggZnVuY3Rpb24gKG9yaWdJdGVtKSB7IHJldHVybiBhbmd1bGFyLmVxdWFscyggb3JpZ0l0ZW0sICRzZWxlY3QudGFnZ2luZy5mY3QoJHNlbGVjdC5zZWFyY2gpICk7IH0gKS5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtLmlzVGFnID0gdHJ1ZTtcbiAgICAgICAgICAvLyBoYW5kbGUgbmV3SXRlbSBzdHJpbmcgYW5kIHN0cmlwcGluZyBkdXBlcyBpbiB0YWdnaW5nIHN0cmluZyBjb250ZXh0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbmQgYW55IHRhZ2dpbmcgaXRlbXMgYWxyZWFkeSBpbiB0aGUgJHNlbGVjdC5pdGVtcyBhcnJheSBhbmQgc3RvcmUgdGhlbVxuICAgICAgICAgICAgdGFnSXRlbXMgPSAkc2VsZWN0LiRmaWx0ZXIoJ2ZpbHRlcicpKGl0ZW1zLGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtLm1hdGNoKCRzZWxlY3QudGFnZ2luZ0xhYmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCB0YWdJdGVtcy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICB0YWdJdGVtID0gdGFnSXRlbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbMF07XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmcgdGFnIGl0ZW0gaWYgZm91bmQgKHNob3VsZCBvbmx5IGV2ZXIgYmUgb25lIHRhZyBpdGVtKVxuICAgICAgICAgICAgaWYgKCBpdGVtICE9PSB1bmRlZmluZWQgJiYgaXRlbXMubGVuZ3RoID4gMCAmJiB0YWdJdGVtICkge1xuICAgICAgICAgICAgICBoYXNUYWcgPSB0cnVlO1xuICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDEsaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgc3Rhc2hBcnIgPSBzdGFzaEFyci5zbGljZSgxLHN0YXNoQXJyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtID0gJHNlbGVjdC5zZWFyY2grJyAnKyRzZWxlY3QudGFnZ2luZ0xhYmVsO1xuICAgICAgICAgICAgaWYgKCBfZmluZEFwcHJveER1cGUoJHNlbGVjdC5zZWxlY3RlZCwgJHNlbGVjdC5zZWFyY2gpID4gLTEgKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZlcmlmeSB0aGUgdGhlIHRhZyBkb2Vzbid0IG1hdGNoIHRoZSB2YWx1ZSBvZiBhbiBleGlzdGluZyBpdGVtIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSBzZWFyY2hlZCBkYXRhIHNldCBvciB0aGUgaXRlbXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAgaWYgKCBfZmluZENhc2VJbnNlbnNpdGl2ZUR1cGUoc3Rhc2hBcnIuY29uY2F0KCRzZWxlY3Quc2VsZWN0ZWQpKSApIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YWcgZnJvbSBwcmV2IGl0ZXJhdGlvbiwgc3RyaXAgaXQgLyBxdWV1ZSB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgaWYgKCBoYXNUYWcgKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBzdGFzaEFycjtcbiAgICAgICAgICAgICAgICBzY29wZS4kZXZhbEFzeW5jKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAkc2VsZWN0LmFjdGl2ZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICRzZWxlY3QuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIF9maW5kQ2FzZUluc2Vuc2l0aXZlRHVwZShzdGFzaEFycikgKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGFnIGZyb20gcHJldiBpdGVyYXRpb24sIHN0cmlwIGl0XG4gICAgICAgICAgICAgIGlmICggaGFzVGFnICkge1xuICAgICAgICAgICAgICAgICRzZWxlY3QuaXRlbXMgPSBzdGFzaEFyci5zbGljZSgxLHN0YXNoQXJyLmxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGhhc1RhZyApIGR1cGVJbmRleCA9IF9maW5kQXBwcm94RHVwZSgkc2VsZWN0LnNlbGVjdGVkLCBuZXdJdGVtKTtcbiAgICAgICAgICAvLyBkdXBlIGZvdW5kLCBzaGF2ZSB0aGUgZmlyc3QgaXRlbVxuICAgICAgICAgIGlmICggZHVwZUluZGV4ID4gLTEgKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKGR1cGVJbmRleCsxLGl0ZW1zLmxlbmd0aC0xKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChzdGFzaEFycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLiRldmFsQXN5bmMoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzZWxlY3QuYWN0aXZlSW5kZXggPSAwO1xuICAgICAgICAgICAgJHNlbGVjdC5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZ1bmN0aW9uIF9maW5kQ2FzZUluc2Vuc2l0aXZlRHVwZShhcnIpIHtcbiAgICAgICAgaWYgKCBhcnIgPT09IHVuZGVmaW5lZCB8fCAkc2VsZWN0LnNlYXJjaCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzRHVwZSA9IGFyci5maWx0ZXIoIGZ1bmN0aW9uIChvcmlnSXRlbSkge1xuICAgICAgICAgIGlmICggJHNlbGVjdC5zZWFyY2gudG9VcHBlckNhc2UoKSA9PT0gdW5kZWZpbmVkIHx8IG9yaWdJdGVtID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnSXRlbS50b1VwcGVyQ2FzZSgpID09PSAkc2VsZWN0LnNlYXJjaC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KS5sZW5ndGggPiAwO1xuXG4gICAgICAgIHJldHVybiBoYXNEdXBlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2ZpbmRBcHByb3hEdXBlKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICAgICAgdmFyIGR1cGVJbmRleCA9IC0xO1xuICAgICAgICBpZihhbmd1bGFyLmlzQXJyYXkoaGF5c3RhY2spKSB7XG4gICAgICAgICAgdmFyIHRlbXBBcnIgPSBhbmd1bGFyLmNvcHkoaGF5c3RhY2spO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDx0ZW1wQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHNpbXBsZSBzdHJpbmcgdmVyc2lvbiBvZiB0YWdnaW5nXG4gICAgICAgICAgICBpZiAoICRzZWxlY3QudGFnZ2luZy5mY3QgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgLy8gc2VhcmNoIHRoZSBhcnJheSBmb3IgdGhlIG1hdGNoXG4gICAgICAgICAgICAgIGlmICggdGVtcEFycltpXSsnICcrJHNlbGVjdC50YWdnaW5nTGFiZWwgPT09IG5lZWRsZSApIHtcbiAgICAgICAgICAgICAgZHVwZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBvYmplY3QgdGFnZ2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG1vY2tPYmogPSB0ZW1wQXJyW2ldO1xuICAgICAgICAgICAgICBtb2NrT2JqLmlzVGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKCBhbmd1bGFyLmVxdWFscyhtb2NrT2JqLCBuZWVkbGUpICkge1xuICAgICAgICAgICAgICBkdXBlSW5kZXggPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkdXBlSW5kZXg7XG4gICAgICB9XG5cbiAgICAgICRzZWxlY3Quc2VhcmNoSW5wdXQub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggPSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIH1cbiAgfTtcbn1dKTtcblxudWlzLmRpcmVjdGl2ZSgndWlTZWxlY3RTaW5nbGUnLCBbJyR0aW1lb3V0JywnJGNvbXBpbGUnLCBmdW5jdGlvbigkdGltZW91dCwgJGNvbXBpbGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXF1aXJlOiBbJ151aVNlbGVjdCcsICdebmdNb2RlbCddLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcblxuICAgICAgdmFyICRzZWxlY3QgPSBjdHJsc1swXTtcbiAgICAgIHZhciBuZ01vZGVsID0gY3RybHNbMV07XG5cbiAgICAgIC8vRnJvbSB2aWV3IC0tPiBtb2RlbFxuICAgICAgbmdNb2RlbC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG4gICAgICAgIHZhciBsb2NhbHMgPSB7fSxcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgbG9jYWxzWyRzZWxlY3QucGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IGlucHV0VmFsdWU7XG4gICAgICAgIHJlc3VsdCA9ICRzZWxlY3QucGFyc2VyUmVzdWx0Lm1vZGVsTWFwcGVyKHNjb3BlLCBsb2NhbHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vRnJvbSBtb2RlbCAtLT4gdmlld1xuICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy51bnNoaWZ0KGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0gJHNlbGVjdC5wYXJzZXJSZXN1bHQuc291cmNlIChzY29wZSwgeyAkc2VsZWN0IDoge3NlYXJjaDonJ319KSwgLy9PdmVyd3JpdGUgJHNlYXJjaFxuICAgICAgICAgICAgbG9jYWxzID0ge30sXG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmIChkYXRhKXtcbiAgICAgICAgICB2YXIgY2hlY2tGblNpbmdsZSA9IGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgbG9jYWxzWyRzZWxlY3QucGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IGQ7XG4gICAgICAgICAgICByZXN1bHQgPSAkc2VsZWN0LnBhcnNlclJlc3VsdC5tb2RlbE1hcHBlcihzY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vSWYgcG9zc2libGUgcGFzcyBzYW1lIG9iamVjdCBzdG9yZWQgaW4gJHNlbGVjdC5zZWxlY3RlZFxuICAgICAgICAgIGlmICgkc2VsZWN0LnNlbGVjdGVkICYmIGNoZWNrRm5TaW5nbGUoJHNlbGVjdC5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkc2VsZWN0LnNlbGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrRm5TaW5nbGUoZGF0YVtpXSkpIHJldHVybiBkYXRhW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvL1VwZGF0ZSB2aWV3VmFsdWUgaWYgbW9kZWwgY2hhbmdlXG4gICAgICBzY29wZS4kd2F0Y2goJyRzZWxlY3Quc2VsZWN0ZWQnLCBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmdNb2RlbC4kdmlld1ZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBuZ01vZGVsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJHNlbGVjdC5zZWxlY3RlZCA9IG5nTW9kZWwuJHZpZXdWYWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiRvbigndWlzOnNlbGVjdCcsIGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICAkc2VsZWN0LnNlbGVjdGVkID0gaXRlbTtcbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJ3VpczpjbG9zZScsIGZ1bmN0aW9uIChldmVudCwgc2tpcEZvY3Vzc2VyKSB7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgJHNlbGVjdC5mb2N1c3Nlci5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoIXNraXBGb2N1c3NlcikgJHNlbGVjdC5mb2N1c3NlclswXS5mb2N1cygpO1xuICAgICAgICB9LDAsZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbigndWlzOmFjdGl2YXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb2N1c3Nlci5wcm9wKCdkaXNhYmxlZCcsIHRydWUpOyAvL1dpbGwgcmVhY3RpdmF0ZSBpdCBvbiAuY2xvc2UoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vSWRlYSBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIvYmxvYi83OWI1YmY2ZGI5MThkNzU2MGJkZDk1OTEwOWI3YmNmYjQ3ZWRhZjQzL3NlbGVjdDIuanMjTDE5NTRcbiAgICAgIHZhciBmb2N1c3NlciA9IGFuZ3VsYXIuZWxlbWVudChcIjxpbnB1dCBuZy1kaXNhYmxlZD0nJHNlbGVjdC5kaXNhYmxlZCcgY2xhc3M9J3VpLXNlbGVjdC1mb2N1c3NlciB1aS1zZWxlY3Qtb2Zmc2NyZWVuJyB0eXBlPSd0ZXh0JyBpZD0ne3sgJHNlbGVjdC5mb2N1c3NlcklkIH19JyBhcmlhLWxhYmVsPSd7eyAkc2VsZWN0LmZvY3Vzc2VyVGl0bGUgfX0nIGFyaWEtaGFzcG9wdXA9J3RydWUnIHJvbGU9J2J1dHRvbicgLz5cIik7XG4gICAgICAkY29tcGlsZShmb2N1c3Nlcikoc2NvcGUpO1xuICAgICAgJHNlbGVjdC5mb2N1c3NlciA9IGZvY3Vzc2VyO1xuXG4gICAgICAvL0lucHV0IHRoYXQgd2lsbCBoYW5kbGUgZm9jdXNcbiAgICAgICRzZWxlY3QuZm9jdXNJbnB1dCA9IGZvY3Vzc2VyO1xuXG4gICAgICBlbGVtZW50LnBhcmVudCgpLmFwcGVuZChmb2N1c3Nlcik7XG4gICAgICBmb2N1c3Nlci5iaW5kKFwiZm9jdXNcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgc2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICRzZWxlY3QuZm9jdXMgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZm9jdXNzZXIuYmluZChcImJsdXJcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgc2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICRzZWxlY3QuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGZvY3Vzc2VyLmJpbmQoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuQkFDS1NQQUNFKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgJHNlbGVjdC5zZWxlY3QodW5kZWZpbmVkKTtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLlRBQiB8fCBLRVkuaXNDb250cm9sKGUpIHx8IEtFWS5pc0Z1bmN0aW9uS2V5KGUpIHx8IGUud2hpY2ggPT09IEtFWS5FU0MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS53aGljaCA9PSBLRVkuRE9XTiAgfHwgZS53aGljaCA9PSBLRVkuVVAgfHwgZS53aGljaCA9PSBLRVkuRU5URVIgfHwgZS53aGljaCA9PSBLRVkuU1BBQ0Upe1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICRzZWxlY3QuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb2N1c3Nlci5iaW5kKFwia2V5dXAgaW5wdXRcIiwgZnVuY3Rpb24oZSl7XG5cbiAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWS5UQUIgfHwgS0VZLmlzQ29udHJvbChlKSB8fCBLRVkuaXNGdW5jdGlvbktleShlKSB8fCBlLndoaWNoID09PSBLRVkuRVNDIHx8IGUud2hpY2ggPT0gS0VZLkVOVEVSIHx8IGUud2hpY2ggPT09IEtFWS5CQUNLU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkc2VsZWN0LmFjdGl2YXRlKGZvY3Vzc2VyLnZhbCgpKTsgLy9Vc2VyIHByZXNzZWQgc29tZSByZWd1bGFyIGtleSwgc28gd2UgcGFzcyBpdCB0byB0aGUgc2VhcmNoIGlucHV0XG4gICAgICAgIGZvY3Vzc2VyLnZhbCgnJyk7XG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcblxuICAgICAgfSk7XG5cblxuICAgIH1cbiAgfTtcbn1dKTtcbi8vIE1ha2UgbXVsdGlwbGUgbWF0Y2hlcyBzb3J0YWJsZVxudWlzLmRpcmVjdGl2ZSgndWlTZWxlY3RTb3J0JywgWyckdGltZW91dCcsICd1aVNlbGVjdENvbmZpZycsICd1aVNlbGVjdE1pbkVycicsIGZ1bmN0aW9uKCR0aW1lb3V0LCB1aVNlbGVjdENvbmZpZywgdWlTZWxlY3RNaW5FcnIpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXnVpU2VsZWN0JyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsICRzZWxlY3QpIHtcbiAgICAgIGlmIChzY29wZVthdHRycy51aVNlbGVjdFNvcnRdID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHVpU2VsZWN0TWluRXJyKCdzb3J0JywgXCJFeHBlY3RlZCBhIGxpc3QgdG8gc29ydFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZCh7XG4gICAgICAgICAgYXhpczogJ2hvcml6b250YWwnXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlLiRldmFsKGF0dHJzLnVpU2VsZWN0U29ydE9wdGlvbnMpKTtcblxuICAgICAgdmFyIGF4aXMgPSBvcHRpb25zLmF4aXMsXG4gICAgICAgIGRyYWdnaW5nQ2xhc3NOYW1lID0gJ2RyYWdnaW5nJyxcbiAgICAgICAgZHJvcHBpbmdDbGFzc05hbWUgPSAnZHJvcHBpbmcnLFxuICAgICAgICBkcm9wcGluZ0JlZm9yZUNsYXNzTmFtZSA9ICdkcm9wcGluZy1iZWZvcmUnLFxuICAgICAgICBkcm9wcGluZ0FmdGVyQ2xhc3NOYW1lID0gJ2Ryb3BwaW5nLWFmdGVyJztcblxuICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiAkc2VsZWN0LnNvcnRhYmxlO1xuICAgICAgfSwgZnVuY3Rpb24obil7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgZWxlbWVudC5hdHRyKCdkcmFnZ2FibGUnLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHIoJ2RyYWdnYWJsZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKGRyYWdnaW5nQ2xhc3NOYW1lKTtcblxuICAgICAgICAoZS5kYXRhVHJhbnNmZXIgfHwgZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlcikuc2V0RGF0YSgndGV4dC9wbGFpbicsIHNjb3BlLiRpbmRleCk7XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRyYWdnaW5nQ2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbW92ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgICAgICB0aGlzLnNwbGljZSh0bywgMCwgdGhpcy5zcGxpY2UoZnJvbSwgMSlbMF0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRyYWdPdmVySGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBheGlzID09PSAndmVydGljYWwnID8gZS5vZmZzZXRZIHx8IGUubGF5ZXJZIHx8IChlLm9yaWdpbmFsRXZlbnQgPyBlLm9yaWdpbmFsRXZlbnQub2Zmc2V0WSA6IDApIDogZS5vZmZzZXRYIHx8IGUubGF5ZXJYIHx8IChlLm9yaWdpbmFsRXZlbnQgPyBlLm9yaWdpbmFsRXZlbnQub2Zmc2V0WCA6IDApO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPCAodGhpc1theGlzID09PSAndmVydGljYWwnID8gJ29mZnNldEhlaWdodCcgOiAnb2Zmc2V0V2lkdGgnXSAvIDIpKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhkcm9wcGluZ0FmdGVyQ2xhc3NOYW1lKTtcbiAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKGRyb3BwaW5nQmVmb3JlQ2xhc3NOYW1lKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoZHJvcHBpbmdCZWZvcmVDbGFzc05hbWUpO1xuICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoZHJvcHBpbmdBZnRlckNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBkcm9wVGltZW91dDtcblxuICAgICAgdmFyIGRyb3BIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGRyb3BwZWRJdGVtSW5kZXggPSBwYXJzZUludCgoZS5kYXRhVHJhbnNmZXIgfHwgZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2ZlcikuZ2V0RGF0YSgndGV4dC9wbGFpbicpLCAxMCk7XG5cbiAgICAgICAgLy8gcHJldmVudCBldmVudCBmaXJpbmcgbXVsdGlwbGUgdGltZXMgaW4gZmlyZWZveFxuICAgICAgICAkdGltZW91dC5jYW5jZWwoZHJvcFRpbWVvdXQpO1xuICAgICAgICBkcm9wVGltZW91dCA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9kcm9wSGFuZGxlcihkcm9wcGVkSXRlbUluZGV4KTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfTtcblxuICAgICAgdmFyIF9kcm9wSGFuZGxlciA9IGZ1bmN0aW9uKGRyb3BwZWRJdGVtSW5kZXgpIHtcbiAgICAgICAgdmFyIHRoZUxpc3QgPSBzY29wZS4kZXZhbChhdHRycy51aVNlbGVjdFNvcnQpLFxuICAgICAgICAgIGl0ZW1Ub01vdmUgPSB0aGVMaXN0W2Ryb3BwZWRJdGVtSW5kZXhdLFxuICAgICAgICAgIG5ld0luZGV4ID0gbnVsbDtcblxuICAgICAgICBpZiAoZWxlbWVudC5oYXNDbGFzcyhkcm9wcGluZ0JlZm9yZUNsYXNzTmFtZSkpIHtcbiAgICAgICAgICBpZiAoZHJvcHBlZEl0ZW1JbmRleCA8IHNjb3BlLiRpbmRleCkge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBzY29wZS4kaW5kZXggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IHNjb3BlLiRpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRyb3BwZWRJdGVtSW5kZXggPCBzY29wZS4kaW5kZXgpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gc2NvcGUuJGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IHNjb3BlLiRpbmRleCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbW92ZS5hcHBseSh0aGVMaXN0LCBbZHJvcHBlZEl0ZW1JbmRleCwgbmV3SW5kZXhdKTtcblxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2NvcGUuJGVtaXQoJ3VpU2VsZWN0U29ydDpjaGFuZ2UnLCB7XG4gICAgICAgICAgICBhcnJheTogdGhlTGlzdCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1Ub01vdmUsXG4gICAgICAgICAgICBmcm9tOiBkcm9wcGVkSXRlbUluZGV4LFxuICAgICAgICAgICAgdG86IG5ld0luZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoZHJvcHBpbmdDbGFzc05hbWUpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRyb3BwaW5nQmVmb3JlQ2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhkcm9wcGluZ0FmdGVyQ2xhc3NOYW1lKTtcblxuICAgICAgICBlbGVtZW50Lm9mZignZHJvcCcsIGRyb3BIYW5kbGVyKTtcbiAgICAgIH07XG5cbiAgICAgIGVsZW1lbnQub24oJ2RyYWdlbnRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNDbGFzcyhkcmFnZ2luZ0NsYXNzTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKGRyb3BwaW5nQ2xhc3NOYW1lKTtcblxuICAgICAgICBlbGVtZW50Lm9uKCdkcmFnb3ZlcicsIGRyYWdPdmVySGFuZGxlcik7XG4gICAgICAgIGVsZW1lbnQub24oJ2Ryb3AnLCBkcm9wSGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5vbignZHJhZ2xlYXZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgIT0gZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRyb3BwaW5nQ2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhkcm9wcGluZ0JlZm9yZUNsYXNzTmFtZSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoZHJvcHBpbmdBZnRlckNsYXNzTmFtZSk7XG5cbiAgICAgICAgZWxlbWVudC5vZmYoJ2RyYWdvdmVyJywgZHJhZ092ZXJIYW5kbGVyKTtcbiAgICAgICAgZWxlbWVudC5vZmYoJ2Ryb3AnLCBkcm9wSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSk7XG5cbi8qKlxuICogUGFyc2VzIFwicmVwZWF0XCIgYXR0cmlidXRlLlxuICpcbiAqIFRha2VuIGZyb20gQW5ndWxhckpTIG5nUmVwZWF0IHNvdXJjZSBjb2RlXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9ibG9iL3YxLjIuMTUvc3JjL25nL2RpcmVjdGl2ZS9uZ1JlcGVhdC5qcyNMMjExXG4gKlxuICogT3JpZ2luYWwgZGlzY3Vzc2lvbiBhYm91dCBwYXJzaW5nIFwicmVwZWF0XCIgYXR0cmlidXRlIGluc3RlYWQgb2YgZnVsbHkgcmVseWluZyBvbiBuZy1yZXBlYXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1zZWxlY3QvY29tbWl0LzVkZDYzYWQjY29tbWl0Y29tbWVudC01NTA0Njk3XG4gKi9cblxudWlzLnNlcnZpY2UoJ3Vpc1JlcGVhdFBhcnNlcicsIFsndWlTZWxlY3RNaW5FcnInLCckcGFyc2UnLCBmdW5jdGlvbih1aVNlbGVjdE1pbkVyciwgJHBhcnNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvKipcbiAgICogRXhhbXBsZTpcbiAgICogZXhwcmVzc2lvbiA9IFwiYWRkcmVzcyBpbiBhZGRyZXNzZXMgfCBmaWx0ZXI6IHtzdHJlZXQ6ICRzZWxlY3Quc2VhcmNofSB0cmFjayBieSAkaW5kZXhcIlxuICAgKiBpdGVtTmFtZSA9IFwiYWRkcmVzc1wiLFxuICAgKiBzb3VyY2UgPSBcImFkZHJlc3NlcyB8IGZpbHRlcjoge3N0cmVldDogJHNlbGVjdC5zZWFyY2h9XCIsXG4gICAqIHRyYWNrQnlFeHAgPSBcIiRpbmRleFwiLFxuICAgKi9cbiAgc2VsZi5wYXJzZSA9IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcblxuXG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBpc09iamVjdENvbGxlY3Rpb24gPSAvXFwoXFxzKihbXFwkXFx3XVtcXCRcXHddKilcXHMqLFxccyooW1xcJFxcd11bXFwkXFx3XSopXFxzKlxcKS8udGVzdChleHByZXNzaW9uKTtcbiAgICAvLyBJZiBhbiBhcnJheSBpcyB1c2VkIGFzIGNvbGxlY3Rpb25cblxuICAgIC8vIGlmIChpc09iamVjdENvbGxlY3Rpb24pe1xuICAgICAgLy8wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMTExMTAwMDAwMDAwMDAwMDAwMDIyMjIyMjIyMjIyMjIyMDAzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDAwMDAwMDAwMDAwMDAwMDU1NjY2NjY2MDAwMDA3Nzc3Nzc3Nzc3Nzc1NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODg4MDAwMDAwMFxuICAgIG1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaCgvXlxccyooPzooW1xcc1xcU10rPylcXHMrYXNcXHMrKT8oPzooW1xcJFxcd11bXFwkXFx3XSopfCg/OlxcKFxccyooW1xcJFxcd11bXFwkXFx3XSopXFxzKixcXHMqKFtcXCRcXHddW1xcJFxcd10qKVxccypcXCkpKVxccytpblxccysoKFtcXHdcXC5dKyk/XFxzKih8XFxzKltcXHNcXFNdKz8pKT8oPzpcXHMrdHJhY2tcXHMrYnlcXHMrKFtcXHNcXFNdKz8pKT9cXHMqJC8pOyAgICAgIFxuXG4gICAgLy8gMSBBbGlhc1xuICAgIC8vIDIgSXRlbVxuICAgIC8vIDMgS2V5IG9uIChrZXksdmFsdWUpXG4gICAgLy8gNCBWYWx1ZSBvbiAoa2V5LHZhbHVlKVxuICAgIC8vIDUgQ29sbGVjdGlvbiBleHByZXNpb24gKG9ubHkgdXNlZCB3aGVuIHVzaW5nIGFuIGFycmF5IGNvbGxlY3Rpb24pXG4gICAgLy8gNiBPYmplY3QgdGhhdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBBcnJheSB3aGVuIHVzaW5nIChrZXksdmFsdWUpIHN5bnRheFxuICAgIC8vIDcgRmlsdGVycyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byAjNiB3aGVuIHVzaW5nIChrZXksdmFsdWUpIHN5bnRheFxuICAgIC8vIDggVHJhY2sgYnlcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IHVpU2VsZWN0TWluRXJyKCdpZXhwJywgXCJFeHBlY3RlZCBleHByZXNzaW9uIGluIGZvcm0gb2YgJ19pdGVtXyBpbiBfY29sbGVjdGlvbl9bIHRyYWNrIGJ5IF9pZF9dJyBidXQgZ290ICd7MH0nLlwiLFxuICAgICAgICAgICAgICBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgaWYgKCFtYXRjaFs2XSAmJiBpc09iamVjdENvbGxlY3Rpb24pIHtcbiAgICAgIHRocm93IHVpU2VsZWN0TWluRXJyKCdpZXhwJywgXCJFeHBlY3RlZCBleHByZXNzaW9uIGluIGZvcm0gb2YgJ19pdGVtXyBhcyAoX2tleV8sIF9pdGVtXykgaW4gX09iakNvbGxlY3Rpb25fIFsgdHJhY2sgYnkgX2lkX10nIGJ1dCBnb3QgJ3swfScuXCIsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpdGVtTmFtZTogbWF0Y2hbNF0gfHwgbWF0Y2hbMl0sIC8vIChsaHMpIExlZnQtaGFuZCBzaWRlLFxuICAgICAga2V5TmFtZTogbWF0Y2hbM10sIC8vZm9yIChrZXksIHZhbHVlKSBzeW50YXhcbiAgICAgIHNvdXJjZTogJHBhcnNlKCFtYXRjaFszXSA/IG1hdGNoWzVdIDogbWF0Y2hbNl0pLFxuICAgICAgc291cmNlTmFtZTogbWF0Y2hbNl0sXG4gICAgICBmaWx0ZXJzOiBtYXRjaFs3XSxcbiAgICAgIHRyYWNrQnlFeHA6IG1hdGNoWzhdLFxuICAgICAgbW9kZWxNYXBwZXI6ICRwYXJzZShtYXRjaFsxXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFsyXSksXG4gICAgICByZXBlYXRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZ3JvdXBlZCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuaXRlbU5hbWUgKyAnIGluICcgKyAoZ3JvdXBlZCA/ICckZ3JvdXAuaXRlbXMnIDogJyRzZWxlY3QuaXRlbXMnKTtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tCeUV4cCkge1xuICAgICAgICAgIGV4cHJlc3Npb24gKz0gJyB0cmFjayBieSAnICsgdGhpcy50cmFja0J5RXhwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfSBcbiAgICB9O1xuXG4gIH07XG5cbiAgc2VsZi5nZXRHcm91cE5nUmVwZWF0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJGdyb3VwIGluICRzZWxlY3QuZ3JvdXBzJztcbiAgfTtcblxufV0pO1xuXG59KCkpO1xuYW5ndWxhci5tb2R1bGUoXCJ1aS5zZWxlY3RcIikucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7JHRlbXBsYXRlQ2FjaGUucHV0KFwiYm9vdHN0cmFwL2Nob2ljZXMudHBsLmh0bWxcIixcIjx1bCBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXMgdWktc2VsZWN0LWNob2ljZXMtY29udGVudCB1aS1zZWxlY3QtZHJvcGRvd24gZHJvcGRvd24tbWVudVxcXCIgcm9sZT1cXFwibGlzdGJveFxcXCIgbmctc2hvdz1cXFwiJHNlbGVjdC5pdGVtcy5sZW5ndGggPiAwXFxcIj48bGkgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLWdyb3VwXFxcIiBpZD1cXFwidWktc2VsZWN0LWNob2ljZXMte3sgJHNlbGVjdC5nZW5lcmF0ZWRJZCB9fVxcXCI+PGRpdiBjbGFzcz1cXFwiZGl2aWRlclxcXCIgbmctc2hvdz1cXFwiJHNlbGVjdC5pc0dyb3VwZWQgJiYgJGluZGV4ID4gMFxcXCI+PC9kaXY+PGRpdiBuZy1zaG93PVxcXCIkc2VsZWN0LmlzR3JvdXBlZFxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLWdyb3VwLWxhYmVsIGRyb3Bkb3duLWhlYWRlclxcXCIgbmctYmluZD1cXFwiJGdyb3VwLm5hbWVcXFwiPjwvZGl2PjxkaXYgaWQ9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXJvdy17eyAkc2VsZWN0LmdlbmVyYXRlZElkIH19LXt7JGluZGV4fX1cXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1yb3dcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiAkc2VsZWN0LmlzQWN0aXZlKHRoaXMpLCBkaXNhYmxlZDogJHNlbGVjdC5pc0Rpc2FibGVkKHRoaXMpfVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIj48YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1yb3ctaW5uZXJcXFwiPjwvYT48L2Rpdj48L2xpPjwvdWw+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwiYm9vdHN0cmFwL21hdGNoLW11bHRpcGxlLnRwbC5odG1sXCIsXCI8c3BhbiBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoXFxcIj48c3BhbiBuZy1yZXBlYXQ9XFxcIiRpdGVtIGluICRzZWxlY3Quc2VsZWN0ZWRcXFwiPjxzcGFuIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2gtaXRlbSBidG4gYnRuLWRlZmF1bHQgYnRuLXhzXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctZGlzYWJsZWQ9XFxcIiRzZWxlY3QuZGlzYWJsZWRcXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCA9ICRpbmRleDtcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnYnRuLXByaW1hcnlcXCc6JHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggPT09ICRpbmRleCwgXFwnc2VsZWN0LWxvY2tlZFxcJzokc2VsZWN0LmlzTG9ja2VkKHRoaXMsICRpbmRleCl9XFxcIiB1aS1zZWxlY3Qtc29ydD1cXFwiJHNlbGVjdC5zZWxlY3RlZFxcXCI+PHNwYW4gY2xhc3M9XFxcImNsb3NlIHVpLXNlbGVjdC1tYXRjaC1jbG9zZVxcXCIgbmctaGlkZT1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctY2xpY2s9XFxcIiRzZWxlY3RNdWx0aXBsZS5yZW1vdmVDaG9pY2UoJGluZGV4KVxcXCI+Jm5ic3A7JnRpbWVzOzwvc3Bhbj4gPHNwYW4gdWlzLXRyYW5zY2x1ZGUtYXBwZW5kPVxcXCJcXFwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj5cIik7XG4kdGVtcGxhdGVDYWNoZS5wdXQoXCJib290c3RyYXAvbWF0Y2gudHBsLmh0bWxcIixcIjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCIgbmctaGlkZT1cXFwiJHNlbGVjdC5vcGVuXFxcIiBuZy1kaXNhYmxlZD1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctY2xhc3M9XFxcIntcXCdidG4tZGVmYXVsdC1mb2N1c1xcJzokc2VsZWN0LmZvY3VzfVxcXCI+PHNwYW4gdGFiaW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGZvcm0tY29udHJvbCB1aS1zZWxlY3QtdG9nZ2xlXFxcIiBhcmlhLWxhYmVsPVxcXCJ7eyAkc2VsZWN0LmJhc2VUaXRsZSB9fSBhY3RpdmF0ZVxcXCIgbmctZGlzYWJsZWQ9XFxcIiRzZWxlY3QuZGlzYWJsZWRcXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0LmFjdGl2YXRlKClcXFwiIHN0eWxlPVxcXCJvdXRsaW5lOiAwO1xcXCI+PHNwYW4gbmctc2hvdz1cXFwiJHNlbGVjdC5pc0VtcHR5KClcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtcGxhY2Vob2xkZXIgdGV4dC1tdXRlZFxcXCI+e3skc2VsZWN0LnBsYWNlaG9sZGVyfX08L3NwYW4+IDxzcGFuIG5nLWhpZGU9XFxcIiRzZWxlY3QuaXNFbXB0eSgpXFxcIiBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoLXRleHQgcHVsbC1sZWZ0XFxcIiBuZy1jbGFzcz1cXFwie1xcJ3VpLXNlbGVjdC1hbGxvdy1jbGVhclxcJzogJHNlbGVjdC5hbGxvd0NsZWFyICYmICEkc2VsZWN0LmlzRW1wdHkoKX1cXFwiIG5nLXRyYW5zY2x1ZGU9XFxcIlxcXCI+PC9zcGFuPiA8aSBjbGFzcz1cXFwiY2FyZXQgcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcIiRzZWxlY3QudG9nZ2xlKCRldmVudClcXFwiPjwvaT4gPGEgbmctc2hvdz1cXFwiJHNlbGVjdC5hbGxvd0NsZWFyICYmICEkc2VsZWN0LmlzRW1wdHkoKVxcXCIgYXJpYS1sYWJlbD1cXFwie3sgJHNlbGVjdC5iYXNlVGl0bGUgfX0gY2xlYXJcXFwiIHN0eWxlPVxcXCJtYXJnaW4tcmlnaHQ6IDEwcHhcXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0LmNsZWFyKCRldmVudClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXhzIGJ0bi1saW5rIHB1bGwtcmlnaHRcXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvaT48L2E+PC9zcGFuPjwvZGl2PlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcImJvb3RzdHJhcC9zZWxlY3QtbXVsdGlwbGUudHBsLmh0bWxcIixcIjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1jb250YWluZXIgdWktc2VsZWN0LW11bHRpcGxlIHVpLXNlbGVjdC1ib290c3RyYXAgZHJvcGRvd24gZm9ybS1jb250cm9sXFxcIiBuZy1jbGFzcz1cXFwie29wZW46ICRzZWxlY3Qub3Blbn1cXFwiPjxkaXY+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoXFxcIj48L2Rpdj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJmYWxzZVxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtc2VhcmNoIGlucHV0LXhzXFxcIiBwbGFjZWhvbGRlcj1cXFwie3skc2VsZWN0TXVsdGlwbGUuZ2V0UGxhY2Vob2xkZXIoKX19XFxcIiBuZy1kaXNhYmxlZD1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctaGlkZT1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctY2xpY2s9XFxcIiRzZWxlY3QuYWN0aXZhdGUoKVxcXCIgbmctbW9kZWw9XFxcIiRzZWxlY3Quc2VhcmNoXFxcIiByb2xlPVxcXCJjb21ib2JveFxcXCIgYXJpYS1sYWJlbD1cXFwie3sgJHNlbGVjdC5iYXNlVGl0bGUgfX1cXFwiIG9uZHJvcD1cXFwicmV0dXJuIGZhbHNlO1xcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiPjwvZGl2PjwvZGl2PlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcImJvb3RzdHJhcC9zZWxlY3QudHBsLmh0bWxcIixcIjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1jb250YWluZXIgdWktc2VsZWN0LWJvb3RzdHJhcCBkcm9wZG93blxcXCIgbmctY2xhc3M9XFxcIntvcGVuOiAkc2VsZWN0Lm9wZW59XFxcIj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiPjwvZGl2PjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBhdXRvY29tcGxldGU9XFxcImZhbHNlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcInRydWVcXFwiIGFyaWEtbGFiZWw9XFxcInt7ICRzZWxlY3QuYmFzZVRpdGxlIH19XFxcIiBhcmlhLW93bnM9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX1cXFwiIGFyaWEtYWN0aXZlZGVzY2VuZGFudD1cXFwidWktc2VsZWN0LWNob2ljZXMtcm93LXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX0te3sgJHNlbGVjdC5hY3RpdmVJbmRleCB9fVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB1aS1zZWxlY3Qtc2VhcmNoXFxcIiBwbGFjZWhvbGRlcj1cXFwie3skc2VsZWN0LnBsYWNlaG9sZGVyfX1cXFwiIG5nLW1vZGVsPVxcXCIkc2VsZWN0LnNlYXJjaFxcXCIgbmctc2hvdz1cXFwiJHNlbGVjdC5zZWFyY2hFbmFibGVkICYmICRzZWxlY3Qub3BlblxcXCI+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiPjwvZGl2PjwvZGl2PlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcInNlbGVjdGl6ZS9jaG9pY2VzLnRwbC5odG1sXCIsXCI8ZGl2IG5nLXNob3c9XFxcIiRzZWxlY3Qub3BlblxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzIHVpLXNlbGVjdC1kcm9wZG93biBzZWxlY3RpemUtZHJvcGRvd24gc2luZ2xlXFxcIj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1jb250ZW50IHNlbGVjdGl6ZS1kcm9wZG93bi1jb250ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1ncm91cCBvcHRncm91cFxcXCIgcm9sZT1cXFwibGlzdGJveFxcXCI+PGRpdiBuZy1zaG93PVxcXCIkc2VsZWN0LmlzR3JvdXBlZFxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLWdyb3VwLWxhYmVsIG9wdGdyb3VwLWhlYWRlclxcXCIgbmctYmluZD1cXFwiJGdyb3VwLm5hbWVcXFwiPjwvZGl2PjxkaXYgcm9sZT1cXFwib3B0aW9uXFxcIiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXMtcm93XFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogJHNlbGVjdC5pc0FjdGl2ZSh0aGlzKSwgZGlzYWJsZWQ6ICRzZWxlY3QuaXNEaXNhYmxlZCh0aGlzKX1cXFwiPjxkaXYgY2xhc3M9XFxcIm9wdGlvbiB1aS1zZWxlY3QtY2hvaWNlcy1yb3ctaW5uZXJcXFwiIGRhdGEtc2VsZWN0YWJsZT1cXFwiXFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj5cIik7XG4kdGVtcGxhdGVDYWNoZS5wdXQoXCJzZWxlY3RpemUvbWF0Y2gudHBsLmh0bWxcIixcIjxkaXYgbmctaGlkZT1cXFwiKCRzZWxlY3Qub3BlbiB8fCAkc2VsZWN0LmlzRW1wdHkoKSlcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiIG5nLXRyYW5zY2x1ZGU9XFxcIlxcXCI+PC9kaXY+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwic2VsZWN0aXplL3NlbGVjdC50cGwuaHRtbFwiLFwiPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNvbnRhaW5lciBzZWxlY3RpemUtY29udHJvbCBzaW5nbGVcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnb3BlblxcJzogJHNlbGVjdC5vcGVufVxcXCI+PGRpdiBjbGFzcz1cXFwic2VsZWN0aXplLWlucHV0XFxcIiBuZy1jbGFzcz1cXFwie1xcJ2ZvY3VzXFwnOiAkc2VsZWN0Lm9wZW4sIFxcJ2Rpc2FibGVkXFwnOiAkc2VsZWN0LmRpc2FibGVkLCBcXCdzZWxlY3RpemUtZm9jdXNcXCcgOiAkc2VsZWN0LmZvY3VzfVxcXCIgbmctY2xpY2s9XFxcIiRzZWxlY3QuYWN0aXZhdGUoKVxcXCI+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoXFxcIj48L2Rpdj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJmYWxzZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwidWktc2VsZWN0LXNlYXJjaCB1aS1zZWxlY3QtdG9nZ2xlXFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdC50b2dnbGUoJGV2ZW50KVxcXCIgcGxhY2Vob2xkZXI9XFxcInt7JHNlbGVjdC5wbGFjZWhvbGRlcn19XFxcIiBuZy1tb2RlbD1cXFwiJHNlbGVjdC5zZWFyY2hcXFwiIG5nLWhpZGU9XFxcIiEkc2VsZWN0LnNlYXJjaEVuYWJsZWQgfHwgKCRzZWxlY3Quc2VsZWN0ZWQgJiYgISRzZWxlY3Qub3BlbilcXFwiIG5nLWRpc2FibGVkPVxcXCIkc2VsZWN0LmRpc2FibGVkXFxcIiBhcmlhLWxhYmVsPVxcXCJ7eyAkc2VsZWN0LmJhc2VUaXRsZSB9fVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiPjwvZGl2PjwvZGl2PlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcInNlbGVjdDIvY2hvaWNlcy50cGwuaHRtbFwiLFwiPHVsIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcyB1aS1zZWxlY3QtY2hvaWNlcy1jb250ZW50IHNlbGVjdDItcmVzdWx0c1xcXCI+PGxpIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1ncm91cFxcXCIgbmctY2xhc3M9XFxcIntcXCdzZWxlY3QyLXJlc3VsdC13aXRoLWNoaWxkcmVuXFwnOiAkc2VsZWN0LmNob2ljZUdyb3VwZWQoJGdyb3VwKSB9XFxcIj48ZGl2IG5nLXNob3c9XFxcIiRzZWxlY3QuY2hvaWNlR3JvdXBlZCgkZ3JvdXApXFxcIiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXMtZ3JvdXAtbGFiZWwgc2VsZWN0Mi1yZXN1bHQtbGFiZWxcXFwiIG5nLWJpbmQ9XFxcIiRncm91cC5uYW1lXFxcIj48L2Rpdj48dWwgcm9sZT1cXFwibGlzdGJveFxcXCIgaWQ9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX1cXFwiIG5nLWNsYXNzPVxcXCJ7XFwnc2VsZWN0Mi1yZXN1bHQtc3ViXFwnOiAkc2VsZWN0LmNob2ljZUdyb3VwZWQoJGdyb3VwKSwgXFwnc2VsZWN0Mi1yZXN1bHQtc2luZ2xlXFwnOiAhJHNlbGVjdC5jaG9pY2VHcm91cGVkKCRncm91cCkgfVxcXCI+PGxpIHJvbGU9XFxcIm9wdGlvblxcXCIgaWQ9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXJvdy17eyAkc2VsZWN0LmdlbmVyYXRlZElkIH19LXt7JGluZGV4fX1cXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1yb3dcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnc2VsZWN0Mi1oaWdobGlnaHRlZFxcJzogJHNlbGVjdC5pc0FjdGl2ZSh0aGlzKSwgXFwnc2VsZWN0Mi1kaXNhYmxlZFxcJzogJHNlbGVjdC5pc0Rpc2FibGVkKHRoaXMpfVxcXCI+PGRpdiBjbGFzcz1cXFwic2VsZWN0Mi1yZXN1bHQtbGFiZWwgdWktc2VsZWN0LWNob2ljZXMtcm93LWlubmVyXFxcIj48L2Rpdj48L2xpPjwvdWw+PC9saT48L3VsPlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcInNlbGVjdDIvbWF0Y2gtbXVsdGlwbGUudHBsLmh0bWxcIixcIjxzcGFuIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiPjxsaSBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoLWl0ZW0gc2VsZWN0Mi1zZWFyY2gtY2hvaWNlXFxcIiBuZy1yZXBlYXQ9XFxcIiRpdGVtIGluICRzZWxlY3Quc2VsZWN0ZWRcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnc2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWZvY3VzXFwnOiRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4ID09PSAkaW5kZXgsIFxcJ3NlbGVjdDItbG9ja2VkXFwnOiRzZWxlY3QuaXNMb2NrZWQodGhpcywgJGluZGV4KX1cXFwiIHVpLXNlbGVjdC1zb3J0PVxcXCIkc2VsZWN0LnNlbGVjdGVkXFxcIj48c3BhbiB1aXMtdHJhbnNjbHVkZS1hcHBlbmQ9XFxcIlxcXCI+PC9zcGFuPiA8YSBocmVmPVxcXCJqYXZhc2NyaXB0OjtcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2gtY2xvc2Ugc2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWNsb3NlXFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdE11bHRpcGxlLnJlbW92ZUNob2ljZSgkaW5kZXgpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjwvYT48L2xpPjwvc3Bhbj5cIik7XG4kdGVtcGxhdGVDYWNoZS5wdXQoXCJzZWxlY3QyL21hdGNoLnRwbC5odG1sXCIsXCI8YSBjbGFzcz1cXFwic2VsZWN0Mi1jaG9pY2UgdWktc2VsZWN0LW1hdGNoXFxcIiBuZy1jbGFzcz1cXFwie1xcJ3NlbGVjdDItZGVmYXVsdFxcJzogJHNlbGVjdC5pc0VtcHR5KCl9XFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdC50b2dnbGUoJGV2ZW50KVxcXCIgYXJpYS1sYWJlbD1cXFwie3sgJHNlbGVjdC5iYXNlVGl0bGUgfX0gc2VsZWN0XFxcIj48c3BhbiBuZy1zaG93PVxcXCIkc2VsZWN0LmlzRW1wdHkoKVxcXCIgY2xhc3M9XFxcInNlbGVjdDItY2hvc2VuXFxcIj57eyRzZWxlY3QucGxhY2Vob2xkZXJ9fTwvc3Bhbj4gPHNwYW4gbmctaGlkZT1cXFwiJHNlbGVjdC5pc0VtcHR5KClcXFwiIGNsYXNzPVxcXCJzZWxlY3QyLWNob3NlblxcXCIgbmctdHJhbnNjbHVkZT1cXFwiXFxcIj48L3NwYW4+IDxhYmJyIG5nLWlmPVxcXCIkc2VsZWN0LmFsbG93Q2xlYXIgJiYgISRzZWxlY3QuaXNFbXB0eSgpXFxcIiBjbGFzcz1cXFwic2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWNsb3NlXFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdC5jbGVhcigkZXZlbnQpXFxcIj48L2FiYnI+IDxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLWFycm93IHVpLXNlbGVjdC10b2dnbGVcXFwiPjxiPjwvYj48L3NwYW4+PC9hPlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcInNlbGVjdDIvc2VsZWN0LW11bHRpcGxlLnRwbC5odG1sXCIsXCI8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY29udGFpbmVyIHVpLXNlbGVjdC1tdWx0aXBsZSBzZWxlY3QyIHNlbGVjdDItY29udGFpbmVyIHNlbGVjdDItY29udGFpbmVyLW11bHRpXFxcIiBuZy1jbGFzcz1cXFwie1xcJ3NlbGVjdDItY29udGFpbmVyLWFjdGl2ZSBzZWxlY3QyLWRyb3Bkb3duLW9wZW4gb3BlblxcJzogJHNlbGVjdC5vcGVuLCBcXCdzZWxlY3QyLWNvbnRhaW5lci1kaXNhYmxlZFxcJzogJHNlbGVjdC5kaXNhYmxlZH1cXFwiPjx1bCBjbGFzcz1cXFwic2VsZWN0Mi1jaG9pY2VzXFxcIj48c3BhbiBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoXFxcIj48L3NwYW4+PGxpIGNsYXNzPVxcXCJzZWxlY3QyLXNlYXJjaC1maWVsZFxcXCI+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGF1dG9jb21wbGV0ZT1cXFwiZmFsc2VcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIGF1dG9jYXBpdGFsaXplPVxcXCJvZmZcXFwiIHNwZWxsY2hlY2s9XFxcImZhbHNlXFxcIiByb2xlPVxcXCJjb21ib2JveFxcXCIgYXJpYS1leHBhbmRlZD1cXFwidHJ1ZVxcXCIgYXJpYS1vd25zPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy17eyAkc2VsZWN0LmdlbmVyYXRlZElkIH19XFxcIiBhcmlhLWxhYmVsPVxcXCJ7eyAkc2VsZWN0LmJhc2VUaXRsZSB9fVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1yb3cte3sgJHNlbGVjdC5nZW5lcmF0ZWRJZCB9fS17eyAkc2VsZWN0LmFjdGl2ZUluZGV4IH19XFxcIiBjbGFzcz1cXFwic2VsZWN0Mi1pbnB1dCB1aS1zZWxlY3Qtc2VhcmNoXFxcIiBwbGFjZWhvbGRlcj1cXFwie3skc2VsZWN0TXVsdGlwbGUuZ2V0UGxhY2Vob2xkZXIoKX19XFxcIiBuZy1kaXNhYmxlZD1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctaGlkZT1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctbW9kZWw9XFxcIiRzZWxlY3Quc2VhcmNoXFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdC5hY3RpdmF0ZSgpXFxcIiBzdHlsZT1cXFwid2lkdGg6IDM0cHg7XFxcIiBvbmRyb3A9XFxcInJldHVybiBmYWxzZTtcXFwiPjwvbGk+PC91bD48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtZHJvcGRvd24gc2VsZWN0Mi1kcm9wIHNlbGVjdDItd2l0aC1zZWFyY2hib3ggc2VsZWN0Mi1kcm9wLWFjdGl2ZVxcXCIgbmctY2xhc3M9XFxcIntcXCdzZWxlY3QyLWRpc3BsYXktbm9uZVxcJzogISRzZWxlY3Qub3Blbn1cXFwiPjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzXFxcIj48L2Rpdj48L2Rpdj48L2Rpdj5cIik7XG4kdGVtcGxhdGVDYWNoZS5wdXQoXCJzZWxlY3QyL3NlbGVjdC50cGwuaHRtbFwiLFwiPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNvbnRhaW5lciBzZWxlY3QyIHNlbGVjdDItY29udGFpbmVyXFxcIiBuZy1jbGFzcz1cXFwie1xcJ3NlbGVjdDItY29udGFpbmVyLWFjdGl2ZSBzZWxlY3QyLWRyb3Bkb3duLW9wZW4gb3BlblxcJzogJHNlbGVjdC5vcGVuLCBcXCdzZWxlY3QyLWNvbnRhaW5lci1kaXNhYmxlZFxcJzogJHNlbGVjdC5kaXNhYmxlZCwgXFwnc2VsZWN0Mi1jb250YWluZXItYWN0aXZlXFwnOiAkc2VsZWN0LmZvY3VzLCBcXCdzZWxlY3QyLWFsbG93Y2xlYXJcXCc6ICRzZWxlY3QuYWxsb3dDbGVhciAmJiAhJHNlbGVjdC5pc0VtcHR5KCl9XFxcIj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1kcm9wZG93biBzZWxlY3QyLWRyb3Agc2VsZWN0Mi13aXRoLXNlYXJjaGJveCBzZWxlY3QyLWRyb3AtYWN0aXZlXFxcIiBuZy1jbGFzcz1cXFwie1xcJ3NlbGVjdDItZGlzcGxheS1ub25lXFwnOiAhJHNlbGVjdC5vcGVufVxcXCI+PGRpdiBjbGFzcz1cXFwic2VsZWN0Mi1zZWFyY2hcXFwiIG5nLXNob3c9XFxcIiRzZWxlY3Quc2VhcmNoRW5hYmxlZFxcXCI+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGF1dG9jb21wbGV0ZT1cXFwiZmFsc2VcXFwiIGF1dG9jb3JyZWN0PVxcXCJmYWxzZVxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiIHJvbGU9XFxcImNvbWJvYm94XFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJ0cnVlXFxcIiBhcmlhLW93bnM9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX1cXFwiIGFyaWEtbGFiZWw9XFxcInt7ICRzZWxlY3QuYmFzZVRpdGxlIH19XFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXJvdy17eyAkc2VsZWN0LmdlbmVyYXRlZElkIH19LXt7ICRzZWxlY3QuYWN0aXZlSW5kZXggfX1cXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtc2VhcmNoIHNlbGVjdDItaW5wdXRcXFwiIG5nLW1vZGVsPVxcXCIkc2VsZWN0LnNlYXJjaFxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PlwiKTt9XSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdWktc2VsZWN0L2Rpc3Qvc2VsZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2VsZWN0LmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2VsZWN0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2VsZWN0LmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vdWktc2VsZWN0L2Rpc3Qvc2VsZWN0LmNzc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIHVpLXNlbGVjdFxcbiAqIGh0dHA6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktc2VsZWN0XFxuICogVmVyc2lvbjogMC4xMy4yIC0gMjAxNS0xMC0wOVQxNTozNDoyNC4wNDVaXFxuICogTGljZW5zZTogTUlUXFxuICovXFxuXFxuXFxuLyogU3R5bGUgd2hlbiBoaWdobGlnaHRpbmcgYSBzZWFyY2guICovXFxuLnVpLXNlbGVjdC1oaWdobGlnaHQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi51aS1zZWxlY3Qtb2Zmc2NyZWVuIHtcXG4gIGNsaXA6IHJlY3QoMCAwIDAgMCkgIWltcG9ydGFudDtcXG4gIHdpZHRoOiAxcHggIWltcG9ydGFudDtcXG4gIGhlaWdodDogMXB4ICFpbXBvcnRhbnQ7XFxuICBib3JkZXI6IDAgIWltcG9ydGFudDtcXG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xcbiAgcGFkZGluZzogMCAhaW1wb3J0YW50O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xcbiAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XFxuICBvdXRsaW5lOiAwICFpbXBvcnRhbnQ7XFxuICBsZWZ0OiAwcHggIWltcG9ydGFudDtcXG4gIHRvcDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi51aS1zZWxlY3QtY2hvaWNlcy1yb3c6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTtcXG59XFxuXFxuLyogU2VsZWN0MiB0aGVtZSAqL1xcblxcbi8qIE1hcmsgaW52YWxpZCBTZWxlY3QyICovXFxuLm5nLWRpcnR5Lm5nLWludmFsaWQgPiBhLnNlbGVjdDItY2hvaWNlIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjRDQ0OTUwO1xcbn1cXG5cXG4uc2VsZWN0Mi1yZXN1bHQtc2luZ2xlIHtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG59XFxuXFxuLnNlbGVjdDItbG9ja2VkID4gLnNlbGVjdDItc2VhcmNoLWNob2ljZS1jbG9zZXtcXG4gIGRpc3BsYXk6bm9uZTtcXG59XFxuXFxuLnNlbGVjdC1sb2NrZWQgPiAudWktc2VsZWN0LW1hdGNoLWNsb3Nle1xcbiAgICBkaXNwbGF5Om5vbmU7XFxufVxcblxcbmJvZHkgPiAuc2VsZWN0Mi1jb250YWluZXIub3BlbiB7XFxuICB6LWluZGV4OiA5OTk5OyAvKiBUaGUgei1pbmRleCBTZWxlY3QyIGFwcGxpZXMgdG8gdGhlIHNlbGVjdDItZHJvcCAqL1xcbn1cXG5cXG4vKiBIYW5kbGUgdXAgZGlyZWN0aW9uIFNlbGVjdDIgKi9cXG4udWktc2VsZWN0LWNvbnRhaW5lclt0aGVtZT1cXFwic2VsZWN0MlxcXCJdLmRpcmVjdGlvbi11cCAudWktc2VsZWN0LW1hdGNoIHtcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4OyAvKiBGSVhNRSBoYXJkY29kZWQgdmFsdWUgOi0vICovXFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbn1cXG4udWktc2VsZWN0LWNvbnRhaW5lclt0aGVtZT1cXFwic2VsZWN0MlxcXCJdLmRpcmVjdGlvbi11cCAudWktc2VsZWN0LWRyb3Bkb3duIHtcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4OyAvKiBGSVhNRSBoYXJkY29kZWQgdmFsdWUgOi0vICovXFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcblxcbiAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7ICAvKiBGSVhNRSBoYXJkY29kZWQgdmFsdWUgOi0vICovXFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcblxcbiAgICBib3gtc2hhZG93OiAwIC00cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuXFxuICAgIG1hcmdpbi10b3A6IC00cHg7IC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG59XFxuLnVpLXNlbGVjdC1jb250YWluZXJbdGhlbWU9XFxcInNlbGVjdDJcXFwiXS5kaXJlY3Rpb24tdXAgLnVpLXNlbGVjdC1kcm9wZG93biAuc2VsZWN0Mi1zZWFyY2gge1xcbiAgICBtYXJnaW4tdG9wOiA0cHg7IC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG59XFxuLnVpLXNlbGVjdC1jb250YWluZXJbdGhlbWU9XFxcInNlbGVjdDJcXFwiXS5kaXJlY3Rpb24tdXAuc2VsZWN0Mi1kcm9wZG93bi1vcGVuIC51aS1zZWxlY3QtbWF0Y2gge1xcbiAgICBib3JkZXItYm90dG9tLWNvbG9yOiAjNTg5N2ZiO1xcbn1cXG5cXG4vKiBTZWxlY3RpemUgdGhlbWUgKi9cXG5cXG4vKiBIZWxwZXIgY2xhc3MgdG8gc2hvdyBzdHlsZXMgd2hlbiBmb2N1cyAqL1xcbi5zZWxlY3RpemUtaW5wdXQuc2VsZWN0aXplLWZvY3Vze1xcbiAgYm9yZGVyLWNvbG9yOiAjMDA3RkJCICFpbXBvcnRhbnQ7XFxufVxcblxcbi8qIEZpeCBpbnB1dCB3aWR0aCBmb3IgU2VsZWN0aXplIHRoZW1lICovXFxuLnNlbGVjdGl6ZS1jb250cm9sID4gLnNlbGVjdGl6ZS1pbnB1dCA+IGlucHV0IHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4vKiBGaXggZHJvcGRvd24gd2lkdGggZm9yIFNlbGVjdGl6ZSB0aGVtZSAqL1xcbi5zZWxlY3RpemUtY29udHJvbCA+IC5zZWxlY3RpemUtZHJvcGRvd24ge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi8qIE1hcmsgaW52YWxpZCBTZWxlY3RpemUgKi9cXG4ubmctZGlydHkubmctaW52YWxpZCA+IGRpdi5zZWxlY3RpemUtaW5wdXQge1xcbiAgICBib3JkZXItY29sb3I6ICNENDQ5NTA7XFxufVxcblxcbi8qIEhhbmRsZSB1cCBkaXJlY3Rpb24gU2VsZWN0aXplICovXFxuLnVpLXNlbGVjdC1jb250YWluZXJbdGhlbWU9XFxcInNlbGVjdGl6ZVxcXCJdLmRpcmVjdGlvbi11cCAudWktc2VsZWN0LWRyb3Bkb3duIHtcXG4gICAgYm94LXNoYWRvdzogMCAtNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcblxcbiAgICBtYXJnaW4tdG9wOiAtMnB4OyAvKiBGSVhNRSBoYXJkY29kZWQgdmFsdWUgOi0vICovXFxufVxcblxcbi8qIEJvb3RzdHJhcCB0aGVtZSAqL1xcblxcbi8qIEhlbHBlciBjbGFzcyB0byBzaG93IHN0eWxlcyB3aGVuIGZvY3VzICovXFxuLmJ0bi1kZWZhdWx0LWZvY3VzIHtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0VCRUJFQjtcXG4gIGJvcmRlci1jb2xvcjogI0FEQURBRDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4wNzUpLCAwIDAgOHB4IHJnYmEoMTAyLCAxNzUsIDIzMywgMC42KTtcXG59XFxuXFxuLnVpLXNlbGVjdC1ib290c3RyYXAgLnVpLXNlbGVjdC10b2dnbGUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4udWktc2VsZWN0LWJvb3RzdHJhcCAudWktc2VsZWN0LXRvZ2dsZSA+IC5jYXJldCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICB0b3A6IDUwJTtcXG4gIHJpZ2h0OiAxMHB4O1xcbiAgbWFyZ2luLXRvcDogLTJweDtcXG59XFxuXFxuLyogRml4IEJvb3RzdHJhcCBkcm9wZG93biBwb3NpdGlvbiB3aGVuIGluc2lkZSBhIGlucHV0LWdyb3VwICovXFxuLmlucHV0LWdyb3VwID4gLnVpLXNlbGVjdC1ib290c3RyYXAuZHJvcGRvd24ge1xcbiAgLyogSW5zdGVhZCBvZiByZWxhdGl2ZSAqL1xcbiAgcG9zaXRpb246IHN0YXRpYztcXG59XFxuXFxuLmlucHV0LWdyb3VwID4gLnVpLXNlbGVjdC1ib290c3RyYXAgPiBpbnB1dC51aS1zZWxlY3Qtc2VhcmNoLmZvcm0tY29udHJvbCB7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7IC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxufVxcbi5pbnB1dC1ncm91cCA+IC51aS1zZWxlY3QtYm9vdHN0cmFwID4gaW5wdXQudWktc2VsZWN0LXNlYXJjaC5mb3JtLWNvbnRyb2wuZGlyZWN0aW9uLXVwIHtcXG4gIGJvcmRlci1yYWRpdXM6IDRweCAhaW1wb3J0YW50OyAvKiBGSVhNRSBoYXJkY29kZWQgdmFsdWUgOi0vICovXFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMCAhaW1wb3J0YW50O1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDAgIWltcG9ydGFudDtcXG59XFxuXFxuLnVpLXNlbGVjdC1ib290c3RyYXAgPiAudWktc2VsZWN0LW1hdGNoID4gLmJ0bntcXG4gIC8qIEluc3RlYWQgb2YgY2VudGVyIGJlY2F1c2Ugb2YgLmJ0biAqL1xcbiAgdGV4dC1hbGlnbjogbGVmdCAhaW1wb3J0YW50O1xcbn1cXG5cXG4udWktc2VsZWN0LWJvb3RzdHJhcCA+IC51aS1zZWxlY3QtbWF0Y2ggPiAuY2FyZXQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA0NSU7XFxuICByaWdodDogMTVweDtcXG59XFxuXFxuLyogU2VlIFNjcm9sbGFibGUgTWVudSB3aXRoIEJvb3RzdHJhcCAzIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTkyMjc0OTYgKi9cXG4udWktc2VsZWN0LWJvb3RzdHJhcCA+IC51aS1zZWxlY3QtY2hvaWNlcyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgbWFyZ2luLXRvcDogLTFweDtcXG59XFxuXFxuYm9keSA+IC51aS1zZWxlY3QtYm9vdHN0cmFwLm9wZW4ge1xcbiAgei1pbmRleDogMTAwMDsgLyogU3RhbmRhcmQgQm9vdHN0cmFwIGRyb3Bkb3duIHotaW5kZXggKi9cXG59XFxuXFxuLnVpLXNlbGVjdC1tdWx0aXBsZS51aS1zZWxlY3QtYm9vdHN0cmFwIHtcXG4gIGhlaWdodDogYXV0bztcXG4gIHBhZGRpbmc6IDNweCAzcHggMCAzcHg7XFxufVxcblxcbi51aS1zZWxlY3QtbXVsdGlwbGUudWktc2VsZWN0LWJvb3RzdHJhcCBpbnB1dC51aS1zZWxlY3Qtc2VhcmNoIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7IC8qIFRvIHByZXZlbnQgZG91YmxlIGJhY2tncm91bmQgd2hlbiBkaXNhYmxlZCAqL1xcbiAgYm9yZGVyOiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIGhlaWdodDogMS42NjY2NjZlbTtcXG4gIG1hcmdpbi1ib3R0b206IDNweDtcXG59XFxuXFxuLnVpLXNlbGVjdC1tdWx0aXBsZS51aS1zZWxlY3QtYm9vdHN0cmFwIC51aS1zZWxlY3QtbWF0Y2ggLmNsb3NlIHtcXG4gIGZvbnQtc2l6ZTogMS42ZW07XFxuICBsaW5lLWhlaWdodDogMC43NTtcXG59XFxuXFxuLnVpLXNlbGVjdC1tdWx0aXBsZS51aS1zZWxlY3QtYm9vdHN0cmFwIC51aS1zZWxlY3QtbWF0Y2gtaXRlbSB7XFxuICBvdXRsaW5lOiAwO1xcbiAgbWFyZ2luOiAwIDNweCAzcHggMDtcXG59XFxuXFxuLnVpLXNlbGVjdC1tdWx0aXBsZSAudWktc2VsZWN0LW1hdGNoLWl0ZW0ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4udWktc2VsZWN0LW11bHRpcGxlIC51aS1zZWxlY3QtbWF0Y2gtaXRlbS5kcm9wcGluZy1iZWZvcmU6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgcmlnaHQ6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW4tcmlnaHQ6IDJweDtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgIzQyOGJjYTtcXG59XFxuXFxuLnVpLXNlbGVjdC1tdWx0aXBsZSAudWktc2VsZWN0LW1hdGNoLWl0ZW0uZHJvcHBpbmctYWZ0ZXI6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgbWFyZ2luLWxlZnQ6IDJweDtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICM0MjhiY2E7XFxufVxcblxcbi51aS1zZWxlY3QtYm9vdHN0cmFwIC51aS1zZWxlY3QtY2hvaWNlcy1yb3c+YSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBwYWRkaW5nOiAzcHggMjBweDtcXG4gICAgY2xlYXI6IGJvdGg7XFxuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjQyODU3MTQzO1xcbiAgICBjb2xvcjogIzMzMztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxuLnVpLXNlbGVjdC1ib290c3RyYXAgLnVpLXNlbGVjdC1jaG9pY2VzLXJvdz5hOmhvdmVyLCAudWktc2VsZWN0LWJvb3RzdHJhcCAudWktc2VsZWN0LWNob2ljZXMtcm93PmE6Zm9jdXMge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIGNvbG9yOiAjMjYyNjI2O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNWY1O1xcbn1cXG5cXG4udWktc2VsZWN0LWJvb3RzdHJhcCAudWktc2VsZWN0LWNob2ljZXMtcm93LmFjdGl2ZT5hIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgb3V0bGluZTogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQyOGJjYTtcXG59XFxuXFxuLnVpLXNlbGVjdC1ib290c3RyYXAgLnVpLXNlbGVjdC1jaG9pY2VzLXJvdy5kaXNhYmxlZD5hLFxcbi51aS1zZWxlY3QtYm9vdHN0cmFwIC51aS1zZWxlY3QtY2hvaWNlcy1yb3cuYWN0aXZlLmRpc2FibGVkPmEge1xcbiAgICBjb2xvcjogIzc3NztcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG59XFxuXFxuLyogZml4IGhpZGUvc2hvdyBhbmd1bGFyIGFuaW1hdGlvbiAqL1xcbi51aS1zZWxlY3QtbWF0Y2gubmctaGlkZS1hZGQsXFxuLnVpLXNlbGVjdC1zZWFyY2gubmctaGlkZS1hZGQge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxufVxcblxcbi8qIE1hcmsgaW52YWxpZCBCb290c3RyYXAgKi9cXG4udWktc2VsZWN0LWJvb3RzdHJhcC5uZy1kaXJ0eS5uZy1pbnZhbGlkID4gYnV0dG9uLmJ0bi51aS1zZWxlY3QtbWF0Y2gge1xcbiAgICBib3JkZXItY29sb3I6ICNENDQ5NTA7XFxufVxcblxcbi8qIEhhbmRsZSB1cCBkaXJlY3Rpb24gQm9vdHN0cmFwICovXFxuLnVpLXNlbGVjdC1jb250YWluZXJbdGhlbWU9XFxcImJvb3RzdHJhcFxcXCJdLmRpcmVjdGlvbi11cCAudWktc2VsZWN0LWRyb3Bkb3duIHtcXG4gICAgYm94LXNoYWRvdzogMCAtNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuY3NzXG4gKiogbW9kdWxlIGlkID0gMTMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwidmFsaWRhdGlvbi1pbnB1dC1ncm91cFxcXCI+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiZmllbGQgdmFsaWRhdGlvbi1pbnB1dFxcXCIgbmctY2xhc3M9XFxcInsgJ2hhcy1lcnJvcic6IHNlbGVjdC5uZ01vZGVsLiRpbnZhbGlkIH1cXFwiPlxcclxcblxcdFxcdDxsYWJlbCBuZy1zaG93PVxcXCJzZWxlY3Quc2VsZWN0aW9uXFxcIiBjbGFzcz1cXFwic2hvdy1oaWRlIGFuZ3VsYXItYW5pbWF0ZVxcXCI+XFxyXFxuXFx0XFx0XFx0e3tzZWxlY3QubGFiZWx9fSA8c3BhbiBjbGFzcz1cXFwicHVsbC1yaWdodCBlcnJvci1zdHJpbmdcXFwiPnt7c2VsZWN0LnNlbGVjdFZhbGlkYXRvci5lcnJvcn19PC9zcGFuPlxcclxcblxcdFxcdDwvbGFiZWw+XFxyXFxuXFx0XFx0PHVpLXNlbGVjdCBuZy1tb2RlbD1cXFwic2VsZWN0LnNlbGVjdGlvblxcXCIgc2VhcmNoLWVuYWJsZWQ9XFxcImZhbHNlXFxcIiB0aGVtZT1cXFwiYm9vdHN0cmFwXFxcIiBuZy1kaXNhYmxlZD1cXFwic2VsZWN0Lm5nRGlzYWJsZWRcXFwiPlxcclxcblxcdFxcdFxcdDx1aS1zZWxlY3QtbWF0Y2ggcGxhY2Vob2xkZXI9XFxcInt7c2VsZWN0LmxhYmVsfX1cXFwiPnt7c2VsZWN0LmdldERpc3BsYXlOYW1lKCRzZWxlY3Quc2VsZWN0ZWQpfX08L3VpLXNlbGVjdC1tYXRjaD5cXHJcXG5cXHRcXHRcXHQ8dWktc2VsZWN0LWNob2ljZXMgcmVwZWF0PVxcXCJvcHRpb24gaW4gc2VsZWN0Lm9wdGlvbnNcXFwiPlxcclxcblxcdFxcdFxcdFxcdHt7c2VsZWN0LmdldERpc3BsYXlOYW1lKG9wdGlvbil9fVxcclxcblxcdFxcdFxcdDwvdWktc2VsZWN0LWNob2ljZXM+XFxyXFxuXFx0XFx0PC91aS1zZWxlY3Q+XFxyXFxuXFx0XFx0PHJsLWJ1c3kgbG9hZGluZz1cXFwic2VsZWN0LmxvYWRpbmdcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8aSBjbGFzcz1cXFwiZmEgZmEtZXhjbGFtYXRpb24tdHJpYW5nbGUgdGV4dC1kYW5nZXJcXFwiIG5nLXNob3c9XFxcInNlbGVjdC5uZ01vZGVsLiRlcnJvci5yZXF1aXJlZFxcXCI+PC9pPlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDEzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIFNpZ25hdHVyZVBhZCA9IHJlcXVpcmUoJ3NpZ25hdHVyZV9wYWQnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuc2lnbmF0dXJlUGFkJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsU2lnbmF0dXJlUGFkJztcclxuZnVuY3Rpb24gc2lnbmF0dXJlUGFkKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8Y2FudmFzIGNsYXNzPVxcXCJzaWduYXR1cmUtcGFkXFxcIiBuZy1pZj1cXFwiIW5nRGlzYWJsZWRcXFwiPjwvY2FudmFzPlxcblxcdFxcdFxcdDxpbWcgbmctc3JjPVxcXCJ7e25nTW9kZWwuJHZpZXdWYWx1ZX19XFxcIiBuZy1zdHlsZT1cXFwic3R5bGVcXFwiIG5nLWlmPVxcXCJuZ0Rpc2FibGVkXFxcIiAvPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIHBhZDogJz0nLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICc9JyxcclxuICAgICAgICAgICAgd2lkdGg6ICc9JyxcclxuICAgICAgICAgICAgbmdEaXNhYmxlZDogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ25nRGlzYWJsZWQnLCBmdW5jdGlvbiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlLm5nTW9kZWwgPSBuZ01vZGVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogc2NvcGUuaGVpZ2h0ICE9IG51bGwgPyBzY29wZS5oZWlnaHQgOiAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzY29wZS53aWR0aCAhPSBudWxsID8gc2NvcGUud2lkdGggOiAyMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBlbGVtZW50LmZpbmQoJy5zaWduYXR1cmUtcGFkJykuZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjU1LCAyNTUsIDI1NSknLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFkID0gbmV3IFNpZ25hdHVyZVBhZChjYW52YXMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzY29wZS5oZWlnaHQgIT0gbnVsbCA/IHNjb3BlLmhlaWdodCA6IDEwMDtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBzY29wZS53aWR0aCAhPSBudWxsID8gc2NvcGUud2lkdGggOiAyMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nTW9kZWwuJHZpZXdWYWx1ZTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wYWQuZnJvbURhdGFVUkwodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlLnBhZC50b0RhdGFVUkwoKTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2lnbmF0dXJlUGFkID0gc2lnbmF0dXJlUGFkO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHNpZ25hdHVyZVBhZCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZVBhZC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc2lnbmF0dXJlUGFkL3NpZ25hdHVyZVBhZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgY2FyZCA9IHJlcXVpcmUoJy4vc2ltcGxlQ2FyZCcpO1xyXG5leHBvcnRzLnNpbXBsZUNhcmQgPSBjYXJkO1xyXG52YXIgbGlzdCA9IHJlcXVpcmUoJy4vc2ltcGxlQ2FyZExpc3QnKTtcclxuZXhwb3J0cy5zaW1wbGVDYXJkTGlzdCA9IGxpc3Q7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnNpbXBsZUNhcmRMaXN0JztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYnNlcnZhYmxlLm1vZHVsZU5hbWUsIF9fcGFyZW50Q2hpbGQubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGxpc3QuZGlyZWN0aXZlTmFtZSwgbGlzdC5zaW1wbGVDYXJkTGlzdClcclxuICAgIC5jb250cm9sbGVyKGxpc3QuY29udHJvbGxlck5hbWUsIGxpc3QuU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyKVxyXG4gICAgLmRpcmVjdGl2ZShjYXJkLmRpcmVjdGl2ZU5hbWUsIGNhcmQuc2ltcGxlQ2FyZClcclxuICAgIC5jb250cm9sbGVyKGNhcmQuY29udHJvbGxlck5hbWUsIGNhcmQuU2ltcGxlQ2FyZENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVDYXJkTGlzdC5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmRMaXN0Lm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4vLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2pxdWVyeS9qcXVlcnkuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTaW1wbGVDYXJkJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdTaW1wbGVDYXJkQ29udHJvbGxlcic7XHJcbnZhciBTaW1wbGVDYXJkQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaW1wbGVDYXJkQ29udHJvbGxlcigkc2NvcGUsICRlbGVtZW50LCBwYXJlbnRDaGlsZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZCA9IHBhcmVudENoaWxkO1xyXG4gICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmF1dG9zYXZlTGluayA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5zaG93Q29udGVudCA9PT0gZmFsc2UgfHwgX3RoaXMuYWx3YXlzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmF1dG9zYXZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5jYW5PcGVuID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW5PcGVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0Q29udHJvbGxlciA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ3JsU2ltcGxlQ2FyZExpc3QnKTtcclxuICAgICAgICBpZiAodGhpcy5saXN0Q29udHJvbGxlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdENvbnRyb2xsZXIgPSB0aGlzLm5vTGlzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmVoYXZpb3IgPSB7XHJcbiAgICAgICAgICAgIGF1dG9zYXZlOiB0aGlzLmF1dG9zYXZlLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIGNsb3NlOiB0aGlzLmNsb3NlLFxyXG4gICAgICAgICAgICBzZXRBbHdheXNPcGVuOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFsd2F5c09wZW4gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGlzdENvbnRyb2xsZXIucmVnaXN0ZXJDYXJkKGJlaGF2aW9yKTtcclxuICAgICAgICBwYXJlbnRDaGlsZC5yZWdpc3RlckNoaWxkQmVoYXZpb3IodGhpcy5jaGlsZExpbmssIGJlaGF2aW9yKTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFsd2F5c09wZW47IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNob3dDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFNpbXBsZUNhcmRDb250cm9sbGVyLnByb3RvdHlwZS50b2dnbGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dDb250ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaW1wbGVDYXJkQ29udHJvbGxlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5PcGVuICYmIHRoaXMubGlzdENvbnRyb2xsZXIub3BlbkNhcmQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU2ltcGxlQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLmF1dG9zYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Q2hpbGQudHJpZ2dlckNoaWxkQmVoYXZpb3IodGhpcy5hdXRvc2F2ZUxpbmssIGZ1bmN0aW9uIChiZWhhdmlvcikge1xyXG4gICAgICAgICAgICB2YXIgY2FuQ2xvc2UgPSBiZWhhdmlvci5hdXRvc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAoY2FuQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNob3dDb250ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbkNsb3NlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFNpbXBsZUNhcmRDb250cm9sbGVyLnByb3RvdHlwZS5ub0xpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3BlbkNhcmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWdpc3RlckNhcmQ6IGZ1bmN0aW9uIChiZWhhdmlvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBTaW1wbGVDYXJkQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGVsZW1lbnQnLCBfX3BhcmVudENoaWxkLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBTaW1wbGVDYXJkQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TaW1wbGVDYXJkQ29udHJvbGxlciA9IFNpbXBsZUNhcmRDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBzaW1wbGVDYXJkKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgcmVxdWlyZTogJz9eXnJsU2ltcGxlQ2FyZExpc3QnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3NpbXBsZUNhcmQuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY2FyZCcsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgb25PcGVuOiAnJicsXHJcbiAgICAgICAgICAgIGNhbk9wZW46ICc9JyxcclxuICAgICAgICAgICAgYWx3YXlzT3BlbjogJz0nLFxyXG4gICAgICAgICAgICBjaGlsZExpbms6ICc9JyxcclxuICAgICAgICAgICAgdmFsaWRhdGU6ICcmJyxcclxuICAgICAgICAgICAgc2F2ZTogJyYnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlciwgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICB0cmFuc2NsdWRlKGZ1bmN0aW9uIChjbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGNsb25lLmZpbHRlcigncmwtY2FyZC1oZWFkZXInKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gY2xvbmUuZmlsdGVyKCdybC1jYXJkLWNvbnRlbnQnKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb290ZXIgPSBjbG9uZS5maWx0ZXIoJ3JsLWNhcmQtZm9vdGVyJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyQXJlYSA9IGVsZW1lbnQuZmluZCgnLmhlYWRlci10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyQXJlYS5hcHBlbmQoaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50QXJlYSA9IGVsZW1lbnQuZmluZCgnLmNvbnRlbnQtdGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRBcmVhLmFwcGVuZChjb250ZW50KTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLmhhc0Zvb3RlciA9IChmb290ZXIubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuaGFzRm9vdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvb3RlckFyZWEgPSBlbGVtZW50LmZpbmQoJy5mb290ZXItdGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICBmb290ZXJBcmVhLmFwcGVuZChmb290ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNpbXBsZUNhcmQgPSBzaW1wbGVDYXJkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVDYXJkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkLmpzXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiY2FyZCBjb2wteHMtMTJcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImhlYWRlciByb3dcXFwiIG5nLWNsYXNzPVxcXCJ7ICdhY3RpdmUnOiBjYXJkLmNhbk9wZW4gJiYgIWNhcmQuYWx3YXlzT3BlbiwgJ2Vycm9yJzogY2FyZEZvcm0uJGludmFsaWQgfVxcXCIgbmctY2xpY2s9XFxcImNhcmQudG9nZ2xlQ29udGVudCgpXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJoZWFkZXItdGVtcGxhdGVcXFwiPjwvZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHQ8bmctZm9ybSBuYW1lPVxcXCJjYXJkRm9ybVxcXCIgcmwtYXV0b3NhdmU9XFxcImNhcmQuYXV0b3NhdmVMaW5rXFxcIiB2YWxpZGF0ZT1cXFwiY2FyZC52YWxpZGF0ZSgpXFxcIiBzYXZlPVxcXCJjYXJkLnNhdmUoKVxcXCI+XFxyXFxuXFx0XFx0PGRpdiBuZy1zaG93PVxcXCJjYXJkLnNob3dDb250ZW50IHx8IGNhcmQuYWx3YXlzT3BlblxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiYm9keSByb3dcXFwiPlxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbnRlbnQtdGVtcGxhdGVcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L25nLWZvcm0+XFxyXFxuXFx0PGRpdiBuZy1zaG93PVxcXCJoYXNGb290ZXIgJiYgY2FyZC5zaG93Q29udGVudFxcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9vdGVyIHJvd1xcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9vdGVyLXRlbXBsYXRlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0PC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc2ltcGxlQ2FyZExpc3Qvc2ltcGxlQ2FyZC5odG1sXG4gKiogbW9kdWxlIGlkID0gMTM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsU2ltcGxlQ2FyZExpc3QnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NpbXBsZUNhcmRMaXN0Q29udHJvbGxlcic7XHJcbnZhciBTaW1wbGVDYXJkTGlzdENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsIG9ic2VydmFibGVGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gJHBhcnNlKCRhdHRycy5hbHdheXNPcGVuKSgkc2NvcGUpOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMuYWx3YXlzT3BlbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2Fsd2F5c09wZW4nLCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBTaW1wbGVDYXJkTGlzdENvbnRyb2xsZXIucHJvdG90eXBlLnJlZ2lzdGVyQ2FyZCA9IGZ1bmN0aW9uIChiZWhhdmlvcikge1xyXG4gICAgICAgIGJlaGF2aW9yLnNldEFsd2F5c09wZW4odGhpcy5hbHdheXNPcGVuKTtcclxuICAgICAgICB2YXIgdW5yZWdpc3RlckZ1bmN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHVucmVnaXN0ZXJGdW5jdGlvbnMucHVzaCh0aGlzLm9ic2VydmFibGUucmVnaXN0ZXIoYmVoYXZpb3IuY2xvc2UsICdjbG9zZScpKTtcclxuICAgICAgICB1bnJlZ2lzdGVyRnVuY3Rpb25zLnB1c2godGhpcy5vYnNlcnZhYmxlLnJlZ2lzdGVyKGJlaGF2aW9yLnNldEFsd2F5c09wZW4sICdhbHdheXNPcGVuJykpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaCh1bnJlZ2lzdGVyRnVuY3Rpb25zLCBmdW5jdGlvbiAodW5yZWdpc3Rlcikge1xyXG4gICAgICAgICAgICAgICAgdW5yZWdpc3RlcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlci5wcm90b3R5cGUub3BlbkNhcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uYWxsKHRoaXMub2JzZXJ2YWJsZS5maXJlKCdjbG9zZScpKTtcclxuICAgIH07XHJcbiAgICBTaW1wbGVDYXJkTGlzdENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCBfX29ic2VydmFibGUuZmFjdG9yeU5hbWVdO1xyXG4gICAgcmV0dXJuIFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5TaW1wbGVDYXJkTGlzdENvbnRyb2xsZXIgPSBTaW1wbGVDYXJkTGlzdENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHNpbXBsZUNhcmRMaXN0KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNpbXBsZUNhcmRMaXN0ID0gc2ltcGxlQ2FyZExpc3Q7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZUNhcmRMaXN0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkTGlzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9ib290c3RyYXAtdG91Y2hzcGluL2Jvb3RzdHJhcC10b3VjaHNwaW4uZC50cycgLz5cclxuLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9qcXVlcnkvanF1ZXJ5LmQudHMnIC8+XHJcbi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5yZXF1aXJlKCcuLi8uLi8uLi9saWJyYXJpZXMvYm9vdHN0cmFwLXRvdWNoc3Bpbi9pbmRleCcpO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fc3RyaW5nID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnN0cmluZztcclxudmFyIF9fbnVtYmVyID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm51bWJlcjtcclxudmFyIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuc3Bpbm5lcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFNwaW5uZXInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NwaW5uZXJDb250cm9sbGVyJztcclxuZXhwb3J0cy5kZWZhdWx0TWF4VmFsdWUgPSAxMDAwMDAwMDAwMDAwMDAwMDAwMDA7XHJcbnZhciBTcGlubmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTcGlubmVyQ29udHJvbGxlcigkc2NvcGUsIGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1bnJlZ2lzdGVyID0gJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5uZ01vZGVsOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF90aGlzLnZhbGlkYXRvcikpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNwaW5uZXJWYWxpZGF0b3IgPSBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgICAgICAgICBuZ01vZGVsOiBfdGhpcy5uZ01vZGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZTogJHNjb3BlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IFtfdGhpcy52YWxpZGF0b3JdLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW5yZWdpc3RlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgU3Bpbm5lckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gU3Bpbm5lckNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU3Bpbm5lckNvbnRyb2xsZXIgPSBTcGlubmVyQ29udHJvbGxlcjtcclxuc3Bpbm5lci4kaW5qZWN0ID0gWyckdGltZW91dCcsIF9fc3RyaW5nLnNlcnZpY2VOYW1lLCBfX251bWJlci5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIHNwaW5uZXIoJHRpbWVvdXQsIHN0cmluZ1V0aWxpdHksIG51bWJlclV0aWxpdHkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zcGlubmVyLmh0bWwnKSxcclxuICAgICAgICByZXF1aXJlOiAnP15uZ01vZGVsJyxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3NwaW5uZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIG1pbjogJz0nLFxyXG4gICAgICAgICAgICBtYXg6ICc9JyxcclxuICAgICAgICAgICAgc3RlcDogJz0nLFxyXG4gICAgICAgICAgICBkZWNpbWFsczogJz0nLFxyXG4gICAgICAgICAgICBwcmVmaXg6ICdAJyxcclxuICAgICAgICAgICAgcG9zdGZpeDogJ0AnLFxyXG4gICAgICAgICAgICByb3VuZFRvU3RlcDogJz0nLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgICAgIHNwaW5uZXJJZDogJ0AnLFxyXG4gICAgICAgICAgICBuYW1lOiAnQCcsXHJcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgc3Bpbm5lciA9IHNjb3BlLnNwaW5uZXI7XHJcbiAgICAgICAgICAgIHNwaW5uZXIubmdNb2RlbCA9IG5nTW9kZWw7XHJcbiAgICAgICAgICAgIHZhciB1bmJpbmRXYXRjaGVzO1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ25nRGlzYWJsZWQnLCBmdW5jdGlvbiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odW5iaW5kV2F0Y2hlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kV2F0Y2hlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHNwaW5uZXIgYWZ0ZXIgJHRpbWVvdXQgdG8gZ2l2ZSBhbmd1bGFyIGEgY2hhbmNlIGluaXRpYWxpemUgbmdNb2RlbFxyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoc3BpbiA9IGVsZW1lbnQuZmluZCgnaW5wdXQuc3Bpbm5lcicpLlRvdWNoU3Bpbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IChzcGlubmVyLm1pbiAhPSBudWxsID8gc3Bpbm5lci5taW4gOiAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogKHNwaW5uZXIubWF4ICE9IG51bGwgPyBzcGlubmVyLm1heCA6IGV4cG9ydHMuZGVmYXVsdE1heFZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHNwaW5uZXIuc3RlcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogc3Bpbm5lci5wcmVmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0Zml4OiBzcGlubmVyLnBvc3RmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogc3Bpbm5lci5kZWNpbWFscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXR2YWw6IG5nTW9kZWwuJHZpZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlc3RlcGRpdmlzaWJpbGl0eTogc3Bpbm5lci5yb3VuZFRvU3RlcCA/ICdyb3VuZCcgOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3VjaHNwaW4ub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwaW5WYWx1ZSA9IHRvdWNoc3Bpbi52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoc3RyaW5nVXRpbGl0eS50b051bWJlcihzcGluVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuYmluZFZpZXdXYXRjaCA9IHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmdNb2RlbC4kdmlld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoc3Bpbi52YWwobmV3VmFsdWUgIT0gbnVsbCA/IG5ld1ZhbHVlLnRvU3RyaW5nKCkgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5iaW5kTW9kZWxXYXRjaCA9IHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmdNb2RlbC4kbW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKG5ld01vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZ01vZGVsLiRtb2RlbFZhbHVlID0gcm91bmQobmV3TW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kV2F0Y2hlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuYmluZFZpZXdXYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kTW9kZWxXYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gcm91bmQobnVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtICE9IG51bGwgJiYgc3Bpbm5lci5yb3VuZFRvU3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IG51bWJlclV0aWxpdHkucm91bmRUb1N0ZXAobnVtLCBzcGlubmVyLnN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IG51bWJlclV0aWxpdHkucHJlY2lzZVJvdW5kKG51bSwgc3Bpbm5lci5kZWNpbWFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX3N0cmluZy5tb2R1bGVOYW1lLCBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLm1vZHVsZU5hbWUsIF9fbnVtYmVyLm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHNwaW5uZXIpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBTcGlubmVyQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwaW5uZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwialF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcblxyXG5yZXF1aXJlKCcuL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzcycpO1xyXG5yZXF1aXJlKCcuL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWJyYXJpZXMvYm9vdHN0cmFwLXRvdWNoc3Bpbi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLypcXHJcXG4gKiAgQm9vdHN0cmFwIFRvdWNoU3BpbiAtIHYzLjAuMVxcclxcbiAqICBBIG1vYmlsZSBhbmQgdG91Y2ggZnJpZW5kbHkgaW5wdXQgc3Bpbm5lciBjb21wb25lbnQgZm9yIEJvb3RzdHJhcCAzLlxcclxcbiAqICBodHRwOi8vd3d3LnZpcnR1b3NvZnQuZXUvY29kZS9ib290c3RyYXAtdG91Y2hzcGluL1xcclxcbiAqXFxyXFxuICogIE1hZGUgYnkgSXN0dsOhbiBVamotTcOpc3rDoXJvc1xcclxcbiAqICBVbmRlciBBcGFjaGUgTGljZW5zZSB2Mi4wIExpY2Vuc2VcXHJcXG4gKi9cXHJcXG5cXHJcXG4uYm9vdHN0cmFwLXRvdWNoc3BpbiAuaW5wdXQtZ3JvdXAtYnRuLXZlcnRpY2FsIHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuICB3aWR0aDogMSU7XFxyXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcclxcbiAgZGlzcGxheTogdGFibGUtY2VsbDtcXHJcXG59XFxyXFxuXFxyXFxuLmJvb3RzdHJhcC10b3VjaHNwaW4gLmlucHV0LWdyb3VwLWJ0bi12ZXJ0aWNhbCA+IC5idG4ge1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBmbG9hdDogbm9uZTtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgbWF4LXdpZHRoOiAxMDAlO1xcclxcbiAgcGFkZGluZzogOHB4IDEwcHg7XFxyXFxuICBtYXJnaW4tbGVmdDogLTFweDtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmJvb3RzdHJhcC10b3VjaHNwaW4gLmlucHV0LWdyb3VwLWJ0bi12ZXJ0aWNhbCAuYm9vdHN0cmFwLXRvdWNoc3Bpbi11cCB7XFxyXFxuICBib3JkZXItcmFkaXVzOiAwO1xcclxcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG59XFxyXFxuXFxyXFxuLmJvb3RzdHJhcC10b3VjaHNwaW4gLmlucHV0LWdyb3VwLWJ0bi12ZXJ0aWNhbCAuYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duIHtcXHJcXG4gIG1hcmdpbi10b3A6IC0ycHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiAwO1xcclxcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG59XFxyXFxuXFxyXFxuLmJvb3RzdHJhcC10b3VjaHNwaW4gLmlucHV0LWdyb3VwLWJ0bi12ZXJ0aWNhbCBpIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogM3B4O1xcclxcbiAgbGVmdDogNXB4O1xcclxcbiAgZm9udC1zaXplOiA5cHg7XFxyXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG4gKiAgQm9vdHN0cmFwIFRvdWNoU3BpbiAtIHYzLjAuMVxyXG4gKiAgQSBtb2JpbGUgYW5kIHRvdWNoIGZyaWVuZGx5IGlucHV0IHNwaW5uZXIgY29tcG9uZW50IGZvciBCb290c3RyYXAgMy5cclxuICogIGh0dHA6Ly93d3cudmlydHVvc29mdC5ldS9jb2RlL2Jvb3RzdHJhcC10b3VjaHNwaW4vXHJcbiAqXHJcbiAqICBNYWRlIGJ5IElzdHbDoW4gVWpqLU3DqXN6w6Fyb3NcclxuICogIFVuZGVyIEFwYWNoZSBMaWNlbnNlIHYyLjAgTGljZW5zZVxyXG4gKi9cclxuKGZ1bmN0aW9uKCQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHZhciBfY3VycmVudFNwaW5uZXJJZCA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIF9zY29wZWRFdmVudE5hbWUobmFtZSwgaWQpIHtcclxuICAgIHJldHVybiBuYW1lICsgJy50b3VjaHNwaW5fJyArIGlkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3Njb3BlRXZlbnROYW1lcyhuYW1lcywgaWQpIHtcclxuICAgIHJldHVybiAkLm1hcChuYW1lcywgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICByZXR1cm4gX3Njb3BlZEV2ZW50TmFtZShuYW1lLCBpZCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gICQuZm4uVG91Y2hTcGluID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cclxuICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcclxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcmlnaW5hbGlucHV0ID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgb3JpZ2luYWxpbnB1dF9kYXRhID0gb3JpZ2luYWxpbnB1dC5kYXRhKCk7XHJcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKF9zY29wZUV2ZW50TmFtZXMoW1xyXG4gICAgICAgICAgJ21vdXNldXAnLFxyXG4gICAgICAgICAgJ3RvdWNoZW5kJyxcclxuICAgICAgICAgICd0b3VjaGNhbmNlbCcsXHJcbiAgICAgICAgICAnbW91c2Vtb3ZlJyxcclxuICAgICAgICAgICd0b3VjaG1vdmUnLFxyXG4gICAgICAgICAgJ3Njcm9sbCcsXHJcbiAgICAgICAgICAnc2Nyb2xsc3RhcnQnXSwgb3JpZ2luYWxpbnB1dF9kYXRhLnNwaW5uZXJpZCkuam9pbignICcpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgIG1pbjogMCxcclxuICAgICAgbWF4OiAxMDAsXHJcbiAgICAgIGluaXR2YWw6ICcnLFxyXG4gICAgICBzdGVwOiAxLFxyXG4gICAgICBkZWNpbWFsczogMCxcclxuICAgICAgc3RlcGludGVydmFsOiAxMDAsXHJcbiAgICAgIGZvcmNlc3RlcGRpdmlzaWJpbGl0eTogJ3JvdW5kJywgLy8gbm9uZSB8IGZsb29yIHwgcm91bmQgfCBjZWlsXHJcbiAgICAgIHN0ZXBpbnRlcnZhbGRlbGF5OiA1MDAsXHJcbiAgICAgIHZlcnRpY2FsYnV0dG9uczogZmFsc2UsXHJcbiAgICAgIHZlcnRpY2FsdXBjbGFzczogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cCcsXHJcbiAgICAgIHZlcnRpY2FsZG93bmNsYXNzOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd24nLFxyXG4gICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICBwb3N0Zml4OiAnJyxcclxuICAgICAgcHJlZml4X2V4dHJhY2xhc3M6ICcnLFxyXG4gICAgICBwb3N0Zml4X2V4dHJhY2xhc3M6ICcnLFxyXG4gICAgICBib29zdGVyOiB0cnVlLFxyXG4gICAgICBib29zdGF0OiAxMCxcclxuICAgICAgbWF4Ym9vc3RlZHN0ZXA6IGZhbHNlLFxyXG4gICAgICBtb3VzZXdoZWVsOiB0cnVlLFxyXG4gICAgICBidXR0b25kb3duX2NsYXNzOiAnYnRuIGJ0bi1kZWZhdWx0JyxcclxuICAgICAgYnV0dG9udXBfY2xhc3M6ICdidG4gYnRuLWRlZmF1bHQnLFxyXG5cdCAgYnV0dG9uZG93bl90eHQ6ICctJyxcclxuXHQgIGJ1dHRvbnVwX3R4dDogJysnXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBhdHRyaWJ1dGVNYXAgPSB7XHJcbiAgICAgIG1pbjogJ21pbicsXHJcbiAgICAgIG1heDogJ21heCcsXHJcbiAgICAgIGluaXR2YWw6ICdpbml0LXZhbCcsXHJcbiAgICAgIHN0ZXA6ICdzdGVwJyxcclxuICAgICAgZGVjaW1hbHM6ICdkZWNpbWFscycsXHJcbiAgICAgIHN0ZXBpbnRlcnZhbDogJ3N0ZXAtaW50ZXJ2YWwnLFxyXG4gICAgICB2ZXJ0aWNhbGJ1dHRvbnM6ICd2ZXJ0aWNhbC1idXR0b25zJyxcclxuICAgICAgdmVydGljYWx1cGNsYXNzOiAndmVydGljYWwtdXAtY2xhc3MnLFxyXG4gICAgICB2ZXJ0aWNhbGRvd25jbGFzczogJ3ZlcnRpY2FsLWRvd24tY2xhc3MnLFxyXG4gICAgICBmb3JjZXN0ZXBkaXZpc2liaWxpdHk6ICdmb3JjZS1zdGVwLWRpdmlzaWJpbGl0eScsXHJcbiAgICAgIHN0ZXBpbnRlcnZhbGRlbGF5OiAnc3RlcC1pbnRlcnZhbC1kZWxheScsXHJcbiAgICAgIHByZWZpeDogJ3ByZWZpeCcsXHJcbiAgICAgIHBvc3RmaXg6ICdwb3N0Zml4JyxcclxuICAgICAgcHJlZml4X2V4dHJhY2xhc3M6ICdwcmVmaXgtZXh0cmEtY2xhc3MnLFxyXG4gICAgICBwb3N0Zml4X2V4dHJhY2xhc3M6ICdwb3N0Zml4LWV4dHJhLWNsYXNzJyxcclxuICAgICAgYm9vc3RlcjogJ2Jvb3N0ZXInLFxyXG4gICAgICBib29zdGF0OiAnYm9vc3RhdCcsXHJcbiAgICAgIG1heGJvb3N0ZWRzdGVwOiAnbWF4LWJvb3N0ZWQtc3RlcCcsXHJcbiAgICAgIG1vdXNld2hlZWw6ICdtb3VzZS13aGVlbCcsXHJcbiAgICAgIGJ1dHRvbmRvd25fY2xhc3M6ICdidXR0b24tZG93bi1jbGFzcycsXHJcbiAgICAgIGJ1dHRvbnVwX2NsYXNzOiAnYnV0dG9uLXVwLWNsYXNzJyxcclxuXHQgIGJ1dHRvbmRvd25fdHh0OiAnYnV0dG9uLWRvd24tdHh0JyxcclxuXHQgIGJ1dHRvbnVwX3R4dDogJ2J1dHRvbi11cC10eHQnXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgc2V0dGluZ3MsXHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0ID0gJCh0aGlzKSxcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXRfZGF0YSA9IG9yaWdpbmFsaW5wdXQuZGF0YSgpLFxyXG4gICAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgICAgZWxlbWVudHMsXHJcbiAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgIGRvd25TcGluVGltZXIsXHJcbiAgICAgICAgICB1cFNwaW5UaW1lcixcclxuICAgICAgICAgIGRvd25EZWxheVRpbWVvdXQsXHJcbiAgICAgICAgICB1cERlbGF5VGltZW91dCxcclxuICAgICAgICAgIHNwaW5jb3VudCA9IDAsXHJcbiAgICAgICAgICBzcGlubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgaW5pdCgpO1xyXG5cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuZGF0YSgnYWxyZWFkeWluaXRpYWxpemVkJykpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQuZGF0YSgnYWxyZWFkeWluaXRpYWxpemVkJywgdHJ1ZSk7XHJcbiAgICAgICAgX2N1cnJlbnRTcGlubmVySWQgKz0gMTtcclxuICAgICAgICBvcmlnaW5hbGlucHV0LmRhdGEoJ3NwaW5uZXJpZCcsIF9jdXJyZW50U3Bpbm5lcklkKTtcclxuXHJcblxyXG4gICAgICAgIGlmICghb3JpZ2luYWxpbnB1dC5pcygnaW5wdXQnKSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ011c3QgYmUgYW4gaW5wdXQuJyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfaW5pdFNldHRpbmdzKCk7XHJcbiAgICAgICAgX3NldEluaXR2YWwoKTtcclxuICAgICAgICBfY2hlY2tWYWx1ZSgpO1xyXG4gICAgICAgIF9idWlsZEh0bWwoKTtcclxuICAgICAgICBfaW5pdEVsZW1lbnRzKCk7XHJcbiAgICAgICAgX2hpZGVFbXB0eVByZWZpeFBvc3RmaXgoKTtcclxuICAgICAgICBfYmluZEV2ZW50cygpO1xyXG4gICAgICAgIF9iaW5kRXZlbnRzSW50ZXJmYWNlKCk7XHJcbiAgICAgICAgZWxlbWVudHMuaW5wdXQuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9zZXRJbml0dmFsKCkge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5pbml0dmFsICE9PSAnJyAmJiBvcmlnaW5hbGlucHV0LnZhbCgpID09PSAnJykge1xyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC52YWwoc2V0dGluZ3MuaW5pdHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjaGFuZ2VTZXR0aW5ncyhuZXdzZXR0aW5ncykge1xyXG4gICAgICAgIF91cGRhdGVTZXR0aW5ncyhuZXdzZXR0aW5ncyk7XHJcbiAgICAgICAgX2NoZWNrVmFsdWUoKTtcclxuXHJcbiAgICAgICAgdmFyIHZhbHVlID0gZWxlbWVudHMuaW5wdXQudmFsKCk7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgIHZhbHVlID0gTnVtYmVyKGVsZW1lbnRzLmlucHV0LnZhbCgpKTtcclxuICAgICAgICAgIGVsZW1lbnRzLmlucHV0LnZhbCh2YWx1ZS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfaW5pdFNldHRpbmdzKCkge1xyXG4gICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcmlnaW5hbGlucHV0X2RhdGEsIF9wYXJzZUF0dHJpYnV0ZXMoKSwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9wYXJzZUF0dHJpYnV0ZXMoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICAkLmVhY2goYXR0cmlidXRlTWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnYnRzLScgKyB2YWx1ZSArICcnO1xyXG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJ1tkYXRhLScgKyBhdHRyTmFtZSArICddJykpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gb3JpZ2luYWxpbnB1dC5kYXRhKGF0dHJOYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX3VwZGF0ZVNldHRpbmdzKG5ld3NldHRpbmdzKSB7XHJcbiAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgc2V0dGluZ3MsIG5ld3NldHRpbmdzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2J1aWxkSHRtbCgpIHtcclxuICAgICAgICB2YXIgaW5pdHZhbCA9IG9yaWdpbmFsaW5wdXQudmFsKCksXHJcbiAgICAgICAgICAgIHBhcmVudGVsZW1lbnQgPSBvcmlnaW5hbGlucHV0LnBhcmVudCgpO1xyXG5cclxuICAgICAgICBpZiAoaW5pdHZhbCAhPT0gJycpIHtcclxuICAgICAgICAgIGluaXR2YWwgPSBOdW1iZXIoaW5pdHZhbCkudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0LmRhdGEoJ2luaXR2YWx1ZScsIGluaXR2YWwpLnZhbChpbml0dmFsKTtcclxuICAgICAgICBvcmlnaW5hbGlucHV0LmFkZENsYXNzKCdmb3JtLWNvbnRyb2wnKTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmVudGVsZW1lbnQuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwJykpIHtcclxuICAgICAgICAgIF9hZHZhbmNlSW5wdXRHcm91cChwYXJlbnRlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBfYnVpbGRJbnB1dEdyb3VwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfYWR2YW5jZUlucHV0R3JvdXAocGFyZW50ZWxlbWVudCkge1xyXG4gICAgICAgIHBhcmVudGVsZW1lbnQuYWRkQ2xhc3MoJ2Jvb3RzdHJhcC10b3VjaHNwaW4nKTtcclxuXHJcbiAgICAgICAgdmFyIHByZXYgPSBvcmlnaW5hbGlucHV0LnByZXYoKSxcclxuICAgICAgICAgICAgbmV4dCA9IG9yaWdpbmFsaW5wdXQubmV4dCgpO1xyXG5cclxuICAgICAgICB2YXIgZG93bmh0bWwsXHJcbiAgICAgICAgICAgIHVwaHRtbCxcclxuICAgICAgICAgICAgcHJlZml4aHRtbCA9ICc8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGJvb3RzdHJhcC10b3VjaHNwaW4tcHJlZml4XCI+JyArIHNldHRpbmdzLnByZWZpeCArICc8L3NwYW4+JyxcclxuICAgICAgICAgICAgcG9zdGZpeGh0bWwgPSAnPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXBvc3RmaXhcIj4nICsgc2V0dGluZ3MucG9zdGZpeCArICc8L3NwYW4+JztcclxuXHJcbiAgICAgICAgaWYgKHByZXYuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwLWJ0bicpKSB7XHJcbiAgICAgICAgICBkb3duaHRtbCA9ICc8YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbmRvd25fY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tZG93blwiIHR5cGU9XCJidXR0b25cIj4nICsgc2V0dGluZ3MuYnV0dG9uZG93bl90eHQgKyAnPC9idXR0b24+JztcclxuICAgICAgICAgIHByZXYuYXBwZW5kKGRvd25odG1sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBkb3duaHRtbCA9ICc8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiPjxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9uZG93bl9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duXCIgdHlwZT1cImJ1dHRvblwiPicgKyBzZXR0aW5ncy5idXR0b25kb3duX3R4dCArICc8L2J1dHRvbj48L3NwYW4+JztcclxuICAgICAgICAgICQoZG93bmh0bWwpLmluc2VydEJlZm9yZShvcmlnaW5hbGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXh0Lmhhc0NsYXNzKCdpbnB1dC1ncm91cC1idG4nKSkge1xyXG4gICAgICAgICAgdXBodG1sID0gJzxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9udXBfY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tdXBcIiB0eXBlPVwiYnV0dG9uXCI+JyArIHNldHRpbmdzLmJ1dHRvbnVwX3R4dCArICc8L2J1dHRvbj4nO1xyXG4gICAgICAgICAgbmV4dC5wcmVwZW5kKHVwaHRtbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdXBodG1sID0gJzxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCI+PGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b251cF9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi11cFwiIHR5cGU9XCJidXR0b25cIj4nICsgc2V0dGluZ3MuYnV0dG9udXBfdHh0ICsgJzwvYnV0dG9uPjwvc3Bhbj4nO1xyXG4gICAgICAgICAgJCh1cGh0bWwpLmluc2VydEFmdGVyKG9yaWdpbmFsaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJChwcmVmaXhodG1sKS5pbnNlcnRCZWZvcmUob3JpZ2luYWxpbnB1dCk7XHJcbiAgICAgICAgJChwb3N0Zml4aHRtbCkuaW5zZXJ0QWZ0ZXIob3JpZ2luYWxpbnB1dCk7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lciA9IHBhcmVudGVsZW1lbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9idWlsZElucHV0R3JvdXAoKSB7XHJcbiAgICAgICAgdmFyIGh0bWw7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy52ZXJ0aWNhbGJ1dHRvbnMpIHtcclxuICAgICAgICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGJvb3RzdHJhcC10b3VjaHNwaW5cIj48c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGJvb3RzdHJhcC10b3VjaHNwaW4tcHJlZml4XCI+JyArIHNldHRpbmdzLnByZWZpeCArICc8L3NwYW4+PHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXBvc3RmaXhcIj4nICsgc2V0dGluZ3MucG9zdGZpeCArICc8L3NwYW4+PHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG4tdmVydGljYWxcIj48YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbmRvd25fY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tdXBcIiB0eXBlPVwiYnV0dG9uXCI+PGkgY2xhc3M9XCInICsgc2V0dGluZ3MudmVydGljYWx1cGNsYXNzICsgJ1wiPjwvaT48L2J1dHRvbj48YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbnVwX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLWRvd25cIiB0eXBlPVwiYnV0dG9uXCI+PGkgY2xhc3M9XCInICsgc2V0dGluZ3MudmVydGljYWxkb3duY2xhc3MgKyAnXCI+PC9pPjwvYnV0dG9uPjwvc3Bhbj48L2Rpdj4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGJvb3RzdHJhcC10b3VjaHNwaW5cIj48c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiPjxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9uZG93bl9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duXCIgdHlwZT1cImJ1dHRvblwiPicgKyBzZXR0aW5ncy5idXR0b25kb3duX3R4dCArICc8L2J1dHRvbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXByZWZpeFwiPicgKyBzZXR0aW5ncy5wcmVmaXggKyAnPC9zcGFuPjxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gYm9vdHN0cmFwLXRvdWNoc3Bpbi1wb3N0Zml4XCI+JyArIHNldHRpbmdzLnBvc3RmaXggKyAnPC9zcGFuPjxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCI+PGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b251cF9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi11cFwiIHR5cGU9XCJidXR0b25cIj4nICsgc2V0dGluZ3MuYnV0dG9udXBfdHh0ICsgJzwvYnV0dG9uPjwvc3Bhbj48L2Rpdj4nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29udGFpbmVyID0gJChodG1sKS5pbnNlcnRCZWZvcmUob3JpZ2luYWxpbnB1dCk7XHJcblxyXG4gICAgICAgICQoJy5ib290c3RyYXAtdG91Y2hzcGluLXByZWZpeCcsIGNvbnRhaW5lcikuYWZ0ZXIob3JpZ2luYWxpbnB1dCk7XHJcblxyXG4gICAgICAgIGlmIChvcmlnaW5hbGlucHV0Lmhhc0NsYXNzKCdpbnB1dC1zbScpKSB7XHJcbiAgICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoJ2lucHV0LWdyb3VwLXNtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9yaWdpbmFsaW5wdXQuaGFzQ2xhc3MoJ2lucHV0LWxnJykpIHtcclxuICAgICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcygnaW5wdXQtZ3JvdXAtbGcnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9pbml0RWxlbWVudHMoKSB7XHJcbiAgICAgICAgZWxlbWVudHMgPSB7XHJcbiAgICAgICAgICBkb3duOiAkKCcuYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duJywgY29udGFpbmVyKSxcclxuICAgICAgICAgIHVwOiAkKCcuYm9vdHN0cmFwLXRvdWNoc3Bpbi11cCcsIGNvbnRhaW5lciksXHJcbiAgICAgICAgICBpbnB1dDogJCgnaW5wdXQnLCBjb250YWluZXIpLFxyXG4gICAgICAgICAgcHJlZml4OiAkKCcuYm9vdHN0cmFwLXRvdWNoc3Bpbi1wcmVmaXgnLCBjb250YWluZXIpLmFkZENsYXNzKHNldHRpbmdzLnByZWZpeF9leHRyYWNsYXNzKSxcclxuICAgICAgICAgIHBvc3RmaXg6ICQoJy5ib290c3RyYXAtdG91Y2hzcGluLXBvc3RmaXgnLCBjb250YWluZXIpLmFkZENsYXNzKHNldHRpbmdzLnBvc3RmaXhfZXh0cmFjbGFzcylcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfaGlkZUVtcHR5UHJlZml4UG9zdGZpeCgpIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3MucHJlZml4ID09PSAnJykge1xyXG4gICAgICAgICAgZWxlbWVudHMucHJlZml4LmhpZGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5wb3N0Zml4ID09PSAnJykge1xyXG4gICAgICAgICAgZWxlbWVudHMucG9zdGZpeC5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuXHJcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzgpIHtcclxuICAgICAgICAgICAgaWYgKHNwaW5uaW5nICE9PSAndXAnKSB7XHJcbiAgICAgICAgICAgICAgdXBPbmNlKCk7XHJcbiAgICAgICAgICAgICAgc3RhcnRVcFNwaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gNDApIHtcclxuICAgICAgICAgICAgaWYgKHNwaW5uaW5nICE9PSAnZG93bicpIHtcclxuICAgICAgICAgICAgICBkb3duT25jZSgpO1xyXG4gICAgICAgICAgICAgIHN0YXJ0RG93blNwaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCdrZXl1cCcsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZGUgPT09IDM4KSB7XHJcbiAgICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSA0MCkge1xyXG4gICAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBfY2hlY2tWYWx1ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuXHJcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcclxuICAgICAgICAgICAgaWYgKHNwaW5uaW5nICE9PSAnZG93bicpIHtcclxuICAgICAgICAgICAgICBkb3duT25jZSgpO1xyXG4gICAgICAgICAgICAgIHN0YXJ0RG93blNwaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdrZXl1cCcsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuXHJcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcclxuICAgICAgICAgICAgaWYgKHNwaW5uaW5nICE9PSAndXAnKSB7XHJcbiAgICAgICAgICAgICAgdXBPbmNlKCk7XHJcbiAgICAgICAgICAgICAgc3RhcnRVcFNwaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy51cC5vbigna2V5dXAnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgdmFyIGNvZGUgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoO1xyXG5cclxuICAgICAgICAgIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSAxMykge1xyXG4gICAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdtb3VzZWRvd24udG91Y2hzcGluJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGVsZW1lbnRzLmRvd24ub2ZmKCd0b3VjaHN0YXJ0LnRvdWNoc3BpbicpOyAgLy8gYW5kcm9pZCA0IHdvcmthcm91bmRcclxuXHJcbiAgICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5pcygnOmRpc2FibGVkJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRvd25PbmNlKCk7XHJcbiAgICAgICAgICBzdGFydERvd25TcGluKCk7XHJcblxyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCd0b3VjaHN0YXJ0LnRvdWNoc3BpbicsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBlbGVtZW50cy5kb3duLm9mZignbW91c2Vkb3duLnRvdWNoc3BpbicpOyAgLy8gYW5kcm9pZCA0IHdvcmthcm91bmRcclxuXHJcbiAgICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5pcygnOmRpc2FibGVkJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRvd25PbmNlKCk7XHJcbiAgICAgICAgICBzdGFydERvd25TcGluKCk7XHJcblxyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy51cC5vbignbW91c2Vkb3duLnRvdWNoc3BpbicsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBlbGVtZW50cy51cC5vZmYoJ3RvdWNoc3RhcnQudG91Y2hzcGluJyk7ICAvLyBhbmRyb2lkIDQgd29ya2Fyb3VuZFxyXG5cclxuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCc6ZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdXBPbmNlKCk7XHJcbiAgICAgICAgICBzdGFydFVwU3BpbigpO1xyXG5cclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMudXAub24oJ3RvdWNoc3RhcnQudG91Y2hzcGluJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGVsZW1lbnRzLnVwLm9mZignbW91c2Vkb3duLnRvdWNoc3BpbicpOyAgLy8gYW5kcm9pZCA0IHdvcmthcm91bmRcclxuXHJcbiAgICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5pcygnOmRpc2FibGVkJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHVwT25jZSgpO1xyXG4gICAgICAgICAgc3RhcnRVcFNwaW4oKTtcclxuXHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCdtb3VzZW91dCB0b3VjaGxlYXZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGlmICghc3Bpbm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbignbW91c2VvdXQgdG91Y2hsZWF2ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmRvd24ub24oJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy51cC5vbignbW91c2Vtb3ZlIHRvdWNobW92ZScsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKF9zY29wZUV2ZW50TmFtZXMoWydtb3VzZXVwJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ10sIF9jdXJyZW50U3Bpbm5lcklkKS5qb2luKCcgJyksIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJChkb2N1bWVudCkub24oX3Njb3BlRXZlbnROYW1lcyhbJ21vdXNlbW92ZScsICd0b3VjaG1vdmUnLCAnc2Nyb2xsJywgJ3Njcm9sbHN0YXJ0J10sIF9jdXJyZW50U3Bpbm5lcklkKS5qb2luKCcgJyksIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbignbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBpZiAoIXNldHRpbmdzLm1vdXNld2hlZWwgfHwgIW9yaWdpbmFsaW5wdXQuaXMoJzpmb2N1cycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgZGVsdGEgPSBldi5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEgfHwgLWV2Lm9yaWdpbmFsRXZlbnQuZGVsdGFZIHx8IC1ldi5vcmlnaW5hbEV2ZW50LmRldGFpbDtcclxuXHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICBkb3duT25jZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVwT25jZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfYmluZEV2ZW50c0ludGVyZmFjZSgpIHtcclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCd0b3VjaHNwaW4udXBvbmNlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgICAgdXBPbmNlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi5kb3dub25jZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICAgIGRvd25PbmNlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi5zdGFydHVwc3BpbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc3RhcnRVcFNwaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLnN0YXJ0ZG93bnNwaW4nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHN0YXJ0RG93blNwaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLnN0b3BzcGluJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCd0b3VjaHNwaW4udXBkYXRlc2V0dGluZ3MnLCBmdW5jdGlvbihlLCBuZXdzZXR0aW5ncykge1xyXG4gICAgICAgICAgY2hhbmdlU2V0dGluZ3MobmV3c2V0dGluZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfZm9yY2VzdGVwZGl2aXNpYmlsaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5mb3JjZXN0ZXBkaXZpc2liaWxpdHkpIHtcclxuICAgICAgICAgIGNhc2UgJ3JvdW5kJzpcclxuICAgICAgICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKHZhbHVlIC8gc2V0dGluZ3Muc3RlcCkgKiBzZXR0aW5ncy5zdGVwKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKTtcclxuICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcclxuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKHZhbHVlIC8gc2V0dGluZ3Muc3RlcCkgKiBzZXR0aW5ncy5zdGVwKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKTtcclxuICAgICAgICAgIGNhc2UgJ2NlaWwnOlxyXG4gICAgICAgICAgICByZXR1cm4gKE1hdGguY2VpbCh2YWx1ZSAvIHNldHRpbmdzLnN0ZXApICogc2V0dGluZ3Muc3RlcCkudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscyk7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfY2hlY2tWYWx1ZSgpIHtcclxuICAgICAgICB2YXIgdmFsLCBwYXJzZWR2YWwsIHJldHVybnZhbDtcclxuXHJcbiAgICAgICAgdmFsID0gb3JpZ2luYWxpbnB1dC52YWwoKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbCA9PT0gJycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFscyA+IDAgJiYgdmFsID09PSAnLicpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTmFOKHBhcnNlZHZhbCkpIHtcclxuICAgICAgICAgIHBhcnNlZHZhbCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm52YWwgPSBwYXJzZWR2YWw7XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWR2YWwudG9TdHJpbmcoKSAhPT0gdmFsKSB7XHJcbiAgICAgICAgICByZXR1cm52YWwgPSBwYXJzZWR2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkdmFsIDwgc2V0dGluZ3MubWluKSB7XHJcbiAgICAgICAgICByZXR1cm52YWwgPSBzZXR0aW5ncy5taW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VkdmFsID4gc2V0dGluZ3MubWF4KSB7XHJcbiAgICAgICAgICByZXR1cm52YWwgPSBzZXR0aW5ncy5tYXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm52YWwgPSBfZm9yY2VzdGVwZGl2aXNpYmlsaXR5KHJldHVybnZhbCk7XHJcblxyXG4gICAgICAgIGlmIChOdW1iZXIodmFsKS50b1N0cmluZygpICE9PSByZXR1cm52YWwudG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC52YWwocmV0dXJudmFsKTtcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfZ2V0Qm9vc3RlZFN0ZXAoKSB7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5ib29zdGVyKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc3RlcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB2YXIgYm9vc3RlZCA9IE1hdGgucG93KDIsIE1hdGguZmxvb3Ioc3BpbmNvdW50IC8gc2V0dGluZ3MuYm9vc3RhdCkpICogc2V0dGluZ3Muc3RlcDtcclxuXHJcbiAgICAgICAgICBpZiAoc2V0dGluZ3MubWF4Ym9vc3RlZHN0ZXApIHtcclxuICAgICAgICAgICAgaWYgKGJvb3N0ZWQgPiBzZXR0aW5ncy5tYXhib29zdGVkc3RlcCkge1xyXG4gICAgICAgICAgICAgIGJvb3N0ZWQgPSBzZXR0aW5ncy5tYXhib29zdGVkc3RlcDtcclxuICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQoKHZhbHVlIC8gYm9vc3RlZCkpICogYm9vc3RlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBNYXRoLm1heChzZXR0aW5ncy5zdGVwLCBib29zdGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHVwT25jZSgpIHtcclxuICAgICAgICBfY2hlY2tWYWx1ZSgpO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoZWxlbWVudHMuaW5wdXQudmFsKCkpO1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgIHZhbHVlID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbml0dmFsdWUgPSB2YWx1ZSxcclxuICAgICAgICAgICAgYm9vc3RlZHN0ZXAgPSBfZ2V0Qm9vc3RlZFN0ZXAoKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSArIGJvb3N0ZWRzdGVwO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPiBzZXR0aW5ncy5tYXgpIHtcclxuICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MubWF4O1xyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24ubWF4Jyk7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudHMuaW5wdXQudmFsKE51bWJlcih2YWx1ZSkudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscykpO1xyXG5cclxuICAgICAgICBpZiAoaW5pdHZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGRvd25PbmNlKCkge1xyXG4gICAgICAgIF9jaGVja1ZhbHVlKCk7XHJcblxyXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdChlbGVtZW50cy5pbnB1dC52YWwoKSk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluaXR2YWx1ZSA9IHZhbHVlLFxyXG4gICAgICAgICAgICBib29zdGVkc3RlcCA9IF9nZXRCb29zdGVkU3RlcCgpO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlIC0gYm9vc3RlZHN0ZXA7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA8IHNldHRpbmdzLm1pbikge1xyXG4gICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5taW47XHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5taW4nKTtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbGVtZW50cy5pbnB1dC52YWwodmFsdWUudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscykpO1xyXG5cclxuICAgICAgICBpZiAoaW5pdHZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0RG93blNwaW4oKSB7XHJcbiAgICAgICAgc3RvcFNwaW4oKTtcclxuXHJcbiAgICAgICAgc3BpbmNvdW50ID0gMDtcclxuICAgICAgICBzcGlubmluZyA9ICdkb3duJztcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RhcnRzcGluJyk7XHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RhcnRkb3duc3BpbicpO1xyXG5cclxuICAgICAgICBkb3duRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGRvd25TcGluVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc3BpbmNvdW50Kys7XHJcbiAgICAgICAgICAgIGRvd25PbmNlKCk7XHJcbiAgICAgICAgICB9LCBzZXR0aW5ncy5zdGVwaW50ZXJ2YWwpO1xyXG4gICAgICAgIH0sIHNldHRpbmdzLnN0ZXBpbnRlcnZhbGRlbGF5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3RhcnRVcFNwaW4oKSB7XHJcbiAgICAgICAgc3RvcFNwaW4oKTtcclxuXHJcbiAgICAgICAgc3BpbmNvdW50ID0gMDtcclxuICAgICAgICBzcGlubmluZyA9ICd1cCc7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0YXJ0c3BpbicpO1xyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0YXJ0dXBzcGluJyk7XHJcblxyXG4gICAgICAgIHVwRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHVwU3BpblRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHNwaW5jb3VudCsrO1xyXG4gICAgICAgICAgICB1cE9uY2UoKTtcclxuICAgICAgICAgIH0sIHNldHRpbmdzLnN0ZXBpbnRlcnZhbCk7XHJcbiAgICAgICAgfSwgc2V0dGluZ3Muc3RlcGludGVydmFsZGVsYXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdG9wU3BpbigpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoZG93bkRlbGF5VGltZW91dCk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHVwRGVsYXlUaW1lb3V0KTtcclxuICAgICAgICBjbGVhckludGVydmFsKGRvd25TcGluVGltZXIpO1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodXBTcGluVGltZXIpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHNwaW5uaW5nKSB7XHJcbiAgICAgICAgICBjYXNlICd1cCc6XHJcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0b3B1cHNwaW4nKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RvcHNwaW4nKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdkb3duJzpcclxuICAgICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RvcGRvd25zcGluJyk7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0b3BzcGluJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3BpbmNvdW50ID0gMDtcclxuICAgICAgICBzcGlubmluZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gIH07XHJcblxyXG59KShqUXVlcnkpO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8cmwtZ2VuZXJpYy1jb250YWluZXIgc2VsZWN0b3I9XFxcInNwaW5uZXIubmdEaXNhYmxlZFxcXCI+XFxyXFxuXFx0PHRlbXBsYXRlIGRlZmF1bHQ+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwidmFsaWRhdGlvbi1pbnB1dC1ncm91cFxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwidmFsaWRhdGlvbi1pbnB1dFxcXCIgbmctY2xhc3M9XFxcInsgJ2Vycm9yJzogc3Bpbm5lci5uZ01vZGVsLiRpbnZhbGlkLCAncmVxdWlyZWQtZXJyb3InOiBzcGlubmVyLm5nTW9kZWwuJGVycm9yLnJlcXVpcmVkIH1cXFwiPlxcclxcblxcdFxcdFxcdFxcdDxpbnB1dCBuYW1lPVxcXCJ7e3NwaW5uZXIubmFtZX19XFxcIiBjbGFzcz1cXFwic3Bpbm5lclxcXCIgaWQ9XFxcInt7c3Bpbm5lci5zcGlubmVySWR9fVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgLz5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImVycm9yLXN0cmluZ1xcXCIgbmctaGlkZT1cXFwic3Bpbm5lci5zcGlubmVyVmFsaWRhdG9yLmVycm9yIHwgaXNFbXB0eVxcXCI+e3tzcGlubmVyLnNwaW5uZXJWYWxpZGF0b3IuZXJyb3J9fTwvc3Bhbj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3RlbXBsYXRlPlxcclxcblxcdDx0ZW1wbGF0ZSB3aGVuLXNlbGVjdG9yPVxcXCJ0cnVlXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCIgbmctc2hvdz1cXFwic3Bpbm5lci5wcmVmaXggIT0gbnVsbCAmJiBzcGlubmVyLnBvc3RmaXggIT0gbnVsbFxcXCI+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj57e3NwaW5uZXIucHJlZml4fX08L3NwYW4+XFxyXFxuXFx0XFx0XFx0PGlucHV0IGRpc2FibGVkPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic3Bpbm5lci5uZ01vZGVsLiR2aWV3VmFsdWVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIC8+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj57e3NwaW5uZXIucG9zdGZpeH19PC9zcGFuPlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIiBuZy1zaG93PVxcXCJzcGlubmVyLnByZWZpeCAhPSBudWxsICYmIHNwaW5uZXIucG9zdGZpeCA9PSBudWxsXFxcIj5cXHJcXG5cXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb25cXFwiPnt7c3Bpbm5lci5wcmVmaXh9fTwvc3Bhbj5cXHJcXG5cXHRcXHRcXHQ8aW5wdXQgZGlzYWJsZWQ9XFxcInRydWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJzcGlubmVyLm5nTW9kZWwuJHZpZXdWYWx1ZVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgLz5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCIgbmctc2hvdz1cXFwic3Bpbm5lci5wcmVmaXggPT0gbnVsbCAmJiBzcGlubmVyLnBvc3RmaXggIT0gbnVsbFxcXCI+XFxyXFxuXFx0XFx0XFx0PGlucHV0IGRpc2FibGVkPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic3Bpbm5lci5uZ01vZGVsLiR2aWV3VmFsdWVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIC8+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj57e3NwaW5uZXIucG9zdGZpeH19PC9zcGFuPlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIiBuZy1zaG93PVxcXCJzcGlubmVyLnByZWZpeCA9PSBudWxsICYmIHNwaW5uZXIucG9zdGZpeCA9PSBudWxsXFxcIj5cXHJcXG5cXHRcXHRcXHQ8aW5wdXQgZGlzYWJsZWQ9XFxcInRydWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJzcGlubmVyLm5nTW9kZWwuJHZpZXdWYWx1ZVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgLz5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3RlbXBsYXRlPlxcclxcbjwvcmwtZ2VuZXJpYy1jb250YWluZXI+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnN0cmluZ1dpdGhXYXRlcm1hcmsnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTdHJpbmdXaXRoV2F0ZXJtYXJrJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlcic7XHJcbnZhciBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlcigkc2NvcGUsIG9iamVjdFV0aWxpdHkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RyaW5nOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFzU3RyaW5nID0gb2JqZWN0VXRpbGl0eS5pc051bGxPckVtcHR5KHZhbHVlKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXIgPSBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gc3RyaW5nV2l0aFdhdGVybWFyaygpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8c3Bhbj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBuZy1zaG93PVxcXCJjb250cm9sbGVyLmhhc1N0cmluZ1xcXCI+e3tjb250cm9sbGVyLnN0cmluZ319PC9zcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIG5nLWhpZGU9XFxcImNvbnRyb2xsZXIuaGFzU3RyaW5nXFxcIiBjbGFzcz1cXFwid2F0ZXJtYXJrXFxcIj57e2NvbnRyb2xsZXIud2F0ZXJtYXJrfX08L3NwYW4+XFxuXFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY29udHJvbGxlcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc3RyaW5nOiAnQCcsXHJcbiAgICAgICAgICAgIHdhdGVybWFyazogJ0AnLFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zdHJpbmdXaXRoV2F0ZXJtYXJrID0gc3RyaW5nV2l0aFdhdGVybWFyaztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgc3RyaW5nV2l0aFdhdGVybWFyaylcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFN0cmluZ1dpdGhXYXRlcm1hcmtDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nV2l0aFdhdGVybWFyay5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc3RyaW5nV2l0aFdhdGVybWFyay9zdHJpbmdXaXRoV2F0ZXJtYXJrLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdGFiXzEgPSByZXF1aXJlKCcuL3RhYicpO1xyXG5leHBvcnRzLnRhYkRpcmVjdGl2ZU5hbWUgPSB0YWJfMS5kaXJlY3RpdmVOYW1lO1xyXG5leHBvcnRzLnRhYiA9IHRhYl8xLnRhYjtcclxuZXhwb3J0cy50YWJDb250cm9sbGVyTmFtZSA9IHRhYl8xLmNvbnRyb2xsZXJOYW1lO1xyXG5leHBvcnRzLlRhYkNvbnRyb2xsZXIgPSB0YWJfMS5UYWJDb250cm9sbGVyO1xyXG52YXIgdGFic2V0XzEgPSByZXF1aXJlKCcuL3RhYnNldCcpO1xyXG5leHBvcnRzLnRhYnNldERpcmVjdGl2ZU5hbWUgPSB0YWJzZXRfMS5kaXJlY3RpdmVOYW1lO1xyXG5leHBvcnRzLnRhYnNldCA9IHRhYnNldF8xLnRhYnNldDtcclxuZXhwb3J0cy50YWJzZXRDb250cm9sbGVyTmFtZSA9IHRhYnNldF8xLmNvbnRyb2xsZXJOYW1lO1xyXG5leHBvcnRzLlRhYnNldENvbnRyb2xsZXIgPSB0YWJzZXRfMS5UYWJzZXRDb250cm9sbGVyO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy50YWJzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUodGFiXzEuZGlyZWN0aXZlTmFtZSwgdGFiXzEudGFiKVxyXG4gICAgLmNvbnRyb2xsZXIodGFiXzEuY29udHJvbGxlck5hbWUsIHRhYl8xLlRhYkNvbnRyb2xsZXIpXHJcbiAgICAuZGlyZWN0aXZlKHRhYnNldF8xLmRpcmVjdGl2ZU5hbWUsIHRhYnNldF8xLnRhYnNldClcclxuICAgIC5jb250cm9sbGVyKHRhYnNldF8xLmNvbnRyb2xsZXJOYW1lLCB0YWJzZXRfMS5UYWJzZXRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFicy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFicy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxUYWInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ3JsVGFiQ29udHJvbGxlcic7XHJcbnZhciBUYWJDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhYkNvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCd0YWJGb3JtLiR2YWxpZCcsIGZ1bmN0aW9uIChpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhlYWRlci5pc1ZhbGlkID0gaXNWYWxpZCAhPSBudWxsID8gaXNWYWxpZCA6IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBUYWJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIFRhYkNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGFiQ29udHJvbGxlciA9IFRhYkNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHRhYigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHJlcXVpcmU6IFsnXl5ybFRhYnNldCcsICdybFRhYiddLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RhYi5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICd0YWInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250cm9sbGVycywgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICB0cmFuc2NsdWRlKGZ1bmN0aW9uIChjbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGNsb25lLmZpbHRlcigncmwtdGFiLWhlYWRlcicpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjbG9uZS5maWx0ZXIoJ3JsLXRhYi1jb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9vdGVyID0gY2xvbmUuZmlsdGVyKCdybC10YWItZm9vdGVyJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFic2V0ID0gY29udHJvbGxlcnNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFiID0gY29udHJvbGxlcnNbMV07XHJcbiAgICAgICAgICAgICAgICB0YWIuaGVhZGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBoZWFkZXIuaHRtbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGFic2V0LnJlZ2lzdGVyVGFiKGVsZW1lbnQsIHRhYi5oZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRBcmVhID0gZWxlbWVudC5maW5kKCcuY29udGVudC10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudEFyZWEuYXBwZW5kKGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuaGFzRm9vdGVyID0gKGZvb3Rlci5sZW5ndGggPiAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5oYXNGb290ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9vdGVyQXJlYSA9IGVsZW1lbnQuZmluZCgnLmZvb3Rlci10ZW1wbGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvb3RlckFyZWEuYXBwZW5kKGZvb3Rlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMudGFiID0gdGFiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFiLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIG5nLWNsYXNzPVxcXCJ7ICdhY3RpdmUnOiB0YWIuaGVhZGVyLmlzVmlzaWJsZSB9XFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJ0YWItYm9keVxcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC10ZW1wbGF0ZVxcXCIgbmctZm9ybT1cXFwidGFiRm9ybVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcInRhYi1mb290ZXJcXFwiIG5nLXNob3c9XFxcImhhc0Zvb3RlclxcXCI+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9vdGVyLXRlbXBsYXRlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvdGFicy90YWIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFRhYnNldCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAncmxUYWJzZXRDb250cm9sbGVyJztcclxudmFyIFRhYnNldENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGFic2V0Q29udHJvbGxlcigpIHtcclxuICAgICAgICB0aGlzLnRhYkhlYWRlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIFRhYnNldENvbnRyb2xsZXIucHJvdG90eXBlLnJlZ2lzdGVyVGFiID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhlYWRlcikge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZFBvc2l0aW9uKGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMudGFiSGVhZGVyc1tpbmRleF0gPSBoZWFkZXI7XHJcbiAgICAgICAgaGVhZGVyLmlzVmlzaWJsZSA9IChpbmRleCA9PT0gMCk7XHJcbiAgICB9O1xyXG4gICAgVGFic2V0Q29udHJvbGxlci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHRhYikge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLnRhYkhlYWRlcnMsIGZ1bmN0aW9uIChvdGhlclRhYikge1xyXG4gICAgICAgICAgICBvdGhlclRhYi5pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0YWIuaXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGFic2V0Q29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5UYWJzZXRDb250cm9sbGVyID0gVGFic2V0Q29udHJvbGxlcjtcclxuZnVuY3Rpb24gdGFic2V0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdGFic2V0Lmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3RhYnNldCcsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGxpbms6IHtcclxuICAgICAgICAgICAgcHJlOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB0YWJzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRhYnNldC5maW5kUG9zaXRpb24gPSBmdW5jdGlvbiAodGFiRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBieSBpdGVyYXRpbmcgb3ZlciB0aGUgdGFicyBhbmQgZmluZGluZyBhIG1hdGNoaW5nIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFicyA9IGVsZW1lbnQuZmluZCgncmwtdGFiJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bTtcclxuICAgICAgICAgICAgICAgICAgICBfLmVhY2godGFicywgZnVuY3Rpb24gKGVsZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWJFbGVtZW50WzBdID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW0gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMudGFic2V0ID0gdGFic2V0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzZXQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFic2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibmF2LXRhYnMtZHJvcHNoYWRvd1xcXCI+XFxyXFxuXFx0PHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnNcXFwiPlxcclxcblxcdFxcdDxsaSBuZy1yZXBlYXQ9XFxcInRhYkhlYWRlciBpbiB0YWJzZXQudGFiSGVhZGVyc1xcXCIgbmctY2xpY2s9XFxcInRhYnNldC5zZWxlY3QodGFiSGVhZGVyKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1jbGFzcz1cXFwieyAnYWN0aXZlJzogdGFiSGVhZGVyLmlzVmlzaWJsZSwgJ2Vycm9yJzogIXRhYkhlYWRlci5pc1ZhbGlkIH1cXFwiPlxcclxcblxcdFxcdFxcdDxhPjxzcGFuIG5nLWJpbmQtaHRtbD1cXFwidGFiSGVhZGVyLnRlbXBsYXRlXFxcIj48L3NwYW4+PC9hPlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0PC91bD5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxyXFxuXFx0XFx0PGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFic2V0Lmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMudGV4dGFyZWEnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxUZXh0YXJlYSc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnVGV4dGFyZWFDb250cm9sbGVyJztcclxudmFyIFRleHRhcmVhQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZXh0YXJlYUNvbnRyb2xsZXIoJGVsZW1lbnQsICRzY29wZSwgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMubmdNb2RlbCA9ICRlbGVtZW50LmNvbnRyb2xsZXIoJ25nTW9kZWwnKTtcclxuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy52YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWFWYWxpZGF0b3IgPSBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgICAgIG5nTW9kZWw6IHRoaXMubmdNb2RlbCxcclxuICAgICAgICAgICAgICAgICRzY29wZTogJHNjb3BlLFxyXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW3RoaXMudmFsaWRhdG9yXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHRhcmVhQ29udHJvbGxlci5wcm90b3R5cGUsIFwidGV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5nTW9kZWwuJHZpZXdWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRleHRhcmVhQ29udHJvbGxlci4kaW5qZWN0ID0gWyckZWxlbWVudCcsICckc2NvcGUnLCBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLmZhY3RvcnlOYW1lXTtcclxuICAgIHJldHVybiBUZXh0YXJlYUNvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVGV4dGFyZWFDb250cm9sbGVyID0gVGV4dGFyZWFDb250cm9sbGVyO1xyXG5mdW5jdGlvbiB0ZXh0YXJlYSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdGV4dGFyZWEuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAndGV4dGFyZWEnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdAJyxcclxuICAgICAgICAgICAgcm93czogJz0nLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnQCcsXHJcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMudGV4dGFyZWEgPSB0ZXh0YXJlYTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCB0ZXh0YXJlYSlcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFRleHRhcmVhQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHRhcmVhLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0YXJlYS90ZXh0YXJlYS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInZhbGlkYXRpb24taW5wdXQtZ3JvdXBcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImZpZWxkIHZhbGlkYXRpb24taW5wdXRcXFwiIG5nLWNsYXNzPVxcXCJ7ICdlcnJvcic6IHRleHRhcmVhLm5nTW9kZWwuJGludmFsaWQsICdyZXF1aXJlZC1lcnJvcic6IHRleHRhcmVhLm5nTW9kZWwuJGVycm9yLnJlcXVpcmVkIH1cXFwiPlxcclxcblxcdFxcdDxsYWJlbCBuZy1zaG93PVxcXCJ0ZXh0YXJlYS50ZXh0XFxcIiBjbGFzcz1cXFwic2hvdy1oaWRlIGFuZ3VsYXItYW5pbWF0ZVxcXCI+e3t0ZXh0YXJlYS5sYWJlbH19PC9sYWJlbD5cXHJcXG5cXHRcXHQ8dGV4dGFyZWEgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmctbW9kZWw9XFxcInRleHRhcmVhLnRleHRcXFwiIG5hbWU9XFxcInt7dGV4dGFyZWEubmFtZX19XFxcIiByb3dzPVxcXCJ7e3RleHRhcmVhLnJvd3N9fVxcXCIgbmctZGlzYWJsZWQ9XFxcInRleHRhcmVhLm5nRGlzYWJsZWRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7e3RleHRhcmVhLmxhYmVsfX1cXFwiPjwvdGV4dGFyZWE+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZXJyb3Itc3RyaW5nXFxcIiBuZy1oaWRlPVxcXCJ0ZXh0YXJlYS50ZXh0YXJlYVZhbGlkYXRvci5lcnJvciB8IGlzRW1wdHlcXFwiPnt7dGV4dGFyZWEudGV4dGFyZWFWYWxpZGF0b3IuZXJyb3J9fTwvc3Bhbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0YXJlYS90ZXh0YXJlYS5odG1sXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvY29tcG9uZW50VmFsaWRhdG9yL2NvbXBvbmVudFZhbGlkYXRvci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnRleHRib3gnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxUZXh0Ym94JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdUZXh0Ym94Q29udHJvbGxlcic7XHJcbnZhciBUZXh0Ym94Q29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZXh0Ym94Q29udHJvbGxlcigkZWxlbWVudCwgJHNjb3BlLCBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5uZ01vZGVsID0gJGVsZW1lbnQuY29udHJvbGxlcignbmdNb2RlbCcpO1xyXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aGlzLnZhbGlkYXRvcikpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0Ym94VmFsaWRhdG9yID0gY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeS5nZXRJbnN0YW5jZSh7XHJcbiAgICAgICAgICAgICAgICBuZ01vZGVsOiB0aGlzLm5nTW9kZWwsXHJcbiAgICAgICAgICAgICAgICAkc2NvcGU6ICRzY29wZSxcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IFt0aGlzLnZhbGlkYXRvcl0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0Ym94Q29udHJvbGxlci5wcm90b3R5cGUsIFwidGV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5nTW9kZWwuJHZpZXdWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRleHRib3hDb250cm9sbGVyLiRpbmplY3QgPSBbJyRlbGVtZW50JywgJyRzY29wZScsIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEuZmFjdG9yeU5hbWVdO1xyXG4gICAgcmV0dXJuIFRleHRib3hDb250cm9sbGVyO1xyXG59KSgpO1xyXG5leHBvcnRzLlRleHRib3hDb250cm9sbGVyID0gVGV4dGJveENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHRleHRib3goKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RleHRib3guaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAndGV4dGJveCcsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yOiAnPScsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnQCcsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy50ZXh0Ym94ID0gdGV4dGJveDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCB0ZXh0Ym94KVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgVGV4dGJveENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0Ym94LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0Ym94L3RleHRib3guanNcbiAqKiBtb2R1bGUgaWQgPSAxNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ2YWxpZGF0aW9uLWlucHV0LWdyb3VwXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJmaWVsZCB2YWxpZGF0aW9uLWlucHV0XFxcIiBuZy1jbGFzcz1cXFwieyAnZXJyb3InOiB0ZXh0Ym94Lm5nTW9kZWwuJGludmFsaWQsICdyZXF1aXJlZC1lcnJvcic6IHRleHRib3gubmdNb2RlbC4kZXJyb3IucmVxdWlyZWQgfVxcXCI+XFxyXFxuXFx0XFx0PGxhYmVsIG5nLXNob3c9XFxcInRleHRib3gudGV4dFxcXCIgY2xhc3M9XFxcInNob3ctaGlkZSBhbmd1bGFyLWFuaW1hdGVcXFwiPnt7dGV4dGJveC5sYWJlbH19PC9sYWJlbD5cXHJcXG5cXHRcXHQ8aW5wdXQgIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgYW5ndWxhci1hbmltYXRlXFxcIiBuZy1tb2RlbD1cXFwidGV4dGJveC50ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwie3t0ZXh0Ym94LmxhYmVsfX1cXFwiLz5cXHJcXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJlcnJvci1zdHJpbmdcXFwiIG5nLWhpZGU9XFxcInRleHRib3gudGV4dGJveFZhbGlkYXRvci5lcnJvciB8IGlzRW1wdHlcXFwiPnt7dGV4dGJveC50ZXh0Ym94VmFsaWRhdG9yLmVycm9yfX08L3NwYW4+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvdGV4dGJveC90ZXh0Ym94Lmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBfX2dlbmVyaWNTZWFyY2ggPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZ2VuZXJpY1NlYXJjaEZpbHRlcjtcclxudmFyIF9fb2JqZWN0VXRpbGl0eSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBfX2FycmF5VXRpbGl0eSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIF9fcHJvbWlzZVV0aWxpdHkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMudHlwZWFoZWFkJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsVHlwZWFoZWFkJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdUeXBlYWhlYWRDb250cm9sbGVyJztcclxudmFyIFR5cGVhaGVhZENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHlwZWFoZWFkQ29udHJvbGxlcigkc2NvcGUsICRhdHRycywgJHEsIHBhcmVudENoaWxkLCBnZW5lcmljU2VhcmNoRmFjdG9yeSwgb2JqZWN0LCBhcnJheSwgcHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy4kcSA9ICRxO1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQgPSBwYXJlbnRDaGlsZDtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFkZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY2FjaGVkSXRlbXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FjaGVkSXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmNhY2hlZEl0ZW1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFycmF5LnJlbW92ZShfdGhpcy5jYWNoZWRJdGVtcywgaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2VhcmNoRmlsdGVyID0gZ2VuZXJpY1NlYXJjaEZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmxvYWREZWxheSA9IHRoaXMudXNlQ2xpZW50U2VhcmNoaW5nID8gMTAwIDogNTAwO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb25CaW5kaW5nO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9ICdTZWFyY2gnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zaG93U2VhcmNoID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51c2VTY29wZVNlbGVjdGlvbiA9IG9iamVjdC5pc051bGxPckVtcHR5KCRhdHRycy5zZWxlY3Rpb24pID09PSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhhc1RyYW5zZm9ybSA9IG9iamVjdC5pc051bGxPckVtcHR5KCRhdHRycy50cmFuc2Zvcm0pID09PSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVzZUFwcGx5ID0gb2JqZWN0LmlzTnVsbE9yRW1wdHkoJGF0dHJzLmFwcGx5KSA9PT0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZC5yZWdpc3RlckNoaWxkQmVoYXZpb3IodGhpcy5jaGlsZExpbmssIHtcclxuICAgICAgICAgICAgYWRkOiB0aGlzLmFkZEl0ZW0sXHJcbiAgICAgICAgICAgIHJlbW92ZTogdGhpcy5yZW1vdmVJdGVtLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0aW9uOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFzU2VsZWN0aW9uID0gXy5pc09iamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnNldFNlbGVjdGlvbih2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3Rpb25CaW5kaW5nOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFR5cGVhaGVhZENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICBpZiAodGhpcy51c2VTY29wZVNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLnNlbGVjdCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoeyB2YWx1ZTogb2JqZWN0LCBoYXNTZWxlY3Rpb246IHRoaXMuaGFzU2VsZWN0aW9uIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUeXBlYWhlYWRDb250cm9sbGVyLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzVHJhbnNmb3JtICYmIG9iamVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUluUGFyZW50KHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBvYmplY3QsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfTtcclxuICAgIFR5cGVhaGVhZENvbnRyb2xsZXIucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24gKHNlYXJjaCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVzZUNsaWVudFNlYXJjaGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtc0luUGFyZW50KHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaDogc2VhcmNoLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmlsdGVyLnNlYXJjaFRleHQgPSBzZWFyY2g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlZEl0ZW1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLndoZW4odGhpcy5maWx0ZXIodGhpcy5jYWNoZWRJdGVtcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEud2hlbih0aGlzLmdldEl0ZW1zSW5QYXJlbnQoKSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhY2hlZEl0ZW1zID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmlsdGVyKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuYXBwbHlJdGVtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMudXNlQXBwbHkgJiYgdGhpcy5oYXNTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLmFwcGx5KHsgdmFsdWU6IHRoaXMuc2VsZWN0aW9uIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9taXNlLmlzUHJvbWlzZShyZXF1ZXN0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlSXRlbShfdGhpcy5zZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChyZXF1ZXN0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtKHRoaXMuc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy4kcS53aGVuKCk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGxpc3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfLmZpbHRlcihsaXN0LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gX3RoaXMuc2VhcmNoRmlsdGVyLmZpbHRlcihpdGVtKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLFxyXG4gICAgICAgICckYXR0cnMnLFxyXG4gICAgICAgICckcScsXHJcbiAgICAgICAgX19wYXJlbnRDaGlsZC5zZXJ2aWNlTmFtZSxcclxuICAgICAgICBfX2dlbmVyaWNTZWFyY2guZmFjdG9yeU5hbWUsXHJcbiAgICAgICAgX19vYmplY3RVdGlsaXR5LnNlcnZpY2VOYW1lLFxyXG4gICAgICAgIF9fYXJyYXlVdGlsaXR5LnNlcnZpY2VOYW1lLFxyXG4gICAgICAgIF9fcHJvbWlzZVV0aWxpdHkuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFR5cGVhaGVhZENvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVHlwZWFoZWFkQ29udHJvbGxlciA9IFR5cGVhaGVhZENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHR5cGVhaGVhZCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90eXBlYWhlYWQuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAndHlwZWFoZWFkJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBjaGlsZExpbms6ICc9JyxcclxuICAgICAgICAgICAgc2VsZWN0aW9uQmluZGluZzogJz1zZWxlY3Rpb24nLFxyXG4gICAgICAgICAgICBoYXNTZWxlY3Rpb246ICc9JyxcclxuICAgICAgICAgICAgc2VsZWN0OiAnJicsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUluUGFyZW50OiAnJnRyYW5zZm9ybScsXHJcbiAgICAgICAgICAgIGdldEl0ZW1zSW5QYXJlbnQ6ICcmZ2V0SXRlbXMnLFxyXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJ0AnLFxyXG4gICAgICAgICAgICB1c2VDbGllbnRTZWFyY2hpbmc6ICc9JyxcclxuICAgICAgICAgICAgaGFzRXJyb3I6ICc9JyxcclxuICAgICAgICAgICAgc2hvd1NlYXJjaDogJz0nLFxyXG4gICAgICAgICAgICBhcHBseTogJyYnLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMudHlwZWFoZWFkID0gdHlwZWFoZWFkO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIF9fcGFyZW50Q2hpbGQubW9kdWxlTmFtZSxcclxuICAgIF9fZ2VuZXJpY1NlYXJjaC5tb2R1bGVOYW1lLFxyXG4gICAgX19vYmplY3RVdGlsaXR5Lm1vZHVsZU5hbWUsXHJcbiAgICBfX2FycmF5VXRpbGl0eS5tb2R1bGVOYW1lLFxyXG4gICAgX19wcm9taXNlVXRpbGl0eS5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCB0eXBlYWhlYWQpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBUeXBlYWhlYWRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWFoZWFkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLmpzXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7ICdoYXMtZXJyb3InOiB0eXBlYWhlYWQuaGFzRXJyb3IgfVxcXCI+XFxyXFxuXFx0PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJ0eXBlYWhlYWQuc2VsZWN0aW9uXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIlxcclxcblxcdFxcdHBsYWNlaG9sZGVyPVxcXCJ7e3R5cGVhaGVhZC5wbGFjZWhvbGRlcn19XFxcIiB0eXBlYWhlYWQ9XFxcIm9iamVjdCBhcyB0eXBlYWhlYWQudHJhbnNmb3JtKG9iamVjdCkgZm9yIG9iamVjdCBpbiB0eXBlYWhlYWQuZ2V0SXRlbXMoJHZpZXdWYWx1ZSlcXFwiXFxyXFxuXFx0XFx0dHlwZWFoZWFkLWxvYWRpbmc9XFxcInR5cGVhaGVhZC5sb2FkaW5nXFxcIiB0eXBlYWhlYWQtd2FpdC1tcz1cXFwidHlwZWFoZWFkLmxvYWREZWxheVxcXCIgLz5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cC1hZGRvblxcXCIgbmctaWY9XFxcInR5cGVhaGVhZC5zaG93U2VhcmNoXFxcIj5cXHJcXG5cXHRcXHQ8cmwtYnVzeSBsb2FkaW5nPVxcXCJ0eXBlYWhlYWQubG9hZGluZ1xcXCI+PC9ybC1idXN5PlxcclxcblxcdFxcdDxzcGFuIG5nLWhpZGU9XFxcInR5cGVhaGVhZC5sb2FkaW5nXFxcIj5cXHJcXG5cXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtc2VhcmNoXFxcIiBuZy1oaWRlPVxcXCJ0eXBlYWhlYWQuaGFzU2VsZWN0aW9uXFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWNoZWNrXFxcIiBuZy1zaG93PVxcXCJ0eXBlYWhlYWQuaGFzU2VsZWN0aW9uXFxcIj48L2k+XFxyXFxuXFx0XFx0PC9zcGFuPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCIgbmctaWY9XFxcInR5cGVhaGVhZC51c2VBcHBseVxcXCI+XFxyXFxuXFx0XFx0PHJsLWJ1dHRvbi1hc3luYyB0eXBlPVxcXCJkZWZhdWx0XFxcIiBhY3Rpb249XFxcInR5cGVhaGVhZC5hcHBseUl0ZW0oKVxcXCIgcmlnaHQtYWxpZ25lZD1cXFwidHJ1ZVxcXCIgbmctZGlzYWJsZWQ9XFxcIiF0eXBlYWhlYWQuaGFzU2VsZWN0aW9uXFxcIj5cXHJcXG5cXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtcGx1cyBuZXdcXFwiPjwvaT5cXHJcXG5cXHRcXHQ8L3JsLWJ1dHRvbi1hc3luYz5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC5jb21wb25lbnRzLnVzZXJSYXRpbmcnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxVc2VyUmF0aW5nJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdVc2VyUmF0aW5nQ29udHJvbGxlcic7XHJcbnZhciBVc2VyUmF0aW5nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVc2VyUmF0aW5nQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuc3RhcnMgPSBbXTtcclxuICAgICAgICB2YXIgcmFuZ2VTaXplID0gdGhpcy4kc2NvcGUucmFuZ2UgIT0gbnVsbCA/IHRoaXMuJHNjb3BlLnJhbmdlIDogNTtcclxuICAgICAgICAvLyBjc3Mgc3R5bGUgcmVxdWlyZXMgdGhlIHN0YXJzIHRvIHNob3cgcmlnaHQgdG8gbGVmdC4gUmV2ZXJzZSB0aGUgbGlzdCBzbyB0aGUgaGlnaGVzdCB2YWx1ZSBpcyBmaXJzdFxyXG4gICAgICAgIHZhciByYW5nZSA9IF8ucmFuZ2UoMSwgcmFuZ2VTaXplICsgMSkucmV2ZXJzZSgpO1xyXG4gICAgICAgIF8uZWFjaChyYW5nZSwgZnVuY3Rpb24gKHJhdGluZykge1xyXG4gICAgICAgICAgICBfdGhpcy5zdGFycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiByYXRpbmcsXHJcbiAgICAgICAgICAgICAgICBmaWxsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgdW5iaW5kID0gdGhpcy4kc2NvcGUuJHdhdGNoKCduZ01vZGVsJywgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN0YXJWaWV3KF90aGlzLiRzY29wZS5uZ01vZGVsLiR2aWV3VmFsdWUpO1xyXG4gICAgICAgICAgICB1bmJpbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFVzZXJSYXRpbmdDb250cm9sbGVyLnByb3RvdHlwZS5zZXRSYXRpbmcgPSBmdW5jdGlvbiAocmF0aW5nKSB7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHJhdGluZyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGFyVmlldyhyYXRpbmcpO1xyXG4gICAgfTtcclxuICAgIFVzZXJSYXRpbmdDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVTdGFyVmlldyA9IGZ1bmN0aW9uIChyYXRpbmcpIHtcclxuICAgICAgICBfLmVhY2godGhpcy5zdGFycywgZnVuY3Rpb24gKHN0YXIpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXIudmFsdWUgPD0gcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFyLmZpbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFyLmZpbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVXNlclJhdGluZ0NvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gVXNlclJhdGluZ0NvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuVXNlclJhdGluZ0NvbnRyb2xsZXIgPSBVc2VyUmF0aW5nQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gdXNlclJhdGluZygpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcInJhdGluZ1xcXCI+XFxuXFx0XFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcInN0YXJcXFwiIG5nLXJlcGVhdD1cXFwic3RhciBpbiB1c2VyUmF0aW5nLnN0YXJzXFxcIiBuZy1jbGFzcz1cXFwieyAnZmlsbGVkJzogc3Rhci5maWxsZWQgfVxcXCIgbmctY2xpY2s9XFxcInVzZXJSYXRpbmcuc2V0UmF0aW5nKHN0YXIudmFsdWUpXFxcIj48L3NwYW4+XFxuXFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAndXNlclJhdGluZycsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgcmFuZ2U6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgICAgICAgc2NvcGUubmdNb2RlbCA9IG5nTW9kZWw7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy51c2VyUmF0aW5nID0gdXNlclJhdGluZztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCB1c2VyUmF0aW5nKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgVXNlclJhdGluZ0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VyUmF0aW5nLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy91c2VyUmF0aW5nL3VzZXJSYXRpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMudmFsaWRhdGlvbkdyb3VwJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsVmFsaWRhdGlvbkdyb3VwJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdWYWxpZGF0aW9uR3JvdXBDb250cm9sbGVyJztcclxudmFyIFZhbGlkYXRpb25Hcm91cENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkdyb3VwQ29udHJvbGxlcigkc2NvcGUsIGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1bmJpbmQgPSAkc2NvcGUuJHdhdGNoKCd2YWxpZGF0aW9uR3JvdXBGb3JtJywgZnVuY3Rpb24gKGZvcm0pIHtcclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF90aGlzLnZhbGlkYXRvcikpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmdyb3VwVmFsaWRhdG9yID0gY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeS5nZXRJbnN0YW5jZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybTogJHNjb3BlLnZhbGlkYXRpb25Hcm91cEZvcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlOiAkc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yczogW190aGlzLnZhbGlkYXRvcl0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1bmJpbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFZhbGlkYXRpb25Hcm91cENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvbkdyb3VwQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5WYWxpZGF0aW9uR3JvdXBDb250cm9sbGVyID0gVmFsaWRhdGlvbkdyb3VwQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gdmFsaWRhdGlvbkdyb3VwKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdmFsaWRhdGlvbkdyb3VwLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2dyb3VwJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICB2YWxpZGF0b3I6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnZhbGlkYXRpb25Hcm91cCA9IHZhbGlkYXRpb25Hcm91cDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCB2YWxpZGF0aW9uR3JvdXApXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBWYWxpZGF0aW9uR3JvdXBDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbkdyb3VwLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy92YWxpZGF0aW9uR3JvdXAvdmFsaWRhdGlvbkdyb3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMTU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiY29udGVudC1ncm91cFxcXCIgbmctZm9ybT1cXFwidmFsaWRhdGlvbkdyb3VwRm9ybVxcXCI+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiZXJyb3JcXFwiIG5nLXNob3c9XFxcInZhbGlkYXRpb25Hcm91cEZvcm0uJGVycm9yLmN1c3RvbVZhbGlkYXRpb25cXFwiPlxcclxcblxcdFxcdDxsYWJlbD57e2dyb3VwLmdyb3VwVmFsaWRhdG9yLmVycm9yfX08L2xhYmVsPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy92YWxpZGF0aW9uR3JvdXAvdmFsaWRhdGlvbkdyb3VwLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBhdXRvc2F2ZSA9IHJlcXVpcmUoJy4vYXV0b3NhdmUvYXV0b3NhdmUuc2VydmljZScpO1xyXG5leHBvcnRzLmF1dG9zYXZlID0gYXV0b3NhdmU7XHJcbnZhciBhdXRvc2F2ZUFjdGlvbiA9IHJlcXVpcmUoJy4vYXV0b3NhdmVBY3Rpb24vYXV0b3NhdmVBY3Rpb24uc2VydmljZScpO1xyXG5leHBvcnRzLmF1dG9zYXZlQWN0aW9uID0gYXV0b3NhdmVBY3Rpb247XHJcbnZhciBhdXRvc2F2ZURpYWxvZyA9IHJlcXVpcmUoJy4vYXV0b3NhdmVEaWFsb2cvYXV0b3NhdmVEaWFsb2cubW9kdWxlJyk7XHJcbmV4cG9ydHMuYXV0b3NhdmVEaWFsb2cgPSBhdXRvc2F2ZURpYWxvZztcclxudmFyIGJyZWFrcG9pbnRzID0gcmVxdWlyZSgnLi9icmVha3BvaW50cy9icmVha3BvaW50cy5tb2R1bGUnKTtcclxuZXhwb3J0cy5icmVha3BvaW50cyA9IGJyZWFrcG9pbnRzO1xyXG52YXIgY29tcG9uZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5jb21wb25lbnRWYWxpZGF0b3IgPSBjb21wb25lbnRWYWxpZGF0b3I7XHJcbnZhciBjb250ZW50UHJvdmlkZXIgPSByZXF1aXJlKCcuL2NvbnRlbnRQcm92aWRlci9jb250ZW50UHJvdmlkZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmNvbnRlbnRQcm92aWRlciA9IGNvbnRlbnRQcm92aWRlcjtcclxudmFyIGRpYWxvZyA9IHJlcXVpcmUoJy4vZGlhbG9nL2RpYWxvZy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZGlhbG9nID0gZGlhbG9nO1xyXG52YXIgZG9jdW1lbnRXcmFwcGVyID0gcmVxdWlyZSgnLi9kb2N1bWVudFdyYXBwZXIvZG9jdW1lbnRXcmFwcGVyLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kb2N1bWVudFdyYXBwZXIgPSBkb2N1bWVudFdyYXBwZXI7XHJcbnZhciBqcXVlcnkgPSByZXF1aXJlKCcuL2pxdWVyeS9qcXVlcnkuc2VydmljZScpO1xyXG5leHBvcnRzLmpxdWVyeSA9IGpxdWVyeTtcclxudmFyIHRlbXBsYXRlTG9hZGVyID0gcmVxdWlyZSgnLi90ZW1wbGF0ZUxvYWRlci90ZW1wbGF0ZUxvYWRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMudGVtcGxhdGVMb2FkZXIgPSB0ZW1wbGF0ZUxvYWRlcjtcclxudmFyIHdpbmRvd1dyYXBwZXIgPSByZXF1aXJlKCcuL3dpbmRvd1dyYXBwZXIvd2luZG93V3JhcHBlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMud2luZG93V3JhcHBlciA9IHdpbmRvd1dyYXBwZXI7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgYXV0b3NhdmUubW9kdWxlTmFtZSxcclxuICAgIGF1dG9zYXZlQWN0aW9uLm1vZHVsZU5hbWUsXHJcbiAgICBhdXRvc2F2ZURpYWxvZy5tb2R1bGVOYW1lLFxyXG4gICAgYnJlYWtwb2ludHMubW9kdWxlTmFtZSxcclxuICAgIGNvbXBvbmVudFZhbGlkYXRvci5tb2R1bGVOYW1lLFxyXG4gICAgY29udGVudFByb3ZpZGVyLm1vZHVsZU5hbWUsXHJcbiAgICBkaWFsb2cubW9kdWxlTmFtZSxcclxuICAgIGRvY3VtZW50V3JhcHBlci5tb2R1bGVOYW1lLFxyXG4gICAganF1ZXJ5Lm1vZHVsZU5hbWUsXHJcbiAgICB0ZW1wbGF0ZUxvYWRlci5tb2R1bGVOYW1lLFxyXG4gICAgd2luZG93V3JhcHBlci5tb2R1bGVOYW1lLFxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZXMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvc2VydmljZXMubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcHJvbWlzZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG52YXIgYXV0b3NhdmVfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vYXV0b3NhdmUvYXV0b3NhdmUuc2VydmljZScpO1xyXG52YXIgYXV0b3NhdmVEaWFsb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZy5zZXJ2aWNlJyk7XHJcbnZhciBhdXRvc2F2ZURpYWxvZ19jb250cm9sbGVyXzEgPSByZXF1aXJlKCcuL2F1dG9zYXZlRGlhbG9nLmNvbnRyb2xsZXInKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZy5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2F1dG9zYXZlRGlhbG9nLmNvbnRyb2xsZXInKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5hdXRvc2F2ZURpYWxvZyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fcHJvbWlzZS5tb2R1bGVOYW1lLCBhdXRvc2F2ZV9zZXJ2aWNlXzEubW9kdWxlTmFtZV0pXHJcbiAgICAuc2VydmljZShhdXRvc2F2ZURpYWxvZ19zZXJ2aWNlXzEuc2VydmljZU5hbWUsIGF1dG9zYXZlRGlhbG9nX3NlcnZpY2VfMS5BdXRvc2F2ZURpYWxvZ1NlcnZpY2UpXHJcbiAgICAuY29udHJvbGxlcihhdXRvc2F2ZURpYWxvZ19jb250cm9sbGVyXzEuY29udHJvbGxlck5hbWUsIGF1dG9zYXZlRGlhbG9nX2NvbnRyb2xsZXJfMS5BdXRvc2F2ZURpYWxvZ0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZURpYWxvZy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZURpYWxvZy9hdXRvc2F2ZURpYWxvZy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcHJvbWlzZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG52YXIgZGlhbG9nX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RpYWxvZy9kaWFsb2cuc2VydmljZScpO1xyXG52YXIgYXV0b3NhdmVfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vYXV0b3NhdmUvYXV0b3NhdmUuc2VydmljZScpO1xyXG52YXIgYXV0b3NhdmVEaWFsb2dfY29udHJvbGxlcl8xID0gcmVxdWlyZSgnLi9hdXRvc2F2ZURpYWxvZy5jb250cm9sbGVyJyk7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnYXV0b3NhdmVEaWFsb2cnO1xyXG52YXIgQXV0b3NhdmVEaWFsb2dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlRGlhbG9nU2VydmljZSgkcm9vdFNjb3BlLCBkaWFsb2csIGF1dG9zYXZlRmFjdG9yeSwgcHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlID0gJHJvb3RTY29wZTtcclxuICAgICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcclxuICAgICAgICB0aGlzLmF1dG9zYXZlRmFjdG9yeSA9IGF1dG9zYXZlRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVDbG9zZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXhwbGljaXQpIHtcclxuICAgICAgICAgICAgaWYgKGV4cGxpY2l0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXV0b3NhdmUuYXV0b3NhdmUoX3RoaXMuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNldEZvcm0gPSBmdW5jdGlvbiAoZm9ybSkge1xyXG4gICAgICAgICAgICBfdGhpcy5hdXRvc2F2ZS5jb250ZW50Rm9ybSA9IGZvcm07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIEF1dG9zYXZlRGlhbG9nU2VydmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnByb21pc2UucmVzb2x2ZVByb21pc2VzKG9wdGlvbnMucmVzb2x2ZSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNjb3BlID0gb3B0aW9ucy5zY29wZTtcclxuICAgICAgICAgICAgaWYgKHNjb3BlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlID0gX3RoaXMuJHJvb3RTY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNjb3BlID0gc2NvcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50cmlnZ2VycyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRyaWdnZXJzID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmF1dG9zYXZlID0gX3RoaXMuYXV0b3NhdmVGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgICAgIHNhdmU6IG9wdGlvbnMuc2F2ZSxcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlOiBvcHRpb25zLnZhbGlkYXRlLFxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnM6IG9wdGlvbnMudHJpZ2dlcnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzY29wZS5mb3JtID0gb3B0aW9ucy5mb3JtO1xyXG4gICAgICAgICAgICBzY29wZS5mb3JtR2V0dGVyID0gb3B0aW9ucy5mb3JtR2V0dGVyO1xyXG4gICAgICAgICAgICBzY29wZS5zZXRGb3JtID0gX3RoaXMuc2V0Rm9ybTtcclxuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IF8uZXh0ZW5kKG9wdGlvbnMuZGF0YSwgcmVzb2x2ZURhdGEpO1xyXG4gICAgICAgICAgICBzY29wZS5kaWFsb2cgPSBfdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgZGlhbG9nT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIGRpYWxvZ09wdGlvbnMuY29udHJvbGxlciA9IGF1dG9zYXZlRGlhbG9nX2NvbnRyb2xsZXJfMS5jb250cm9sbGVyTmFtZTtcclxuICAgICAgICAgICAgZGlhbG9nT3B0aW9ucy5jb250cm9sbGVyQXMgPSAnY29udHJvbGxlcic7XHJcbiAgICAgICAgICAgIF90aGlzLmRpYWxvZy5vcGVuKG9wdGlvbnMsIF90aGlzLmF1dG9zYXZlQ2xvc2VIYW5kbGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBdXRvc2F2ZURpYWxvZ1NlcnZpY2UuJGluamVjdCA9IFsnJHJvb3RTY29wZScsIGRpYWxvZ19zZXJ2aWNlXzEuc2VydmljZU5hbWUsIGF1dG9zYXZlX3NlcnZpY2VfMS5mYWN0b3J5TmFtZSwgX19wcm9taXNlLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBBdXRvc2F2ZURpYWxvZ1NlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQXV0b3NhdmVEaWFsb2dTZXJ2aWNlID0gQXV0b3NhdmVEaWFsb2dTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZURpYWxvZy5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmVEaWFsb2cvYXV0b3NhdmVEaWFsb2cuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgbmcgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBiYXNlRGlhbG9nID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nL2Jhc2VEaWFsb2cubW9kdWxlJyk7XHJcbmV4cG9ydHMuYmFzZURpYWxvZyA9IGJhc2VEaWFsb2c7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5kaWFsb2cnO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ2RpYWxvZyc7XHJcbnZhciBEaWFsb2dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpYWxvZ1NlcnZpY2UoZGlhbG9nKSB7XHJcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XHJcbiAgICB9XHJcbiAgICBEaWFsb2dTZXJ2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsb3NlSGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpYWxvZy5vcGVuKG9wdGlvbnMsIGNsb3NlSGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpYWxvZ1NlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRGlhbG9nU2VydmljZSA9IERpYWxvZ1NlcnZpY2U7XHJcbmZ1bmN0aW9uIGRpYWxvZ1NlcnZpY2VQcm92aWRlcigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB2YXIgcHJvdmlkZXIgPSB7XHJcbiAgICAgICAgc2V0SW1wbGVtZW50YXRpb246IGZ1bmN0aW9uIChkaWFsb2dJbXBsZW1lbnRhdGlvbikge1xyXG4gICAgICAgICAgICBfdGhpcy5kaWFsb2dJbXBsZW1lbnRhdGlvbiA9IGRpYWxvZ0ltcGxlbWVudGF0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJGdldDogZnVuY3Rpb24gKGJhc2VEaWFsb2cpIHtcclxuICAgICAgICAgICAgdmFyIGRpYWxvZ0ltcGxlbWVudGF0aW9uID0gX3RoaXMuZGlhbG9nSW1wbGVtZW50YXRpb24gIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5kaWFsb2dJbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgOiBiYXNlRGlhbG9nO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWxvZ1NlcnZpY2UoZGlhbG9nSW1wbGVtZW50YXRpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcHJvdmlkZXIuJGdldC4kaW5qZWN0ID0gW2Jhc2VEaWFsb2cuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIHByb3ZpZGVyO1xyXG59XHJcbmV4cG9ydHMuZGlhbG9nU2VydmljZVByb3ZpZGVyID0gZGlhbG9nU2VydmljZVByb3ZpZGVyO1xyXG5uZy5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbYmFzZURpYWxvZy5tb2R1bGVOYW1lXSlcclxuICAgIC5wcm92aWRlcihleHBvcnRzLnNlcnZpY2VOYW1lLCBkaWFsb2dTZXJ2aWNlUHJvdmlkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWFsb2cuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9kaWFsb2cuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3Byb21pc2UgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxudmFyIGJhc2VEaWFsb2dfY29udHJvbGxlcl8xID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nLmNvbnRyb2xsZXInKTtcclxudmFyIGJhc2VEaWFsb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nLnNlcnZpY2UnKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9iYXNlRGlhbG9nLmNvbnRyb2xsZXInKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYmFzZURpYWxvZy5zZXJ2aWNlJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMuZGlhbG9nLmJhc2VEaWFsb2cnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX3Byb21pc2UubW9kdWxlTmFtZV0pXHJcbiAgICAuY29udHJvbGxlcihiYXNlRGlhbG9nX2NvbnRyb2xsZXJfMS5jb250cm9sbGVyTmFtZSwgYmFzZURpYWxvZ19jb250cm9sbGVyXzEuQmFzZURpYWxvZ0NvbnRyb2xsZXIpXHJcbiAgICAuc2VydmljZShiYXNlRGlhbG9nX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSwgYmFzZURpYWxvZ19zZXJ2aWNlXzEuQmFzZURpYWxvZ1NlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlRGlhbG9nLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9iYXNlRGlhbG9nL2Jhc2VEaWFsb2cubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBiYXNlRGlhbG9nX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vYmFzZURpYWxvZy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQmFzZURpYWxvZ0NvbnRyb2xsZXInO1xyXG52YXIgQmFzZURpYWxvZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFzZURpYWxvZ0NvbnRyb2xsZXIoJHNjb3BlLCAkY29udHJvbGxlciwgYmFzZURpYWxvZykge1xyXG4gICAgICAgIHZhciBjb250cm9sbGVyO1xyXG4gICAgICAgIGlmICgkc2NvcGUubW9kYWxDb250cm9sbGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FscyA9ICRzY29wZS5yZXNvbHZlRGF0YSB8fCB7fTtcclxuICAgICAgICAgICAgJHNjb3BlLnJlc29sdmVEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgbG9jYWxzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICAgICAgY29udHJvbGxlciA9ICRjb250cm9sbGVyKCRzY29wZS5tb2RhbENvbnRyb2xsZXIsIGxvY2Fscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS4kb24oJ21vZGFsLmNsb3NpbmcnLCBiYXNlRGlhbG9nLm1vZGFsQ2xvc2luZyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XHJcbiAgICB9XHJcbiAgICBCYXNlRGlhbG9nQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGNvbnRyb2xsZXInLCBiYXNlRGlhbG9nX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQmFzZURpYWxvZ0NvbnRyb2xsZXI7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQmFzZURpYWxvZ0NvbnRyb2xsZXIgPSBCYXNlRGlhbG9nQ29udHJvbGxlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZURpYWxvZy5jb250cm9sbGVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2Jhc2VEaWFsb2cvYmFzZURpYWxvZy5jb250cm9sbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3Byb21pc2UgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxudmFyIGJhc2VEaWFsb2dfY29udHJvbGxlcl8xID0gcmVxdWlyZSgnLi9iYXNlRGlhbG9nLmNvbnRyb2xsZXInKTtcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICdiYXNlRGlhbG9nJztcclxudmFyIEJhc2VEaWFsb2dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2VEaWFsb2dTZXJ2aWNlKCRtb2RhbCwgJHJvb3RTY29wZSwgcHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kbW9kYWwgPSAkbW9kYWw7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlID0gJHJvb3RTY29wZTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMubW9kYWxDbG9zaW5nID0gZnVuY3Rpb24gKGV2ZW50LCByZWFzb24sIGV4cGxpY2l0bHlDbG9zZWQpIHtcclxuICAgICAgICAgICAgdmFyIGNhbkNsb3NlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihfdGhpcy5jbG9zZUhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5DbG9zZSA9IF90aGlzLmNsb3NlSGFuZGxlcihleHBsaWNpdGx5Q2xvc2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIEJhc2VEaWFsb2dTZXJ2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNsb3NlSGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaWFsb2dJbnN0YW5jZSA9IHtcclxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICAgICAgZGlzbWlzczogZnVuY3Rpb24gKCkgeyB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlLnJlc29sdmVQcm9taXNlcyhvcHRpb25zLnJlc29sdmUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2xvc2VIYW5kbGVyID0gY2xvc2VIYW5kbGVyO1xyXG4gICAgICAgICAgICBvcHRpb25zID0gX3RoaXMuY29uZmlndXJlTW9kYWxTZXR0aW5ncyhvcHRpb25zLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgdmFyIG1vZGFsSW5zdGFuY2UgPSBfdGhpcy4kbW9kYWwub3BlbihvcHRpb25zKTtcclxuICAgICAgICAgICAgZGlhbG9nSW5zdGFuY2UuY2xvc2UgPSBtb2RhbEluc3RhbmNlLmNsb3NlO1xyXG4gICAgICAgICAgICBkaWFsb2dJbnN0YW5jZS5kaXNtaXNzID0gbW9kYWxJbnN0YW5jZS5kaXNtaXNzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkaWFsb2dJbnN0YW5jZTtcclxuICAgIH07XHJcbiAgICBCYXNlRGlhbG9nU2VydmljZS5wcm90b3R5cGUuY29uZmlndXJlTW9kYWxTZXR0aW5ncyA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXNvbHZlRGF0YSkge1xyXG4gICAgICAgIHZhciBtb2RhbFNjb3BlID0gb3B0aW9ucy5zY29wZTtcclxuICAgICAgICBpZiAobW9kYWxTY29wZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vZGFsU2NvcGUgPSB0aGlzLiRyb290U2NvcGUuJG5ldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5yZXNvbHZlVG9EaWFsb2cpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlhbG9nQXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZVtvcHRpb25zLmRpYWxvZ0FzXSA9IHJlc29sdmVEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZSA9IF8uZXh0ZW5kKG1vZGFsU2NvcGUsIHJlc29sdmVEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9kYWxTY29wZS5yZXNvbHZlRGF0YSA9IHJlc29sdmVEYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb2RhbFNjb3BlLm1vZGFsQ29udHJvbGxlciA9IG9wdGlvbnMuY29udHJvbGxlcjtcclxuICAgICAgICBvcHRpb25zLnJlc29sdmUgPSBudWxsO1xyXG4gICAgICAgIG9wdGlvbnMuY29udHJvbGxlciA9IGJhc2VEaWFsb2dfY29udHJvbGxlcl8xLmNvbnRyb2xsZXJOYW1lO1xyXG4gICAgICAgIG9wdGlvbnMuc2NvcGUgPSBtb2RhbFNjb3BlO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfTtcclxuICAgIEJhc2VEaWFsb2dTZXJ2aWNlLiRpbmplY3QgPSBbJyRtb2RhbCcsICckcm9vdFNjb3BlJywgX19wcm9taXNlLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBCYXNlRGlhbG9nU2VydmljZTtcclxufSkoKTtcclxuZXhwb3J0cy5CYXNlRGlhbG9nU2VydmljZSA9IEJhc2VEaWFsb2dTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlRGlhbG9nLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvYmFzZURpYWxvZy9iYXNlRGlhbG9nLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdBdXRvc2F2ZURpYWxvZ0NvbnRyb2xsZXInO1xyXG52YXIgQXV0b3NhdmVEaWFsb2dDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlRGlhbG9nQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICBpZiAoJHNjb3BlLmZvcm0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgdW5iaW5kID0gJHNjb3BlLiR3YXRjaCgkc2NvcGUuZm9ybSwgZnVuY3Rpb24gKGZvcm0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0Rm9ybShmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmJpbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCRzY29wZS5mb3JtR2V0dGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHVuYmluZCA9ICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gJHNjb3BlLmZvcm1HZXR0ZXIoJHNjb3BlKTsgfSwgZnVuY3Rpb24gKGZvcm0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0Rm9ybShmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmJpbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQXV0b3NhdmVEaWFsb2dDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIEF1dG9zYXZlRGlhbG9nQ29udHJvbGxlcjtcclxufSkoKTtcclxuZXhwb3J0cy5BdXRvc2F2ZURpYWxvZ0NvbnRyb2xsZXIgPSBBdXRvc2F2ZURpYWxvZ0NvbnRyb2xsZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9zYXZlRGlhbG9nLmNvbnRyb2xsZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZURpYWxvZy9hdXRvc2F2ZURpYWxvZy5jb250cm9sbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIHdpbmRvd1dyYXBwZXJfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vd2luZG93V3JhcHBlci93aW5kb3dXcmFwcGVyLnNlcnZpY2UnKTtcclxudmFyIHZpc2libGVCcmVha3BvaW50X3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vdmlzaWJsZUJyZWFrcG9pbnQuc2VydmljZScpO1xyXG52YXIgYnJlYWtwb2ludHNfc2VydmljZV8xID0gcmVxdWlyZSgnLi9icmVha3BvaW50cy5zZXJ2aWNlJyk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYnJlYWtwb2ludCcpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi92aXNpYmxlQnJlYWtwb2ludC5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2JyZWFrcG9pbnRzLnNlcnZpY2UnKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5icmVha3BvaW50cyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9ic2VydmFibGUubW9kdWxlTmFtZSxcclxuICAgIHdpbmRvd1dyYXBwZXJfc2VydmljZV8xLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuY29uc3RhbnQoJ3Jlc2l6ZURlYm91bmNlTWlsbGlzZWNvbmRzJywgNTAwKVxyXG4gICAgLnNlcnZpY2UodmlzaWJsZUJyZWFrcG9pbnRfc2VydmljZV8xLnZpc2libGVCcmVha3BvaW50U2VydmljZU5hbWUsIHZpc2libGVCcmVha3BvaW50X3NlcnZpY2VfMS5WaXNpYmxlQnJlYWtwb2ludFNlcnZpY2UpXHJcbiAgICAuc2VydmljZShicmVha3BvaW50c19zZXJ2aWNlXzEuYnJlYWtwb2ludFNlcnZpY2VOYW1lLCBicmVha3BvaW50c19zZXJ2aWNlXzEuQnJlYWtwb2ludFNlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVha3BvaW50cy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50cy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy53aW5kb3dXcmFwcGVyJztcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICd3aW5kb3dXcmFwcGVyJztcclxudmFyIFdpbmRvd1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gV2luZG93U2VydmljZSgpIHtcclxuICAgICAgICB0aGlzLndpbmRvd0NvbnRyb2wgPSAkKHdpbmRvdyk7XHJcbiAgICB9XHJcbiAgICBXaW5kb3dTZXJ2aWNlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLndpbmRvd0NvbnRyb2wucmVzaXplKGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBXaW5kb3dTZXJ2aWNlLnByb3RvdHlwZS5zY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93Q29udHJvbC5zY3JvbGxUb3AoKTtcclxuICAgIH07XHJcbiAgICBXaW5kb3dTZXJ2aWNlLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMud2luZG93Q29udHJvbC5zY3JvbGwoaGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgV2luZG93U2VydmljZS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpbmRvd0NvbnRyb2wuaGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdpbmRvd1NlcnZpY2U7XHJcbn0pKCk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBXaW5kb3dTZXJ2aWNlKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93V3JhcHBlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvd2luZG93V3JhcHBlci93aW5kb3dXcmFwcGVyLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuLypcclxuICogSW1wbGVtZW50YXRpb24gYWxzbyByZXF1aXJlcyB0aGUgZm9sbG93aW5nIGVsZW1lbnRzIHRvIGJlIGluc2VydGVkIG9uIHRoZSBwYWdlOlxyXG4gKiAgIDxkaXYgY2xhc3M9XCJkZXZpY2UteHMgdmlzaWJsZS14c1wiPjwvZGl2PlxyXG4gKiAgIDxkaXYgY2xhc3M9XCJkZXZpY2Utc20gdmlzaWJsZS1zbVwiPjwvZGl2PlxyXG4gKiAgIDxkaXYgY2xhc3M9XCJkZXZpY2UtbWQgdmlzaWJsZS1tZFwiPjwvZGl2PlxyXG4gKiAgIDxkaXYgY2xhc3M9XCJkZXZpY2UtbGcgdmlzaWJsZS1sZ1wiPjwvZGl2PlxyXG4gKiBUaGV5IGhhdmUgYmVlbiBpbnNlcnRlZCBpbnRvIGluZGV4Lmh0bWwgZm9yIHlvdXIgY29udmVuaWVuY2UuXHJcbiAqL1xyXG5leHBvcnRzLnZpc2libGVCcmVha3BvaW50U2VydmljZU5hbWUgPSAndmlzaWJsZUJyZWFrcG9pbnQnO1xyXG52YXIgVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpc2libGVCcmVha3BvaW50U2VydmljZSgpIHtcclxuICAgIH1cclxuICAgIFZpc2libGVCcmVha3BvaW50U2VydmljZS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKGJyZWFrcG9pbnQpIHtcclxuICAgICAgICAvLyBqcXVlcnkgZ2V0cyB0aGUgYnJlYWtwb2ludCB0cmlnZ2VyIGRpcmVjdGl2ZXMgbGlzdGVkIGFib3ZlIG9uIGxpbmUgM1xyXG4gICAgICAgIHJldHVybiAkKCcuZGV2aWNlLScgKyBicmVha3BvaW50KS5pcygnOnZpc2libGUnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlO1xyXG59KSgpO1xyXG5leHBvcnRzLlZpc2libGVCcmVha3BvaW50U2VydmljZSA9IFZpc2libGVCcmVha3BvaW50U2VydmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlzaWJsZUJyZWFrcG9pbnQuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2JyZWFrcG9pbnRzL3Zpc2libGVCcmVha3BvaW50LnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIHdpbmRvd1dyYXBwZXJfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vd2luZG93V3JhcHBlci93aW5kb3dXcmFwcGVyLnNlcnZpY2UnKTtcclxudmFyIHZpc2libGVCcmVha3BvaW50X3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vdmlzaWJsZUJyZWFrcG9pbnQuc2VydmljZScpO1xyXG52YXIgYnJlYWtwb2ludF8xID0gcmVxdWlyZSgnLi9icmVha3BvaW50Jyk7XHJcbmV4cG9ydHMuYnJlYWtwb2ludFNlcnZpY2VOYW1lID0gJ2JyZWFrcG9pbnRzJztcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgQnJlYWtwb2ludFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnJlYWtwb2ludFNlcnZpY2UoJHJvb3RTY29wZSwgdmlzaWJsZUJyZWFrcG9pbnRzLCByZXNpemVEZWJvdW5jZU1pbGxpc2Vjb25kcywgd2luZG93U2VydmljZSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHJvb3RTY29wZSA9ICRyb290U2NvcGU7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlQnJlYWtwb2ludHMgPSB2aXNpYmxlQnJlYWtwb2ludHM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCcmVha3BvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3QnJlYWtQb2ludCA9IF90aGlzLmdldEJyZWFrcG9pbnQoKTtcclxuICAgICAgICAgICAgaWYgKG5ld0JyZWFrUG9pbnQgIT09IF90aGlzLmN1cnJlbnRCcmVha3BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy4kcm9vdFNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudEJyZWFrcG9pbnQgPSBuZXdCcmVha1BvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9ic2VydmFibGUuZmlyZSgnd2luZG93LmJyZWFrcG9pbnRDaGFuZ2VkJywgX3RoaXMuY3VycmVudEJyZWFrcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJyZWFrcG9pbnQgPSB0aGlzLmdldEJyZWFrcG9pbnQoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBlZmZpY2llbnRSZXNpemUgPSBfLmRlYm91bmNlKHRoaXMudXBkYXRlQnJlYWtwb2ludCwgcmVzaXplRGVib3VuY2VNaWxsaXNlY29uZHMsIHtcclxuICAgICAgICAgICAgbGVhZGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgdHJhaWxpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIG1heFdhaXQ6IHJlc2l6ZURlYm91bmNlTWlsbGlzZWNvbmRzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdpbmRvd1NlcnZpY2UucmVzaXplKGVmZmljaWVudFJlc2l6ZSk7XHJcbiAgICB9XHJcbiAgICBCcmVha3BvaW50U2VydmljZS5wcm90b3R5cGUuZ2V0QnJlYWtwb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52aXNpYmxlQnJlYWtwb2ludHMuaXNWaXNpYmxlKGJyZWFrcG9pbnRfMS5sZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRfMS5sZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy52aXNpYmxlQnJlYWtwb2ludHMuaXNWaXNpYmxlKGJyZWFrcG9pbnRfMS5tZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRfMS5tZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy52aXNpYmxlQnJlYWtwb2ludHMuaXNWaXNpYmxlKGJyZWFrcG9pbnRfMS5zbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRfMS5zbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBicmVha3BvaW50XzEueHM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJyZWFrcG9pbnRTZXJ2aWNlLnByb3RvdHlwZS5pc0JyZWFrcG9pbnQgPSBmdW5jdGlvbiAoYnJlYWtwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRCcmVha3BvaW50ID09PSBicmVha3BvaW50O1xyXG4gICAgfTtcclxuICAgIEJyZWFrcG9pbnRTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlLnJlZ2lzdGVyKGFjdGlvbiwgJ3dpbmRvdy5icmVha3BvaW50Q2hhbmdlZCcpO1xyXG4gICAgfTtcclxuICAgIEJyZWFrcG9pbnRTZXJ2aWNlLiRpbmplY3QgPSBbJyRyb290U2NvcGUnLCB2aXNpYmxlQnJlYWtwb2ludF9zZXJ2aWNlXzEudmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlTmFtZSwgJ3Jlc2l6ZURlYm91bmNlTWlsbGlzZWNvbmRzJywgd2luZG93V3JhcHBlcl9zZXJ2aWNlXzEuc2VydmljZU5hbWUsIF9fb2JzZXJ2YWJsZS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gQnJlYWtwb2ludFNlcnZpY2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQnJlYWtwb2ludFNlcnZpY2UgPSBCcmVha3BvaW50U2VydmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJlYWtwb2ludHMuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi90eXBpbmdzL2pxdWVyeS9qcXVlcnkuZC50c1wiIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIG5nID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYnNlcnZhYmxlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9ic2VydmFibGU7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51dGlsaXRpZXMuc2VydmljZXMuY29udGVudFByb3ZpZGVyJztcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICdjb250ZW50UHJvdmlkZXJGYWN0b3J5JztcclxudmFyIENvbnRlbnRQcm92aWRlclNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29udGVudFByb3ZpZGVyU2VydmljZShvYnNlcnZhYmxlRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zZXRUcmFuc2NsdWRlQ29udGVudCA9IGZ1bmN0aW9uICh0cmFuc2NsdWRlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0cmFuc2NsdWRlRnVuY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2NsdWRlRnVuY3Rpb24oZnVuY3Rpb24gKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0Q29udGVudChjbG9uZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldENvbnRlbnQobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGVGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICBDb250ZW50UHJvdmlkZXJTZXJ2aWNlLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKCdjb250ZW50Q2hhbmdlZCcpO1xyXG4gICAgfTtcclxuICAgIENvbnRlbnRQcm92aWRlclNlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGFjdGlvbiwgc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5nZXRDb250ZW50KHNlbGVjdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmFibGUucmVnaXN0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBhY3Rpb24oX3RoaXMuZ2V0Q29udGVudChzZWxlY3RvcikpO1xyXG4gICAgICAgIH0sICdjb250ZW50Q2hhbmdlZCcpO1xyXG4gICAgfTtcclxuICAgIENvbnRlbnRQcm92aWRlclNlcnZpY2UucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcihzZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnRlbnRQcm92aWRlclNlcnZpY2U7XHJcbn0pKCk7XHJcbmNvbnRlbnRQcm92aWRlclNlcnZpY2VGYWN0b3J5LiRpbmplY3QgPSBbX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lXTtcclxuZnVuY3Rpb24gY29udGVudFByb3ZpZGVyU2VydmljZUZhY3Rvcnkob2JzZXJ2YWJsZUZhY3RvcnkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250ZW50UHJvdmlkZXJTZXJ2aWNlKG9ic2VydmFibGVGYWN0b3J5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbm5nLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShleHBvcnRzLnNlcnZpY2VOYW1lLCBjb250ZW50UHJvdmlkZXJTZXJ2aWNlRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRlbnRQcm92aWRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvY29udGVudFByb3ZpZGVyL2NvbnRlbnRQcm92aWRlci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMuZG9jdW1lbnRXcmFwcGVyJztcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICdkb2N1bWVudFdyYXBwZXInO1xyXG52YXIgRG9jdW1lbnRTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERvY3VtZW50U2VydmljZSgpIHtcclxuICAgICAgICB0aGlzLmRvY3VtZW50Q29udHJvbCA9ICQoZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgRG9jdW1lbnRTZXJ2aWNlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDb250cm9sLmhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEb2N1bWVudFNlcnZpY2U7XHJcbn0pKCk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBEb2N1bWVudFNlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudFdyYXBwZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RvY3VtZW50V3JhcHBlci9kb2N1bWVudFdyYXBwZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgdmlld0RhdGEgPSByZXF1aXJlKCcuL3ZpZXdEYXRhJyk7XHJcbmV4cG9ydHMudmlld0RhdGEgPSB2aWV3RGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvdHlwZXMvdHlwZXMubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdEYXRhLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvdHlwZXMvdmlld0RhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=